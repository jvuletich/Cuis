'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 21 April 2012 at 12:41:42 pm'!


	Smalltalk condenseSources!

Clipboard default: Clipboard new!

Transcript clear!

Clipboard default: Clipboard new!

Smalltalk flushClassNameCache.!

DebuggerMethodMap voidMapCache.!

Smalltalk garbageCollect.!

Smalltalk garbageCollect.!

Smalltalk garbageCollect.!

----SNAPSHOT----#(21 April 2012 12:42:58 pm) Cuis4.0.image priorSource: 0!

----QUIT----#(21 April 2012 12:43:04 pm) Cuis4.0.image priorSource: 358!

----STARTUP----#(12 December 2012 11:54:20 am) as /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/Cuis4.0.image!


Smalltalk at: #About put: self!

About edit!

'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 25 April 2012 at 10:29:12 am'!

!classDefinition: #ChangeSet category: #'Tools-Changes'!
Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses isForBaseSystem hasUnsavedChanges'
	classVariableNames: 'CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses isForBaseSystem hasUnsavedChanges '
	classVariableNames: 'CurrentBaseCSNumber Installing '
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 09:46'!
        hasUnsavedChanges

	^hasUnsavedChanges! !
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 09:46'!
                     hasUnsavedChanges: aBoolean

	hasUnsavedChanges _ aBoolean.
	self triggerEvent: #dirtyFlagChanged! !
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 10:18'!
                          isForBaseSystem: aBoolean

	isForBaseSystem _ aBoolean! !
!ChangeSorter class methodsFor: 'enumerating' stamp: 'jmv 4/25/2012 10:24'!
                          existingOrNewChangeSetNamed: aName forBaseSystem: aBoolean

	| newSet |

	^(self changeSetNamed: aName)
		ifNotNil: [ :existing |
			existing assert: existing isForBaseSystem = aBoolean ]
		ifNil: [
			newSet _ ChangeSet basicNewNamed: aName.
			newSet isForBaseSystem: aBoolean.
			AllChangeSets add: newSet.
			newSet ]! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 4/25/2012 09:34'!
            named: aString createIfAbsent: neverAnswerNil registerIfNew: doRegisterIfJustCreated
	"Answer the instance with name aString.
	If there's no package named aString, answer nil or a new instance as requested.
	If a new instance is created, register it or not as requested.
	CodePackage named: 'Morphic' createIfAbsent: false registerIfNew: false
	CodePackage named: 'Morphic' createIfAbsent: true registerIfNew: false
	CodePackage named: 'XXXXXTest' createIfAbsent: true registerIfNew: true
	"

	| answer newInstance |
	answer _ InstalledPackages
		at: aString
		ifAbsent: [
			neverAnswerNil ifTrue: [ 
				newInstance _ self new packageName: aString.
				doRegisterIfJustCreated ifTrue: [ self register: newInstance ].
				newInstance ]].
	^ answer! !
!ChangeSet methodsFor: 'initialize-release' stamp: 'jmv 4/25/2012 10:24' prior: 16799784!
                      clear 
	"Reset the receiver to be empty.  "

	changeRecords _ Dictionary new.
	preamble _ nil.
	postscript _ nil.
	self hasUnsavedChanges: false.
	self isForBaseSystem: true 	"Not a great default, but at least some Boolean"! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:50' prior: 16799811!
       noteAddClass: class
	"Include indication that a new class was created."

	class wantsChangeSetLogging ifFalse: [^ self].
	self atClass: class add: #new.
	self atClass: class add: #change.
	self addCoherency: class name.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:52' prior: 16799821!
             noteChangeClass: class from: oldClass
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	class wantsChangeSetLogging ifFalse: [^ self].
	class isMeta 
		ifFalse: [self atClass: class add: #change]	"normal"
		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 
			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass
				is not recorded, even though it was added.  A further change is
				really just part of the original add."
			ifFalse: [self atClass: class add: #change]].
	self addCoherency: class name.
	(self changeRecorderFor: class) notePriorDefinition: oldClass.
	self noteClassStructure: oldClass.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:56' prior: 16799847!
      noteClassMoveToOtherPackage: class
	"The class is about to be moved to some other package, who will hold it.
	Adjust the receiver to reflect that fact."

	class wantsChangeSetLogging ifFalse: [^ self].
	self atClass: class add: #movedToOtherPackage.
	changeRecords removeKey: class class name ifAbsent: nil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:56' prior: 16799859!
                     noteMethodMoveToOtherPackage: selector forClass: class

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteMethodMoveToOtherPackage: selector.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:54' prior: 16799867!
                      noteNewMethod: newMethod forClass: class selector: selector priorMethod: methodOrNil

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteNewMethod: newMethod selector: selector priorMethod: methodOrNil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 10:10' prior: 16799877!
                          noteRemoveSelector: selector class: class priorMethod: priorMethod lastMethodInfo: info
	"Include indication that a method has been forgotten.
	info is a pair of the source code pointer and message category
	for the method that was removed."

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: info.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:54' prior: 16799892!
                       noteRenameClass: class as: newName 
	"Include indication that a class has been renamed."

	| recorder |
	(recorder _ self changeRecorderFor: class)
		noteChangeType: #rename;
		noteNewName: newName asSymbol.
		
	"store under new name (metaclass too)"
	changeRecords at: newName put: recorder.
	changeRecords removeKey: class name.
	self noteClassStructure: class.

	recorder _ changeRecords at: class class name ifAbsent: [nil].
	recorder ifNotNil: [
		changeRecords at: (newName, ' class') put: recorder.
		changeRecords removeKey: class class name.
		recorder noteNewName: newName , ' class' ].

	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 10:18' prior: 16800026!
                        isForBaseSystem

	^isForBaseSystem! !
!ChangeSet methodsFor: 'method changes' stamp: 'jmv 4/25/2012 10:07' prior: 16800128!
    removeSelectorChanges: selector class: class 
	"Remove all memory of changes associated with the argument, selector, in 
	this class."

	| chgRecord |
	(chgRecord _ changeRecords at: class name ifAbsent: [^ self])
		removeSelector: selector.
	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name].
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:56' prior: 16800245!
                 noteClassForgotten: className
	"Remove from structures if class is not a superclass of some other one we are remembering"

	structures ifNil: [^ self].
	Smalltalk at: className ifPresent: [:cls |
		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [
			^ self]]].  "No delete"
	structures removeKey: className ifAbsent: nil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:51' prior: 16800290!
                      noteCommentClass: class 
	"Include indication that a class comment has been changed."

	class wantsChangeSetLogging ifFalse: [^ self].
	self atClass: class add: #comment.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:52' prior: 16800298!
                               noteRemovalOf: class
	"The class is about to be removed from the system.
	Adjust the receiver to reflect that fact."

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteChangeType: #remove fromClass: class.
	changeRecords removeKey: class class name ifAbsent: nil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:54' prior: 16800310!
                             noteReorganizeClass: class 
	"Include indication that a class was reorganized."

	self atClass: class add: #reorganize.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 10:01' prior: 16800575!
                     assurePreambleExists
	"Make sure there is a TextModel holding the preamble; if it's found to have reverted to empty contents, put up the template"

	(preamble == nil or: [preamble actualContents isEmptyOrNil])
		ifTrue: [
			preamble _ TextModel withText: self preambleTemplate.	
			self hasUnsavedChanges: true ]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 10:02' prior: 16800715!
                 fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	self checkForConversionMethods.
	nameToUse := Preferences changeSetVersionNumbers
				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name coda: '-', Utilities authorInitials extension: 'cs']
				ifFalse: [(self name , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'cs') asFileName].
	Cursor write
		showWhile: [
			| file |
			file := self defaultChangeSetDirectory newFileNamed: nameToUse.
			[
				file timeStamp.
				self fileOutPreambleOn: file.
				self fileOutOn: file.
				self fileOutPostscriptOn: file]
					ensure: [file close]].
	
	self hasUnsavedChanges: false.
	Preferences checkForSlips
		ifFalse: [^ self].
	slips := self checkForSlips.
	(slips size > 0
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [Smalltalk browseMessageList: slips name: 'Possible slips in ' , name]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 10:25' prior: 16800921!
                       objectForDataStream: refStrm
	"I am about to be written on an object file.  Write a path to me in the other system instead."

	"try to write reference for me"
	^ DiskProxy 
		global: #ChangeSorter
		selector: #existingOrNewChangeSetNamed:forBaseSystem:
		args: (Array with: self name with: self isForBaseSystem)
"===
	refStrm replace: self with: nil.
	^ nil
==="
! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 09:58' prior: 16800942!
                               postscriptString: aString

	postscript _ TextModel withText: aString.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 09:58' prior: 16800954!
       preambleString: aString
	"Establish aString as the new contents of the preamble.  "

	preamble _ TextModel withText: aString.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'system change notifications' stamp: 'jmv 4/25/2012 09:52' prior: 16801090!
                              classRecategorized: aClass from: oldCategory to: newCategory

	"
	self hasUnsavedChanges: true
	"! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 4/25/2012 09:41' prior: 16812828!
           save
	| nameToUse |
	fullFileName ifNil: [
		fullFileName _
			(ChangeSet defaultChangeSetDirectory pathName, FileDirectory slash, 
			self packageName, FileDirectory dot, 'pck')
				asFileName ].
	nameToUse _ fullFileName.
"	nameToUse _ Preferences changeSetVersionNumbers
		ifTrue: [
			ChangeSet defaultChangeSetDirectory
				nextNameFor: self packageName coda: '-', Utilities authorInitials
				extension: 'pck' ]
		ifFalse: [ (self packageName , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'pck') asFileName ]."
	Cursor write
		showWhile: [
			| file |
			file _ ChangeSet defaultChangeSetDirectory forceNewFileNamed: nameToUse.
			[
				file timeStamp.
				self writeOnStream: file ]
					ensure: [ file close ]].
	self hasUnsavedChanges: false.
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: self)! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 4/25/2012 09:40' prior: 16812988!
                  register: aCodePackage
	"
	Usually call #named:createIfAbsent:registerIfNew: instead
	CodePackage register: (CodePackage newNamed: 'Tests-Files')
	"
	InstalledPackages at: aCodePackage packageName put: aCodePackage.
	self triggerEvent: #installedPackagesChanged! !
!CodePackageFile methodsFor: 'initialize' stamp: 'jmv 4/25/2012 09:35' prior: 16813067!
                               buildFileStream: aFileStream packageName: pkName fullName: fullFileName
	"Just build the PackageFile object. Don't install the code."

	| classesDefined classesExtended classesToDeleteButCant classesToReallyDelete packageInMemory |
	packageName _pkName.
	fullName _fullFileName.
	"Don't register a package!!"
	packageInMemory _ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: false.
	self buildFrom: aFileStream.
	"Compute stuff no longer in package: Should be removed from system."
	classesDefined _ Set new.
	classesExtended _ Set new.
	self classes do: [ :pseudoClass |
		pseudoClass hasDefinition
			ifTrue: [ classesDefined add: pseudoClass name ]
			ifFalse: [ classesExtended add: pseudoClass name ]].
	classesToRemove _ (packageInMemory classes asSet collect: [ :each | each name ]) difference: classesDefined.
	"Add here:
		- classes in classesToDelete, that #allCallsOn answers selectors that aren't in classesToDelete or methodsToRemove
		- classes with #subclasses that aren't in classesToDelete.
		- classes with existing instances (#instanceCount)? Not really sure... Maybe sole instance referenced from classVar or such...
		- something else I forgot?
	Warning: This search for stuff that can't be removed must be iterated again until it doesn't find any more."
	classesToDeleteButCant _ classesToRemove intersection: classesExtended.
	classesToReallyDelete _ classesToRemove difference: classesToDeleteButCant.
	"Methods. Could also mean classes that can't be deleted!! (include in the iteration)
	Warn if deleting last implementor of sent messages?"
	methodsToRemove _ packageInMemory methods asSet difference: self allMethodReferences.
	methodsToRemove _ methodsToRemove reject: [ :methodReference | classesToReallyDelete includes: methodReference classSymbol ].

"
	'=============' print.
	('classesToRemove: ', classesToRemove printString) print.
	('classesToDeleteButCant: ', classesToDeleteButCant printString) print.
	('classesToReallyDelete: ', classesToReallyDelete printString) print.
	'=============' print.
	'methodsToRemove: ' print.
	methodsToRemove do: [ :methodReference | methodReference print ].
	'=============' print.
"! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 4/25/2012 09:36' prior: 16813537!
                            createPackage

	| pkName |
	pkName_ FillInTheBlank request: 'Name for new package?'.
	CodePackage
		named: pkName
		createIfAbsent: true
		registerIfNew: true! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 4/25/2012 10:11' prior: 16961957!
                              okayToDiscardUnsavedCodeSaving: wouldSave
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk okayToDiscardUnsavedCodeSaving: true
	Smalltalk okayToDiscardUnsavedCodeSaving: false
	"

	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSorter allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any isEmpty hasUnsavedChanges ]].
	dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ].

	baseCSdirty & dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'      (would need to be saved on next run), ', String newLineString,
				'and unsaved Changes to Cuis core', String newLineString,
				'      (they would be lost as a separate ChangeSet).', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'and unsaved Changes to Cuis core.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core might have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Continue?' ].

	dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will need to be saved on next run.', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	^true! !

!classDefinition: #ChangeSet category: #'Tools-Changes'!
Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses hasUnsavedChanges isForBaseSystem'
	classVariableNames: 'CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses hasUnsavedChanges isForBaseSystem'
	classVariableNames: 'CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
| name |
ChangeSet allInstancesDo: [ :each |
	each hasUnsavedChanges: each isEmpty not.
	name _ each name.
	each isForBaseSystem: ((name at: 1) isDigit
		and: [ (name at: 1) isDigit
			and: [ (name at: 1) isDigit
				and: [ (name at: 1) isDigit
					and: [ name is: '-CuisCore-' substingAt: 5 ]]]])]!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1261-CuisCore-JuanVuletich-2012Apr25-09h17m-jmv.9.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1261] on 25 April 2012 at 9:58:57 pm'!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 4/25/2012 10:26' prior: 16801492!
changeSetForBaseSystem

	| csName numberToUse |
	Installing

		ifNil: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifNotNil: [
			csName _ 'Affects-BaseSystem--Install-', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 4/25/2012 10:25' prior: 16801513!
    changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ Installing
		ifNil: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifNotNil: [
			Installing = aCodePackage packageName
				ifTrue: [ 'Install-', Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--Install-', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 4/25/2012 09:37' prior: 16812113!
                         installPackageStream: aStream

	| fullName pkName existing |
	fullName _ aStream name.
	pkName _ CodePackageFile packageNameFrom: fullName.
	existing _ CodePackage named: pkName createIfAbsent: false registerIfNew: false.
	(existing isNil
		or: [ existing hasUnsavedChanges not
			or: [ self confirm: 'If you install this package, there are unsaved changes that will be lost.', String newLineString, 'Continue?' ]]) ifTrue: [
		Cursor wait showWhile: [
			CodePackageFile
				installFileStream: aStream
				packageName: pkName
				fullName: fullName ]]! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 4/25/2012 09:36' prior: 16813151!
                              install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !

CodePackage class removeSelector: #named:!

CodePackage class removeSelector: #named:!

CodePackage class removeSelector: #newNamed:!

CodePackage class removeSelector: #newNamed:!

CodePackage removeSelector: #register!

CodePackage removeSelector: #register!

ChangeSorter class removeSelector: #existingOrNewChangeSetNamed:!

ChangeSorter class removeSelector: #existingOrNewChangeSetNamed:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

| name |
ChangeSet allInstancesDo: [ :each |
	each hasUnsavedChanges: each isEmpty not.
	name _ each name.
	each isForBaseSystem: ((name at: 1) isDigit
		and: [ (name at: 1) isDigit
			and: [ (name at: 1) isDigit
				and: [ (name at: 1) isDigit
					and: [ name is: '-CuisCore-' substingAt: 5 ]]]])]!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1262-CuisCore-JuanVuletich-2012Apr25-21h56m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 23 April 2012 at 11:21:55 pm'!
!CodePackage methodsFor: 'saving' stamp: 'JMG 4/23/2012 23:21' prior: 50332027!
       save
	| nameToUse |
	fullFileName ifNil: [
		fullFileName _
			ChangeSet defaultChangeSetDirectory fullNameFor: (self packageName, FileDirectory dot, 'pck')].
	nameToUse _ fullFileName.
"	nameToUse _ Preferences changeSetVersionNumbers
		ifTrue: [
			ChangeSet defaultChangeSetDirectory
				nextNameFor: self packageName coda: '-', Utilities authorInitials
				extension: 'pck' ]
		ifFalse: [ (self packageName , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'pck') asFileName ]."
	Cursor write
		showWhile: [
			| file |
			file _ ChangeSet defaultChangeSetDirectory forceNewFileNamed: nameToUse.
			[
				file timeStamp.
				self writeOnStream: file ]
					ensure: [ file close ]].
	self hasUnsavedChanges: false.
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: self)! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1263-CuisCore-JeffGonis-2012Apr23-23h19m-JMG.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 10:52:28 am'!
!TextProvider methodsFor: 'testing' stamp: 'jmv 4/25/2012 10:50'!
                 refusesToAccept
	"This method must answer false if we usually accept text from a PluggableTextModel (i.e. we understand its textSetter), but are not accepting text right now."

	^ false! !
!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 4/25/2012 10:52' prior: 16915463!
           wantsFrameAdornments

	^textSetter notNil! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1264-CuisCore-JuanVuletich-2012Apr25-10h29m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 11:01:04 am'!
!SocketStream commentStamp: '<historical>' prior: 16946165!
                SocketStream is a wrapper for class Socket making it easy to write networking code by giving the programmer a stream-like protocol. A Socket is a two way communication link with two logically separate channels - input and output. The Socket class is the lowest level in Squeak for network communication and using it directly can be difficult and bug prone.

A SocketStream can be in binary or ascii mode, ascii is the default which means you are transmitting and receiving Strings. Most Internet protocols are in clear text ascii, like for example HTTP. Another setting is what timeout you want to use - default is the standardTimeout from Socket. More settings can be found in the method category 'configuration'.

Simplest example of connecting, sending/receiving and closing:

| stream result |
stream := SocketStream openConnectionToHostNamed: 'www.squeak.org' port: 80.
[[stream nextPutAll: 'GET / HTTP/1.0'; newLine; newLine; flush.
result := stream upToEnd. "Give us all data until the socket is closed."
Transcript show: result withCuisLineEndings; newLine.]
	ensure: [stream close]]
		on: ConnectionTimedOut
		do: [:ex | Transcript show: ex asString; newLine. ex resume]

There are two important things to note above:
	- The methods in category "stream in" can signal two exceptions (unless turned off with #shouldSignal:):
		ConnectionClosed and ConnectionTimedOut
	- We close the stream using #ensure:, that is to make sure it isn't left opened.
	- We use #on:do: to catch any signal. In this case we do not need to catch ConnectionClosed since #upToEnd does that for us intrinsically.

----------------
SocketStream (below called SS) is a reimplementation of 'Old'-SocketStream (below called OSS) - the class that originates from the original Comanche implementation but now is included in standard Squeak. SS has the same protocol as OSS and is meant to replace it. SS is faster, more flexible, is better documented and adds a few features:

1. #shouldSignal:, which decides if SS should signal low level Socket exceptions (true) or if it should swallow them like original OSS did. Default is true. The only reason I added this is for backwards compatibility - not signalling causes problems - see bug 4 below.

2. #nextAllInBuffer, #nextInBuffer:, #skip:, #receiveData:, #nextPutAllFlush: and #recentlyRead are new additions to the public protocol.


It also fixes various bugs:

1. #isDataAvailable could theoretically answer false, when there actually is some in the buffer in OSS. If #receiveDataIfAvailable reads the last byte then the following "socket dataAvailable" would answer false. So the last byte would be sitting in the inStream missed.

2. #upToAll: in OSS has several problems, for example - #positionOfSubCollection:ifAbsent: which was introduced answers one position too low. This was compensated in upToAll:, but only in the pushBack: call, not the actual result being returned which was cut short 1 byte. Amusingly this makes KomHttpServer not use "Keep-Alive" since the last $e in 'Alive' was cut short. :)

3. SS doesn't inherit from PositionableStream since that just breaks various inherited messages, like for example #skip:. OSS should IMHO be changed to inherit from Object - or of course, replaced in full with SS. :)

4. Since SocketStream by default signals closes and timeouts the SocketStreamTest now passes. The reason for SocketStream to fail is that while it does timeout on a low level (#SocketStream>>receiveData doesn't hang forever) - the callers of #receiveData sometimes loop - like in #next:, and thus eliminates the timeout. SS warns about some methods (in their method comments) not honouring timeouts if shouldSignal is false, I really don't know what they should do in that case:
	#next:, #upTo:, #upToAll: and #upToEnd (and #receiveData:)


The primary reason for the SS implementation is optimal performance. The main differences in implementation with the old OSS are:

1. SS uses two buffers directly (inBuffer and outBuffer) with pointers marking start and stop within the buffer. OSS instead uses two regular streams, a ReadStream and a WriteStream. Using internal buffers makes it possible to avoid copying and reallocation in various ways, it also makes SS be able to have specialized growing/buffer moving behaviour.

2. #upTo:, #upToAll: and #peekForAll: uses selectged String messages that in turn uses fast primitives for searching. OSS used other messages that fell back on byte per byte reading.

3. #receiveData in OSS creates a temporary buffer stream for each call!! During a long read operation, like say #upToAll: (which for example is used when uploading files using HTTP POST forms), this is devastating - especially since the default size is only 2000 bytes - and leads to a very high number of low level read operations on the Socket, typically 100 times more calls than with OSS. The buffer in OSS is held in an instvar (not recreated for each call), is larger from the start and above all - grows dynamically by doubling. OSS can also avoid a grow/reallocation by doing a "move down" if data has been read from the SS as it comes in and through that making room in the lower part of the inBuffer. The net result is that upToAll: for large files is about 10 times faster.

4. The implementation of upTo: and upToAll: tries to avoid doing unnecessary find operations in the buffer and is greedy by default, which means it favors reading more data - if available - before searching for the stop sequence. If we had #findString:startingAt:stoppingAt: this wouldn't have to be greedy and we wouldn't be needlessly scanning dead buffer area. VM hackers? Also, while you are at it - make it work for ByteArrays too. :)


SS can not be run unbuffered, since that seems unneeded. The option to autoFlush is still available, with it set to true SocketStream (just like OSS) will flush on its own on each nextPut:/nextPutAll:, otherwise flushing it will have to be done manually but is done on close.

The first performance tests shows that, as noted above, receiving large amounts of data using #upToAll: is greatly improved - factor of 10. Serving HTTP with small payloads seemed at first not be faster at all - but this is due to the high overhead of Socket connect/close and other things. Increasing payloads show a difference and especially with keep alive on - where the new SS roughly doubles the throughput!!!
!String methodsFor: 'converting' stamp: 'jmv 4/25/2012 10:59' prior: 16956235!
                         withCuisLineEndings
	"assume the string is textual, and that CR, LF, and CRLF are all 
	valid line endings.  Replace each occurence with a single Lf
	('aLine', String crlfString, 'anotherOne') withCuisLineEndings
	"

	^ self withLineEndings: String newLineString! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1265-CuisCore-JuanVuletich-2012Apr25-10h52m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 11:22:21 am'!
!CodeProvider methodsFor: 'testing' stamp: 'jmv 4/25/2012 11:20'!
             isRefusingToAccept
	"Answer whether receiver, given its current contentsSymbol, could accept code happily if asked to"

	^ (#(byteCodes documentation) includes: self contentsSymbol)! !
!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 4/25/2012 11:18' prior: 16915459!
               refusesToAccept
	^textProvider is: #refusingToAccept! !
!CodeProvider methodsFor: 'testing' stamp: 'jmv 4/25/2012 11:20' prior: 16814766!
                      is: aSymbol
	aSymbol = #refusingToAccept
		ifTrue: [ ^self isRefusingToAccept ].
	^(#(CodeProvider #ShoutEnabled) pointsTo: aSymbol)
		or: [ super is: aSymbol ]! !

CodeProvider removeSelector: #refusesToAccept!

CodeProvider removeSelector: #refusesToAccept!

TextProvider removeSelector: #refusesToAccept!

TextProvider removeSelector: #refusesToAccept!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1266-CuisCore-JuanVuletich-2012Apr25-11h11m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1266] on 2 December 2012 at 10:01:51 pm'!
!BorderedMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2012 21:35' prior: 16793261!
                         initialize
	"initialize the state of the receiver"
	super initialize.
	"initialize the receiver state related to border"
	borderColor _ self defaultBorderColor.
	borderWidth _ self defaultBorderWidth! !
!CodePackageFile methodsFor: 'initialize' stamp: 'jmv 12/2/2012 21:37' prior: 50332069!
                             buildFileStream: aFileStream packageName: pkName fullName: fullFileName
	"Just build the PackageFile object. Don't install the code."

	| classesDefined classesExtended classesToDeleteButCant classesToReallyDelete packageInMemory |
	packageName _ pkName.
	fullName _ fullFileName.
	"Don't register a package!!"
	packageInMemory _ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: false.
	self buildFrom: aFileStream.
	"Compute stuff no longer in package: Should be removed from system."
	classesDefined _ Set new.
	classesExtended _ Set new.
	self classes do: [ :pseudoClass |
		pseudoClass hasDefinition
			ifTrue: [ classesDefined add: pseudoClass name ]
			ifFalse: [ classesExtended add: pseudoClass name ]].
	classesToRemove _ (packageInMemory classes asSet collect: [ :each | each name ]) difference: classesDefined.
	"Add here:
		- classes in classesToDelete, that #allCallsOn answers selectors that aren't in classesToDelete or methodsToRemove
		- classes with #subclasses that aren't in classesToDelete.
		- classes with existing instances (#instanceCount)? Not really sure... Maybe sole instance referenced from classVar or such...
		- something else I forgot?
	Warning: This search for stuff that can't be removed must be iterated again until it doesn't find any more."
	classesToDeleteButCant _ classesToRemove intersection: classesExtended.
	classesToReallyDelete _ classesToRemove difference: classesToDeleteButCant.
	"Methods. Could also mean classes that can't be deleted!! (include in the iteration)
	Warn if deleting last implementor of sent messages?"
	methodsToRemove _ packageInMemory methods asSet difference: self allMethodReferences.
	methodsToRemove _ methodsToRemove reject: [ :methodReference | classesToReallyDelete includes: methodReference classSymbol ].

"
	'=============' print.
	('classesToRemove: ', classesToRemove printString) print.
	('classesToDeleteButCant: ', classesToDeleteButCant printString) print.
	('classesToReallyDelete: ', classesToReallyDelete printString) print.
	'=============' print.
	'methodsToRemove: ' print.
	methodsToRemove do: [ :methodReference | methodReference print ].
	'=============' print.
"! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 12/2/2012 21:34' prior: 50332141!
                          createPackage

	| pkName |
	pkName _ FillInTheBlank request: 'Name for new package?'.
	CodePackage
		named: pkName
		createIfAbsent: true
		registerIfNew: true! !
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 12/2/2012 21:36' prior: 16815146!
       browseFullProtocol
	"Create and schedule a new protocol browser on the currently selected class or meta."

	| aPBrowser label |
	model selectedClassOrMetaClass ifNotNil: [ :classOrMetaclass |
		aPBrowser _ ProtocolBrowser new on: classOrMetaclass.
		label _ 'Entire protocol of: ', classOrMetaclass name.
		MessageSetWindow open: aPBrowser label: label ]! !
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 12/2/2012 21:36' prior: 16815242!
    browseProtocol
	"Create and schedule a new protocol browser on the currently selected class or meta."
	| aPBrowser label |
	model selectedClassOrMetaClass ifNotNil: [ :classOrMetaclass |
		aPBrowser _ ProtocolBrowser new onSubProtocolOf: classOrMetaclass.
		label _'Sub-protocol of: ', classOrMetaclass name.
		MessageSetWindow open: aPBrowser label: label ]! !
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 12/2/2012 22:01' prior: 16861517!
                     arrowOfDirection: aSymbol size: finalSizeInteger
	^CachedForms
		at: { aSymbol . finalSizeInteger }
		ifAbsentPut: [
			Form extent: finalSizeInteger@finalSizeInteger depth: 32.
			"self buildArrowOfDirection: aSymbol size: finalSizeInteger" ]! !
!HaloSpec methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2012 21:35' prior: 16864464!
               horizontalPlacement: hp verticalPlacement: vp color: col iconSymbol: is addHandleSelector: sel
	horizontalPlacement _ hp.
	verticalPlacement _ vp.
	color _ col.
	iconSymbol _ is asSymbol.
	addHandleSelector _ sel! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/2/2012 21:37' prior: 50332150!
        okayToDiscardUnsavedCodeSaving: wouldSave
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk okayToDiscardUnsavedCodeSaving: true
	Smalltalk okayToDiscardUnsavedCodeSaving: false
	"

	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSorter allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any hasUnsavedChanges ]].
	dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ].

	baseCSdirty & dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'      (would need to be saved on next run), ', String newLineString,
				'and unsaved Changes to Cuis core', String newLineString,
				'      (they would be lost as a separate ChangeSet).', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'and unsaved Changes to Cuis core.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core might have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Continue?' ].

	dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will need to be saved on next run.', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	^true! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1267-CuisCore-JuanVuletich-2012Dec02-22h01m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1267] on 28 April 2012 at 11:38:12 am'!
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 4/28/2012 11:34'!
  popUpOwner
	^popUpOwner! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 4/27/2012 16:37'!
   makeMeFullyVisible 

	self world extent > (0@0) ifFalse: [^ self].

	(self position >= (0@0) and: [ self position < (self world extent-self extent)]) ifTrue: [
		^ self "OK -- visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [self position: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [self position: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].

! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 4/28/2012 11:38' prior: 16886998!
                    mouseEnter: evt
	"The mouse entered the receiver"
	owner popUpOwner ifNotNil: [ :parentItem |
		parentItem removeAlarm: #deselectTimeOut: ].
	owner ifNil: [ ^self ].
	owner selectItem: self event: evt! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 4/27/2012 16:38' prior: 16912138!
                               bringWindowsFullOnscreen
	"Make ever SystemWindow on the desktop be totally on-screen, whenever possible."
	
	(SystemWindow windowsIn: self satisfying: [:w | true]) do: [ :each |
		each makeMeFullyVisible ]! !

MenuMorph removeSelector: #staysUp!

MenuMorph removeSelector: #staysUp!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1268-CuisCore-JuanVuletich-2012Apr28-11h36m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1267] on 30 April 2012 at 12:10:30 am'!
!CodePackage commentStamp: 'jmv 4/30/2012 00:03' prior: 16812140!
                           A CodePackage is a package that is currently loaded in the system. If saved (.pck), then it is stored in a file that can be dealt with as an instance of PackageFile. As the code is already in the system, all we need to know is the packageName. Implementation is originally based on PackageInfo, but has diverged.

CodePackage instances are usually created when installing CodePackageFiles. These instances track the code for that package, that we'll need to save if we don't want to lose changes. These instances are held in the InstalledPackages class variable.

We can also create 'transient' instances with whatever name (and classes and extension methods) we chose, like
	(CodePackage named: 'Collections' createIfAbsent: true registerIfNew: false) inspect; save
This won't mean the system is actually partitioned in such way.

(CodePackage named: 'TestPackage' createIfAbsent: true registerIfNew: false) inspect; save!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1269-CuisCore-JuanVuletich-2012Apr30-00h01m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1269] on 30 April 2012 at 9:30:39 pm'!
!CodePackageFile class methodsFor: 'services' stamp: 'jmv 4/30/2012 21:29'!
                  monticelloPackageNameFrom: fullName
	| localName |
	localName _ FileDirectory localNameFor: fullName.
	^(localName prefixAndSuffix: $-)
		ifNotNil: [ :ary | ary first ]
		ifNil: [ localName sansPeriodSuffix ].! !
!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 4/30/2012 21:29' prior: 16799128!
                  browseMCZContents: aStream
	"Browse the selected file."
	| unzipped changeList fullName packageFile pkName |
	
	"For Monticello packages we do as we do with our own .pck files: Instead of just browsing
	contents, also include what is no longer part of the package (and should therefore be removed on install)
	See #browsePackageContents:
	However, this was never tested to run!!"
	self flag: #jmvVer.

	fullName _ aStream name.
	pkName _ CodePackageFile monticelloPackageNameFrom: fullName.
	unzipped _ aStream asUnZippedStream: 'snapshot/source.st'.
	unzipped ascii.
	Cursor read showWhile: [
		changeList _ self new scanFile: unzipped from: 0 to: unzipped size.
		aStream reset.
		packageFile _ CodePackageFile
			buildFileStream: unzipped
			packageName: pkName
			fullName: fullName ].
	"Add deletions of methods and classes that are in the PackageInfo (i.e., active in the system)
	but are no longer in the PackageFile being viewed."
	packageFile methodsToRemove do: [ :methodReference |
		changeList
			addItem: (MethodDeletionChangeRecord new methodReference: methodReference)
			text: 'method no longer in package: ', methodReference asStringOrText ].
	packageFile classesToRemove do: [ :clsName |
		changeList
			addItem: (ClassDeletionChangeRecord new clsName: clsName)
			text: 'class no longer in package: ', clsName ].
	changeList clearSelections.
	ChangeListWindow open: changeList label: aStream name! !
!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 4/30/2012 21:29' prior: 16812099!
                   installMonticelloPackageStream: aStream
	
	| stream fullName pkName |
	fullName _ aStream name.
	pkName _ CodePackageFile monticelloPackageNameFrom: fullName.
	stream _ aStream asUnZippedStream: 'snapshot/source.st'.
	stream ascii.
	Cursor wait showWhile: [
		CodePackageFile
			installFileStream: stream
			packageName: pkName
			fullName: fullName ]! !
!CodePackageFile class methodsFor: 'services' stamp: 'jmv 4/30/2012 21:30' prior: 16813274!
 packageNameFrom: fullName

	^(FileDirectory localNameFor: fullName) sansPeriodSuffix! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1270-CuisCore-JuanVuletich-2012Apr30-21h29m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1270] on 2 May 2012 at 6:42:19 pm'!
!TestRunner methodsFor: 'processing' stamp: 'gsa 5/2/2012 18:39'!
   runProfiledTests
	| suite |
	Cursor execute showWhile: [
		suite _ TestSuite new name: 'TestRunner Suite'.
		self selectedTests do: [ :ea | self addTestsFor: ea toSuite: suite ].
		self runSuiteProfiled: suite.
	]
! !
!TestRunner methodsFor: 'processing' stamp: 'gsa 5/2/2012 18:40'!
    runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'gsa 5/2/2012 18:06'!
         buildRunProfiledButton
	| runProfiledButton |
	runProfiledButton := PluggableButtonMorph 
				model: model
				stateGetter: #runButtonState
				action: #runProfiledTests
				label: 'Run Profiled'.
	runProfiledButton
		color: self runButtonColor.
	^runProfiledButton! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'gsa 5/2/2012 18:34' prior: 16969110!
                         buildUpperControls
	| refreshButton filterButton stopButton runOneButton runButton runProfiledButton row column1 column2 column3 theTestsList |

	refreshButton _ self buildRefreshButton.
	filterButton _ self buildFilterButton.
	stopButton _ self buildStopButton.
	column1 _ LayoutMorph newColumn.
	column1 addMorphs: { refreshButton . filterButton . stopButton }.

	theTestsList _ PluggableListMorphOfMany
				model: model
				listGetter: #tests
				primarySelectionGetter: #selectedSuite
				primarySelectionSetter: #selectedSuite:
				listSelectionGetter: #listSelectionAt:
				listSelectionSetter: #listSelectionAt:put:
				mainView: self
				menuGetter: #listMenu
				keystrokeAction: nil.
	theTestsList autoDeselect: false.
	theTestsList color: Color veryVeryLightGray.
	column2 _ LayoutMorph newColumn.
	column2
		addMorph: theTestsList proportionalHeight: 1;
		addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight.

	runOneButton _ self buildRunOneButton.
	runButton _ self buildRunButton.
	runProfiledButton := self buildRunProfiledButton.	
	column3 _ LayoutMorph newColumn.
	column3 addMorphs: { runOneButton . runButton . runProfiledButton }.
	
	row _ LayoutMorph newRow.
	row
		addMorph: column1 fixedWidth: 80;
		addMorph: column2 proportionalWidth: 1;
		addMorph: column3 fixedWidth: 120.

	^row

! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1271-CuisCore-GermanArduino-2012May02-17h58m-gsa.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:35:44 am'!

!classDefinition: #SystemConsistencyTest category: #'System-Tests'!
TestCase subclass: #SystemConsistencyTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Tests'!

TestCase subclass: #SystemConsistencyTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Tests'!
!SystemConsistencyTest commentStamp: '<historical>' prior: 0!
    General system - wide image health tests.!
!SystemConsistencyTest methodsFor: 'testing' stamp: 'jmv 5/7/2012 09:35'!
           testMethodsWithUnboundGlobals
	"
	SystemConsistencyTest new testMethodsWithUnboundGlobals
	"
	self assert: Smalltalk methodsWithUnboundGlobals isEmpty! !
!SystemDictionary methodsFor: 'query' stamp: 'jmv 5/6/2012 19:26'!
   methodsWithUnboundGlobals
	"Get all methods that use undeclared global objects that are not listed in Undeclared. For a clean image the result should be empty."
	"
	self assert: Smalltalk methodsWithUnboundGlobals isEmpty
	"
	^ self allSelect: [ :m |
		m literals anySatisfy: [ :l |
			l isVariableBinding and: [
				l key isSymbol and: [
					"avoid class-side methodClass literals"
					(m methodClass bindingOf: l key)
						ifNil: [
							(Undeclared
								associationAt: l key
								ifAbsent: [ ]) ~~ l ]
						ifNotNil: [ :b |
							b ~~ l ]]]]]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1272-MethodsWithUnboundGlobals-JuanVuletich-2012May07-09h32m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:38:15 am'!
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:36' prior: 16892238!
     spyAllOn: aBlock
	"Spy on all the processes in the system
	
	[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.
	[1000 timesRepeat: [20 factorial. Processor yield]] fork.
	[1000 timesRepeat: [20 factorial. Processor yield]] fork.
	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]
	
	"
	| node result |
	node _ self new.
	node reportOtherProcesses: true.	"Irrelevant in this case. All processes will be reported on their own."
	result _ node spyAllEvery: self defaultPollPeriod on: aBlock.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false.
	^ result! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:36' prior: 16892275!
                      spyOn: aBlock reportOtherProcesses: aBoolean
	"
	Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.
	[1000 timesRepeat: [
		100 timesRepeat: [120 factorial].
		(Delay forMilliseconds: 10) wait
		]] forkAt: 45 named: '45'.
	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]] reportOtherProcesses: true
	"
	| node result |
	node _ self new.
	node reportOtherProcesses: aBoolean.
	result _ node spyEvery: self defaultPollPeriod on: aBlock.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false.
	^ result! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:37' prior: 16892331!
      spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: aBoolean
	"
	Spy on aProcess for a certain amount of time
	| p1 p2 |  
	p1 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  
	p2 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.
	p1 resume.
	p2 resume.  
	(Delay forMilliseconds: 100) wait.  
	MessageTally spyOnProcess: p1 forMilliseconds: 1000 reportOtherProcesses: true
	"
	| node |
	node _ self new.
	node reportOtherProcesses: aBoolean.
	node
		spyEvery: self defaultPollPeriod
		onProcess: aProcess
		forMilliseconds: msecDuration.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:37' prior: 16892381!
                            tallySendsTo: receiver inBlock: aBlock showTree: treeOption
	"
	MessageTally tallySends: [3.14159 printString]
	"
	"This method uses the simulator to count the number of calls on each method
	invoked in evaluating aBlock. If receiver is not nil, then only sends
	to that receiver are tallied.
	Results are presented as leaves, sorted by frequency,
	preceded, optionally, by the whole tree."
	| prev tallies startTime totalTime |
	startTime _ Time millisecondClockValue.
	tallies _ MessageTally new class: aBlock receiver class method: aBlock method.
	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"
	prev _ aBlock.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep: [ :current |
			current == prev ifFalse: [ "call or return"
				prev sender ifNotNil: [ "call only"
					(receiver == nil or: [ current receiver == receiver ])
						ifTrue: [ tallies tally: current by: 1 ]].
				prev _ current]].

	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [ :s |
			s nextPutAll: 'This simulation took ' , totalTime printString, ' seconds.'; newLine.
			treeOption
				ifTrue: [ tallies fullPrintExactOn: s ]
				ifFalse: [ tallies leavesPrintExactOn: s ]]))
		label: 'Spy Results'
		wrap: false! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1273-MessageTallyOpensWorkspace-JuanVuletich-2012May07-09h35m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:41:05 am'!
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 5/7/2012 09:40' prior: 16861123!
      paragraph: aParagraph bounds: boundsInWorld color: c selectionColor: sc
	| displayScanner leftInRun line |

	self setPaintColor: c.

	displayScanner _ MorphicScanner new 
		text: aParagraph paragraphText
		foreground: (shadowColor ifNil: [ c ])
		ignoreColorChanges: self isShadowDrawing.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	(aParagraph lineIndexForPoint: (0@0 max: clipRect origin- boundsInWorld origin))
		to: (aParagraph lineIndexForPoint: (boundsInWorld extent min: clipRect corner - boundsInWorld origin))
		do: [ :i |
			line _ aParagraph lines at: i.
			aParagraph
				displaySelectionInLine: line
				on: self
				paragraphTopLeft: boundsInWorld topLeft
				selectionColor: sc.
			leftInRun _ displayScanner displayLine: line paragraphTopLeft: boundsInWorld topLeft leftInRun: leftInRun  ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1274-SuperFastHugeTextDraw-JuanVuletich-2012May07-09h38m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:58:06 am'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/7/2012 09:56' prior: 16821805!
             endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		1 to: 3 do: [:i | (self at: size - i) = 0 ifFalse: [^size - i]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1275-endPCfix-JuanVuletich-2012May07-09h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1275] on 7 May 2012 at 1:44:24 pm'!
!BreakPoint commentStamp: '<historical>' prior: 16793543!
                     This exception is raised on executing a breakpoint.

"BreakPoint signal" is called from "Object>>break".!
!BreakpointManager commentStamp: '<historical>' prior: 16793556!
                     This class manages methods that include breakpoints.
It has several class methods to install and uninstall breakpoints.

Evaluating "BreakpointManager clear" will remove all installed breakpoints in the system.

Known issues:
- currently, only break-on-entry type of breakpoints are supported
- emphasis change not implemented for MVC browsers
- uninstalling the breakpoint doesn't auto-update other browsers
- uninstalling a breakpoint while debugging should restart-simulate the current method

Ernest Micklei, 2002

Send comments to emicklei@philemonworks.com!
!ConnectionClosed commentStamp: '<historical>' prior: 16826045!
            Signals a prematurely closed connection.!
!ConnectionTimedOut commentStamp: '<historical>' prior: 16826325!
                    Signals that a connection attempt timed out.!
!ExceptionAboutToReturn commentStamp: '<historical>' prior: 16846364!
            This class is private to the EHS implementation.  Its use allows for ensured execution to survive code such as:

[self doThis.
^nil]
	ensure: [self doThat]

Signaling or handling this exception is not recommended.  Not even slightly.!
!ExternalSemaphoreTable commentStamp: '<historical>' prior: 16847198!
               By John M McIntosh johnmci@smalltalkconsulting.com
This class was written to mange the external semaphore table. When I was writing a Socket test server I discovered various race conditions on the access to the externalSemaphore table. This new class uses class side methods to restrict access using a mutex semaphore. It seemed cleaner to deligate the reponsibility here versus adding more code and another class variable to SystemDictionary 

Note that in Smalltalk recreateSpecialObjectsArray we still directly play with the table.!
!IdentityBag commentStamp: '<historical>' prior: 16867422!
             Like a Bag, except that items are compared with #== instead of #= .

See the comment of IdentitySet for more information.!
!InvalidSocketStatusException commentStamp: '<historical>' prior: 16878188!
                         Signals if an operation on a Socket found it in a state invalid for that operation.!
!NetNameResolver commentStamp: '<historical>' prior: 16901704!
            This class implements TCP/IP style network name lookup and translation facilities.

Attempt to keep track of whether there is a network available.
HaveNetwork	true if last attempt to contact the network was successful.
LastContact		Time of that contact (totalSeconds).
haveNetwork	returns true, false, or #expired.  True means there was contact in the last 30 minutes.  False means contact failed or was false last time we asked.  Get out of false state by making contact with a server in some way (FileList or updates).!
!NoNetworkError commentStamp: '<historical>' prior: 16902223!
                        Signals that no network was found. This could happen, e.g., on dial-up connection when no connection was established when Squeak tried to access it.!
!SoundService commentStamp: '<historical>' prior: 16949962!
              This is the AppRegistry class for the sound system.

A sound system offers a small protocol for playing sounds and making beeps and works like a facade towards the rest of Squeak. A sound system is registered in this registry and can be accessed by "SoundService default". This way we decouple the sound system from the rest of Squeak and make it pluggable. It also is a perfect spot to check for the Preference class>>soundsEnabled.!
!Transcript commentStamp: '<historical>' prior: 16978076!
                   A new implementation of Transcript.
- Thread safe.
- Very fast.
- Independent of Morphic or any other UI framework.
- Immediate feedback.
- Can log to file.
- Not an editor. Only used for output.
- All protocol is on the Class side!
!UnloadedSound commentStamp: '<historical>' prior: 16980518!
                          Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1276-FixCrs-JuanVuletich-2012May07-13h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1275] on 7 May 2012 at 2:00:31 pm'!

!classDefinition: #SHTextStyler category: #'Shout-Styling'!
Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess monitor formattedText textModel mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!

Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess monitor formattedText textModel mutex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!
!SHTextStyler methodsFor: 'private' stamp: 'jmv 5/7/2012 13:57'!
    mutex
	mutex
		ifNil: [ mutex := Mutex new ].
	^mutex! !
!SHTextStyler methodsFor: 'styling' stamp: 'jmv 5/7/2012 13:57' prior: 16931250!
                      styleInBackgroundProcess
	"Do the styling on a copy of the provided text (and in a separate process).
	After finishing, send it to the model, via #stylerStyled:checkForChanges:
	The the model should grab the TextAttributes we added to the copy, as appropriate."
	self terminateBackgroundStylingProcess.

	formattedText _ textModel actualContents copy.
	self mutex critical: [
		
		"This part, running at current priority, and fired by sem, is for events to be triggered at current priority"
		sem _ Semaphore new. 
		[
			sem ifNotNil: [
				sem wait.
				textModel stylerStyled: formattedText checkForChanges: true ]
		] forkAt: Processor activePriority.

		"This part runs at low priority, and signals sem when finished"
		backgroundProcess _  [
			textModel privateStyleWith: self.
			sem signal] newProcess.
		backgroundProcess priority: Processor userBackgroundPriority.
		backgroundProcess resume
	]! !
!SHTextStyler methodsFor: 'private' stamp: 'jmv 5/7/2012 13:58' prior: 16931288!
  terminateBackgroundStylingProcess
	self mutex critical: [
		backgroundProcess 
			ifNotNil: [
				backgroundProcess terminate.
				backgroundProcess := nil].
		sem 
			ifNotNil:[
				sem terminateProcess.
				sem := nil].	
	]		! !

SHTextStyler removeSelector: #monitor!

SHTextStyler removeSelector: #monitor!

!classDefinition: #SHTextStyler category: #'Shout-Styling'!
Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess formattedText textModel mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!

Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess formattedText textModel mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1277-UseMutexInShout-JuanVuletich-2012May07-13h44m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1277] on 7 May 2012 at 2:40:53 pm'!
!Mutex commentStamp: 'jmv 5/7/2012 14:40' prior: 16901598!
                        A Mutex is a light-weight MUTual EXclusion object being used when two or more processes need to access a shared resource concurrently. A Mutex grants ownership to a single process and will suspend any other process trying to aquire the mutex while in use. Waiting processes are granted access to the mutex in the order the access was requested.

Nested (or recursive) calls to #critical: from a single process are allowed, and the process is not blocked for this: access is granted immediately. For this reason instances of Mutex should be used for resources that support this form of multiple access (i.e. multiple simultaneous access from within a single Process). Resources that don't support this, like access to private state that changes for each call, should use a Semaphore. See Semaphore's class comment

Instance variables:
	semaphore		<Semaphore>		The (primitive) semaphore used for synchronization.
	owner			<Process>			The process owning the mutex.!
!Semaphore commentStamp: 'jmv 5/7/2012 14:39' prior: 16935436!
                              I provide synchronized communication of a single bit of information (a "signal") between Processes. A signal is sent by sending the message signal and received by sending the message wait. If no signal has been sent when a wait message is sent, the sending Process will be suspended until a signal is sent.

Beware that if a process calls 'aSemaphore critical: []' while already in a critical section for that semaphore, it will enter a deadlock. In some cases, a Mutex can be used instead. Refer to the Mutex class comment.!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1278-MutexAndSemaphoreComments-JuanVuletich-2012May07-14h03m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1278] on 7 May 2012 at 10:10:48 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/7/2012 22:09'!
                   contributorInitialsAndNames
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DSM' 				'Duane Maxwell')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !
!AdditionalMethodState methodsFor: 'testing' stamp: 'jmv 5/7/2012 16:16' prior: 16781057!
                              hasLiteralSuchThat: aBlock
	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.
	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"
	1 to: self basicSize do: [:i |
		| propertyOrPragma "<Association|Pragma>" |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [(aBlock value: propertyOrPragma key)
					or: [(aBlock value: propertyOrPragma value)
					or: [propertyOrPragma value isArray
						and: [propertyOrPragma value hasLiteralSuchThat: aBlock]]]]
			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue: [^true]].
	^false! !
!AdditionalMethodState methodsFor: 'accessing' stamp: 'jmv 5/7/2012 21:34' prior: 16781171!
at: aKey put: aValue
	"Replace the property value or pragma associated with aKey."

	| keyAlreadyExists |
	keyAlreadyExists _ false.
	
	1 to: self basicSize do: [ :i |
		| propertyOrPragma "<Association|Pragma>" |
		(propertyOrPragma _ self basicAt: i) key == aKey ifTrue: [
			keyAlreadyExists _ true.
			propertyOrPragma isVariableBinding
				ifTrue: [ propertyOrPragma value: aValue ]
				ifFalse: [ self basicAt: i put: aValue ]]].
	
	keyAlreadyExists ifFalse: [
		method propertyValueAt: aKey put: aValue ].
	
	^ aValue! !
!Color methodsFor: 'transformations' stamp: 'jmv 5/7/2012 15:05' prior: 16817497!
                              twiceDarker
	"Answer a significantly darker shade of this color."

	^ self adjustSaturation: 0.076 brightness: -0.15! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:26' prior: 16832510!
                noon
	"Answer a DateAndTime starting at noon"

	^ self dayMonthYearDo: [ :d :m :y |
		self class year: y month: m day: d hour: 12 minute: 0 second: 0 ]! !
!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:25' prior: 16832895!
       epoch
	"Answer a DateAndTime representing the Squeak epoch: 1 January 1901"

	^ self julianDayNumber: SqueakEpoch! !
!ExceptionSet methodsFor: 'private' stamp: 'jmv 5/7/2012 21:38' prior: 16846393!
                          add: anException

	^exceptions add: anException! !
!ExceptionTester methodsFor: 'tests' stamp: 'jmv 5/7/2012 21:38' prior: 16846949!
                           simpleNoTimeoutTest

	[ self doSomething ]
		valueWithin: 1 days onTimeout:
			[ self doSomethingElse ]! !
!FloatTest methodsFor: 'IEEE 754' stamp: 'jmv 5/7/2012 15:15' prior: 16856078!
      testInfinity3
	self assert:
		(Float infinity negated asIEEE32BitWord
			printPaddedWith: $0
			to: 32
			base: 2) = '11111111100000000000000000000000'.
	self assert:
		(Float fromIEEE32Bit:
			(Integer
				readFrom: '11111111100000000000000000000000' readStream
				base: 2)) = Float infinity negated! !
!FloatTest methodsFor: 'IEEE 754' stamp: 'jmv 5/7/2012 15:15' prior: 16856112!
testZero2
	self assert:
		(Float negativeZero asIEEE32BitWord
			printPaddedWith: $0
			to: 32
			base: 2) = '10000000000000000000000000000000'.
	self assert:
		(Float fromIEEE32Bit:
			(Integer
				readFrom: '10000000000000000000000000000000' readStream
				base: 2)) = Float negativeZero! !
!Heap methodsFor: 'removing' stamp: 'jmv 5/7/2012 21:54' prior: 16866021!
                 removeAll

	array atAllPut: nil.
	tally _ 0! !
!Integer methodsFor: 'bit manipulation' stamp: 'jmv 5/7/2012 15:09' prior: 16873686!
                            >> shiftAmount  "right shift"
	shiftAmount < 0 ifTrue: [self error: 'negative arg'].
	^ self bitShift: shiftAmount negated! !
!MethodContext methodsFor: 'printing' stamp: 'jmv 5/7/2012 20:25' prior: 16893289!
               printString
	"Answer an emphasized string in case of a breakpoint method"
	(self method notNil and: [ self method hasBreakpoint ])
		ifFalse: [ ^ super printString ].
	^ super printString , ' [break]' asText allBold! !
!ParserNotification methodsFor: 'as yet unclassified' stamp: 'jmv 5/7/2012 16:20' prior: 16911486!
  setName: aString

	name _ aString! !
!Process methodsFor: 'accessing' stamp: 'jmv 5/7/2012 16:16' prior: 16921330!
             isTerminated

	self isActiveProcess ifTrue: [^ false].
	^suspendedContext isNil
	  or: ["If the suspendedContext is the bottomContext it is the block in Process>>newProcess.
		   If so, and the pc is greater than the startpc, the bock has alrteady sent and returned
		   from value and there is nothing more to do."
		suspendedContext isBottomContext
		and: [
			suspendedContext pc > suspendedContext startpc]]! !
!SmallIntegerTest methodsFor: 'testing - basic' stamp: 'jmv 5/7/2012 21:35' prior: 16941097!
    testEven
	
	self assert: (SmallInteger minVal even).
	self deny: (SmallInteger maxVal even).
	
	self deny: ((SmallInteger minVal + 1) even).
	self assert: ((SmallInteger maxVal - 1) even).
	
	self deny: (1 even).
	self deny: (-1 even).
	
	self assert: (2 even).
	self assert: (-2 even).
	
	self assert: (0 even)! !
!SmallIntegerTest methodsFor: 'testing - basic' stamp: 'jmv 5/7/2012 21:35' prior: 16941110!
        testOdd
	
	self deny: (SmallInteger minVal odd).
	self assert: (SmallInteger maxVal odd).
	
	self assert: ((SmallInteger minVal + 1) odd).
	self deny: ((SmallInteger maxVal - 1) odd).
	
	self assert: (1 odd).
	self assert: (-1 odd).
	
	self deny: (2 odd).
	self deny: (-2 odd).
	
	self deny: (0 odd)! !
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/7/2012 15:19' prior: 16959983!
                       allContributors
"
	Smalltalk allContributors
"
	| bag author |
	bag _ Bag new.
	Smalltalk allBehaviorsDo: [ :behavior |
		behavior methodsDo: [ :compiledMethod |
			author _ compiledMethod author.
			author notEmpty ifTrue: [
				bag add: author ]]].
	^bag! !
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 5/7/2012 14:49' prior: 16964558!
                               copyright
	"The Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak and Cuis projects. 1997-2012.'! !
!Time class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:26' prior: 16977361!
      hour: hour minute: minute second: second nanoSecond: nanoCount
	"Answer a Time"

	^ self 
		seconds: (hour * SecondsInHour) + (minute * SecondsInMinute) + second 
		nanoSeconds: nanoCount! !
!Time class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:27' prior: 16977375!
          noon

	^ self seconds: (SecondsInDay / 2)! !
!UndefinedVariable methodsFor: 'as yet unclassified' stamp: 'jmv 5/7/2012 16:19' prior: 16980327!
                 openMenuIn: aBlock
	| labels caption index |
	labels _ #('yes' 'no' ).
	caption _ name , ' appears to be 
undefined at this point.
Proceed anyway?'.
	index _ aBlock
		value: labels
		value: #()
		value: caption.
	^ self resume: index = 1! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:25' prior: 16985838!
                        startDay
	^ StartDay ifNil: [ StartDay _ DayNames first ]! !

Utilities class removeSelector: #reportSenderCountsFor:!

Utilities class removeSelector: #reportSenderCountsFor:!

SystemDictionary removeSelector: #agreedContributors!

SystemDictionary removeSelector: #agreedContributors!

SystemDictionary removeSelector: #missingAuthorsWithMethods!

SystemDictionary removeSelector: #missingAuthorsWithMethods!

SystemDictionary removeSelector: #newContributors!

SystemDictionary removeSelector: #newContributors!

SystemDictionary removeSelector: #okContributors!

SystemDictionary removeSelector: #okContributors!

SystemDictionary removeSelector: #relicenseEffortStartDate!

SystemDictionary removeSelector: #relicenseEffortStartDate!

SystemDictionary removeSelector: #returnedSignatories!

SystemDictionary removeSelector: #returnedSignatories!

BlockContext removeSelector: #argumentCount!

BlockContext removeSelector: #argumentCount!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1279-AuthorNamesTweaks-JuanVuletich-2012May07-18h42m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #4220] on 11 May 2012 at 3:42:03 pm'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/11/2012 15:40' prior: 50333413!
              endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		size-1 to: size-3 by: -1 do: [ :i |
			i < self initialPC ifTrue: [ ^ i ].
			(self at: i) = 0 ifFalse: [ ^ i ]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1280-CuisCore-JuanVuletich-2012May11-15h33m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:08:45 pm'!
!CodePackageFile methodsFor: 'services' stamp: 'jmv 5/12/2012 23:08' prior: 50332312!
      install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 5/12/2012 23:03' prior: 16813546!
  deletePackage

	| current cs |
	current _ model selection.
	current ifNil: [ ^self ].
	model selectionIndex: 0.	"no selection"
	cs _ ChangeSet changeSetForPackage: current.
	cs isEmpty ifFalse: [
		cs name: cs hash asString, cs name.
		cs isForBaseSystem: true ].
	CodePackage deregister: current! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1281-ChangeSetTweaks-JuanVuletich-2012May12-22h55m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:31:06 pm'!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:27'!
                            clearAuthor
	AuthorInitials _ ''.
	AuthorName _ ''! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:29'!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 5/12/2012 23:27' prior: 16962604!
                               openSourceFiles
	self imageName = LastImageName ifFalse: [
		"Reset the author initials to blank when the image gets moved"
		LastImageName _ self imageName.
		Utilities clearAuthor].
	"Warning: Do open the source files only if nil.
	If not nil, it is because they are internalized and the files should not be opened"
	FileDirectory
		openSources: self defaultSourcesName
		andChanges: self localChangesName
		forImage: LastImageName.
	CuisSourceFileArray install! !
!Theme methodsFor: 'menus' stamp: 'jmv 5/12/2012 23:26' prior: 16975775!
    miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('command-key help') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (h)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980966!
         authorInitials
	"Answer the initials to be used to identify the current code author.  "

	[AuthorInitials isEmpty] whileTrue: [self setAuthor].
	^ AuthorInitials! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980981!
                               authorName
	[AuthorName isEmpty] whileTrue: [self setAuthor].
	^ AuthorName! !

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorName!

Utilities class removeSelector: #setAuthorName!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1282-AuthorNameAndInitialsTweaks-JuanVuletich-2012May12-23h08m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:08:55 pm'!
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2012 22:07' prior: 16802259!
                             changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename.
	aMenu add: 'Destroy change set (x)' 			action: #remove.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 		action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.
	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	aMenu add: 'trim history' target: model action: #trimHistory.
	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	aMenu add: 'view affected class categories' target: model action: #viewAffectedClassCategories.
	aMenu balloonTextForLastItem: ' Show class categories affected by any contained change'.

	^ aMenu! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920783!
                         cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920802!
                  slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic true)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920820!
                   smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak in recent years. Caution: this theme removes the standard Squeak flaps, turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more."

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(thoroughSenders false)
	)! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:03' prior: 16974647!
                buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:51' prior: 16974931!
                              openMenu
	"Build the open window menu for the world."

	| menu |
	menu _ self menu: 'Open...'.

	ExtraOpenCommands ifNotNil: [
		self fillIn: menu from: ExtraOpenCommands ].

	self fillIn: menu from: {
		{'Text Editor' . {self . #openTextEditor}. 'A window for composing text' }.
		{'Workspace' . {self . #openWorkspace}. 'A window for evaluating Smalltalk expressions' }.
		{'Browser' . { self . #openBrowser}. 'A Smalltalk code browser, for studying and modifying the system'}.
		{'Message Names' . { self . #openMessageNames} . 'A tool for finding and editing methods that contain any given keyword in their names.'}.
		{'Transcript' . {self . #openTranscript}. 'A window showing contents of the System Transcript' }.
		nil.
		{'Installed Packages' . { self . #openPackageList}. 'A tool for managing Packages (optional units of code) installed in the system'}.
		{'Change Sorter' . {self . #openChangeSorter1} . 'A tool allowing you to view the methods in a Change Set, especially changes to the Base System' }.
		nil.
		{ 'Process Browser' . { ProcessBrowserWindow . #openProcessBrowser } }.
		{ 'Emergency Evaluator'. { Transcripter. #emergencyEvaluator } }.
		nil.
		{'File List' . {self . #openFileList} . 'An explorer of the File System' }.
		{'SUnit Test Runner' . {TestRunnerWindow . #openTestRunner} . 'A tool allowing you to compare and manipulate two change sets concurrently' }.
	}.
	^menu! !

Preferences class removeSelector: #simpleMenus!

Preferences class removeSelector: #simpleMenus!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1283-MenuTweaks-JuanVuletich-2012May13-21h47m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:38:14 pm'!

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags '
	classVariableNames: 'AllChangeSets '
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:28'!
         changeSetDirtyFlags

	^ (ChangeSorter allChangeSets collect: [ :each |
		(each isForBaseSystem and: [ each hasUnsavedChanges ])
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]) reversed! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:23'!
                initialExtent
	^720@480! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:31' prior: 16801656!
            fileOutAndKeep
	"File out the current change set."

	myChangeSet fileOut.
	self update! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:37' prior: 16801780!
             updateIfNecessary
	"Recompute all of my panes."

	| newList |

	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"
	myChangeSet isMoribund ifTrue: [
		self changed: #changeSetList.
		^ self showChangeSet: ChangeSet changeSetForBaseSystem ].

	newList _ self changeSetList.
	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])
		ifTrue: [
			priorChangeSetList _ newList.
			self changed: #changeSetList ].

	newList _ self changeSetDirtyFlags.
	(priorDirtyFlags == nil or: [priorDirtyFlags ~= newList])
		ifTrue: [
			priorDirtyFlags _ newList.
			self changed: #changeSetDirtyFlags ]! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:27' prior: 16802203!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: Color white.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1284-DirtyFlagVisibleInChangeSorter-JuanVuletich-2012May13-22h08m-jmv.6.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1284] on 13 May 2012 at 11:12:09 pm'!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:01'!
 notInstallOrTestRun

	^Installing isNil or: [
		(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:46'!
                  runningTest: aTestName do: aBlock

	Installing _ 'RunningTest-', aTestName.
	aBlock ensure: [ Installing _ nil ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:10' prior: 50332249!
             changeSetForBaseSystem

	| csName numberToUse |
	self notInstallOrTestRun
		ifTrue: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifFalse: [
			csName _ 'Affects-BaseSystem--', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:11' prior: 50332274!
                               changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ 	self notInstallOrTestRun
		ifTrue: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifFalse: [
			Installing = ('Install-', aCodePackage packageName)
				ifTrue: [ Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:42' prior: 16801541!
                   installing: aCodePackageOrChangeSetName do: aBlock

	| currentCS currentCSNumber newHighestUpdate |
	Installing _ 'Install-', aCodePackageOrChangeSetName.
	aBlock ensure: [ Installing _ nil ].

	SystemVersion current registerUpdate: aCodePackageOrChangeSetName.
	newHighestUpdate _  SystemVersion current highestUpdate.

	currentCSNumber _ self currentBaseCSNumber.
	currentCS _ self changeSetForBaseSystem.
	currentCS isEmpty ifTrue: [
		ChangeSorter removeChangeSet: currentCS.
		currentCSNumber > newHighestUpdate ifFalse: [
			CurrentBaseCSNumber _ newHighestUpdate + 1 ]]! !
!TestCase methodsFor: 'Running' stamp: 'jmv 5/13/2012 23:05' prior: 16968097!
              run: aResult
	ChangeSet
		runningTest: self printString
		do: [ aResult runCase: self ]
			! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 16968792!
              runSuite: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ suite run ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 50333110!
        runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1285-TestRunnerCreatedCodeInOwnChangeSet-JuanVuletich-2012May13-23h09m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1286] on 15 May 2012 at 11:06:34 am'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 5/15/2012 11:05' prior: 16897419!
        focusKeyboardFor: aKeyboardEvent

	"If aKeyboardEvent ctrl-tab or shift-ctrl-tab use it to navigate keyboard focus.
	Warning: This doesn't work on Windows... the event is not sent"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent controlKeyPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ]
				ifFalse: [ aKeyboardEvent hand keyboardFocusNext ].
			^ true ].
	"On Windows use at least some keystroke to navigate morphs... even shift-Tab that should navigate backwards"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent shiftPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent hand keyboardFocusNext.
			^ true ].

	"Cycle through windows with cmdAlt + < and cmdAlt + >.
	VM and platform peculiarities are hidden in #isCmdAltLessThan and #isCmdAltGreaterThan"
	"This was done as an attempt to mimic the Mac OSX keystrokes for 'Move focus to next window in active application'. Unfortunately, it only works if OS X is set to use any other keys for this. If (as for example, with German defaults), OS-X uses these keystrokes, then they are not sent to the VM. This is a long standing issues in Chromium and PhotoShop, for example..."
	self disableCode: [
		aKeyboardEvent isCmdAltLessThan ifTrue: [
			aKeyboardEvent hand activatePreviousWindow.
			^true ].
		aKeyboardEvent isCmdAltGreaterThan ifTrue: [
			aKeyboardEvent hand activateNextWindow.
			^true ]].
	"Alternative for Mac OS-X: option-Tab and option-shift-Tab"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent rawMacOptionKeyPressed ])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand activatePreviousWindow ]
				ifFalse: [ aKeyboardEvent hand activateNextWindow ].
			^ true ].
	"Alternative for non-Mac OS-X: alt-< and alt->"
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter = $< ]) ifTrue: [
		aKeyboardEvent hand activatePreviousWindow.
		^true ].
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter = $> ]) ifTrue: [
		aKeyboardEvent hand activateNextWindow.
		^true ].
	^false! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1286-KeyboardNavigationTweaks-JuanVuletich-2012May15-09h49m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1286] on 15 May 2012 at 10:23:27 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/15/2012 18:00'!
                               unknownContributors
	"Answer a collection of authorInitials for whom there is code in the system 
	(either in core or in loaded packages), but we don't knwo their full name.
	Smalltalk unknownContributors
	"

	| all ok |
	all _ Smalltalk allContributors asSet.
	ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
	^(all difference: ok) asArray sort! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1287-UnknownContributors-JuanVuletich-2012May15-22h21m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1287] on 17 May 2012 at 10:08:11 am'!
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 5/17/2012 09:06'!
         noteRecategorizationOfClass: aClass
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	aClass wantsChangeSetLogging ifFalse: [^ self].
	self atClass: aClass add: #change.
	self addCoherency: aClass name.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'method changes' stamp: 'jmv 5/17/2012 09:41' prior: 50331875!
              removeSelectorChanges: selector class: class 
	"Remove all memory of changes associated with the argument, selector, in 
	this class."

	| chgRecord |
	self hasUnsavedChanges: true.	"set the flag in any case"
	(chgRecord _ changeRecords at: class name ifAbsent: [^ self])
		removeSelector: selector.
	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name]! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 5/17/2012 09:45' prior: 50331889!
                      noteClassForgotten: className
	"Remove from structures if class is not a superclass of some other one we are remembering"

	self hasUnsavedChanges: true.	"set the flag in any case"
	structures ifNil: [^ self].
	Smalltalk at: className ifPresent: [:cls |
		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [
			^ self]]].  "No delete"
	structures removeKey: className ifAbsent: nil! !
!ChangeSet methodsFor: 'system change notifications' stamp: 'jmv 5/17/2012 09:04' prior: 50332021!
             classRecategorized: aClass from: oldCategory to: newCategory

	self noteRecategorizationOfClass: aClass! !
!ChangeSet class methodsFor: 'system change notifications' stamp: 'jmv 5/17/2012 09:20' prior: 16801317!
            classRecategorized: aClass from: oldCategory to: newCategory
	"If the class was moved to a dfferent package, out of the base system, record the fact in the change set.
	The actual class redefinition is done at #classDefinitionChangedFrom:to: that is also called (if the class really changed)."

	| oldPackageOrNil newPackageOrNil newChangeSet |
	newPackageOrNil _ CodePackage
		packageOfSystemCategory: newCategory
		ifNone:	nil.
	newPackageOrNil ifNotNil: [ newPackageOrNil hasUnsavedChanges: true ].
	newChangeSet _ ChangeSet changeSetForPackage: newPackageOrNil.
	newChangeSet noteRecategorizationOfClass: aClass.

	oldPackageOrNil _ CodePackage
		packageOfSystemCategory: oldCategory
		ifNone: nil.
	oldPackageOrNil
		ifNotNil: [ oldPackageOrNil hasUnsavedChanges: true ]
		ifNil: [
			"If destination is a package, but source isn't, then record the change in the base system changeset"
			newPackageOrNil ifNotNil: [
				self changeSetForBaseSystem noteClassMoveToOtherPackage: aClass ]]! !
!ChangeSet class methodsFor: 'system change notifications' stamp: 'jmv 5/17/2012 09:43' prior: 16801454!
                   selectorRecategorized: selector from: oldCategory to: newCategory inClass: aClass
	"If the method was moved to a dfferent package, affect the package that lost the it. Tell it that it lost the method.
	The actual method redefinition is done at one of the method definition methods, that is also called."

	| newPackageOrNil newChangeSet oldPackageOrNil |
	newPackageOrNil _ CodePackage
		packageOfMethodCategory: newCategory
		ofClass: aClass
		ifNone:	nil.
	newPackageOrNil ifNotNil: [ newPackageOrNil hasUnsavedChanges: true ].
	newChangeSet _ ChangeSet changeSetForPackage: newPackageOrNil.
	newChangeSet selectorRecategorized: selector from: oldCategory to: newCategory inClass: aClass.

	oldPackageOrNil _ CodePackage
		packageOfMethodCategory: oldCategory
		ofClass: aClass
		ifNone: nil.
	oldPackageOrNil
		ifNotNil: [ oldPackageOrNil hasUnsavedChanges: true ]
		ifNil: [
			"If destination is a package, but source isn't, then record the change in the base system changeset"
			newPackageOrNil ifNotNil: [
				self changeSetForBaseSystem noteMethodMoveToOtherPackage: selector forClass: aClass ]]! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 5/17/2012 10:03' prior: 50332057!
             register: aCodePackage
	"
	Usually call #named:createIfAbsent:registerIfNew: instead
	CodePackage register: (CodePackage newNamed: 'Tests-Files')
	"
	| any base |
	InstalledPackages at: aCodePackage packageName put: aCodePackage.

	"Anything that now belongs in this package, was moved out of the base system!!"
	base _ ChangeSet changeSetForBaseSystem.
	any _ false.
	aCodePackage classes do: [ :cls |
		any _ true.
		base noteClassMoveToOtherPackage: cls ].
	aCodePackage extensionMethods do: [ :methodReference |
		methodReference isValid ifTrue: [
			any _ true.
			base
				noteMethodMoveToOtherPackage: methodReference selector
				forClass: methodReference actualClass ]].
	any ifTrue: [
		aCodePackage hasUnsavedChanges: true ].

	self triggerEvent: #installedPackagesChanged! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1288-PackageAndChangeSetFixes-JuanVuletich-2012May17-10h06m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1288] on 23 May 2012 at 8:07:33 pm'!
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:30'!
               drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: bounds extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:17'!
buttonColor

	^Theme current buttonColorFrom: self widgetsColor! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:59'!
                      textBackgroundColor

	^Theme current paneBackgroundFrom: self widgetsColor! !
!Theme methodsFor: 'other options' stamp: 'jmv 5/23/2012 19:33'!
                 embossedButtonLabels
	"Currently only apply to rounded buttons!!"

	^true! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:07'!
                          italizeArguments

	^true! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:06' prior: 16852813!
    createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	result bounds: (29@90 corner: 122@117).
	self addMorph: result.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:08' prior: 16852830!
             createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	result bounds: (149@90 corner: 242@117).
	self addMorph: result.
	^ result! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:20' prior: 16852957!
                   drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				roundRect: bounds
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		fillRectangle: textPane bounds
		colorOrInfiniteForm: (Theme current paneBackgroundFrom: color)! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:31' prior: 16913500!
  draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: bounds
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:33' prior: 16913585!
            drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	rect _ bounds insetBy: 1@3.
	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:43' prior: 16965269!
    openInWorld
	"Ensure all widgets have proper colors before opening"
	self widgetsColor: self widgetsColor.
	super openInWorld! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:46' prior: 16965514!
               widgetsColor

	widgetsColor ifNotNil: [ ^ widgetsColor ].
	^Display depth > 2
		ifTrue: [ self windowColor ]
		ifFalse: [ Color white ]! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 19:00' prior: 16965524!
     widgetsColor: aColor
	"aColor will be used for titles, borders, etc.
	A variation of it, #paneColorFrom:, will be used for panes background"

	widgetsColor _ aColor.
	self color: self textBackgroundColor.
	self adoptWidgetsColor: widgetsColor! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:11' prior: 16813416!
          buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton backColor labelBackground |
	backColor _ self textBackgroundColor.	
	labelBackground _ Theme current background.
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: names proportionalWidth: 0.2;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.7.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: summary proportionalHeight: 0.13;
		addAdjusterAndMorph: description proportionalHeight: 0.3;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.07.
	self setLabel: 'Installed Packages'! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16814896!
            optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:02' prior: 16815041!
                decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm isKindOf: CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		Color tan.							"no sends to super. there is an override in some subclass"
		Color red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Color red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Color green muchLighter.			"doesn't have sub; has super and callsl it"
		Color blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: aColor! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:02' prior: 16795512!
   buildMorphicSwitches
	| instanceSwitch commentSwitch classSwitch row buttonColor |
	instanceSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #instanceMessagesIndicated
				action: #indicateInstanceMessages.
	instanceSwitch
		label: 'instance'.
	commentSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #classCommentIndicated
				action: #plusButtonHit.
	commentSwitch
		label: '?';
		setBalloonText: 'class comment'.
	classSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #classMessagesIndicated
				action: #indicateClassMessages.
	classSwitch
		label: 'class'.
	row _ LayoutMorph newRow.
	row
		addMorph: instanceSwitch proportionalWidth: 0.45;
		addMorph: commentSwitch proportionalWidth: 0.22;
		addMorph: classSwitch proportionalWidth: 0.33.
	buttonColor _ self buttonColor.
	row color: buttonColor.
	{ 
		instanceSwitch.
		commentSwitch.
		classSwitch} do: [:m | 
				m color: buttonColor ].
	^row! !
!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:02' prior: 16799310!
        optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:12' prior: 50334853!
                             buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16834872!
                             customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons _ OrderedCollection new.
	buttonColor _ self buttonColor.
	"button with target = self"
	button _ PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple second.
		button color: buttonColor.
		button label: tuple first asString.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16851920!
                      buttonToTriggerIn: aFileList for: service
	"Answer a button that will trigger the receiver service in a file list"

	| aButton |
	service argumentProvider: aFileList.
	aButton := PluggableButtonMorph 
				model: service
				stateGetter: nil
				action: #performService.
	aButton label: service buttonLabel.
	aButton color: self buttonColor.
	aButton setBalloonText: service description.
	^aButton! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16851975!
                       optionalButtonRow
	"Answer the button row associated with a file list"

	| row buttonColor |
	row _ LayoutMorph newRow.
	buttonColor _ self buttonColor.
	row setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"
	row color: buttonColor.
	self updateButtonRow: row.
	^row! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:25' prior: 50333147!
                           buildUpperControls
	| refreshButton filterButton stopButton runOneButton runButton runProfiledButton row column1 column2 column3 theTestsList |

	refreshButton _ self buildRefreshButton.
	filterButton _ self buildFilterButton.
	stopButton _ self buildStopButton.
	column1 _ LayoutMorph newColumn.
	column1 addMorphs: { refreshButton . filterButton . stopButton }.

	theTestsList _ PluggableListMorphOfMany
				model: model
				listGetter: #tests
				primarySelectionGetter: #selectedSuite
				primarySelectionSetter: #selectedSuite:
				listSelectionGetter: #listSelectionAt:
				listSelectionSetter: #listSelectionAt:put:
				mainView: self
				menuGetter: #listMenu
				keystrokeAction: nil.
	theTestsList autoDeselect: false.
	theTestsList color: self textBackgroundColor.
	column2 _ LayoutMorph newColumn.
	column2
		addMorph: theTestsList proportionalHeight: 1;
		addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight.

	runOneButton _ self buildRunOneButton.
	runButton _ self buildRunButton.
	runProfiledButton := self buildRunProfiledButton.	
	column3 _ LayoutMorph newColumn.
	column3 addMorphs: { runOneButton . runButton . runProfiledButton }.
	
	row _ LayoutMorph newRow.
	row
		addMorph: column1 fixedWidth: 80;
		addMorph: column2 proportionalWidth: 1;
		addMorph: column3 fixedWidth: 120.

	^row

! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16969152!
            optionalButtonRow
	| row button buttons widths buttonColor |

	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | 
		widths add: tuple first.
		button _ PluggableButtonMorph 
			model: model
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button
			label: tuple second.
		buttons add: button].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 16969193!
                       refreshWindow
	| pc |
	pc _ self widgetsColor.
	passFailText color: pc.
	detailsText color: pc.
	model refreshTR! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 16969210!
                     updateColors
	| aTestResult theColor |
	theColor _ self widgetsColor.
	model ifNotNil: [
		model runButtonState ifFalse: [
			aTestResult _ model result.
			theColor _ aTestResult errors size + aTestResult failures size = 0
				ifTrue: [ Color green lighter ]
				ifFalse: [
					aTestResult errors size > 0
						ifTrue: [ Color red lighter ]
						ifFalse: [ Color yellow lighter ]]].
		self updatePartColors: theColor ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23' prior: 16975339!
       messageNames

	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.53 g: 0.77 b: 0.382 ]! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:49' prior: 16975390!
                 acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.2 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51' prior: 16975395!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 5/23/2012 19:50' prior: 16975549!
             generateShoutConfig

	| styles colors |
	
	styles := OrderedCollection new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self literals . colors at: #pseudoVariables}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . #italicArguments}.
		{self symbols . colors at: #messages . #bold}.
		{self nilly . nil . #bold}. "This one is odd.  --cbr"
		{self tempVars . colors at: #tempVars . #italic }.
		{self blockTemps . colors at: #tempBar . #italic}
	} do: [:style|
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection.
					elements at: 1 put: category.
					elements last = #italicArguments ifTrue: [
						self italizeArguments
							ifTrue: [ elements at: 3 put: #italic ]
							ifFalse: [ elements removeLast ]].
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	self flag: #todo. "investigate meaning of nil in this context"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined . #bold}.
		{#unfinishedComment . colors at: #pseudoVariables . #italic}.
		{#comment . colors at: #methodTags . #italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . #italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:06' prior: 16976511!
                  shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(cyan muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 5/23/2012 18:55' prior: 16976584!
   changeTheme

	| themes set menu result |
		themes _ Theme allSubclasses copyWith: Theme.
		set _ themes collect: [ :i | { i asString . i } ].
		menu _ SelectionMenu fromArray: set asArray.
		result _ menu startUpWithCaption: 'Choose a theme'.

	result ifNotNil: [ result beCurrent ]! !

PluggableButtonMorph removeSelector: #drawLabelOn:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1289-FixIssues001to005-JuanVuletich-2012May23-18h45m-jmv.9.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1289] on 23 May 2012 at 10:26:51 pm'!
!BlueTheme methodsFor: 'colors' stamp: 'DSG 5/23/2012 22:19' prior: 16792894!
                 shout
	"Color symbols as an association list."
	
	^ {
		#defaults 							-> #white.
		#undefined 						-> #(orange lighter).
		#methodTags 					-> #(green lighter).
		#pseudoVariables 			-> #(red veryMuchLighter).
		#messages 						-> #(cyan).
		#arguments 				-> #white.
		#instVar 							-> #(magenta muchDarker).
		#incompleteMessages 	-> #(gray veryMuchDarker).
		#blockLevelFour 				-> #(green darker).
		#blockLevelFive 				-> #(red darker).
		#blockLevelSix 				-> #(magenta darker).
		#blockLevelSeven 			-> #blue.
		#tempBar 							-> #gray.
		#tempVars 						-> #(gray quiteWhiter).
	}! !
!HighContrastBlackTheme methodsFor: 'colors' stamp: 'DSG 5/23/2012 22:16' prior: 16867255!
              shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #white.
		#undefined 				-> #cyan.
		#methodTags 			-> #(magenta darker).
		#pseudoVariables 		-> #(cyan darker).
		#messages 				-> #(yellow darker).
		#arguments 				-> #(white darker).
		#instVar 					-> #(green darker).
		#incompleteMessages -> #gray.
		#blockLevelFour 		-> #(magenta).
		#blockLevelFive 		-> #(orange negated).
		#blockLevelSix 			-> #(green).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #(gray veryMuchLighter lighter).
		#tempVars 				-> #(gray muchLighter).
	}! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1290-CuisCore-DavidGraham-2012May23-22h16m-DSG.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1290] on 25 May 2012 at 11:40:36 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 11:35'!
                          knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DSM' 				'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 11:34' prior: 50335203!
                          unknownContributors
	"Answer a collection of authorInitials for whom there is code in the system 
	(either in core or in loaded packages), but we don't knwo their full name.
	Smalltalk unknownContributors
	"

	| all ok |
	all _ Smalltalk allContributors asSet.
	ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
	^(all difference: ok) asArray sort! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/25/2012 11:34' prior: 50334282!
         setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk knownInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !

SystemDictionary removeSelector: #contributorInitialsAndNames!

SystemDictionary removeSelector: #contributorInitialsAndNames!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1291-AuthorInitialsTweaks-JuanVuletich-2012May25-11h33m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1291] on 25 May 2012 at 1:05:09 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 13:00' prior: 50336211!
                            knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DKL'					'Daniel K Lyons ')
	#('DSM' 				'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1292-addDKLtoAuthors-JuanVuletich-2012May25-13h00m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1292] on 25 May 2012 at 11:02:52 pm'!
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 5/25/2012 23:02' prior: 16868326!
             unhighlight

	complexContents highlightingColor ifNotNil: [ self color: Theme current text ].
	self redrawNeeded! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1293-CuisCore-JuanVuletich-2012May25-23h02m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1293] on 6 June 2012 at 1:26:55 pm'!
!Character methodsFor: 'accessing' stamp: 'jmv 6/6/2012 11:52'!
        asciiCode
	"Answer the value of the receiver that represents its ascii encoding."

	^value! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:18'!
                   fileNamed: localFileName do: aBlock
	"Open the file with the given name in this directory for reading and/or writing.
	Create it if it doesn't exist.
	Evaluate aBlock, and close the file"

	(self fileNamed: localFileName) ifNotNil: [ :fileStream |
		[ aBlock value: fileStream ] ensure: [ fileStream close ]]
! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:05'!
                        forceNewFileNamed: localFileName do: aBlock
	"Open the file with the given name in this directory for writing.
	If it already exists, delete it first without asking.
	Evaluate aBlock, and close the file"

	(self forceNewFileNamed: localFileName) ifNotNil: [ :fileStream |
		[ aBlock value: fileStream ] ensure: [ fileStream close ]]! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:06'!
 newFileNamed: localFileName do: aBlock
	"Create a new file with the given name in this directory.
	If the file already exists, give the chance to pick another name or overwrite it
	Evaluate aBlock, and close the file"

	(self newFileNamed: localFileName) ifNotNil: [ :fileStream |
		[ aBlock value: fileStream ] ensure: [ fileStream close ]]! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:07'!
                        oldFileNamed: localFileName do: aBlock
	"Open the existing file with the given name in this directory.
	If the file doesn't exist, give the chance to create the file, use another name, or abort.
	Evaluate aBlock, and close the file"

	(self oldFileNamed: localFileName) ifNotNil: [ :fileStream |
		[ aBlock value: fileStream ] ensure: [ fileStream close ]]! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:14'!
         oldFileNamed: localFileName ifExistsDo: aBlock
	"Open the existing file with the given name in this directory.
	If the file doesn't exist, do nothing.
	If the file exists, evaluate aBlock, and close the file"

	(self oldFileOrNoneNamed: localFileName) ifNotNil: [ :fileStream |
		[ aBlock value: fileStream ] ensure: [ fileStream close ]]! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:11'!
                           readOnlyFileNamed: localFileName do: aBlock
	"Open the existing file with the given name in this directory for read-only access.
	If the file doesn't exist, give the chance to pick another, use another name, or abort.
	Evaluate aBlock, and close the file"

	(self readOnlyFileNamed: localFileName) ifNotNil: [ :fileStream |
		[ aBlock value: fileStream ] ensure: [ fileStream close ]]! !
!SingleSetChangeSorter methodsFor: 'accessing' stamp: 'jmv 6/6/2012 11:45'!
                changeSetDirtyFlags

	^{ (myChangeSet isForBaseSystem and: [ myChangeSet hasUnsavedChanges ])
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ] }! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:18' prior: 16849127!
         fileNamed: localFileName
	"Open the file with the given name in this directory for reading and/or writing.
	Create it if it doesn't exist."

	^ FileStream concreteStream fileNamed: (self fullNameFor: localFileName)
! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:05' prior: 16849135!
      forceNewFileNamed: localFileName
	"Open the file with the given name in this directory for writing.
	If it already exists, delete it first without asking."

	^ FileStream concreteStream forceNewFileNamed: (self fullNameFor: localFileName)
! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:06' prior: 16849146!
              newFileNamed: localFileName
	"Create a new file with the given name in this directory.
	If the file already exists, give the chance to pick another name or overwrite it."

	^ FileStream concreteStream newFileNamed: (self fullNameFor: localFileName)
! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:07' prior: 16849154!
    oldFileNamed: localFileName
	"Open the existing file with the given name in this directory.
	If the file doesn't exist, give the chance to create the file, use another name, or abort."

	^ FileStream concreteStream oldFileNamed: (self fullNameFor: localFileName)
! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 6/6/2012 13:10' prior: 16849174!
                      readOnlyFileNamed: localFileName
	"Open the existing file with the given name in this directory for read-only access.
	If the file doesn't exist, give the chance to pick another, use another name, or abort."

	^ FileStream concreteStream readOnlyFileNamed: (self fullNameFor: localFileName)
! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 6/6/2012 11:58' prior: 16963283!
   browseAllUnimplementedCalls
	"Create and schedule a message browser on each method that includes a 
	message that is not implemented in any object in the system.
	Smalltalk browseAllUnimplementedCalls
	"

	^self browseMessageList: self allUnimplementedCalls name: 'Unimplemented calls'! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1294-FileStreamCreationFromSqueak-JuanVuletich-2012Jun06-13h25m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1294] on 6 June 2012 at 2:40:09 pm'!

!classDefinition: #DirectoryEntry category: #'System-Files'!
Object subclass: #DirectoryEntry
	instanceVariableNames: 'name creationTime modificationTime dirFlag fileSize directory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

Object subclass: #DirectoryEntry
	instanceVariableNames: 'name creationTime modificationTime dirFlag fileSize directory '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

!classDefinition: #DirectoryEntryDirectory category: #'System-Files'!
DirectoryEntry subclass: #DirectoryEntryDirectory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

DirectoryEntry subclass: #DirectoryEntryDirectory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!
!DirectoryEntryDirectory commentStamp: '<historical>' prior: 0!
               an entry in a directory; a reference to a directory.!

!classDefinition: #DirectoryEntryFile category: #'System-Files'!
DirectoryEntry subclass: #DirectoryEntryFile
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

DirectoryEntry subclass: #DirectoryEntryFile
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!
!DirectoryEntryFile commentStamp: '<historical>' prior: 0!
          an entry in a directory; a reference to a file.!
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 10/30/2009 15:50'!
           baseName
	^ FileDirectory baseNameFor: self name! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 9/12/2007 17:36'!
         containingDirectory
	"Answer the FileDirectory in which I reside."
	^ directory! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 8/10/2007 12:25'!
          creationDateAndTime
	"The DateAndTime my entry in the file system was created."
	^DateAndTime fromSeconds: creationTime! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 9/21/2009 18:24'!
  extension
	^ FileDirectory extensionFor: self name! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 2/15/2010 15:52'!
       fileSizeString
	"Answer my file size as an easy-to-read String."
	^ self fileSize asBytesDescription! !
!DirectoryEntry methodsFor: 'access' stamp: 'bgf 9/9/2010 07:36'!
                      fullName
	"The fully-qualified name.
	 Since this method falls into the equality test, make it safe when directory is nil."
	^ directory 
		ifNotNil: [ directory fullNameFor: self name ] 
		ifNil: [ self name ]! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 8/10/2007 12:25'!
       modificationDateAndTime
	"The DateAndTime my entry in the file system was last modified."
	^ DateAndTime fromSeconds: modificationTime! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 8/29/2007 17:44'!
                   printOn: aStream 
	super printOn: aStream.
	aStream
		space ;
		nextPutAll: self name! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 2/18/2011 15:54'!
    splitNameVersionExtension
	" answer an array with the root name, version # and extension."
	^ self directory splitNameVersionExtensionFor: self name! !
!DirectoryEntry methodsFor: 'private-initialization' stamp: 'cmm 9/12/2007 17:20'!
                     setDirectory: aFileDirectoryOrServerDirectory name: name0  creationTime: creationTime0  modificationTime: modificationTime0 fileSize: fileSize0
	directory := aFileDirectoryOrServerDirectory.
	name := name0.
	creationTime := creationTime0.
	modificationTime := modificationTime0.
	fileSize := fileSize0! !
!DirectoryEntry methodsFor: 'testing' stamp: 'cmm 2/24/2011 19:17'!
           = aDirectoryEntry 
	"Answer whether I am equivalent in all of my file-system attributes."
	super = aDirectoryEntry ifTrue: [^ true].
	self species = aDirectoryEntry species ifFalse: [^ false].
	^ self containingDirectory = aDirectoryEntry containingDirectory
		and: [self name = aDirectoryEntry name
				and: [self modificationTime = aDirectoryEntry modificationTime
						and: [self fileSize = aDirectoryEntry fileSize]]]! !
!DirectoryEntry methodsFor: 'testing' stamp: 'cmm 2/21/2011 21:50'!
                  exists
	^ (self containingDirectory
		entryAt: self name
		ifAbsent: [ nil ]) notNil! !
!DirectoryEntry methodsFor: 'testing' stamp: 'cmm 2/18/2011 16:04'!
    hash
	"Hashing on directory + name should be sufficient."
	^ (self containingDirectory hash hashMultiply + self name hash) hashMultiply! !
!DirectoryEntry class methodsFor: 'instance creation' stamp: 'jmv 6/6/2012 13:47'!
  directory: aFileDirectoryOrServerDirectory name: name0 creationTime: creationTime modificationTime: modificationTime fileSize: fileSize 
	^ self new 
		setDirectory: aFileDirectoryOrServerDirectory
		name: name0
		creationTime: creationTime
		modificationTime: modificationTime
		fileSize: fileSize! !
!DirectoryEntry class methodsFor: 'instance creation' stamp: 'jmv 6/6/2012 13:47'!
                               fromArray: array directory: aFileDirectoryOrServerDirectory 
	| entryType |
	entryType := (array at: 4) 
		ifTrue: [ DirectoryEntryDirectory ]
		ifFalse: [ DirectoryEntryFile ].
	^ entryType 
		directory: aFileDirectoryOrServerDirectory
		name: (array at: 1)
		creationTime: (array at: 2)
		modificationTime: (array at: 3)
		fileSize: (array at: 5)! !
!DirectoryEntryDirectory methodsFor: 'testing' stamp: 'cmm 9/13/2007 12:24'!
                   isDirectory
	"whether this entry represents a directory, it does."
	^ true! !
!DirectoryEntryDirectory methodsFor: 'convert' stamp: 'jmv 6/6/2012 14:23'!
      asFileDirectory
	"Answer a FileDirectory representing the same directory I represent."
	^directory on: (directory fullNameFor: self name)! !
!DirectoryEntryFile methodsFor: 'testing' stamp: 'cmm 9/13/2007 12:24'!
           isDirectory
	"whether this entry represents a directory, it does not."
	^ false! !
!DirectoryEntryFile methodsFor: 'stream access' stamp: 'jmv 6/6/2012 14:21'!
readStreamDo: aBlock
	"Obtain a FileStream on my contents that can be read, but not written,
	and send it to aBlock."
	^ directory readOnlyFileNamed: self name do: aBlock! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 2/15/2010 13:16' prior: 16839444!
                               creationTime
	"The time the entry was created, as an Integer number of seconds offset from the DateAndTime epoch."
	^creationTime! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 9/12/2007 17:25' prior: 16839453!
        isDirectory
	"whether this entry represents a directory"
	self subclassResponsibility! !
!DirectoryEntry methodsFor: 'access' stamp: 'cmm 1/25/2011 13:16' prior: 16839480!
                    size
	"For API compatibility with byte objects (for streaming api)."
	^ self fileSize! !
!FileDirectory methodsFor: 'enumeration' stamp: 'jmv 6/6/2012 14:00' prior: 16849221!
                 directoryNames
	"Return a collection of names for the subdirectories of this directory."
	"FileDirectory default directoryNames"
	^ (self entries select: [ :entry |
		entry isDirectory ]) collect: [ :entry |
		entry name ]! !
!FileDirectory methodsFor: 'enumeration' stamp: 'jmv 6/6/2012 13:42' prior: 16849249!
        fileNames
	"Return a collection of names for the files (but not directories) in this directory."
	"FileDirectory default fileNames"
	^ (self entries select: [ :entry |
		entry isDirectory not ]) collect: [ :entry |
		entry name ]! !
!FileDirectory methodsFor: 'private' stamp: 'jmv 6/6/2012 13:53' prior: 16849885!
     directoryContentsFor: fullPath
	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."
	"FileDirectory default directoryContentsFor: ''"

	| entries index done entryArray |
	entries _ OrderedCollection new: 200.
	index _ 1.
	done _ false.
	[done] whileFalse: [
		entryArray _ self primLookupEntryIn: fullPath index: index.
		#badDirectoryPath == entryArray ifTrue: [
			^(InvalidDirectoryError pathName: pathName) signal].
		entryArray
			ifNil: [done _ true]
			ifNotNil: [entries addLast: (DirectoryEntry fromArray: entryArray directory: self)].
		index _ index + 1].

	^ entries asArray! !
!AcornFileDirectory methodsFor: 'private' stamp: 'jmv 6/6/2012 13:49' prior: 16780808!
              directoryContentsFor: fullPath 
	"Return a collection of directory entries for the files and directories in 
	the directory with the given path. See primLookupEntryIn:index: for 
	further details."
	"FileDirectory default directoryContentsFor: ''"

	| entries extraPath |
	entries := super directoryContentsFor: fullPath.
	fullPath isEmpty
		ifTrue: [
			"For Acorn we also make sure that at least the parent of the current dir 
			is added - sometimes this is in a filing system that has not been (or 
			cannot be) polled for disc root names"
			extraPath := self class default containingDirectory.
			"Only add the extra path if we haven't already got the root of the current dir in the list"
			(entries anySatisfy: [:ent | extraPath fullName beginsWith: ent name]) 
				ifFalse: [entries := entries
								copyWith: (DirectoryEntryDirectory
										directory: self
										name: extraPath fullName
										creationTime: 0
										modificationTime: 0
										fileSize: 0)]].
	^ entries! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 6/6/2012 13:59' prior: 16851423!
                       fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font _ Preferences standardListFont.
	spaceWidth _ font widthOf: $ .
	nameStr _ entry isDirectory
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd _ namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr _ nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr _ ((Date fromSeconds: entry modificationTime) printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			(Time fromSeconds: entry modificationTime \\ 86400)
				print24: true
				on: s ]).
	sizeDigits _ entry fileSize printString size.
	sizeStr _ entry fileSize asStringWithCommas.
	sizeDigitsAndCommas _ sizeStr size.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	spacesToAdd _ sizeWithCommasPad - sizeDigitsAndCommas + sizePad - sizeDigits.
	sizeStr _ (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces _ String new: 6 withAll: $ .
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 6/6/2012 14:01' prior: 16851475!
         listForPatterns: anArray
	"Make the list be those file names which match the patterns."

	| sizePad newList namePad sizeWithCommasPad font |
	directory ifNil: [^#()].
	(fileSelectionBlock isKindOf: MessageSend) ifTrue: [
		fileSelectionBlock arguments: {directory entries}.
		newList _ fileSelectionBlock value.
		fileSelectionBlock arguments: #().
	] ifFalse: [
		newList _ Set new.
		anArray do: [ :pat |
			newList addAll: (directory entries select: [ :entry |
				entry isDirectory
					ifTrue: [showDirsInFileList]
					ifFalse: [fileSelectionBlock value: entry value: pat]]) ].
	].
	newList _ newList asArray sort: self sortBlock.
	font _ Preferences standardListFont.
	namePad _ newList inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) printString size.
	sizeWithCommasPad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) asStringWithCommas size.
	newList _ newList collect: [ :e | self fileNameFormattedFrom: e namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad ].
	^ newList! !

DirectoryEntry class removeSelector: #fromArray:!

DirectoryEntry class removeSelector: #fromArray:!

DirectoryEntry class removeSelector: #name:creationTime:modificationTime:isDirectory:fileSize:!

DirectoryEntry class removeSelector: #name:creationTime:modificationTime:isDirectory:fileSize:!

DirectoryEntry removeSelector: #at:!

DirectoryEntry removeSelector: #at:!

DirectoryEntry removeSelector: #privateName:creationTime:modificationTime:isDirectory:fileSize:!

DirectoryEntry removeSelector: #privateName:creationTime:modificationTime:isDirectory:fileSize:!

!classDefinition: #DirectoryEntry category: #'System-Files'!
Object subclass: #DirectoryEntry
	instanceVariableNames: 'directory name creationTime modificationTime fileSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

Object subclass: #DirectoryEntry
	instanceVariableNames: 'directory name creationTime modificationTime fileSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1295-DirectoryEntryFromSqueak-JuanVuletich-2012Jun06-14h35m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1295] on 6 June 2012 at 10:42:56 pm'!
!ThemesTest methodsFor: 'as yet unclassified' stamp: 'jmv 6/6/2012 22:37' prior: 16976607!
                           setUp
	"Create an anonymous subclass of Theme, override #shout.
	We do this because the ouput of #generateShoutConfig, the
	method under test, is dependent on the color data answered 
	by #shout, and we don't want the test to fail just because 
	someone changed the colors on the default theme (Theme.)"

	| metaclass |

	metaclass := Metaclass new
		superclass: Theme class;
		methodDictionary: MethodDictionary new;
		setFormat: Theme class format;
		yourself.

	theme := metaclass new
		superclass: Theme;
		methodDictionary: MethodDictionary new;
		setFormat: Theme format;
		yourself.
		
	theme compile:
'	shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 			-> #green.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 			-> #(blue muchDarker).
		#arguments 			-> #(cyan muchDarker).
		#instVar 				-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 		-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 			-> #(gray muchDarker).
	}
'! !
!ThemesTest methodsFor: 'as yet unclassified' stamp: 'jmv 6/6/2012 22:42' prior: 16976646!
                           shoutArray
	^  #(#(#invalid #green) #(#excessCode #green) #(#'$' #green) #(#undefinedKeyword #green) #(#undefinedBinary #green) #(#undefinedUnary #green) #(#character #(#red #muchDarker)) #(#integer #(#red #muchDarker)) #(#number #(#red #muchDarker)) #(#- #(#red #muchDarker)) #(#blockStart3 #(#red #muchDarker)) #(#blockEnd3 #(#red #muchDarker)) #(#leftParenthesis3 #(#red #muchDarker)) #(#rightParenthesis3 #(#red #muchDarker)) #(#default #black) #(#arrayStart #black) #(#arrayEnd #black) #(#arrayStart1 #black) #(#arrayEnd1 #black) #(#leftBrace #black) #(#rightBrace #black) #(#cascadeSeparator #black) #(#statementSeparator #black) #(#externalCallType #black) #(#externalCallTypePointerIndicator #black) #(#rightParenthesis1 #black) #(#blockArgColon #black) #(#leftParenthesis #black) #(#rightParenthesis #black) #(#blockStart #black) #(#blockEnd #black) #(#self #(#red #muchDarker)) #(#super #(#red #muchDarker)) #(#true #(#red #muchDarker)) #(#false #(#red #muchDarker)) #(#nil #(#red #muchDarker)) #(#thisContext #(#red #muchDarker)) #(#return #(#red #muchDarker)) #(#blockStart4 #(#green #darker)) #(#blockEnd4 #(#green #darker)) #(#leftParenthesis4 #(#green #darker)) #(#rightParenthesis4 #(#green #darker)) #(#instVar #(#magenta #muchDarker)) #(#blockStart2 #(#magenta #muchDarker)) #(#blockEnd2 #(#magenta #muchDarker)) #(#leftParenthesis2 #(#magenta #muchDarker)) #(#rightParenthesis2 #(#magenta #muchDarker)) #(#keyword #(#blue #muchDarker)) #(#binary #(#blue #muchDarker)) #(#unary #(#blue #muchDarker)) #(#leftParenthesis5 #(#orange #darker)) #(#rightParenthesis5 #(#orange #darker)) #(#blockStart5 #(#orange #darker)) #(#blockEnd5 #(#orange #darker)) #(#leftParenthesis6 #(#magenta #darker)) #(#rightParenthesis6 #(#magenta #darker)) #(#blockStart6 #(#magenta #darker)) #(#blockEnd6 #(#magenta #darker)) #(#leftParenthesis7 #blue) #(#rightParenthesis7 #blue) #(#blockStart7 #blue) #(#blockEnd7 #blue) #(#methodTempBar #gray) #(#blockTempBar #gray) #(#blockArgsBar #gray) #(#primitive #(#green #muchDarker) #bold) #(#pragmaKeyword #(#green #muchDarker) #bold) #(#pragmaUnary #(#green #muchDarker) #bold) #(#pragmaBinary #(#green #muchDarker) #bold) #(#externalFunctionCallingConvention #(#green #muchDarker) #bold) #(#module #(#green #muchDarker) #bold) #(#primitiveOrExternalCallStart #black #bold) #(#primitiveOrExternalCallEnd #black #bold) #(#globalVar #black #bold) #(#workspaceVar #black #bold) #(#incompleteKeyword #(#gray #veryMuchDarker) #underlined) #(#incompleteBinary #(#gray #veryMuchDarker) #underlined) #(#incompleteUnary #(#gray #veryMuchDarker) #underlined) #(#patternArg #(#cyan #muchDarker) #italic) #(#methodArg #(#cyan #muchDarker) #italic) #(#blockPatternArg #(#cyan #muchDarker) #italic) #(#blockArg #(#cyan #muchDarker) #italic) #(#argument #(#cyan #muchDarker) #italic) #(#symbol #(#blue #muchDarker) #bold) #(#stringSymbol #(#blue #muchDarker) #bold) #(#literalArray #(#blue #muchDarker) #bold) #(#assignment nil #bold) #(#ansiAssignment nil #bold) #(#patternKeyword nil #bold) #(#patternBinary nil #bold) #(#patternUnary nil #bold) #(#tempVar #(#gray #muchDarker) #italic) #(#patternTempVar #(#gray #muchDarker) #italic) #(#poolConstant #(#gray #muchDarker) #italic) #(#blockTempVar #gray #italic) #(#blockPatternTempVar #gray #italic) #(#unfinishedString #green #normal) #(#undefinedIdentifier #green #bold) #(#unfinishedComment #(#red #muchDarker) #italic) #(#comment #(#green #muchDarker) #italic) #(#string #(#magenta #muchDarker) #normal) #(#literal nil #italic) #(#incompleteIdentifier #(#gray #muchDarker) #(#italic #underlined)) #(#classVar #(#gray #muchDarker) #bold))! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1296-ThemesTestFix-JuanVuletich-2012Jun06-22h34m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1296] on 8 June 2012 at 4:59:10 pm'!
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 6/7/2012 08:23' prior: 16911781!
                              position: aPoint
	"Prevent moving a world"

	self isWorldMorph ifFalse: [^super position: aPoint].
"
	super position: aPoint.
	self viewBox ifNotNil: [self viewBox: (aPoint extent: self viewBox extent)].

"! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 6/7/2012 08:00' prior: 16942233!
                          explainMySel: symbol 
	"Is symbol the selector of this method?  Is it sent by this method?  If 
	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 
	selector sent here.  If not, explain will call (explainAnySel:) to catch any 
	selector. "

	| provider lits classes msg |
	provider _ self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	(msg _ provider selectedMessageName) ifNil: [^nil].	"not in a message"
	classes _ Smalltalk allClassesImplementing: symbol.
	classes size > 12
		ifTrue: [classes _ 'many classes']
		ifFalse: [classes _ 'these classes ' , classes printString].
	msg = symbol
		ifTrue: [
			^ '"' , symbol , ' is the selector of this very method!!  It is defined in ', classes , 
			'.  To see the other definitions, go to the message list pane, get the menu, and select ''implementors of...''."']
		ifFalse: [
			lits _ (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(lits detect: [:each | each == symbol]
				ifNone: nil)
					ifNil: [^nil].
			^ '"' , symbol , ' is a message selector which is defined in ', classes , 
			'.  To see the definitions, go to the message list pane, get the menu from, and select ''implementors of...''."'].! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 6/7/2012 08:00' prior: 16942292!
                 explainPartSel: string 
	"Is this a fragment of a multiple-argument selector sent in this method?"
	| lits whole reply classes s msg provider |
	provider _ self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	(msg _ provider selectedMessageName) ifNil: [^ nil].  "not in a message"
	string last == $: ifFalse: [^ nil].
	"Name of this method"
	lits _ Array with: msg.
	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]
					ifNone: nil) notNil]
				ifNone: nil)
		ifNotNil: [
			reply _ ', which is the selector of this very method!!'.
			s _ '.  To see the other definitions, go to the message list pane, get the menu, and select ''implementors of...''."']
		ifNil: [ 
			"Selectors called from this method"
			lits _ (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(whole _ lits detect: [:each | (each keywords detect: [ :frag | frag = string ]
							ifNone: nil) notNil]
						ifNone: nil) notNil
				ifFalse: [string = 'primitive:'
					ifTrue: [^self explainChar: '<']
					ifFalse: [^nil]].
			reply _ '.'.
			s _ '.  To see the definitions, go to the message list pane, get the menu, and select ''implementors of...''."'].
	classes _ Smalltalk allClassesImplementing: whole.
	classes size > 12
		ifTrue: [classes _ 'many classes']
		ifFalse: [classes _ 'these classes ' , classes printString].
	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !

Utilities class removeSelector: #graphicsFileSuffixes!

Utilities class removeSelector: #graphicsFileSuffixes!

PasteUpMorph removeSelector: #cartesianOrigin!

PasteUpMorph removeSelector: #cartesianOrigin!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1297-DisallowMovingWorld-JuanVuletich-2012Jun08-16h49m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1297] on 10 June 2012 at 11:30:09 am'!

!classDefinition: #Editor category: #'System-Text'!
Object subclass: #Editor
	instanceVariableNames: 'morph'
	classVariableNames: 'KeystrokeActions'
	poolDictionaries: ''
	category: 'System-Text'!

Object subclass: #Editor
	instanceVariableNames: 'morph '
	classVariableNames: 'KeystrokeActions '
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: 'Editor class' category: #'System-Text'!
Editor class
	instanceVariableNames: 'shortcuts cmdShortcuts'!

Editor class
	instanceVariableNames: 'shortcuts cmdShortcuts '!
!Editor commentStamp: '<historical>' prior: 16841697!
                           New text editors.
TextEditor provides most of the functionality that used to be in TextMorphEditor.
SmalltalkEditor is has Smalltalk code specific features.
SimpleEditor provides basic functionality for single line text editing. It does not handle fonts and styles, aligning and Smalltalk utilities. It handles one single line.
CellStyleEditor allows entering alphabetic characters using only number keys, like many cell phones do.!
!Editor methodsFor: 'typing support' stamp: 'jmv 6/10/2012 10:54'!
            cmdShortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	^self class cmdShortcuts! !
!Editor methodsFor: 'typing support' stamp: 'jmv 6/10/2012 11:13'!
        shortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	^self class shortcuts! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 6/10/2012 11:21'!
  basicInitialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c |
		c initializeShortcuts; initializeCmdShortcuts ]! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 6/10/2012 11:20'!
                 initializeCmdShortcuts
	"Initialize the (unshifted) command-key (or alt-key if not on Mac) shortcut table."
	"NOTE: if you don't know what your keyboard generates, use Sensor test"
	"
	Editor initialize
	"

	cmdShortcuts _ Array new: 256 withAll: #noop:.

	self basicCmdShortcutsSpec do: [ :ary |
		cmdShortcuts at: ary first asciiValue + 1 put: ary second ].

	self cmdShortcutsSpec do: [ :ary |
		cmdShortcuts at: ary first asciiValue + 1 put: ary second ]! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 6/10/2012 10:56'!
   initializeShortcuts
	"Initialize the table for regular (i.e. non-command) keystroke dispatch"
	"
	self initializeKeystrokeActions
	"
	| actions |
	actions _ Array new: 256 withAll: #normalCharacter:.
	0 to: 31 do: [ :i | actions at: i+1 put: #noop: ].
	actions at: 1 + 1 put: #cursorHome:.				"home key"
	actions at: 3 + 1 put: #enter:.						"enter / return key"
	actions at: 4 + 1 put: #cursorEnd:.				"end key"
	actions at: 5 + 1 put: #noop:.						"insert key"
	actions at: 8 + 1 put: #backspace:.				"macDelete winBackspace key"
	actions at: 9 + 1 put: #normalCharacter:.		"tab"
	actions at: 11 + 1 put: #cursorPageUp:.			"page up key"
	actions at: 12 + 1 put: #cursorPageDown:.		"page down key"
	actions
		at:  InputSensor returnKey + 1
		put: #returnKey:.									"return (sometimes labelled enter) key"
	actions at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"
	actions at: 28 + 1 put: #cursorLeft:.				"left arrow key"
	actions at: 29 + 1 put: #cursorRight:.				"right arrow key"
	actions at: 30 + 1 put: #cursorUp:.				"up arrow key"
	actions at: 31 + 1 put: #cursorDown:.			"down arrow key"
	actions at: 127 + 1 put: #forwardDelete:.		"winDelete key"
	shortcuts _ actions! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 11:09'!
             basicCmdShortcutsSpec
	^#()! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 10:55'!
              cmdShortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	^cmdShortcuts! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 11:07'!
   cmdShortcutsSpec
	^#()! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 11:13'!
                   shortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	^shortcuts! !
!SimpleEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 11:07'!
   cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$a 	#selectAll:				'Select all')

		#(		$x 	#cut:						'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:					'Paste Clipboard contents')
		#(		$ 	#selectWord:			'Select the current word as with double clicking')
	)! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 11:09'!
       basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					)
		#(		$[ 	#enclose:					)
		#(		${ 	#enclose:					)
		#(		$' 	#enclose:					)
		#(		$" 	#enclose:					)
		#(		$< 	#enclose:					)

		#(		$a 	#selectAll:				'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:				'Find again')
		#(		$h 	#setSearchString:		'Set selection as search string for find again')

		#(		$z 	#undo:					'Undo (multiple levels)')
		#(		$x 	#cut:						'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:					'Paste Clipboard contents')

		#(		$R	#indent:					'Indent (move selection one tab-stap right)')
		#(		$Y	#makeUppercase:		'Force selection to uppercase')
		#(		$U	#changeLineEndsToLf:	'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H	#cursorTopHome:		'Move cursor to start of text')
		#(		$L	#outdent:				'Outdent (move selection one tab-stop left)')

		#(		$Z	#redo:					'Redo (multiple levels)')
		#(		$X	#makeLowercase:		'Force selection to lowercase')
		#(		$C	#compareToClipboard:	'Compare argument to clipboard')

		#(		$ 	#selectWord:			'Select the current word as with double clicking')
	)! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 11:07'!
                     cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$0 	changeEmphasis:			)
		#(		$1 	changeEmphasis:			)
		#(		$2 	changeEmphasis:			)
		#(		$3 	changeEmphasis:			)
		#(		$4 	changeEmphasis:			)
		#(		$5 	changeEmphasis:			)
		#(		$6 	changeEmphasis:			)
		#(		$8	#offerColorMenu:			)

		#(		$k	#offerFontMenu:			'Set font')

		#(		$u	#align:						'Toggle alignment')
	)! !
!TextEditor class methodsFor: 'class initialization' stamp: 'jmv 6/10/2012 11:03'!
                basicInitialize 
	"Initialize the keyboard shortcut maps and the shared buffers for managing again."
	"
	Editor initialize
	"
	super basicInitialize.
	FindText _ ChangeText _ Text new.
	self initializeMenu! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 11:07'!
                   cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:									'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:					'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:		'Method strings containing it')
		#(		$T	#displayIfTrue:						'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$F	#displayIfFalse:						'Insert #ifFalse:')
		#(		$G	#fileItIn:								'File in selection')

		#(		$V	#pasteInitials:						'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 6/10/2012 11:03' prior: 16842345!
    initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c |
		c basicInitialize ]! !
!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 6/10/2012 11:14' prior: 16939133!
        dispatchOn: aKeyboardEvent
	"Carry out the action associated with this character, if any."
	| asciiValue |
	asciiValue _ aKeyboardEvent keyValue.
	"Control keys are handled by #shortcuts even if they have any modifiers"
	(asciiValue >= 32 and: [
		aKeyboardEvent commandAltKeyPressed ]) ifTrue: [
		^self perform: (self cmdShortcuts at: asciiValue + 1) with: aKeyboardEvent ].

	"We don't support multiple lines. Therefore, we don't process return as a #normalCharacter:"
	aKeyboardEvent isReturnKey ifTrue: [
		^ true].

	^ self perform: (self shortcuts at: asciiValue + 1) with: aKeyboardEvent! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 6/10/2012 11:17' prior: 16961624!
                 presumedSentMessages
	| sent |
	"
	In addition to those here, if it is desired to preserve some methods from deletion, see #nominallyUnsent:
	Smalltalk presumedSentMessages
	"

	"The following should be preserved for doIts, etc"
	sent _ IdentitySet new.
	#( rehashWithoutBecome compactSymbolTable
		browseAllSelect:  lastRemoval
		vScrollBarValue: hScrollBarValue: 
		to: removeClassNamed:
		dragon: hilberts: mandala: web test3 factorial tinyBenchmarks benchFib
		newDepth: restoreAfter: zapAllMethods obsoleteClasses
		removeAllUnSentMessages abandonSources removeUnreferencedKeys
		zapOrganization condenseChanges browseObsoleteReferences
		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:
		startTimerEventLoop unusedClasses
		unimplemented
		reduceCuis
		variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
		variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
		variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
		weakSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
		printSpaceAnalysis:on:) do: [ :sel |
			sent add: sel].
	"The following may be sent by perform: in dispatchOnChar..."
	Editor withAllSubclassesDo: [ :c |
		c shortcuts asSet do: [ :sel | sent add: sel ].
		c cmdShortcuts asSet do: [ :sel | sent add: sel ]].
	#(beReadOnlyBinding beReadWriteBinding) do: [ :sel |
		sent add: sel].
	^ sent! !
!TextEditor methodsFor: 'typing support' stamp: 'jmv 6/10/2012 11:15' prior: 16972251!
                             dispatchOn: aKeyboardEvent
	"Carry out the action associated with this character, if any."

	| asciiValue c |
	self clearParens.
  	asciiValue _ aKeyboardEvent keyValue.
	"Control keys are handled by #shortcuts even if they have any modifiers"
	(asciiValue >= 32 and: [
		aKeyboardEvent commandAltKeyPressed ]) ifTrue: [
		^self perform: (self cmdShortcuts at: asciiValue + 1) with: aKeyboardEvent ].

	c _ aKeyboardEvent keyCharacter.
	(')]}' includes: c)
		ifTrue: [ self blinkPrevParen: c ].

	^ self perform: (self shortcuts at: asciiValue + 1) with: aKeyboardEvent! !
!Utilities class methodsFor: 'support windows' stamp: 'jmv 6/10/2012 11:30' prior: 16981952!
      commandKeyMappings
	^ self class firstCommentAt: #commandKeyMappings

"Lower-case command keys
(use with Cmd key on Mac and Alt key on other platforms)
a	Select all
b	Browse it (selection is a class name or cursor is over a class-list or message-list)
c	Copy selection
d	Do it (selection is a valid expression)
e	Exchange selection with prior selection
f	Find
g	Find again
h	Set selection as search string for find again
i	Inspect it (selection is a valid expression, or selection is over an inspect-ilst)
j	Again once (do the last text-related operation again)
k	Set font
l	Cancel
m	Implementors of it (selection is a message selector or cursor is over a class-list or message-list)
n	Senders of it (selection is a message selector or cursor is over a class-list or message-list)
o	Spawn current method
p	Print it (selection is a valid expression)
q	Query symbol (toggle all possible completion for a given prefix)
r	Recognizer
s	Save (i.e. accept)
t	Finds a Transcript (when cursor is over the desktop)
u	Toggle alignment
v	Paste
w	Delete preceding word (over text);  Close-window (over morphic desktop)
x	Cut selection
y	Swap characters
z	Undo

Note: for Do it, Senders of it, etc., a null selection will be expanded to a word or to the current line in an attempt to do what you want.  Also note that Senders/Implementors of it will find the outermost keyword selector in a large selection, as when you have selected a bracketed expression or an entire line.  Finally note that the same cmd-m and cmd-n (and cmd-v for versions) work in the message pane of most browsers.

Upper-case command keys
	(use with Shift-Cmd, or Ctrl on Mac
	or Shift-Alt on other platforms; sometimes Ctrl works too)
A	Advance argument
B	Browse it in this same browser (in System browsers only)
C	Compare argument to clipboard
D	Duplicate
E	Method strings containing it
F	Insert 'ifFalse:'
G	fileIn from it (a file name)
H	cursor TopHome:
I	Inspect via Object Explorer
J	Again many (apply the previous text command repeatedly until the end of the text)
K	Set style
L	Outdent (move selection one tab-stop left)
M	Select current type-in
N	References to it (selection is a class name, or cursor is over a class-list or message-list)
O	Open single-message browser (in message lists)
P	Make project link
R	Indent (move selection one tab-stap right)
S	Search
T	Insert 'ifTrue:'
U	Convert linefeeds to carriage returns in selection
V	Paste author's initials
W	Selectors containing it (in text); show-world-menu (when issued with cursor over desktop)
X	Force selection to lowercase
Y	Force selection to uppercase
Z	Capitalize all words in selection

Other special keys
Backspace	Backward delete character
Del			Forward delete character
Shift-Bksp	Backward delete word
Shift-Del	Forward delete word
Esc			Pop up the Desktop Menu
\			Send top window to back

Cursor keys
left, right,
up, down	Move cursor left, right, up or down
Ctrl-left		Move cursor left one word
Ctrl-right	Move cursor right one word
Home		Move cursor to begin of line or begin of text
End			Move cursor to end of line or end of text
PgUp, Ctrl-up	Move cursor up one page
PgDown, Ctrl-Dn	Move cursor down one page

Note all these keys can be used together with Shift to define or enlarge the selection. You cannot however shrink that selection again, as in some other systems.

Other Cmd-key combinations (not available on all platforms)
Return		Insert return followed by as many tabs as the previous line
			(with a further adjustment for additional brackets in that line)
Space		Select the current word as with double clicking

Enclose the selection in a kind of bracket.  Each is a toggle.
	(not available on all platforms)
Ctrl-(	Enclose within ( and ), or remove enclosing ( and )
Ctrl-[	Enclose within [ and ], or remove enclosing [ and ]
Crtl-{	Enclose within { and }, or remove enclosing { and }
Ctrl-<	Enclose within < and >, or remove enclosing < and >
Ctrl-'	Enclose within ' and ', or remove enclosing ' and '
Ctrl-""	Enclose within "" and "", or remove enclosing "" and ""
Note also that you can double-click just inside any of the above delimiters,
or at the beginning or end of a line, to select the text enclosed.

Text Emphasis
	(not available on all platforms)
Cmd-1	10 point font
Cmd-2	12 point font
Cmd-3	18 point font
Cmd-4	24 point font
Cmd-5	36 point font
Cmd-6	color, action-on-click, link to class comment, link to method, url
		Brings up a menu.  To remove these properties, select
		more than the active part and then use command-0.
Cmd-7	bold
Cmd-8	italic
Cmd-9	narrow (same as negative kern)
Cmd-0	plain text (resets all emphasis)
Cmd--	underlined (toggles it)
Cmd-=	struck out (toggles it)

Shift-Cmd--	(aka _) negative kern (letters 1 pixel closer)
Shift-Cmd-+	positive kern (letters 1 pixel larger spread)
"! !
!Utilities class methodsFor: 'support windows' stamp: 'jmv 6/8/2012 17:36' prior: 16982104!
                      openCommandKeyHelp
	"Open a window giving command key help."
	"
	Utilities openCommandKeyHelp
	"

	(TextModel new contents: self commandKeyMappings)
		openLabel: 'Command Key Actions'
! !

SmalltalkEditor class removeSelector: #cmdKeyShortcuts!

SmalltalkEditor class removeSelector: #initializeCmdKeyShortcuts!

SmalltalkEditor class removeSelector: #initializeCmdKeyShortcuts!

TextEditor class removeSelector: #basicCmdKeyShortcuts!

TextEditor class removeSelector: #basicCmdKeyShortcutsSpec!

TextEditor class removeSelector: #cmdActions!

TextEditor class removeSelector: #cmdActions!

TextEditor class removeSelector: #cmdKeyShortcuts!

TextEditor class removeSelector: #initialize!

TextEditor class removeSelector: #initialize!

TextEditor class removeSelector: #initializeBasicCmdKeyShortcuts!

TextEditor class removeSelector: #initializeBasicCmdKeyShortcuts!

TextEditor class removeSelector: #initializeCmdKeyShortcuts!

TextEditor class removeSelector: #initializeCmdKeyShortcuts!

TextEditor initialize!

!classDefinition: 'TextEditor class' category: #'System-Text'!
TextEditor class
	instanceVariableNames: 'menu'!

TextEditor class
	instanceVariableNames: 'menu'!

TextEditor removeSelector: #cmdActions!

TextEditor removeSelector: #cmdActions!

SimpleEditor class removeSelector: #cmdActions!

SimpleEditor class removeSelector: #cmdActions!

SimpleEditor class removeSelector: #cmdKeyShortcuts!

SimpleEditor class removeSelector: #initialize!

SimpleEditor class removeSelector: #initialize!

SimpleEditor class removeSelector: #initializeCmdKeyShortcuts!

SimpleEditor class removeSelector: #initializeCmdKeyShortcuts!

SimpleEditor initialize!

!classDefinition: 'SimpleEditor class' category: #'System-Text'!
SimpleEditor class
	instanceVariableNames: ''!

SimpleEditor class
	instanceVariableNames: ''!

SimpleEditor removeSelector: #cmdActions!

SimpleEditor removeSelector: #cmdActions!

SimpleEditor removeSelector: #cmdShortcuts!

Editor class removeSelector: #basicCmdKShortcutsSpec!

Editor class removeSelector: #basicCmdKeyShortcuts!

Editor class removeSelector: #basicCmdKeyShortcutsSpec!

Editor class removeSelector: #cmdKeyShortcuts!

Editor class removeSelector: #initializeCmdKeyShortcuts!

Editor class removeSelector: #initializeKeystrokeActions!

Editor class removeSelector: #initializeKeystrokeActions!

Editor initialize!

!classDefinition: 'Editor class' category: #'System-Text'!
Editor class
	instanceVariableNames: 'shortcuts cmdShortcuts'!

Editor class
	instanceVariableNames: 'shortcuts cmdShortcuts'!

!classDefinition: #Editor category: #'System-Text'!
Object subclass: #Editor
	instanceVariableNames: 'morph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

Object subclass: #Editor
	instanceVariableNames: 'morph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1298-EditorShortcutsCleanup-JuanVuletich-2012Jun10-10h35m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1298] on 10 June 2012 at 9:02:17 pm'!
!Editor class methodsFor: 'help' stamp: 'jmv 6/10/2012 20:50'!
                          help
	"
	Editor help
	SimpleEditor help
	CellStyleEditor help
	TextEditor help
	SmalltalkEditor help
	"
	| allSpecs |
	allSpecs _ self basicCmdShortcutsSpec, self cmdShortcutsSpec.
	^String streamContents: [ :strm |
		allSpecs do: [ :triplet | | c |
			c _ triplet first = Character space
				ifFalse: [ triplet first asString, String tab ]
				ifTrue: [ 'Space'].
			strm nextPutAll: ('Cmd-', c, String tab, String tab, triplet third).
			strm newLine ]]! !
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 6/10/2012 20:55'!
   help: aKeyboardEvent
	"Show a help screen"

	self class openHelp.
	^ true! !
!TextEditor class methodsFor: 'misc' stamp: 'jmv 6/10/2012 20:55'!
                openHelp

	TextModel new contents: self help; openLabel: self name, ' Help'.! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 6/10/2012 11:57' prior: 16971526!
                           enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex _ self startIndex.
	stopIndex _ self stopIndex.
	oldSelection _ self selection.
	which _ '([<{"''' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left _ '([<{"''' at: which.
	right _ ')]>}"''' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (String with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (String with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^true! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 20:48' prior: 50337651!
               basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$< 	#enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:				'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:				'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:		'Set selection as search string for find again')

		#(		$z 	#undo:					'Undo (multiple levels)')
		#(		$x 	#cut:						'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:					'Paste Clipboard contents')

		#(		$R	#indent:					'Indent (move selection one tab-stap right)')
		#(		$Y	#makeUppercase:		'Force selection to uppercase')
		#(		$U	#changeLineEndsToLf:	'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H	#cursorTopHome:		'Move cursor to start of text')
		#(		$L	#outdent:				'Outdent (move selection one tab-stop left)')

		#(		$Z	#redo:					'Redo (multiple levels)')
		#(		$X	#makeLowercase:		'Force selection to lowercase')
		#(		$C	#compareToClipboard:	'Compare argument to clipboard')

		#(		$ 	#selectWord:			'Select the current word as with double clicking')
	)! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 12:12' prior: 50337694!
       cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$0 	changeEmphasis:			'Normal')
		#(		$1 	changeEmphasis:			'Bold')
		#(		$2 	changeEmphasis:			'Italic')
		#(		$3 	changeEmphasis:			'Underline')
		#(		$4 	changeEmphasis:			'Strikeout')
		#(		$5 	changeEmphasis:			'Negative kern (letters 1 pixel closer)')
		#(		$6 	changeEmphasis:			'Positive kern (letters 1 pixel larger spread)')
		#(		$8	#offerColorMenu:			'Change color')

		#(		$k	#offerFontMenu:			'Set font')

		#(		$u	#align:						'Toggle alignment')
	)! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 6/10/2012 21:00' prior: 16974839!
                           helpMenu
        "Build the help menu for the world."
        |  menu |

  	menu := self menu: 'Help...'.

        self fillIn: menu from:
        {
                {'About this System...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.
                {'Preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.
                nil.
               {'Editor keyboard shortcuts'. { SmalltalkEditor . #openHelp}. 'summary of keyboard shortcuts in editors for Smalltalk code.'}
	}.

	self addGestureHelpItemsTo: menu.

	self fillIn: menu from:
	{
                {'World menu Help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.
                {'Useful Expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.
                nil.

                {'Set Author initials...' . { Utilities . #setAuthorInitials }. 'supply initials to be used to identify the author of code and other content.'}.
                {'VM Statistics' . { self . #vmStatistics}.  'obtain some intriguing data about the vm.'}.
			nil.
                {'Space Left' . { self . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.
        }.

	^menu

! !
!Theme methodsFor: 'menus' stamp: 'jmv 6/10/2012 21:00' prior: 50334325!
 miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (h)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !

Utilities class removeSelector: #commandKeyMappings!

Utilities class removeSelector: #commandKeyMappings!

Utilities class removeSelector: #openCommandKeyHelp!

Utilities class removeSelector: #openCommandKeyHelp!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Theme current class beCurrent.
Editor initialize!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1299-EditorHelp-JuanVuletich-2012Jun10-11h47m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1299] on 11 June 2012 at 8:51:15 am'!
!TextEditor methodsFor: 'menu messages' stamp: 'jmv 6/11/2012 08:46'!
              openHelp
	"Show help screen"
	self class openHelp! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/11/2012 08:50' prior: 16972876!
    initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.						#openHelp}.
		#-.
		{'Find...(f)'.						#find}.
		{'Find Again (g)'.				#findAgain}.
		{'Use Selection for Find (j)'.		#setSearchString}.
		#-.
		{'Undo - multiple (z)'.			#undo}.
		{'Redo - multiple (Z)'.			#redo}.
		{'Undo / Redo history'.			#offerUndoHistory}.
		#-.
		{'Copy (c)'.						#copySelection}.
		{'Cut (x)'.						#cut}.
		{'Paste (v)'.						#paste}.
		{'Paste without Format'.		#pasteString}.
		{'Paste...'.						#pasteRecent}.
		#-.
		{'Set Font... (k)'.					#offerFontMenu}.
		{'Set Alignment...'.				#chooseAlignment}.
	}! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/11/2012 08:48' prior: 16942563!
  initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.						#openHelp}.
		#-.
		{'Find...(f)'.						#find}.
		{'Find Again (g)'.				#findAgain}.
		{'Use Selection for Find (j)'.		#setSearchString}.
		#-.
		{'Undo - multiple (z)'.			#undo}.
		{'Redo - multiple (Z)'.			#redo}.
		{'Undo / Redo history'.			#offerUndoHistory}.
		#-.
		{'Copy (c)'.						#copySelection}.
		{'Cut (x)'.						#cut}.
		{'Paste (v)'.						#paste}.
		{'Paste without Format'.		#pasteString}.
		{'Paste...'.						#pasteRecent}.
		#-.
		{'Do it (d)'.						#doIt}.
		{'Print it (p)'.					#printIt}.
		{'Inspect it (i)'.					#inspectIt}.
		{'Explore it (I)'.					#exploreIt}.
		{'Debug it'.						#debugIt}.
		#-.
		{'Explain'.						#explain}.
		{'Browse it (b)'.					#browseIt}.
		{'Senders of it (n)'.				#sendersOfIt}.
		{'Implementors of it (m)'.		#implementorsOfIt}.
		{'References to it (N)'.			#referencesToIt}.
		#-.
		{'Accept (s)'.					#acceptContents}.
		{'Cancel (l)'.					#cancelEdits}.
		#-.
		{'Method Strings with it (E)'.	#methodStringsContainingit}.
		{'Method Source with it'.		#methodSourceContainingIt}.
		{'Class Comments with it'.		#classCommentsContainingIt}.
	}! !
!Theme methodsFor: 'menus' stamp: 'jmv 6/11/2012 08:44' prior: 50338301!
                       miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Theme current class beCurrent.
Editor initialize
!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1300-FixEditorsMenuToo-JuanVuletich-2012Jun11-08h42m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1300] on 11 June 2012 at 12:25:31 pm'!
!FileDirectory methodsFor: 'enumeration' stamp: 'jmv 6/11/2012 12:23' prior: 16849243!
            fileAndDirectoryNames
	"FileDirectory default fileAndDirectoryNames"

	^ self entries collect: [:entry | entry name]
! !
!FileDirectory methodsFor: 'file status' stamp: 'jmv 6/11/2012 12:24' prior: 16850023!
                entryAt: fileName ifAbsent: aBlock
	"Find the entry with local name fileName and answer it.
	If not found, answer the result of evaluating aBlock."
	| comparisonBlock |
	comparisonBlock _ self isCaseSensitive
		ifTrue: [
			[ :entry |
			entry name = fileName ]]
		ifFalse: [
			[ :entry |
			entry name sameAs: fileName ]].
	^ self entries
		detect: comparisonBlock
		ifNone: aBlock! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1301-DirectoryEntryFix-JuanVuletich-2012Jun11-12h22m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1300] on 11 June 2012 at 11:23:07 am'!

!classDefinition: #FrameRateMorph category: #'Morphic-Widgets'!
Morph subclass: #FrameRateMorph
	instanceVariableNames: 'lastStepStamp lastStepDelta meanStepDelta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

Morph subclass: #FrameRateMorph
	instanceVariableNames: 'lastStepStamp lastStepDelta meanStepDelta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!FrameRateMorph commentStamp: 'jmv 6/11/2012 10:14' prior: 0!
              A very simple morph to demo stepping, and for knowing about stepping (and world update) frame rates.

FrameRateMorph new openInHand!
!AutoCompleterMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:58'!
                  wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run ALL THE TIME.
	Morphs that send #startStepping and #stopStepping at appropriate times (i.e. when they are already in the world!!) don't need to answer true to this message"

	^true! !
!FrameRateMorph methodsFor: 'drawing' stamp: 'jmv 6/11/2012 10:29'!
             drawOn: aCanvas
	super drawOn: aCanvas.
	meanStepDelta ifNotNil: [
		aCanvas drawString: lastStepDelta rounded printString at: bounds topLeft font: StrikeFont default color: Color black.
		aCanvas drawString: meanStepDelta rounded printString at: bounds topLeft + (0@14) font: StrikeFont default color: Color black.
		aCanvas drawString: lastStepStamp printString at: bounds topLeft + (0@28) font: StrikeFont default color: Color black ]! !
!FrameRateMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 10:31'!
  stepAt: millisecondClockValue

	| n |
	lastStepStamp ifNil: [ lastStepStamp _ millisecondClockValue ].
	lastStepDelta _ millisecondClockValue - lastStepStamp.
	lastStepStamp _ millisecondClockValue.
	"This factor is a damper, to show a sort of mean of the n latest step deltas"
	meanStepDelta
		ifNil: [ meanStepDelta _ 0. n _ 0 ]
		ifNotNil: [
"			n _ (meanStepDelta / lastStepDelta between: 0.5 and: 2)
				ifTrue: [ 10 ]
				ifFalse: [10 ]."
			n _ 20 ].
	meanStepDelta _ meanStepDelta * n + lastStepDelta / (n+1).
	self redrawNeeded ! !
!FrameRateMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 11:20'!
                              stepTime

	^25! !
!FrameRateMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:20'!
         wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run"

	^true! !
!MagnifierMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:58'!
                        wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run ALL THE TIME.
	Morphs that send #startStepping and #stopStepping at appropriate times (i.e. when they are already in the world!!) don't need to answer true to this message"

	^true! !
!PasteUpMorph methodsFor: 'stepping and presenter' stamp: 'jmv 6/11/2012 09:59'!
wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run ALL THE TIME.
	Morphs that send #startStepping and #stopStepping at appropriate times (i.e. when they are already in the world!!) don't need to answer true to this message.
	jmv: Not really sure. Sub-world stepping needs some review."

	^true! !
!Taskbar methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:59'!
                     wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run ALL THE TIME.
	Morphs that send #startStepping and #stopStepping at appropriate times (i.e. when they are already in the world!!) don't need to answer true to this message"

	^true! !
!UpdatingMenuItemMorph methodsFor: 'stepping and presenter' stamp: 'jmv 6/11/2012 10:03'!
                       wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run ALL THE TIME.
	Morphs that send #startStepping and #stopStepping at appropriate times (i.e. when they are already in the world!!) don't need to answer true to this message"

	^true! !
!Morph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:28' prior: 16899010!
     wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run ALL THE TIME.
	Morphs that send #startStepping and #stopStepping at appropriate times (i.e. when they are already in the world!!) don't need to answer true to this message"

	^false! !
!AutoCompleterMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:17' prior: 16783723!
                       step
	self timeOfLastActivity > self timeout
		ifTrue: [ self delete. completer menuClosed ]
		ifFalse: [self updateColor]! !
!AutoCompleterMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:18' prior: 16783730!
         stepTime 
	^ 100! !
!HaloMorph methodsFor: 'testing' stamp: 'jmv 6/11/2012 11:22' prior: 16863943!
                             stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 10! !
!HandleMorph methodsFor: 'testing' stamp: 'jmv 6/11/2012 11:22' prior: 16865821!
              stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 10! !
!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 11:22' prior: 16879809!
    stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 10! !
!MagnifierMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 11:22' prior: 16885121!
          stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 10! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 6/11/2012 10:05' prior: 16885163!
              chooseMagnification: evt
	| handle origin aHand currentMag |
	currentMag _ magnification.
	aHand _ evt ifNil: [ self world activeHand ] ifNotNil: [evt hand].
	origin _ aHand position y.
	handle _ HandleMorph new forEachPointDo:
		[ :newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag ].
	aHand attachMorph: handle.
	handle startStepping.
	self redrawNeeded. ! !
!SystemWindow methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:55' prior: 16965659!
              wantsSteps
	"Return true if the model wants its view to be stepped.  For an open system window, we give the model to offer an opinion"

	^ model wantsStepsIn: self! !
!Taskbar methodsFor: 'initialization' stamp: 'jmv 6/11/2012 09:31' prior: 16967246!
     initialize

	super initialize.
	self step! !
!Taskbar methodsFor: 'stepping' stamp: 'jmv 6/11/2012 11:20' prior: 16967259!
     stepTime
	"Update very often."
	^ 20! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 6/11/2012 11:18' prior: 16986766!
   doOneCycleFor: aWorld
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a MaxCycleLapse delay before the ui gets responsive again."

	| hadAnyEvent thisPause now |
	"Check for unnecessary calls to #millisecondClockValue"
	now _ Time millisecondClockValue.
	alarms ifNotNil: [
		alarms isEmpty not ifTrue: [
			pause _ pause min: (alarms first scheduledTime - now) ]].
	stepList isEmpty not ifTrue: [
		pause _ pause min: stepList first scheduledTime - now ].

	thisPause _ pause.
	"pause is set to very short if we have events already enqueued, so they are processed quickly."
	(Preferences higherPerformance or: [ Sensor eventQueue isEmpty not ]) 
		ifTrue: [ thisPause _ 1 ].
	self interCyclePause: thisPause.

	hadAnyEvent _ self doOneCycleNowFor: aWorld.
	hadAnyEvent
		ifTrue: [  pause _ MinCycleLapse ]
		ifFalse: [
			pause < MaxCycleLapse		"No events processed? Start saving CPU!!"
				ifTrue: [
					pause _ pause * 21//20 ]]! !

PolygonMorph removeSelector: #wantsSteps!

PolygonMorph removeSelector: #wantsSteps!

HandleMorph removeSelector: #startStepping!

HandleMorph removeSelector: #startStepping!

AutoCompleterMorph removeSelector: #initialize!

AutoCompleterMorph removeSelector: #initialize!

Morph removeSelector: #start!

Morph removeSelector: #start!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1302-SteppingTweaks-JuanVuletich-2012Jun11-11h14m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1302] on 11 June 2012 at 12:46:49 pm'!

!classDefinition: #WorldState category: #'Morphic-Worlds'!
Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse MinCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent '
	classVariableNames: 'DeferredUIMessages MaxCycleLapse MinCycleLapse '
	poolDictionaries: ''
	category: 'Morphic-Worlds'!
!WorldState methodsFor: 'initialization' stamp: 'jmv 6/11/2012 11:32' prior: 16986490!
    initialize

	hands _ #().
	damageRecorder_ DamageRecorder new.
	stepList _ Heap sortBlock: self stepListSortBlock.
	lastStepTime _ 0.
	lastAlarmTime _ 0.
	drawingFailingMorphs _ IdentitySet new.
	lastCycleHadAnyEvent _ false! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 6/11/2012 12:46' prior: 50339007!
       doOneCycleFor: aWorld
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a MaxCycleLapse delay before the ui gets responsive again."

	| thisPause now wait |
	thisPause _ MinCycleLapse.
	"fix in a postcript and remove"
	lastCycleHadAnyEvent ifNil: [ lastCycleHadAnyEvent _ false ].
	lastCycleHadAnyEvent
		ifTrue: [  thisPause _ MinCycleLapse ]
		ifFalse: [
			thisPause < MaxCycleLapse		"No events processed? Start saving CPU!!"
				ifTrue: [
					thisPause _ thisPause * 21//20 ]].
	"Check for unnecessary calls to #millisecondClockValue"
	now _ Time millisecondClockValue.
	alarms ifNotNil: [
		alarms isEmpty not ifTrue: [
			thisPause _ thisPause min: (alarms first scheduledTime - now) ]].
	stepList isEmpty not ifTrue: [
		thisPause _ thisPause min: stepList first scheduledTime - now ].

	"thisPause is set to very short if we have events already enqueued, so they are processed quickly."
	(Preferences higherPerformance or: [ Sensor eventQueue isEmpty not ]) 
		ifTrue: [ thisPause _ 1 ].


""
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	wait _ lastCycleTime notNil
		ifTrue: [ lastCycleTime + thisPause - Time millisecondClockValue ]
		ifFalse: [ 0 ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	(wait > 0 and: [ wait <= thisPause ])
		ifTrue: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	lastCycleTime _  Time millisecondClockValue.
""


	lastCycleHadAnyEvent _ self doOneCycleNowFor: aWorld.! !

WorldState removeSelector: #interCyclePause:!

WorldState removeSelector: #interCyclePause:!

!classDefinition: #WorldState category: #'Morphic-Worlds'!
Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse MinCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse MinCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1303-MoreSteppingTweaks-JuanVuletich-2012Jun11-12h44m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1303] on 11 June 2012 at 11:42:12 pm'!

!classDefinition: #WorldState category: #'Morphic-Worlds'!
Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse MinCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent '
	classVariableNames: 'DeferredUIMessages MaxCycleLapse MinCycleLapse '
	poolDictionaries: ''
	category: 'Morphic-Worlds'!
!WorldState commentStamp: '<historical>' prior: 16986326!
                         The state of a Morphic world.  (This needs some serious commenting!!!!)!
!FrameRateMorph methodsFor: 'drawing' stamp: 'jmv 6/11/2012 23:27' prior: 50338833!
   drawOn: aCanvas
	super drawOn: aCanvas.
	meanStepDelta ifNotNil: [
		aCanvas drawString: lastStepDelta rounded printString at: bounds topLeft font: StrikeFont default color: Color black.
		aCanvas drawString: meanStepDelta rounded printString at: bounds topLeft + (0@14) font: StrikeFont default color: Color black.
		"aCanvas drawString: lastStepStamp printString at: bounds topLeft + (0@28) font: StrikeFont default color: Color black "
		]! !
!FrameRateMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 23:30' prior: 50338849!
             stepAt: millisecondClockValue

	| n |
	lastStepStamp ifNil: [ lastStepStamp _ millisecondClockValue ].
	lastStepDelta _ millisecondClockValue - lastStepStamp.
	lastStepStamp _ millisecondClockValue.
	"This factor is a damper, to show a sort of mean of the n latest step deltas"
	meanStepDelta
		ifNil: [ meanStepDelta _ 0. n _ 0 ]
		ifNotNil: [
"			n _ (meanStepDelta / lastStepDelta between: 0.5 and: 2)
				ifTrue: [ 10 ]
				ifFalse: [10 ]."
			n _ 20 ].
	meanStepDelta _ meanStepDelta * n + lastStepDelta / (n+1).
	self redrawNeeded! !
!FrameRateMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 23:34' prior: 50338869!
               stepTime

	^20! !
!HaloMorph methodsFor: 'testing' stamp: 'jmv 6/11/2012 23:32' prior: 50338948!
                               stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 20! !
!HandleMorph methodsFor: 'testing' stamp: 'jmv 6/11/2012 23:32' prior: 50338955!
              stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 20! !
!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 23:32' prior: 50338962!
    stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 20! !
!MagnifierMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 23:32' prior: 50338969!
          stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 20! !
!Taskbar methodsFor: 'stepping' stamp: 'jmv 6/11/2012 23:33' prior: 50339003!
                 stepTime
	"Update often."
	^ 50! !
!WorldState methodsFor: 'initialization' stamp: 'jmv 6/11/2012 23:28' prior: 50339087!
      initialize

	hands _ #().
	damageRecorder_ DamageRecorder new.
	stepList _ Heap sortBlock: self stepListSortBlock.
	lastStepTime _ 0.
	lastAlarmTime _ 0.
	drawingFailingMorphs _ IdentitySet new.
	pause _ 20.
	lastCycleTime _ Time millisecondClockValue.
	lastCycleHadAnyEvent _ false! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 6/11/2012 23:41' prior: 50339097!
             doOneCycleFor: aWorld
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a MaxCycleLapse delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < MaxCycleLapse		"No events processed? Start saving CPU!!"
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time millisecondClockValue ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 0 ifTrue: [
		waitDelay beingWaitedOn
			ifFalse: [ waitDelay setDelay: wait; wait ]
			ifTrue: [
				"If we are called from a different process than that of the main UI, we might be called in the main
				interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
				(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _  Time millisecondClockValue.
	lastCycleHadAnyEvent _ self doOneCycleNowFor: aWorld! !
!WorldState class methodsFor: 'class initialization' stamp: 'jmv 6/11/2012 23:39' prior: 16987069!
                       initialize
	"WorldState initialize"

	MaxCycleLapse _ 200.		"never wait more than this to react to user events"
	DeferredUIMessages _ SharedQueue new.! !

WorldState class removeSelector: #minCycleLapse:!

WorldState class removeSelector: #minCycleLapse:!

WorldState initialize!

!classDefinition: #WorldState category: #'Morphic-Worlds'!
Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

Preferences class removeSelector: #higherPerformance!

Preferences class removeSelector: #higherPerformance!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
((World instVarNamed: 'worldState') instVarNamed: 'lastCycleTime') ifNil: [
	(World instVarNamed: 'worldState') instVarNamed: 'lastCycleTime' put: Time millisecondClockValue ].
((World instVarNamed: 'worldState') instVarNamed: 'lastCycleHadAnyEvent') ifNil: [
	(World instVarNamed: 'worldState') instVarNamed: 'lastCycleHadAnyEvent' put: false ].!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1304-YetMoreSteppingTweaks-JuanVuletich-2012Jun11-22h57m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1304] on 12 June 2012 at 4:58:18 pm'!
!SHParserST80 methodsFor: 'accessing' stamp: 'jmv 6/12/2012 16:53'!
        last3Ranges
	| r s lastI |
	s _ ranges size.
	r _ ranges last.
	lastI _ r type = #excessCode
		ifTrue: [ s - 1 ]
		ifFalse: [ s].
	^{ 
		(lastI > 2 ifTrue: [ranges at: lastI-2]).
		(lastI > 1 ifTrue: [ranges at: lastI-1]).
		(ranges at: lastI)
	}! !
!SmalltalkCompleter methodsFor: 'entries' stamp: 'jmv 6/12/2012 16:55' prior: 16941133!
              computeEntries

	| allSource contextClass id p last3Ranges range prevRange receiverClass prevPrevRange |
	allSource _ model actualContents string.
	p _ (model is: #hasTextProvider)
		ifTrue: [ model textProvider ]
		ifFalse: [ model ].
	contextClass _ (p respondsTo: #selectedClassOrMetaClass) ifTrue: [
		p selectedClassOrMetaClass ].

	"Instead of creating a new string, maybe we could pass the last position to parse to Shout..."
	parser _ SHParserST80 new.
	parser
		workspace: ((model isMemberOf: Workspace) ifTrue: [ model ]);
		classOrMetaClass: contextClass;
		source: (allSource copyFrom: 1 to: position).
	parser parse.
	last3Ranges _ parser last3Ranges.
	range _ last3Ranges third.
	range ifNil: [ ^entries _ #() ].

	"If parsing breaks before position, then we don't know what to suggest, therefore don't open Completion"
	range end = position ifFalse: [ ^entries _ #() ].

	prefix _ allSource copyFrom: range start to: range end.
	
	(parser isMessage: range type) ifTrue: [
		"If previous range is a constant or a well known identifier, we might filter messages"
		prevRange _ last3Ranges second.
		prevPrevRange _ last3Ranges first.
		receiverClass _ nil.
		"3 if -> ifNil: but not ifTrue:
		3=4 -> ifNil: or ifTrue:"
		(prevRange notNil and: [ prevPrevRange isNil or: [ (#(binary keyword) includes: prevPrevRange type) not]]) ifTrue: [
			id _ (allSource copyFrom: prevRange start to: prevRange end).
			receiverClass _ prevRange type caseOf: {
				[ #globalVar ] -> [ (Smalltalk at: id asSymbol) class ].
				[ #self ] -> [ contextClass ].
				[ #super ] -> [ contextClass superclass ].
				[ #true ] -> [ True ].
				[ #false ] -> [ False ].
				[ #nil ] -> [ UndefinedObject ].
				[ #character ] -> [ id first class ].
				[ #number ] -> [ (Compiler evaluate: id) class ].
				[ #string ] -> [ (Compiler evaluate: id) class ].
				[ #symbol ] -> [ (Compiler evaluate: id) class ].
				[ #stringSymbol ] -> [ (Compiler evaluate: id) class ].
				"thisContext could mean ContextPart or BlockClosure..."
				"[ #thisContext ] -> [ ContextPart ]"
			} otherwise: [ nil ]
		].
		^self computeMessageEntries: receiverClass ].

	(parser isPartialOrFullIdentifier: range type) ifTrue: [
		^self computeIdentifierEntries ].
	
	"If we don't know what to do, do nothing"
	entries _ #()! !

SHParserST80 removeSelector: #penultimateRange!

SHParserST80 removeSelector: #penultimateRange!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1305-AutoCompleterTweak-JuanVuletich-2012Jun12-16h57m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1305] on 13 June 2012 at 8:40:40 am'!
!CompiledMethod methodsFor: 'organization' stamp: 'dkh 4/23/2012 21:01'!
             category

	^self methodClass organization categoryOfElement: self selector! !
!SystemDictionary methodsFor: 'accessing' stamp: 'dkh 4/23/2012 21:06'!
          classes

	^self classNames collect: [:each | self at: each ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1306-CompiledMethod-category-JuanVuletich-2012Jun13-08h40m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1306] on 13 June 2012 at 8:49:38 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 6/13/2012 08:48' prior: 50336435!
                 knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dkh'					'Dale Henrichs')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DKL'					'Daniel K Lyons ')
	#('DSM' 				'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1307-AddDaleHenrichsAsKnownAuthor-JuanVuletich-2012Jun13-08h47m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1307] on 13 June 2012 at 6:34:55 pm'!
!Editor methodsFor: 'accessing' stamp: 'jmv 6/13/2012 18:21'!
help
	^self class help! !
!Editor class methodsFor: 'help' stamp: 'jmv 6/13/2012 18:17' prior: 50338118!
                       help
	"
	Editor help
	SimpleEditor help
	CellStyleEditor help
	TextEditor help
	SmalltalkEditor help
	"
	| allSpecs |
	allSpecs _ self cmdShortcutsSpec, self basicCmdShortcutsSpec.
	^String streamContents: [ :strm |
		allSpecs do: [ :triplet | | c |
			c _ triplet first = Character space
				ifFalse: [ triplet first asString, String tab ]
				ifTrue: [ 'Space'].
			strm nextPutAll: ('Cmd-', c, String tab, String tab, triplet third).
			strm newLine ]]! !
!TextEditor methodsFor: 'menu messages' stamp: 'jmv 6/13/2012 18:19' prior: 50338503!
                               openHelp
	"Show help screen"
	TextModel new contents: self help; openLabel: self name, ' Help'.! !
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 6/13/2012 18:18' prior: 50338135!
                           help: aKeyboardEvent
	"Show a help screen"

	self openHelp.
	^ true! !
!TextEditor class methodsFor: 'misc' stamp: 'jmv 6/13/2012 18:19' prior: 50338140!
      openHelp

	self new openHelp! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Editor initialize!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1308-CuisCore-JuanVuletich-2012Jun13-18h34m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1308] on 14 June 2012 at 10:02:25 pm'!
!CompiledMethod methodsFor: 'literals' stamp: 'jmv 6/14/2012 22:01' prior: 16822554!
                           headerDescription
	"Answer a description containing the information about the form of the 
	receiver and the form of the context needed to run the receiver."

	| s |
	s _ String new writeStream.
	self header printOn: s.
	s newLine; nextPutAll: '"primitive: '.
	self primitive printOn: s.
	s newLine; nextPutAll: ' numArgs: '.
	self numArgs printOn: s.
	s newLine; nextPutAll: ' numTemps: '.
	self numTemps printOn: s.
	s newLine; nextPutAll: ' numLiterals: '.
	self numLiterals printOn: s.
	s newLine; nextPutAll: ' frameSize: '.
	self frameSize printOn: s.
	s newLine; nextPutAll: ' isClosureCompiled: '.
	self isBlueBookCompiled not printOn: s.
	s nextPut: $"; newLine.
	^ s contents! !
!DifferenceFinder class methodsFor: 'compatibility' stamp: 'jmv 6/14/2012 22:01' prior: 16839219!
             wordsDisplayPatchFrom: srcString to: dstString
	| finder answer src1 dst1 changedCount |
	finder _ self base: srcString case: dstString.
	finder compareLines; compute.
	answer _ '' asText.
	src1 _ String new writeStream.
	dst1 _ String new writeStream.
	changedCount _ 0.
	finder differences sort first do: [:item :condition |
		condition caseOf: {
			[ #unchanged ] -> [
				changedCount > 0 ifTrue: [
					"If the sequence of changed lines is large, comparing words gets too slow and less useful"
					changedCount > 30 ifTrue: [
						^nil ].
					"Compare the just ended sequence of changed lines"
					finder base: src1 contents case: dst1 contents.
					finder compareWords; compute.
					answer _ answer append:  finder differences anyOne asText.
					src1 resetToStart.
					dst1 resetToStart.
					changedCount _ 0.
				].
				"This line hasn't changed. Just add it to the result in plain text."
				answer append: item ].
			[ #removed ] -> [
				"A removed line belongs in the source"
				src1 nextPutAll: item.
				changedCount _ changedCount + 1 ].
			[ #inserted ] -> [
				"An added line belongs in the destination"
				dst1 nextPutAll: item.
				changedCount _ changedCount + 1  ].
			}.
		].
	"If the sequence of changed lines is large, comparing words gets too slow and less useful"
	changedCount > 30 ifTrue: [
		^nil ].
	finder base: src1 contents case: dst1 contents.
	finder compareWords; compute.
	answer append:  finder differences anyOne asText.

	^answer! !
!String methodsFor: 'converting' stamp: 'jmv 6/14/2012 22:01' prior: 16956034!
     squeezedTo: n
	"
Examples:
	Do nothing:
		'This one is a rather long phrase' squeezedTo: 32

	1-remove blanks (result can be shorter than asked):
		'This one is a rather long phrase' squeezedTo: 30

	2-remove necessary trailing vowels
		'This one is a rather long phrase' squeezedTo: 24

	3-truncate as needed (and add ellipsis)
		'This one is a rather long phrase' squeezedTo: 15

	4-avoid ellipsis
		'This one is a rather long phrase' squeezedTo: 5
	"
	| vowelCount read write i char allowedVowels str desiredSize postFix j |
	str := self.
	desiredSize := n.
	str size <= n ifTrue: [^str].
	str := str asCamelCase.
	str size <= n ifTrue: [^str].
	postFix := ''.
	desiredSize := n - postFix size.
	vowelCount := str
		inject: 0
		into: [:prev :each | each isVowel ifTrue: [prev + 1] ifFalse: [prev]].
	str size - vowelCount <= desiredSize
		ifTrue: [allowedVowels := vowelCount - (str size - desiredSize)]
		ifFalse: [
			allowedVowels := 0.
			postFix := '...'.
			n - postFix size < 5 ifTrue: [postFix := ''].
			desiredSize := n - postFix size].

	read := str readStream.
	write := String new writeStream.
	i := 0.
	j := 0.
	[read atEnd not and: [j < desiredSize]] whileTrue: [
		char := read next.
		(char isVowel not or: [i < allowedVowels]) ifTrue: [
			char isVowel ifTrue: [i := i + 1].
			write nextPut: char.
			j := j + 1]].
	str := write contents , postFix.
	^ str! !
!Transcript class methodsFor: 'class initialization' stamp: 'jmv 6/14/2012 22:02' prior: 16978364!
                        initialize
	"
	self initialize
	"
	showOnDisplay _ true.
	innerRectangle _ 20@20 extent: 300@500.
	logToFile _ false.
	entries _ Array new: self maxEntries.
	unfinishedEntry _ String new writeStream.
	accessSemaphore _ Semaphore forMutualExclusion.
	self clear! !

Transcript initialize!

Transcript showOnDisplay: true; logToFile: true; bounds: (0@0 extent: (700@900 min: Display extent))!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1309-Literal-writeStream-JuanVuletich-2012Jun14-22h01m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1309] on 17 June 2012 at 12:57:14 pm'!
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/17/2012 12:49' prior: 16798621!
                   selectAll
	listIndex _ 0.
	listSelections atAllPut: true.
	self changed: #allSelections.
	self changed: #annotation! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/17/2012 12:49' prior: 16798627!
                    selectEquivalentMethods
	"Selects all method definitions for which there is already an equivalent method in the current image, 
	(meaning that the difference is cosmetic and not in behavior)"
	Cursor wait showWhile: [
		1 to: changeList size do: [ :i | 
			| change class |
			change _ changeList at: i.
			listSelections at: i put:
				((change type == #method and: [
					(class _ change methodClass) notNil]) and: [
						(class includesSelector: change methodSelector) and: [
							| cmWithNode |
							cmWithNode _ [class basicCompile: change string notifying: nil trailer: class defaultMethodTrailer ifFail: nil] 
								on: SyntaxErrorNotification do: [ :ex | ex return ].
							(cmWithNode notNil and: [
								| current inChange |
								current _ (class compiledMethodAt: change methodSelector) copyWithTrailerBytes: #(0).
								inChange _cmWithNode method copyWithTrailerBytes: #(0).
								current = inChange or: [
									| currentCmWithNode |
									currentCmWithNode _ [class basicCompile: (class decompilerClass new decompile: change methodSelector in: class) decompileString
											notifying: nil trailer: class defaultMethodTrailer ifFail: nil] on: SyntaxErrorNotification do: [ :ex | ex return ].
									(currentCmWithNode notNil and: [
										current _ currentCmWithNode method copyWithTrailerBytes: #(0).
										current = inChange])
								]
							])
						]]
				)]].
	self changed: #allSelections.
	self changed: #annotation! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/17/2012 12:50' prior: 16798675!
      selectMethodsForAbsentClasses
	"Selects all method definitions for which there is no counterpart method in the current image"

	Cursor read showWhile: [
		| change |
		1 to: changeList size do: [ :i | 
			change _ changeList at: i.
			listSelections at: i put:
				((change type == #method and:
					[change methodClass isNil]))]].
	self changed: #allSelections.
	self changed: #annotation! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/17/2012 12:50' prior: 16798698!
  selectNewMethods
	"Selects all method definitions for which there is no counterpart method in the current image"

	Cursor read showWhile: [
		| change class |
		1 to: changeList size do: [ :i | 
			change _ changeList at: i.
			listSelections at: i put:
				((change type == #method and:
					[((class _ change methodClass) isNil) or:
						[(class includesSelector: change methodSelector) not]]))]].
	self changed: #allSelections.
	self changed: #annotation! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/17/2012 12:50' prior: 16798714!
                             selectRemovalsOfSent
	"Selects all method removal for sent methods"

	Cursor read showWhile: [
		1 to: changeList size do: [ :i | | change |
			change _ changeList at: i.
			listSelections at: i put:
				(change type = #doIt and: [
					change string includesSubString: 'removeSelector: #' ] and: [
						Smalltalk isThereAReferenceTo: (change string copyAfterLast: $#) asSymbol ]) ]].
	self changed: #allSelections.
	self changed: #annotation! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/17/2012 12:50' prior: 16798730!
            selectSuchThat: aBlock
	"select all changes for which block returns true"
	listSelections _ changeList collect: aBlock.
	self changed: #allSelections.
	self changed: #annotation! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/17/2012 12:50' prior: 16798737!
                      selectUnchangedMethods
	"Selects all method definitions for which there is already a method in the current image, whose source is exactly the same.  9/18/96 sw"

	Cursor read showWhile: [
		| change class |
		1 to: changeList size do: [ :i | 
			change _ changeList at: i.
			listSelections at: i put:
				((change type == #method and:
					[(class _ change methodClass) notNil]) and:
						[(class includesSelector: change methodSelector) and:
							[change string = (class sourceCodeAt: change methodSelector) asString ]])]].
	self changed: #allSelections.
	self changed: #annotation! !
!ChangeList methodsFor: 'viewing access' stamp: 'jmv 6/17/2012 12:42' prior: 16798779!
                           annotation
	"Answer the string to be shown in an annotation pane.  Make plain that the annotation is associated with the current in-image version of the code, not of the selected disk-based version, and if the corresponding method is missing from the in-image version, mention that fact."

	| annot change count selectedCount ann1 ann2 aClass |
	change _ self currentChange.
	
	change isNil ifTrue: [
		count _ listSelections size.
		selectedCount _ listSelections count: [ :flag | flag ].
		^ 'Total items: ', count printString, ' - Selected items: ', selectedCount printString ].

	change type == #classDefinition ifTrue: [
		ann1 _ change isMetaClassChange ifTrue: [ 'Metaclass' ] ifFalse: [ 'Class' ].
		ann2 _ (Smalltalk includesKey: change methodClassName) ifTrue: [ ' already exists' ] ifFalse: [ ' not in system' ].
		^ann1, ann2 ].
	
	annot _ super annotation.
	annot asString = '------' ifTrue: [^ annot].

	^ change methodSelector notNil
		ifFalse: [ annot]
		ifTrue: [
			((aClass _ change methodClass) isNil or: [(aClass includesSelector: change methodSelector) not])
				ifTrue: [
					change methodClassName, ' >> ', change methodSelector, ' is not present in the system.']
				ifFalse: [
					'current version: ', annot]]! !
!ChangeList methodsFor: 'accessing' stamp: 'jmv 6/17/2012 11:57' prior: 16798925!
                     currentChange
	"return the current change being viewed, or nil if none"

	^ listIndex = 0
		ifFalse: [ changeList at: listIndex ]! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 6/17/2012 12:14' prior: 50338258!
    helpMenu
        "Build the help menu for the world."
        |  menu |

  	menu := self menu: 'Help...'.

        self fillIn: menu from:
        {
                {'About this System...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.
                {'Preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.
                nil.
               {'Editor keyboard shortcuts'. { SmalltalkEditor . #openHelp}. 'summary of keyboard shortcuts in editors for Smalltalk code.'}
	}.

	self addGestureHelpItemsTo: menu.

	self fillIn: menu from:
	{
                {'World menu Help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.
                {'Useful Expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.
                nil.

                {'Set Code Author...' . { Utilities . #setAuthor }. 'supply initials to be used to identify the author of code and other content.'}.
                {'VM Statistics' . { self . #vmStatistics}.  'obtain some intriguing data about the vm.'}.
			nil.
                {'Space Left' . { self . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.
        }.

	^menu

! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1310-AnnotationTweaks-JuanVuletich-2012Jun17-12h56m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1310] on 24 June 2012 at 6:47:53 pm'!
!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 6/24/2012 18:35' prior: 16814424!
                 updateListsAndCodeIn: aWindow
	"This is done because we are not the real model (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."
	aWindow canDiscardEdits ifTrue: [
		aWindow updatablePanes do: [ :aPane | aPane verifyContents ].
		self updatePaneIfNeeded ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1311-FixSlowDownsWithDirtyMethods-JuanVuletich-2012Jun24-18h45m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1311] on 27 June 2012 at 10:33:01 pm'!
!ImageMorph commentStamp: '<historical>' prior: 16867719!
                            ImageMorph is a morph that displays a picture (Form). My extent is determined by the extent of my form.

Use #image: to set my picture.

Structure:
 instance var		Type 		Description
 image				Form		The Form to use when drawing

Code examples:
	ImageMorph new openInWorld; grabFromScreen

	ImageMorph new image: (Form fromFileNamed: 'myGraphicsFileName'); openInWorld.

Relationship to SketchMorph: ImageMorph should be favored over SketchMorph, a parallel, legacy class -- see the Swiki FAQ for details ( http://minnow.cc.gatech.edu/squeak/1372 ). 
!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1312-ImageMorphComment-JuanVuletich-2012Jun27-22h30m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1312] on 29 June 2012 at 4:50:25 pm'!

!classDefinition: 'Object class' category: #'Kernel-Objects'!
Object class
	instanceVariableNames: 'protocols'!

Object class
	instanceVariableNames: 'protocols '!
!ProtoObject methodsFor: 'system primitives' stamp: 'jmv 6/29/2012 16:48'!
                           statePointsTo: anObject
	"Answers true if anObject is among my named or indexed instance variables, and false otherwise"

	<primitive: 132>
	1 to: self class instSize do: [ :i |
		(self instVarAt: i) == anObject ifTrue: [ ^ true ]].
	1 to: self basicSize do: [ :i |
		(self basicAt: i) == anObject ifTrue: [ ^ true ]].
	^ false! !
!Object class methodsFor: 'class initialization' stamp: 'jmv 6/29/2012 16:38'!
      initializeProtocols

	protocols _ self gatherProtocols! !
!Object class methodsFor: 'class initialization' stamp: 'jmv 6/29/2012 16:11'!
                       protocols

	^protocols! !
!Object class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 16:38'!
                  gatherProtocols
	"See comment at #is:"

	^#()! !
!Object class methodsFor: 'compiling' stamp: 'jmv 6/29/2012 16:28'!
           noteCompilationOf: aSelector meta: isMeta
	"A hook allowing some classes to react to recompilation of certain selectors"

	aSelector == #gatherProtocols ifTrue: [
		self withAllSubclassesDo: [ :cls |
			cls isMeta ifFalse: [ 
				cls initializeProtocols ]]]! !
!Array class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:48'!
        gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(Array)! !
!CodeProvider class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 16:08'!
                         gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(CodeProvider #ShoutEnabled dynamic)! !
!Color class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:49'!
   gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(Color)! !
!CompiledMethod class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:48'!
                       gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(CompiledMethod)! !
!FloatArray class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:48'!
                  gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(FloatArray)! !
!Form class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:49'!
                            gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(Form)! !
!ColorForm class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:49'!
                             gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(ColorForm)! !
!Cursor class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:50'!
                           gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(Cursor)! !
!Matrix class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:50'!
                              gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(Matrix)! !
!MessageSend class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:50'!
                         gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(MessageSend)! !
!Morph class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:51'!
                          gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(Morph)! !
!BorderedMorph class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:51'!
                        gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(BorderedMorph)! !
!HandMorph class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:52'!
                    gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(HandMorph)! !
!InnerTextMorph class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:53'!
                   gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(InnerTextMorph)! !
!LayoutMorph class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:52'!
                 gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(LayoutMorph)! !
!MorphicEvent class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:53'!
                   gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(MorphicEvent)! !
!PluggableScrollPane class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:51'!
           gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(ScrollPane)! !
!PluggableTextModel class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 16:08'!
              gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(hasTextProvider dynamic)! !
!Stream class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:53'!
             gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(Stream)! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 6/29/2012 16:34'!
         allProtocols
	"Protocols that #is: can test for.  Note: for classes that implement a more dynamic #is: (see PluggableTextModel) care should be taken to ensure that there protocols are not defined that don't get listed.

	Smalltalk allProtocols
	"
	| all |
	all _ Set new.
"	Smalltalk allClasses do: [ :cls|"
	Object withAllSubclassesDo: [ :cls |
		cls isMeta ifFalse: [
			all addAll: cls protocols ]].
	^ all! !
!SystemWindow class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:52'!
         gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(SystemWindow)! !
!Text class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:49'!
                          gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(Text)! !
!WeakMessageSend class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:54'!
                       gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(MessageSend)! !
!Workspace class methodsFor: 'instance protocol testing' stamp: 'jmv 6/29/2012 15:47'!
                      gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(ShoutEnabled)! !
!ProtoObject methodsFor: 'tracing' stamp: 'jmv 6/29/2012 16:48' prior: 16924046!
                           pointsTo: anObject
"Answers true if I hold a reference to anObject, or false otherwise. Or stated another way:

Answers true if the garbage collector would fail to collect anObject because I hold a reference to it, or false otherwise"

	^ (self statePointsTo: anObject)
		or: [ self class == anObject ]! !
!Object methodsFor: 'testing' stamp: 'jmv 6/29/2012 16:49' prior: 16905165!
  is: aSymbol
	"A means for cleanly replacing isXXX like methods.
	Please use judiciously!!
	Suggested by Igor Stasenko at
	http://lists.squeakfoundation.org/pipermail/squeak-dev/2009-June/136793.html
	aSymbol is ussually a class name (starting with uppercase) or a protocolo conformance question (starting with lowercase), such as #hasTextSelector, #hasTextProvider, etc.
	
	A few comments:
	
		- Good for kernel tests
		- Good for tests defined in the same package as the receiver
		- Overwriting this method in a different package is a bad idea. It will surely conflict with other package. Use the traditional isXXX in such cases
		
		- In any case, asking these kinds of questions is a sign of poor design. If possible, avoid the question altogether, using, for example, double dispatching.
		
		- if a class happens to answer true for several Symbols, consider implementing it like:
			^#(symbol1 symbol2 symbol3) statePointsTo: aSymbol
		"
	
	"Enable this to log improper calls to the Transcript..."
	"
	aSymbol class == Symbol ifFalse: [ thisContext sender sender print. aSymbol print ].
	"
	^self class protocols statePointsTo: aSymbol! !
!Object methodsFor: 'tracing' stamp: 'jmv 6/29/2012 16:48' prior: 16905474!
                           inboundPointersExcluding: objectsToExclude
"Answer a list of all objects in the system that point to me, excluding those in the collection of objectsToExclude. I do my best to avoid creating any temporary objects that point to myself, especially method and block contexts. Adapted from PointerFinder class >> #pointersTo:except:"

	| object lastObject pointers objectsToAlwaysExclude |
	Smalltalk garbageCollect.
	"big collection shouldn't grow, so it's contents array is always the same"
	pointers := OrderedCollection new: 1000.

	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious
	 method and block contexts out of the results"
	object := self someObject.
	lastObject _ Object new.
	[lastObject == object] whileFalse: [
		object isInMemory
			ifTrue: [((object statePointsTo: self)
				or: [object class == self])
					ifTrue: [pointers add: object]].
		object := object nextObject].

	objectsToAlwaysExclude := {
		pointers collector.
		thisContext.
		thisContext sender.
		thisContext sender sender.
		objectsToExclude.
	}.

	^ pointers removeAllSuchThat: [:ea |
		(objectsToAlwaysExclude identityIncludes: ea)
			or: [objectsToExclude identityIncludes: ea]]! !
!CodeProvider methodsFor: 'testing' stamp: 'jmv 6/29/2012 16:02' prior: 50332704!
             is: aSymbol

	aSymbol = #refusingToAccept
		ifTrue: [ ^self isRefusingToAccept ].
	^super is: aSymbol! !
!MethodDictionary methodsFor: 'accessing' stamp: 'jmv 6/29/2012 16:48' prior: 16893575!
                               includesKey: aSymbol
	"This override assumes that statePointsTo: uses a fast primitive"

	aSymbol ifNil: [^ false].
	^ self statePointsTo: aSymbol! !
!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 6/29/2012 16:01' prior: 16915452!
                  is: aSymbol

	aSymbol == #ShoutEnabled ifTrue: [ ^textProvider is: aSymbol ].
	^ super is: aSymbol! !
!SHParserST80 methodsFor: 'testing' stamp: 'jmv 6/29/2012 16:49' prior: 16931096!
        isMessage: aSymbol

	^#(binary incompleteBinary keyword incompleteKeyword unary incompleteUnary) statePointsTo: aSymbol! !
!SHParserST80 methodsFor: 'testing' stamp: 'jmv 6/29/2012 16:49' prior: 16931102!
                   isPartialOrFullIdentifier: aSymbol

	(#(#incompleteIdentifier
		#blockTempVar #blockArg #tempVar #methodArg
		#instVar #classVar 
		#workspaceVar #poolConstant #globalVar ) 
			statePointsTo:aSymbol) ifTrue: [ ^ true ].
	(self isReservedName: aSymbol) ifTrue: [ ^ true ].
	^ false! !
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 6/29/2012 15:38' prior: 50339546!
         knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dkh'					'Dale Henrichs')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DKL'					'Daniel K Lyons ')
	#('DSM' 				'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('pb'					'Phil Bellalouna')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 6/29/2012 16:32' prior: 16960902!
                               allClasses  
	"Return all the class defines in the Smalltalk SystemDictionary"
	"
	Smalltalk allClasses
	"

	^ self classNames collect: [:name | self at: name]! !

Workspace removeSelector: #is:!

Workspace removeSelector: #is:!

WeakMessageSend removeSelector: #is:!

WeakMessageSend removeSelector: #is:!

Text removeSelector: #is:!

Text removeSelector: #is:!

SystemWindow removeSelector: #is:!

SystemWindow removeSelector: #is:!

Stream removeSelector: #is:!

Stream removeSelector: #is:!

PluggableScrollPane removeSelector: #is:!

PluggableScrollPane removeSelector: #is:!

!classDefinition: 'Object class' category: #'Kernel-Objects'!
Object class
	instanceVariableNames: 'protocols'!

Object class
	instanceVariableNames: 'protocols'!

MorphicEvent removeSelector: #is:!

MorphicEvent removeSelector: #is:!

LayoutMorph removeSelector: #is:!

LayoutMorph removeSelector: #is:!

InnerTextMorph removeSelector: #is:!

InnerTextMorph removeSelector: #is:!

HandMorph removeSelector: #is:!

HandMorph removeSelector: #is:!

BorderedMorph removeSelector: #is:!

BorderedMorph removeSelector: #is:!

Morph removeSelector: #is:!

Morph removeSelector: #is:!

MessageSend removeSelector: #is:!

MessageSend removeSelector: #is:!

Matrix removeSelector: #is:!

Matrix removeSelector: #is:!

Cursor removeSelector: #is:!

Cursor removeSelector: #is:!

ColorForm removeSelector: #is:!

ColorForm removeSelector: #is:!

Form removeSelector: #is:!

Form removeSelector: #is:!

FloatArray removeSelector: #is:!

FloatArray removeSelector: #is:!

CompiledMethod removeSelector: #is:!

CompiledMethod removeSelector: #is:!

Color removeSelector: #is:!

Color removeSelector: #is:!

Array removeSelector: #is:!

Array removeSelector: #is:!

ProtoObject removeSelector: #instVarsInclude:!

ProtoObject removeSelector: #instVarsInclude:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1313-gatherProtocols-JuanVuletich-2012Jun29-15h31m-jmv.5.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #5315] on 19 July 2012 at 10:12:52 am'!
!Metaclass methodsFor: 'instance protocol testing' stamp: 'jmv 7/19/2012 10:12'!
                             protocols
	"So far, metaclasses don't define protocols. This means, for instance, that
		SmallInteger is: #SomeProtocol
	can not answer anything but false.
	
	It is possible to complete it, maybe adding a new class instance variable to Object to store classProtocols
	"
	^#()! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1314-class-protocols-JuanVuletich-2012Jul18-17h08m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1313] on 18 July 2012 at 3:42:52 pm'!

!classDefinition: #ExponentialRandom category: #'Kernel-Numbers'!
Random subclass: #ExponentialRandom
	instanceVariableNames: 'parameter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

Random subclass: #ExponentialRandom
	instanceVariableNames: 'parameter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!
!ExponentialRandom commentStamp: '<historical>' prior: 0!
                         My instances are random variables with Exponential distribution!
!NormalRandom commentStamp: '<historical>' prior: 16902254!
   My instances are random variables with Normal distribution (mean 0 and variance 1), using the Box-Muller method!

!classDefinition: #RayleighRandom category: #'Kernel-Numbers'!
Random subclass: #RayleighRandom
	instanceVariableNames: 'parameter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

Random subclass: #RayleighRandom
	instanceVariableNames: 'parameter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!
!RayleighRandom commentStamp: '<historical>' prior: 0!
                       My instances are random variables with Rayleigh distribution!
!ExponentialRandom methodsFor: 'generation' stamp: 'JMV 7/3/2000 20:28'!
                         next
	"Answer the next value"

	^(1 / (1 - super next)) ln * 2 * parameter squared! !
!ExponentialRandom methodsFor: 'initialization' stamp: 'JMV 7/3/2000 20:24'!
                             parameter: aNumber

	^parameter _ aNumber! !
!ExponentialRandom class methodsFor: 'instance creation' stamp: 'JMV 7/3/2000 20:25'!
                             newWithParameter: aNumber

	^super new
		parameter: aNumber;
		yourself! !
!RayleighRandom methodsFor: 'initialization' stamp: 'JMV 7/3/2000 20:24'!
           parameter: aNumber

	^parameter _ aNumber! !
!RayleighRandom methodsFor: 'generation' stamp: 'JMV 7/3/2000 20:28'!
             next
	"Answer the next value"

	^((1 / (1 - super next)) ln * 2 * parameter squared) sqrt! !
!RayleighRandom class methodsFor: 'instance creation' stamp: 'JMV 7/3/2000 20:25'!
                newWithParameter: aNumber

	^super new
		parameter: aNumber;
		yourself! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1315-AdditionalRandomDistributions-JuanVuletich-2012Jul18-15h17m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1315] on 19 July 2012 at 12:43:05 pm'!

!classDefinition: #FloatMatrix category: #LinearAlgebra!
Matrix subclass: #FloatMatrix
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

Matrix subclass: #FloatMatrix
	instanceVariableNames: 'elements '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

!classDefinition: #ObjectMatrix category: #LinearAlgebra!
Matrix subclass: #ObjectMatrix
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

Matrix subclass: #ObjectMatrix
	instanceVariableNames: 'elements '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

!classDefinition: #ObjectMatrix category: #LinearAlgebra!
Matrix subclass: #ObjectMatrix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

Matrix subclass: #ObjectMatrix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

!classDefinition: #FloatMatrix category: #LinearAlgebra!
Matrix subclass: #FloatMatrix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

Matrix subclass: #FloatMatrix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1316-MatrixRefactoring-1-JuanVuletich-2012Jul19-12h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1315] on 19 July 2012 at 1:08:02 pm'!

!classDefinition: #Matrix category: #LinearAlgebra!
Object subclass: #Matrix
	instanceVariableNames: 'width height elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

Object subclass: #Matrix
	instanceVariableNames: 'width height elements '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!
!Matrix commentStamp: 'jmv 7/19/2012 11:52' prior: 16885479!
    My instances are m x n matrices, where m is the height and n the width. A matrix is a kind of 2-d array. A Matrix whose width is 1 is called a "Column Vector". A Matrix whose height is 1 is called a "Row Vector".

My instances can hold elements of any kind, but include some methods that assume that the elements understand arithmetic operations. These are useful for Matrices whose elements are Fractions, LargeIntegers, Matrices and Vectors (column or row Matrices). They are also suitable for Complex numbers, but in such cases, an alternative is to use different FloatMatrices for Real and Imaginary parts.!
!FloatMatrix commentStamp: '<historical>' prior: 0!
        My instances are m x n matrices of Float values, where m is the height and n the width. Suitable for LinearAlgebra and SignalProcessing suff, among many other possible applications. It is possible to build VM plugins for fast processing.!
!FloatBandMatrix commentStamp: '<historical>' prior: 0!
                         My instances can have non-zero values only in the diagonal, and a band of certain width around it. Save space.!
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 10:25'!
                  elements
	^ elements! !
!Matrix methodsFor: 'private' stamp: 'jmv 7/19/2012 11:09'!
            elementsIndexForI: i j: j
	"Indexes goes from 1 to size (width or height)"

	^ i-1*width+j! !
!Matrix methodsFor: 'private' stamp: 'jmv 7/19/2012 12:35'!
      zeroElement
	"We don't really restrict the kind of objects we might hold... Our best guess for a kind of null additive value is to just ask some element..."

	^elements first class zero! !
!FloatMatrix methodsFor: 'filling' stamp: 'jmv 7/19/2012 10:46'!
  fillWithIdentity

	self fillWithZeroes.
	1 to: (width min: height) do: [ :j |
		self i: j j: j put: 1 ]! !
!FloatMatrix methodsFor: 'linear equation systems' stamp: 'jmv 7/19/2012 11:16'!
    linesLost

	| result |
	result _ 0.
	[
		(1 to: width) inject: true into: [ :prev :each |
			prev & ((self i: height-result j: each ) = 0.0) ]
	] whileTrue: [ result _ result + 1 ].
	^result! !
!FloatMatrix methodsFor: 'norm and condition number' stamp: 'jmv 7/19/2012 10:57'!
           conditionNumber
	^self norm * self inverse norm! !
!FloatMatrix methodsFor: 'norm and condition number' stamp: 'jmv 7/19/2012 10:57'!
                          norm
	"
	(FloatMatrix identity: 5) norm
	"
	^(self transposed * self) eigenvaluesByQR elements max sqrt! !
!FloatMatrix methodsFor: 'norm and condition number' stamp: 'jmv 7/19/2012 11:06'!
  norm2

	^self norm2Squared sqrt! !
!FloatMatrix methodsFor: 'norm and condition number' stamp: 'jmv 7/19/2012 11:16'!
          norm2Squared

	| result |
	width > 1 & (height > 1) ifTrue: [ ^self error: 'right now, only for vectors' ].
	result _ 0.0.
	width = 1 ifTrue: [
		1 to: height do: [ :i |
			result _ result + (self i: i j: 1) squared ] ]
	ifFalse: [
		1 to: width do: [ :i |
			result _ result + (self i: 1 j: i) squared ] ].
	^result! !
!FloatMatrix methodsFor: 'eigenvalues and eigenvectors' stamp: 'jmv 7/19/2012 10:56'!
          eigenvaluesAndEigenvectors
	"Answers a transposed vector (a row matrix) of eigenvalues and a matrix of eigenvectors.
	Each eigenvector is a column of the eigenvector matrix. Column k is the eigenvector for the
	eigenvalue at column k in the eigenvalue vector.
	The returned object is a Dictionary, with keys #eigenvalues and #eigenvectors."

	^ self eigenvaluesAndEigenvectorsByQR! !
!FloatMatrix methodsFor: 'eigenvalues and eigenvectors' stamp: 'jmv 7/19/2012 11:17'!
          eigenvaluesAndEigenvectorsByQR
	"Answers a transposed vector (a row matrix) of eigenvalues and a matrix of eigenvectors.
	Each eigenvector is a column of the eigenvector matrix. Column k is the eigenvector for the
	eigenvalue at column k in the eigenvalue vector.
	The returned object is a Dictionary, with keys #eigenvalues and #eigenvectors.
	This seems to be a bad way. Numerical Recipes in C has a couple of algorithms that should be studied!!"

	| result eigenvalues eigenvectorSystem eigenvaluesVector resultIndex resultEigenvalues resultEigenvectors rows columns |
	result _ Dictionary new.
	eigenvaluesVector _ self eigenvaluesByQR.
	eigenvaluesVector round.	"This is necesary to consider repeated eigenvalues this way, and not as different ones (that would lead to repeated eigenvectors)"
	eigenvalues _ Bag new.
	1 to: eigenvaluesVector height do: [ :j |
		eigenvalues add: (eigenvaluesVector i: j j: 1) ].
	eigenvectorSystem _ self appropriateResultClass newHeight: height width: width+1.
	resultIndex _ 1.
	resultEigenvalues _ self appropriateResultClass newRowVectorSize: width.
	resultEigenvectors _ self appropriateResultClass newHeight: height width: width.
	eigenvalues asSet do: [ :eigenvalue |
		"For each occurrence of an eigenvalue find a different eigenvector.
		This part could be optimized. The correct way would be to implement a method
		that finds a base of the row space. In single eigenvectors it would be a space 
		of dimension one. In eigenvalues with k occurrences, it would be a space of
		dimension k. This is a less elegant solution."
		1 to: (eigenvalues occurrencesOf: eigenvalue) do: [ :iteration |
			eigenvectorSystem fillWith: self.
			1 to: height do: [ :j |
				eigenvectorSystem i: j j: j put:
					(eigenvectorSystem i: j j: j) - eigenvalue.
				eigenvectorSystem i: j j: width+1 put: 0 ].
			eigenvectorSystem triangleWithPartialPivoting.

			"This second phase completes the linear system so it will have just one solution.
			The added equations are changed for each occurrence of the eigenvalue, to get
			a different eigenvector."
			rows _ eigenvectorSystem rowsCloserToZero: (eigenvalues occurrencesOf: eigenvalue).
			columns _ eigenvectorSystem columnsWithoutPivot: (eigenvalues occurrencesOf: eigenvalue).
			1 to: rows size do: [ :j |
				eigenvectorSystem i: (rows at: j) j: (columns at: j) put: 1.
				iteration = j ifTrue: [
					eigenvectorSystem i: (rows at: j) j: width+1 put: 1 ] ].

			resultEigenvalues i: 1 j: resultIndex put: eigenvalue.
			resultEigenvectors j: resultIndex put: eigenvectorSystem solveLinearSystem.
			resultIndex _ resultIndex + 1 ] ].
	result at: #eigenvalues put: resultEigenvalues.
	result at: #eigenvectors put: resultEigenvectors.
	^result! !
!FloatMatrix methodsFor: 'eigenvalues and eigenvectors' stamp: 'jmv 7/19/2012 11:15'!
                           eigenvaluesByQR
	"This implementation only works if all the eigenvalues are real."
	"(FloatMatrix fromArrayOfArrays: #(
		#(6 4 4 1) 
		#(4 6 1 4) 
		#(4 1 6 4)
		#(1 4 4 6)
	)) eigenvaluesByQR"

	| h q r loopCount |
	h _ self hessembergSuperior.
	q _ self appropriateResultClass newHeight: height width: width.
	r _ self appropriateResultClass newHeight: height width: width.
	loopCount _ 0.
	[ h isFirstSubdiagonalZero ] whileFalse: [
		h storeQRDecompositionOfHessemberSuperiorOnQ: q r: r.
		h fillWith: r multipliedBy: q.
		loopCount _ loopCount + 1.
		loopCount > 200 ifTrue: [^self error: 'Could not find real eigenvalues'] ].
	^h diagonal! !
!FloatMatrix methodsFor: 'eigenvalues and eigenvectors' stamp: 'jmv 7/19/2012 11:15'!
 hessembergSuperior
	"Answers a new matrix that is the Hessember Superior transform of the receiver.
	A Hessember Superior matrix has zero entries below the first subdiagonal.
	The new matrix has the same eigenvalues as the receiver."

	| result u |
	self isSquare ifFalse: [ ^self error: 'Only for Square Matrices' ].
	result _ self copy.
	u _ self appropriateResultClass newHeight: height width: width.
	1 to: width-2 do: [ :j |
		(result storeHouseholderTransformOn: u column: j forQR: false) ifTrue: [
			result _ u * result * u.
		].
	].
	^ result
! !
!FloatMatrix methodsFor: 'eigenvalues and eigenvectors' stamp: 'jmv 7/19/2012 11:17'!
                              storeHouseholderTransformOn: aMatrix column: j forQR: forQR
	"Modifies entries on aMatrix to make it the Householder transforms
	that puts zeroes at column i of the receiver. If forQR is false, the
	product of aMatrix * self is Hessemberg superior, otherways its a
	triangular matrix. "

	| x xNorm2Squared v vNorm2Squared element i |
	i _ j - (forQR ifTrue: [ 1 ] ifFalse: [ 0 ]).
	x _ self appropriateResultClass newVectorSize: height-i.
	xNorm2Squared _ 0.
	1 to: x height do: [ :ii |
		element _ self i: ii+i j: j.
		xNorm2Squared _ xNorm2Squared + element squared.
		x i: ii j: 1 put: element ].
	v _ x.
	"If column already has zeros, do nothing"
	xNorm2Squared = 0.0 ifTrue: [ ^false ].
	"If column already has zeros, do nothing. If forQR = false, then the first element in x
	could not be zero, and anyway there's nothing to do"
	(forQR not and: [ xNorm2Squared = (x i: 1 j: 1) squared ]) ifTrue: [ ^false ].

	v i: 1 j: 1 put: (v i: 1 j: 1) + xNorm2Squared sqrt.
	vNorm2Squared _ v norm2Squared.

	1 to: i do: [ :ii |
		aMatrix i: ii j: ii put: 1.
		ii+1 to: aMatrix width do: [ :jj |
			aMatrix i: ii j: jj put: 0.
			aMatrix i: jj j: ii put: 0 ] ].
	1 to: x height do: [ :ii |
		1 to: x height do: [ :jj |
			aMatrix i: ii+i j: jj+i put: 
				(ii=jj ifTrue:[1] ifFalse:[0]) - 
				(2.0 / vNorm2Squared * (v i: ii j: 1) * (v i: jj j: 1) ) ] ].
	^true! !
!FloatMatrix methodsFor: 'eigenvalues and eigenvectors' stamp: 'jmv 7/19/2012 12:00'!
                       storeQRDecompositionOfHessemberSuperiorOnQ: q r: r
	"Works only if the receiver is a Hessemberg superior matrix."

	| elementAtJ elementBelowJ aux c s |
	q fillWithIdentity.
	r fillWith: self.
	1 to: width-1 do: [ :j |
		elementAtJ _ r i: j j: j.
		elementBelowJ _ r i: j+1 j: j.
		elementBelowJ = 0 ifFalse: [
			aux _ ((elementAtJ*elementAtJ) + (elementBelowJ*elementBelowJ)) sqrt.
			c _ elementAtJ / aux.
			s _ 0 - elementBelowJ / aux.
			r preMultiplyByGivensRotationRowI: j rowK: j+1 titaCosine: c titaSine: s.
			q preMultiplyByGivensRotationRowI: j rowK: j+1 titaCosine: c titaSine: s ] ].
	q transpose.! !
!FloatMatrix methodsFor: 'operations' stamp: 'jmv 7/19/2012 12:19'!
                    round

	| a b |
	1 to: height do: [ :i |
		1 to: width do: [ :j |
			(self i: i j: j) = 0.0 ifFalse: [
				a _ self i: i j: j.
				b _ (10.0 raisedTo: a abs log truncated - 5).
				self i: i j: j put: (a / b) rounded * b ] ] ]! !
!FloatMatrix methodsFor: 'printing' stamp: 'jmv 7/19/2012 12:10'!
                        printOn: aStream
	1 to: height do: [ :i |
		aStream nextPutAll: '| '.
		1 to: width do: [ :j |
			aStream nextPutAll: ((self i: i j: j) printPaddedLeft: 1 decimalPlaces: 2).
			"aStream print: ((self i: i j: j) roundTo: 0.001)."
			aStream nextPut: $  ].
		aStream nextPut: $|; newLine ]! !
!FloatMatrix methodsFor: 'aux operations' stamp: 'jmv 7/19/2012 12:02'!
                     preMultiplyByGivensRotationRowI: i rowK: k titaCosine: c titaSine: s
	"Modify the receiver, doing a premultiplication by a Givens rotation of angle tita,
	affecting rows i and k."

	| elemI elemK |
	1 to: width do: [ :j |
		elemI _ self i: i j: j.
		elemK _ self i: k j: j.
		self i: i j: j put: c*elemI - (s*elemK).
		self i: k j: j put: s*elemI + (c*elemK) ].! !
!FloatMatrix methodsFor: 'aux operations' stamp: 'jmv 7/19/2012 12:01'!
           rowsCloserToZero: count
	"Return a collection with the indexes of the rows that are closer to being all zeroes"

	^(((((1 to: height) collect: [ :i |
		i @ (self i: i) norm2Squared ])
			asSortedCollection: [ :a :b | a y < b y ])
				copyFrom: 1 to: count) collect: [ :each | each x ] ) asSortedCollection! !
!FloatMatrix methodsFor: 'private' stamp: 'jmv 7/19/2012 12:18'!
          epsilon
	"Something better is needed. For example, taking into accoung the largest elements, or the norm, or something like that... In any case it is better to check senders, and use a different strategy for ending iterative methods or such..."

	^1e-3 asFloat! !
!FloatMatrix methodsFor: 'testing' stamp: 'jmv 7/19/2012 13:06'!
                       isFirstSubdiagonalZero

	^(1 to: width-1) inject: true into: [ :previousValue :each |
		previousValue and: [ (self i: each + 1 j: each) abs <= self epsilon ] ]! !
!Number class methodsFor: 'constants' stamp: 'jmv 7/19/2012 12:31'!
                         zero

	^0! !
!Float class methodsFor: 'constants' stamp: 'jmv 7/19/2012 12:32'!
                zero

	^0.0! !
!Collection methodsFor: 'testing' stamp: 'jmv 7/19/2012 12:29' prior: 16816830!
 isZero
	"Answer whether the receiver is zero"
	Transcript newLine.
	#isZero print.
	thisContext printStack: 5.
	self flag: #jmv. "Remove this crap!!"

	^ false! !
!DifferenceFinder methodsFor: 'private' stamp: 'jmv 7/19/2012 10:33' prior: 16838975!
       initializeMatrix
	matrix _ Matrix newHeight: x size width: y size! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:18' prior: 16885484!
             at: aPointOrIndex
	"If aPointOrIndex is a Number, the receiver must be a vector (either row or column).
	Indexes goes from 1 to size (width or height)"

	| i j |
	aPointOrIndex isPoint
		ifTrue: [ i _ aPointOrIndex y. j _ aPointOrIndex x ]
		ifFalse: [
			width = 1 ifTrue: [ i _ aPointOrIndex. j _ 1 ].
			height = 1 ifTrue: [ i _ 1. j _ aPointOrIndex. ]].
	^ self i: i j: j ! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:18' prior: 16885499!
                      at: aPointOrIndex put: aNumber
	"If aPointOrIndex is a Number, the receiver must be a vector (either row or column).
	Indexes goes from 1 to size (width or height)"

	
| i j |
	aPointOrIndex isPoint
		ifTrue: [ i _ aPointOrIndex y. j _ aPointOrIndex x ]
		ifFalse: [
			width = 1 ifTrue: [ i _ aPointOrIndex. j _ 1 ].
			height = 1 ifTrue: [ i _ 1. j _ aPointOrIndex. ]].
	^ self i: i j: j put: aNumber! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:18' prior: 16885514!
                            diagonal

	| x |
	x _ self appropriateResultClass newVectorSize: height.
	1 to: height do: [ :i |
		x i: i j: 1 put: (self i: i j: i ) ].
	^x! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:22' prior: 16885609!
 i: i
	"Answers a row vector with the values at row y"

	| result |
	result _ self appropriateResultClass newRowVectorSize: width.
	1 to: width do: [ :j |
		result i: 1 j: j put: (self i: i j: j) ].
	^result! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 10:27' prior: 16885618!
i: i j: j

	"Answer element at row i, column j"

	^ elements at: (self elementsIndexForI: i j: j)! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 10:25' prior: 16885623!
             i: i j: j put: anObject
	"Store anObject as the element at row i, column j"

	elements at: (self elementsIndexForI: i j: j) put: anObject! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:22' prior: 16885629!
     i: i put: row
	"aVector must be a row vector, i.e. a matrix with height 1"

	1 to: width do: [ :j |
		self i: i j: j put: (row at: j) ]! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:22' prior: 16885646!
       iExtended: i
	"Answers a row vector with the values at row y,
	but with 2 extra values at each end, such that the second derivative is that at the original ends"

	| result |
	result _ self appropriateResultClass newRowVectorSize: width + 4.
	1 to: width do: [ :j |
		result i: 1 j: j+2 put: (self i: i j: j) ].
	"The first available second derivative is
	(s5-s4)-(s4-s3)"
	"
Tomar esto para lo que realmente hace falta. Ver el otro browser
	second _ (third-fourth) * 3.0 + fifth.
	first _ (second-third) * 3.0 + fourth.
	penultimate _ (antepenultimate - thirdToEnd) * 3.0 + fourthToEnd.
	last _ (penultimate -antepenultimate) * 3.0 + thirdToEnd.
	"
	^result! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:19' prior: 16885673!
                            j: j
	"Answers a column vector with the values at column x"

	| result |
	result _ self appropriateResultClass newColumnVectorSize: height.
	1 to: height do: [ :i |
		result i: i j: 1 put: (self i: i j: j) ].
	^result! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:19' prior: 16885687!
                     j: j put: column
	"column can be a column vector (m x 1 matrix), or a kind of Array"

	1 to: height do: [ :i |
		self i: i j: j put: (column at: i) ]! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:27' prior: 16885694!
                         m
	"Usual name in Linear Algebra"

	^height! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 11:27' prior: 16885697!
   n
	"Usual name in Linear Algebra"

	^width! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/19/2012 11:20' prior: 16885756!
   * aMatrixOrNumber
	"Standard matrix multiplication"
	| result |
	(aMatrixOrNumber is: #Matrix) ifTrue: [
		width = aMatrixOrNumber height ifFalse: [ ^self error: 'Matrix sizes do not match' ].
		result _ self appropriateResultClass newHeight: height width: aMatrixOrNumber width.
		result fillWith: self multipliedBy: aMatrixOrNumber ]
	ifFalse: [
		result _ self copy.
		result replaceValues: [ :value | value * aMatrixOrNumber ] ].
	^result
	! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/19/2012 11:20' prior: 16885773!
                 + aMatrixOrNumber
	"Add element by element"
	| result |
	(aMatrixOrNumber is: #Matrix) ifTrue: [
		(width = aMatrixOrNumber width) & (height = aMatrixOrNumber height)
			ifFalse: [ ^self error: 'Matrix sizes do not match' ].
		result _ self appropriateResultClass newHeight: height width: width.
		result fillWith: self plus: aMatrixOrNumber ]
	ifFalse: [
		result _ self copy.
		result replaceValues: [ :value | value + aMatrixOrNumber ] ].
	^result
	! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/19/2012 11:20' prior: 16885790!
         - aMatrixOrNumber
	"Substract element by element"
	| result |
	(aMatrixOrNumber is: #Matrix) ifTrue: [
		(width = aMatrixOrNumber width) & (height = aMatrixOrNumber height)
			ifFalse: [ ^self error: 'Matrix sizes do not match' ].
		result _ self appropriateResultClass newHeight: height width: width.
		result fillWith: self minus: aMatrixOrNumber ]
	ifFalse: [
		result _ self copy.
		result replaceValues: [ :value | value - aMatrixOrNumber ] ].
	^result
	! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/19/2012 12:06' prior: 16885808!
  / aNumber
	"Divide by a scalar"
	| reciprocal result |
	reciprocal _ 1 / aNumber.
	result _ self copy.
	result replaceValues: [ :value | value * reciprocal ].
	^result
	! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/19/2012 11:18' prior: 16885815!
    fillWith: aMatrix minus: bMatrix

	| elem |
	1 to: height do: [ :i |
		1 to: width do: [ :j |
			elem _ ((aMatrix i: i j: j) - (bMatrix i: i j: j)).
			self i: i j: j put: elem ] ]! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/19/2012 12:36' prior: 16885824!
                         fillWith: aMatrix multipliedBy: bMatrix

	| zeroElement elem |
	zeroElement _ self zeroElement.
	1 to: height do: [ :i |
		1 to: width do: [ :j |
			elem _ zeroElement.
			1 to: aMatrix width do: [ :k |
				elem _ ((aMatrix i: i j: k) * (bMatrix i: k j: j)) + elem ].
			self i: i j: j put: elem ] ]! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/19/2012 11:18' prior: 16885835!
  fillWith: aMatrix plus: bMatrix

	| elem |
	1 to: height do: [ :i |
		1 to: width do: [ :j |
			elem _ ((aMatrix i: i j: j) + (bMatrix i: i j: j)).
			self i: i j: j put: elem ] ]! !
!Matrix methodsFor: 'copying' stamp: 'jmv 7/19/2012 10:33' prior: 16885857!
                             copy
	"Don't share the elements collection, but use a new copy of it"

	^self copyTwoLevel! !
!Matrix methodsFor: 'filling' stamp: 'jmv 7/19/2012 11:21' prior: 16886033!
                      fillDiagonalWith: aVectorOrArray

	1 to: (width min: height) do: [ :j |
		self i: j j: j put: (aVectorOrArray at: j) ].! !
!Matrix methodsFor: 'filling' stamp: 'jmv 7/19/2012 11:18' prior: 16886039!
                         fillWith: aMatrix

	1 to: (height min: aMatrix height) do: [ :i |
		1 to: (width min: aMatrix width) do: [ :j |
			self i: i j: j put: (aMatrix i: i j: j) ] ]! !
!Matrix methodsFor: 'filling' stamp: 'jmv 7/19/2012 11:19' prior: 16886047!
                  fillWithArrayOfArrays: anArray
	"FloatMatrix fromArrayOfArrays: #(
		#(1 2 0 0 0 0) 
		#(2 4 1 0 0 -4) 
		#(0 1 1 1 0 0)
		#(0 0 1 1 1 0)
		#(0 0 0 1 1 1)
		#(0 1 0 0 1 1)
	)."

	1 to: height do: [ :i |
		1 to: width do: [ :j |
			self i: i j: j put: ((anArray at: i) at: j) ] ]! !
!Matrix methodsFor: 'initialization' stamp: 'jmv 7/19/2012 10:29' prior: 16886072!
                   initializeElements

	elements _ Array new: height * width! !
!Matrix methodsFor: 'linear equation systems' stamp: 'jmv 7/19/2012 13:07' prior: 16886077!
       solveLinearSystem
	| m n x sum |
	"Solve the sistem A x = b where the receiver has this form | Ab |,
	the last column of the receiver contains the independent term b.
	(FloatMatrix fromArrayOfArrays: #(
		#(1 2 0 0 0 0 3) 
		#(2 4 1 0 0 -4 3) 
		#(0 1 1 1 0 0 3)
		#(0 0 1 1 1 0 3)
		#(0 0 0 1 1 1 3)
		#(0 1 0 0 1 1 3)
	)) solveLinearSystem
	(Matrix fromArrayOfArrays: {
		{1. 2. 0. 0. 0. 0. 3/2}.
		{2. 4. 1. 0. 0. -4. 3/2}. 
		{0. 1. 1. 1. 0. 0. 3/2}.
		{0. 0. 1. 1. 1. 0. 3/2}.
		{0. 0. 0. 1. 1. 1. 3/2}.
		{0. 1. 0. 0. 1. 1. 3/2}
	}) solveLinearSystem
	"

	m _ height.
	n _ width.
	x _ self appropriateResultClass newVectorSize: n-1.

	"Check we have enough equations"
	m < (n-1) ifTrue: [
		^self error: 'This system does not have a single solution' ].

	self triangleWithPartialPivoting.

	"Checks"
	"If the only coeficient of the last equation is zero, we have infinite solutions."
	((self i: n-1 j: n-1) abs <= self epsilon) & ((self i: n-1 j: n) abs <= self epsilon) ifTrue: [
		^self error: 'This system does not have a single solution' ].
	"If the only coeficient of the last equation is zero, but not the independent term,
	the system is incompatible."
	(self i: n-1 j: n-1) abs <= self epsilon ifTrue: [
		^self error: 'This system is incompatible (it does not have solution)' ].
	"We have too much equations, and they did not go away. Incompatible system."
	(m > (n-1) and: [ (self i: n j: n-1) abs > self epsilon ]) ifTrue: [
		^self error: 'This system does is incompatible (it does not have solution)' ].
	"We have too much equations, and they left their independent terms."
	((n to: m) inject: true into: [ :previousValue :k |
		previousValue & ((self i: k j: n) abs <= self epsilon ) ]) ifFalse: [
			^self error: 'This system does is incompatible (it does not have solution)' ].

	"Do backward substitution"
	n-1 to: 1 by: -1 do: [ :i |
		sum _ self i: i j: n.
		n-1 to: i+1 by: -1 do: [ :k |
			sum _ sum - ((self i: i j: k) * (x i: k j: 1)) ].
		x i: i j: 1 put: sum / (self i: i j: i) ].
	^x! !
!Matrix methodsFor: 'linear equation systems' stamp: 'jmv 7/19/2012 12:26' prior: 16886136!
 triangleWithPartialPivoting
	"Triangle self, and answer the row permutation count"

	| j jdelta k factor permutationCount |
	permutationCount _ 0.
	jdelta _ 0.
	1 to: height-1 do: [ :i |

		[
			j _ i + jdelta.
			j <= width ifFalse: [ ^self ].
 			"Look for the pivot for column j, from row i down. Call it row k"
			k _ self rowWithMaxInColumn: j startingAtRow: i.
			((self i: k j: j) isZero) & (j < width) ] whileTrue: [ jdelta _ jdelta + 1 ].

		"Permute rows k and i"
		i = k ifFalse: [
			self permuteRow: i and: k.
			permutationCount _ permutationCount + 1 ].

      	"Substract the row i to all the ones below it"
		i+1 to: height do: [ :ii |
			(self i: ii j: j) isZero ifFalse: [
				factor _ (self i: ii j: j) / (self i: i j: j).
				"Only after column j"
				self substractRow: i multipliedBy: factor to: ii startingAtColumn: j ] ]
	].
	^ permutationCount! !
!Matrix methodsFor: 'printing' stamp: 'jmv 7/19/2012 12:11' prior: 16886395!
          printOn: aStream
	1 to: height do: [ :i |
		aStream nextPutAll: '| '.
		1 to: width do: [ :j |
			aStream print: (self i: i j: j).
			aStream nextPut: $  ].
		aStream nextPut: $|; newLine ]! !
!Matrix methodsFor: 'operations' stamp: 'jmv 7/19/2012 11:20' prior: 16886417!
                determinant

	| aux rowPermutationCount result |
	self isSquare ifFalse: [ ^self error: 'Only for Square Matrices' ].
	aux _ self copy.
	rowPermutationCount _ aux triangleWithPartialPivoting.
	result _ -1 raisedToInteger: rowPermutationCount.
	1 to: width do: [ :i |
		result _ result * (aux i: i j: i) ].
	^result! !
!Matrix methodsFor: 'operations' stamp: 'jmv 7/19/2012 12:36' prior: 16886430!
                   inverse
	"Answers the inverse matrix"

	| zeroElement bigMatrix result |
	zeroElement _ self zeroElement.
	self isSquare ifFalse: [ ^self error: 'Only for Square Matrices' ].
	result _ self appropriateResultClass newHeight: height width: width.
	bigMatrix _ self appropriateResultClass newHeight: height width: width + 1.
	1 to: width do: [ :i |
		bigMatrix fillWith: self.
		1 to: width do: [ :j | bigMatrix i: j j: width+1 put: zeroElement ].
		bigMatrix i: i j: width + 1 put: 1.
		result j: i put: bigMatrix solveLinearSystem ].
	^result! !
!Matrix methodsFor: 'operations' stamp: 'jmv 7/19/2012 12:21' prior: 16886199!
                moveOriginToCenter: aBoolean
	"This method performs a circular shift of the both in horizontal and vertical direction. The magnitude of the shift is half our extent.
	This is useful, for example, to make a better visualization of convolution kernels:
	
	To be properly applied, the kernel is centered at 1@1 . For instance a simple low pass filter could be
	| 0.6   0.1   0.0   0.1 |
	| 0.1   0.0   0.0   0.0 |
	| 0.0   0.0   0.0   0.0 |
	| 0.1   0.0   0.0   0.0 |
	
	But it is much easier to 'see' it if the center of the filter is moved to the center of the matrix like this:
	| 0.0   0.0   0.0   0.0 |
	| 0.0   0.0   0.1   0.0 |
	| 0.0   0.1   0.6   0.1 |
	| 0.0   0.0   0.1   0.0 |
	
	This method takes the receiver and answers a new instance, transforming it from 1@1 to center if aBoolean is true, or backwards if false.
	(if the extent is even, then aBoolean makes no difference).
	
	((FloatMatrix fromArrayOfArrays: #(
		(0.6   0.1   0.0   0.1)
		(0.1   0.0   0.0   0.0)
		(0.0   0.0   0.0   0.0)
		(0.1   0.0   0.0   0.0)))
			moveOriginToCenter: true)
			print

	((Matrix fromArrayOfArrays: #(
		(0.6   0.1   0.0   0.0   0.1)
		(0.1   0.0   0.0   0.0   0.0)
		(0.0   0.0   0.0   0.0   0.0)
		(0.0   0.0   0.0   0.0   0.0)
		(0.1   0.0   0.0   0.0   0.0)))
			moveOriginToCenter: true)
			print
	"
	| answer deltaI deltaJ e ex ey |
	e _ self size.
	ey _ e y.
	ex _ e x.
	deltaI _ ey //2.
	deltaJ _ ex // 2.
	aBoolean ifFalse: [
		deltaI _ deltaI negated.
		deltaJ _ deltaJ negated ].
	answer _ self class newSize: e.
	0 to: ey-1 do: [ :i |
		0 to: ex-1 do: [ :j |
			answer i: i+deltaI\\ey+1 j: j+deltaJ\\ex+1 put: (self i: i+1 j: j+1) ]].
	^answer! !
!Matrix methodsFor: 'operations' stamp: 'jmv 7/19/2012 12:37' prior: 16886253!
                    normalizeColumns

	| zeroElement normSquared |
	zeroElement _ self zeroElement.
	1 to: width do: [ :j |
		normSquared _ zeroElement.
		1 to: height do: [ :i |
			normSquared _(self i: i j: j) squared + normSquared ].
		1 to: height do: [ :i |
			self i: i j: j put: (self i: i j: j) / normSquared sqrt ] ]! !
!Matrix methodsFor: 'operations' stamp: 'jmv 7/19/2012 12:17' prior: 16886263!
                            permuteRow: i and: k

	| a b |
	i = k ifFalse: [
		1 to: width do: [ :j |
			a _ self i: k j: j.
			b _ self i: i j: j.
			self i: k j: j put: b.
			self i: i j: j put: a ] ]! !
!Matrix methodsFor: 'operations' stamp: 'jmv 7/19/2012 12:17' prior: 16886361!
                               transpose
	"Traspose the receiver. Modify it."

	| aux |
	1 to: width do: [ :ii |
		ii+1 to: width do: [ :jj |
			aux _ self i: ii j: jj.
			self i: ii j: jj put: (self i: jj j: ii).
			self i: jj j: ii put: (aux) ] ].! !
!Matrix methodsFor: 'operations' stamp: 'jmv 7/19/2012 12:17' prior: 16886371!
                   transposed
	"Answer a new matrix, transposed."

	| result |
	result _ self appropriateResultClass newHeight: width width: height.
	1 to: result height do: [ :i |
		1 to: result width do: [ :j |
			result i: i j: j put: (self i: j j: i) ] ].
	^result! !
!Matrix methodsFor: 'private' stamp: 'jmv 7/19/2012 12:35' prior: 16885844!
                       epsilon
	"Something better is needed. For example, taking into accoung the largest elements, or the norm, or something like that... In any case it is better to check senders, and use a different strategy for ending iterative methods or such...
	Check inheritance too"

	^self zeroElement! !
!Matrix methodsFor: 'testing' stamp: 'jmv 7/19/2012 11:26' prior: 16885669!
                 isSquare

	^height = width! !
!Matrix methodsFor: 'aux operations' stamp: 'jmv 7/19/2012 12:25' prior: 16886173!
               columnsWithoutPivot: count
	"Return a collection with the indexes of the columns that are closer to not having a pivot"

	| col col2 |
	col _ SortedCollection sortBlock: [ :a :b | a y < b y ].
	1 to: height do: [ :j |
		col2 _ OrderedCollection new.
		1 to: height do: [ :i |
			(j = 1 or: [(self i: i j: j-1) isZero]) ifTrue: [
				col2 add: (self i: i j: j) abs ] ].
		col add: (j @ col2 max) ].
	^((col copyFrom: 1 to: count) collect: [ :each | each x ] ) asSortedCollection! !
!Matrix methodsFor: 'aux operations' stamp: 'jmv 7/19/2012 12:04' prior: 16885717!
            rowWithMaxInColumn: j startingAtRow: jStart

	| rowWithMax |
	rowWithMax _ jStart.
	jStart+1 to: height do: [ :i |
		(self i: i j: j) abs > (self i: rowWithMax j: j) abs ifTrue: [
			rowWithMax _ i ] ].
	^rowWithMax! !
!Matrix methodsFor: 'aux operations' stamp: 'jmv 7/19/2012 12:37' prior: 16886352!
                  substractRow: i multipliedBy: factor to: k startingAtColumn: jStart

	self i: k j: jStart put: self zeroElement..
	jStart+1 to: width do: [ :j |
		self i: k j: j put:
			(self i: k j: j) - ((self i: i j: j) * factor) ]! !
!FloatMatrix methodsFor: 'signal processing' stamp: 'jmv 7/19/2012 11:14' prior: 16855511!
       convolutionLinearWith: aForm
	"Linear convolution. Warning: Slow.
	It is usually preferred to do a circular convolution via FFT and take care of border effects."
	"
	| f m |
	f _ Form fromUser.
	m _ FloatMatrix m: 3 n: 3.
	m fillGaussian.
	(m convolutionWith: f) display
	"

	| resultWidth resultHeight result xx yy blue c green red k |
	resultWidth _ width + aForm width - 1.
	resultHeight _ height + aForm height - 1.
	k _ 1.0 / elements sum.
	result _ Form extent: resultWidth@resultHeight depth: 32.
	1 to: resultHeight do: [ :y |
		1 to: resultWidth do: [ :x |
			red _ 0.0.
			green _ 0.0.
			blue _ 0.0.
			1 to: height do: [ :j |
				1 to: width do: [ :i |
					xx _ x-i+1.
					yy _ y-j+1.
					(xx > 0) & (xx <= aForm width) & (yy > 0) & (yy <= aForm height)
						ifTrue: [
							c _ aForm colorAt: xx@yy.
							red _ c red * (self i: i j: j) + red.
							green _ c green * (self i: i j: j) + green.
							blue _ c blue * (self i: i j: j) + blue ]]].
			red _ red * k min: 1.0 max: 0.0.
			green _ green * k min: 1.0 max: 0.0.
			blue _ blue * k min: 1.0 max: 0.0.
			result colorAt: x@y put:
				(Color r: red g: green b: blue).
		].
	].
	^result! !
!FloatMatrix methodsFor: 'aritmethic - complex' stamp: 'jmv 7/19/2012 11:15' prior: 16855743!
                    imaginary: imaginaryPart elementDivideBy: operandRealPart imaginary: operandImaginaryPart
	"The receiver and imaginaryPart conform a complex matrix.
	operandRealPart and operandImaginaryPart conform another complex matrix.
	fill the receiver (and imaginaryPart) with the result of complex division with operand, element by element.
	I.e., at each position of the matrix, compute (e+if) = (a+ib) / (c+id)

	| r1 i1 r2 i2 |
	r1 _ FloatMatrix fromArrayOfArrays: #(
		#( 1 2 3)
		#( 4 5 6)
		#( 1 2 3)).
	i1 _ FloatMatrix fromArrayOfArrays: #(
		#( 1 1 0)
		#( 0 0 1)
		#( 0 0 0)).
	r2 _ FloatMatrix fromArrayOfArrays: #(
		#( 2 4 6)
		#( 4 5 6)
		#( 1 2 3)).
	i2 _ FloatMatrix fromArrayOfArrays: #(
		#( 5 5 5)
		#( 5 5 5)
		#( 7 8 9)).
	Transcript clear.
	r1 print. i1 print.
	r1 imaginary: i1 elementMultiplyBy: r2 imaginary: i2.
	r1 print. i1 print.
	r1 imaginary: i1 elementDivideBy: r2 imaginary: i2.
	r1 print. i1 print
	"

	| a b c d e f operandSquaredNorm |
	1 to: height do: [ :i |
		1 to: width do: [ :j |
			a _ self i: i j: j.
			b _ imaginaryPart i: i j: j.
			c _ operandRealPart i: i j: j.
			d _ operandImaginaryPart i: i j: j.
			operandSquaredNorm _ c * c + (d * d).
			operandSquaredNorm = 0.0
				ifFalse: [
					e _ a * c + (b * d) / operandSquaredNorm.
					f _ b * c - (a * d) / operandSquaredNorm ]
				ifTrue: [ e _ f _ 0.0 ].
			self i: i j: j put: e.
			imaginaryPart i: i j: j put: f ]]! !
!FloatMatrix methodsFor: 'aritmethic - complex' stamp: 'jmv 7/19/2012 11:15' prior: 16855790!
                           imaginary: imaginaryPart elementDivideBy: operandRealPart imaginary: operandImaginaryPart threshold: threshold
	"The receiver and imaginaryPart conform a complex matrix.
	operandRealPart and operandImaginaryPart conform another complex matrix.
	fill the receiver (and imaginaryPart) with the result of complex division with operand, element by element.
	I.e., at each position of the matrix, compute (e+if) = (a+ib) / (c+id)

	| r1 i1 r2 i2 |
	r1 _ FloatMatrix fromArrayOfArrays: #(
		#( 1 2 3)
		#( 4 5 6)
		#( 1 2 3)).
	i1 _ FloatMatrix fromArrayOfArrays: #(
		#( 1 1 0)
		#( 0 0 1)
		#( 0 0 0)).
	r2 _ FloatMatrix fromArrayOfArrays: #(
		#( 2 4 6)
		#( 4 5 6)
		#( 1 2 3)).
	i2 _ FloatMatrix fromArrayOfArrays: #(
		#( 5 5 5)
		#( 5 5 5)
		#( 7 8 9)).
	Transcript clear.
	r1 print. i1 print.
	r1 imaginary: i1 elementMultiplyBy: r2 imaginary: i2.
	r1 print. i1 print.
	r1 imaginary: i1 elementDivideBy: r2 imaginary: i2.
	r1 print. i1 print
	"

	| a b c d e f operandSquaredNorm |
	1 to: height do: [ :i |
		1 to: width do: [ :j |
			a _ self i: i j: j.
			b _ imaginaryPart i: i j: j.
			c _ operandRealPart i: i j: j.
			d _ operandImaginaryPart i: i j: j.
			operandSquaredNorm _ c * c + (d * d).
			operandSquaredNorm >= threshold
				ifTrue: [
					e _ a * c + (b * d) / operandSquaredNorm.
					f _ b * c - (a * d) / operandSquaredNorm ]
				ifFalse: [ e _ f _ 0.0 ].
			self i: i j: j put: e.
			imaginaryPart i: i j: j put: f ]]! !
!FloatMatrix methodsFor: 'aritmethic - complex' stamp: 'jmv 7/19/2012 11:15' prior: 16855838!
                               imaginary: imaginaryPart elementMultiplyBy: operandRealPart imaginary: operandImaginaryPart
	"The receiver and imaginaryPart conform a complex matrix.
	operandRealPart and operandImaginaryPart conform another complex matrix.
	fill the receiver (and imaginaryPart) with the result of complex multiplication with operand, element by element.
	I.e., at each position of the matrix, compute (e+if) = (a+ib) * (c+id)"

	| a b c d e f |
	1 to: height do: [ :i |
		1 to: width do: [ :j |
			a _ self i: i j: j.
			b _ imaginaryPart i: i j: j.
			c _ operandRealPart i: i j: j.
			d _ operandImaginaryPart i: i j: j.
			e _ a * c - (b * d).
			f _ b * c + (a * d).
			self i: i j: j put: e.
			imaginaryPart i: i j: j put: f ]]! !
!FloatMatrix methodsFor: 'aritmethic - complex' stamp: 'jmv 7/19/2012 11:16' prior: 16855864!
               magnitudeWithImaginary: imaginaryPart
	"answer a new matrix"
	| result a b magnitude |
	result _ FloatMatrix newSize: self size.
	1 to: height do: [ :i |
		1 to: width do: [ :j |
			a _ self i: i j: j.
			b _ imaginaryPart i: i j: j.
			magnitude _ (a * a + (b * b)) sqrt.
			result i: i j: j put: magnitude ]].
	^result! !
!FloatBandMatrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 10:27' prior: 16855344!
     i: i j: j
	"Answer element at row i, column j"

	(self elementsIndexForI: i j: j)
		ifNotNil: [ :position | elements at: position ]
		ifNil: [ 0.0 ]! !
!FloatBandMatrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 10:26' prior: 16855352!
                 i: i j: j put: aNumber
	"Store aNumber as the element at row i, column j"

	(self elementsIndexForI: i j: j)
		ifNotNil: [ :position | elements at: position put: aNumber ]
		ifNil: [ self error: 'Can not store outside band' ]! !
!Rectangle methodsFor: 'testing' stamp: 'jmv 7/19/2012 12:30' prior: 16927216!
            isZero
	"Answer whether the receiver is zero"
	Transcript newLine.
	#isZero print.
	thisContext printStack: 5.
	self flag: #jmv. "is this method needed at all?"

	^origin isZero and:[corner isZero]! !

Number removeSelector: #isNonZero!

Number removeSelector: #isNonZero!

FloatBandMatrix removeSelector: #fillWithIdentity!

FloatBandMatrix removeSelector: #fillWithIdentity!

FloatMatrix removeSelector: #copy!

FloatMatrix removeSelector: #copy!

FloatMatrix removeSelector: #elements!

FloatMatrix removeSelector: #elements!

FloatMatrix removeSelector: #elementsIndexForI:j:!

FloatMatrix removeSelector: #elementsIndexForI:j:!

FloatMatrix removeSelector: #i:j:!

FloatMatrix removeSelector: #i:j:!

FloatMatrix removeSelector: #i:j:put:!

FloatMatrix removeSelector: #i:j:put:!

Matrix removeSelector: #conditionNumber!

Matrix removeSelector: #conditionNumber!

Matrix removeSelector: #eigenvaluesAndEigenvectors!

Matrix removeSelector: #eigenvaluesAndEigenvectors!

Matrix removeSelector: #eigenvaluesAndEigenvectorsByQR!

Matrix removeSelector: #eigenvaluesAndEigenvectorsByQR!

Matrix removeSelector: #eigenvaluesByQR!

Matrix removeSelector: #eigenvaluesByQR!

Matrix removeSelector: #hessembergSuperior!

Matrix removeSelector: #hessembergSuperior!

Matrix removeSelector: #isFirstSubdiagonalZero!

Matrix removeSelector: #isFirstSubdiagonalZero!

Matrix removeSelector: #linesLost!

Matrix removeSelector: #linesLost!

Matrix removeSelector: #norm!

Matrix removeSelector: #norm!

Matrix removeSelector: #norm2!

Matrix removeSelector: #norm2!

Matrix removeSelector: #norm2Squared!

Matrix removeSelector: #norm2Squared!

Matrix removeSelector: #preMultiplyByGivensRotationRowI:rowK:titaCosine:titaSine:!

Matrix removeSelector: #preMultiplyByGivensRotationRowI:rowK:titaCosine:titaSine:!

Matrix removeSelector: #round!

Matrix removeSelector: #round!

Matrix removeSelector: #rowsCloserToZero:!

Matrix removeSelector: #rowsCloserToZero:!

Matrix removeSelector: #storeHouseholderTransformOn:column:forQR:!

Matrix removeSelector: #storeHouseholderTransformOn:column:forQR:!

Matrix removeSelector: #storeQRDecompositionOfHessemberSuperiorOnQ:r:!

Matrix removeSelector: #storeQRDecompositionOfHessemberSuperiorOnQ:r:!

!classDefinition: #Matrix category: #LinearAlgebra!
Object subclass: #Matrix
	instanceVariableNames: 'width height elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

Object subclass: #Matrix
	instanceVariableNames: 'width height elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LinearAlgebra'!

Smalltalk removeClassNamed: #ObjectMatrix!

Smalltalk removeClassNamed: #ObjectMatrix!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1317-MatrixRefactoring-2-JuanVuletich-2012Jul19-12h43m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1317] on 20 July 2012 at 9:43:46 am'!
!FFT methodsFor: 'testing' stamp: 'jmv 7/19/2012 18:04' prior: 16847470!
                      plot: samples in: rect
	"Throw-away code just to check out a couple of examples"
	| min max x dx pen y |
	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.
	min _ 1.0e30.  max _ -1.0e30.
	samples do:
		[:v |
		min _ min min: v.
		max _ max max: v].
	pen _ Pen new.  pen up.
	x _ rect left.
	dx _ rect width asFloat / (samples size-1).
	samples do:
		[:v |
		y _ (max-v) / (max-min) * rect height asFloat.
		pen goto: x asInteger @ (rect top + y asInteger).
		pen down.
		x _ x + dx].
	max printString displayOn: Display at: (x+2) @ (rect top-9).
	min printString displayOn: Display at: (x+2) @ (rect bottom - 9)! !
!FFT methodsFor: 'testing' stamp: 'jmv 7/19/2012 18:04' prior: 16847492!
    plot: samples in: rect color: aColor min: min max: max
	"Throw-away code just to check out a couple of examples"
	| x dx pen y |
	pen _ Pen new.
	pen color: aColor.
	pen up.
	x _ rect left.
	dx _ rect width asFloat / (samples size-1).
	samples do: [ :v |
		y _ (max-v) / (max-min) * rect height asFloat.
		y _ y min: 1000.
		y _ y max: 0.
		pen goto: x asInteger @ (rect top + y asInteger).
		pen down.
		x _ x + dx].
	max printString displayOn: Display at: (x+2) @ (rect top-9).
	min printString displayOn: Display at: (x+2) @ (rect bottom - 9)! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 17:41' prior: 16885521!
             fillEndsWith1Derivative
	"Fill one row and one column at each end with such values that the derivative is that at the ends of the inner submatrix.
	If the size is less than 4 in any direction, meaning we don't have enough elements to compute the derivatives, do nothing.
	Note: We could make derivatives zero, meaning to copy the values."

	| m n third second first antepenultimate penultimate last |
	m _ self m. n _ self n.
	n >= 4 ifTrue: [
		2 to: m-1 do: [ :i |
			second _ self i: i j: 2. third _ self i: i j: 3.
			first _ second * 2-third.
			self i: i j: 1 put: first.
			antepenultimate _ self i: i j: n-2.
			penultimate _ self i: i j: n-1.
			last  _ penultimate * 2 - antepenultimate.
			self i: i j: n put: last ]].
	m >= 4 ifTrue: [
		1 to: n do: [ :j |
			second _ self i: 2 j: j. third _ self i: 3 j: j.
			first _ second * 2-third.
			self i: 1 j: j put: first.
			antepenultimate _ self i: m-2 j: j.
			penultimate _ self i: m-1 j: j.
			last  _ penultimate * 2 - antepenultimate.
			self i: m j: j put: last ]]! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 7/19/2012 17:42' prior: 16885555!
        fillEndsWith2Derivative2
	"Fill two rows and two columns at each end with such values that the second derivative is that at the ends of the inner submatrix.
	If the size is less than 7 in any direction, meaning we don't have enough elements to compute the derivatives, do nothing.
	Note: We could make derivatives zero, meaning to copy the values."

	| m n third fourth fifth second first fourthToEnd thirdToEnd antepenultimate penultimate last |
	m _ self m. n _ self n.
	n >= 7 ifTrue: [
		3 to: m-2 do: [ :i |
			third _ self i: i j: 3. fourth _ self i: i j: 4. fifth _ self i: i j: 5.
			second _ (third-fourth) * 3.0 + fifth.
			first _ (second-third) * 3.0 + fourth.
			self i: i j: 2 put: second.
			self i: i j: 1 put: first.
			fourthToEnd _ self i: i j: n-4.
			thirdToEnd _ self i: i j: n-3.
			antepenultimate _ self i: i j: n-2.
			penultimate _ (antepenultimate - thirdToEnd) * 3.0 + fourthToEnd.
			last _ (penultimate -antepenultimate) * 3.0 + thirdToEnd.
			self i: i j: n-1 put: penultimate.
			self i: i j: n put: last ]].
	m >= 7 ifTrue: [
		1 to: n do: [ :j |
			third _ self i: 3 j: j. fourth _ self i: 4 j: j. fifth _ self i: 5 j: j.
			second _ (third-fourth) * 3.0 + fifth.
			first _ (second-third) * 3.0 + fourth.
			self i: 2 j: j put: second.
			self i: 1 j: j put: first.
			fourthToEnd _ self i: m-4 j: j.
			thirdToEnd _ self i: m-3 j: j.
			antepenultimate _ self i: m-2 j: j.
			penultimate _ (antepenultimate - thirdToEnd) * 3.0 + fourthToEnd.
			last _ (penultimate -antepenultimate) * 3.0 + thirdToEnd.
			self i: m-1 j: j put: penultimate.
			self i: m j: j put: last ]]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1318-MinorTweaksInMatrixAndFFT-JuanVuletich-2012Jul20-09h43m-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 2:34:25 pm'!
!DropEvent methodsFor: 'accessing' stamp: 'jmv 12/11/2011 23:10'!
                            eventPosition
	^position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:42'!
       morphPosition
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"
	^ bounds topLeft! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:43'!
          morphPosition: aPoint
	"Change the position of this morph and and all of its submorphs."

	"Detesto el falso polimorfismo con streams. Ponerle otro nombre a esto!!
	Igual, todavia esta #position, el getter, que es igual de feo..."
	
	"
	VER SENDERS. Acomodar. el argumento es en coord del owner o del world?
	Convertir los senders a senders de #zzpositionInOwner: o #zzpositionInWorld
	Espero que pocos hablen en coordenadas del world!!
	"

	| delta |
	delta _ aPoint - bounds topLeft.
	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.
	self privateFullMoveBy: delta.

	"En realidad, quiero coordenadas relativas al owner!!"
"	position _ aPoint."

	self redrawNeeded
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!HaloMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:43'!
                        morphPosition: pos
	"Halos display imprefectly if their coordinates are non-integral
		-- especially the direction handles."

	^ super morphPosition: pos asIntegerPoint! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:44'!
                morphPosition: aPoint
	"Prevent moving a world (e.g. via HandMorph>>specialGesture:)"

	"for now, let's allow it and see what happens"

	self isWorldMorph ifFalse: [ ^super morphPosition: aPoint ].
	super morphPosition: aPoint.
	self viewBox ifNotNil: [ self viewBox: (aPoint extent: self viewBox extent) ]! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:44'!
      morphPosition: newPos
	super morphPosition: newPos.
	isCollapsed
		ifTrue: [ collapsedFrame _ bounds ]
		ifFalse: [ fullFrame _ bounds ]! !
!UserInputEvent methodsFor: 'accessing' stamp: 'jmv 12/11/2011 23:10'!
             eventPosition
	^position! !
!MouseEvent methodsFor: 'accessing' stamp: 'jmv 12/11/2011 23:12'!
 eventPosition
	"Answer the location of the cursor's hotspot when this event occured."
	^ position! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 12/12/2011 10:43' prior: 16779362!
      storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."

	| bufSize stereoBuffer reverseBytes  |
	self reset.
	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"
	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.
	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.

	'Storing audio...' displayProgressAt: World activeHand morphPosition
		from: 0 to: samplesToStore during: [:bar | | remaining out |
			remaining _ samplesToStore.
			[remaining > 0] whileTrue: [
				bar value: samplesToStore - remaining.
				stereoBuffer primFill: 0.  "clear the buffer"
				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.
				self isStereo
					ifTrue: [out _ stereoBuffer]
					ifFalse: [out _ stereoBuffer extractLeftChannel].
				reverseBytes ifTrue: [out reverseEndianness].
				(aBinaryStream isKindOf: StandardFileStream)
					ifTrue: [  "optimization for files: write sound buffer directly to file"
						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"
					ifFalse: [  "for non-file streams:"
						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].
				remaining _ remaining - bufSize]].
! !
!AutoCompleter methodsFor: 'menu morph' stamp: 'jmv 12/12/2011 10:43' prior: 16783264!
                   openCompletionMenu
	| theEditor |
	theEditor _ textMorph editor.
	position _ theEditor startIndex - 1.
	self closeMenu.
	self computeEntries.
	entries notEmpty
		ifTrue: [ 
			menuMorph _  AutoCompleterMorph 
				completer: self
				position: theEditor startBlock bottomLeft + textMorph morphPosition ]! !
!CodePackage methodsFor: 'testing' stamp: 'jmv 4/10/2012 14:22' prior: 16812459!
                             changeRecordForOverriddenMethod: aMethodReference
	| sourceFilesCopy method position |
	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.
	position := method filePosition.
	sourceFilesCopy := SourceFiles collect:
		[:x | x isNil ifTrue: [ nil ]
				ifFalse: [x readOnlyCopy]].
	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |
	method fileIndex = 0 ifTrue: [^ nil].
	file := sourceFilesCopy at: method fileIndex.
	[position notNil & file notNil] whileTrue: [
		file position: (0 max: position-150).  "Skip back to before the preamble"
		[file position < (position-1)]  "then pick it up from the front"
			whileTrue: [ chunk _ file nextChunk ].

		"Preamble is likely a linked method preamble, if we're in
			a changes file (not the sources file).  Try to parse it
			for prior source position and file index"
		prevPos := nil.
		stamp := ''.
		(chunk findString: 'methodsFor:' startingAt: 1) > 0
			ifTrue: [tokens := Scanner new scanTokens: chunk]
			ifFalse: [tokens := #()  "ie cant be back ref"].
		((tokens size between: 7 and: 8)
			and: [(tokens at: tokens size-5) = #methodsFor:])
			ifTrue:
				[(tokens at: tokens size-3) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp := tokens at: tokens size-2.
						prevPos := tokens last.
						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.
						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]
				ifFalse: ["Old format gives no stamp; prior pointer in two parts"
						prevPos := tokens at: tokens size-2.
						prevFileIndex := tokens last].
				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].
		((tokens size between: 5 and: 6)
			and: [(tokens at: tokens size-3) = #methodsFor:])
			ifTrue:
				[(tokens at: tokens size-1) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp := tokens at: tokens size]].
		methodCategory := (tokens after: #methodsFor:) ifNil: ['as yet unclassifed'].
		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:
			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].
			^ ChangeRecord new file: file position: position type: #method
						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].
		position := prevPos.
		prevPos notNil ifTrue: [
			file _ sourceFilesCopy at: prevFileIndex]].
		^ nil]
			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]
	! !
!DropEvent methodsFor: 'printing' stamp: 'jmv 12/11/2011 23:32' prior: 16841192!
                          printOn: aStream

	aStream nextPut: $[.
	aStream nextPutAll: self eventPosition printString; space.
	aStream nextPutAll: self type.
	aStream nextPut: $].! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:49' prior: 16896791!
             aboutToBeGrabbedBy: aHand
	"The receiver is being grabbed by a hand.
	Perform necessary adjustments (if any) and return the actual morph
	that should be added to the hand."
	self formerOwner: owner.
	self formerPosition: self morphPosition.
	^self "Grab me"! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:52' prior: 16896972!
     slideBackToFormerSituation: evt 
	| slideForm formerOwner formerPosition aWorld startPoint endPoint |
	formerOwner _ self formerOwner.
	formerPosition _ self formerPosition.
	aWorld _ evt hand world.
	slideForm _ self imageForm offset: 0 @ 0.
	startPoint _ evt hand fullBounds origin.
	endPoint _ formerPosition.
	owner removeMorph: self.
	aWorld displayWorld.
	slideForm 
		slideFrom: startPoint
		to: endPoint
		nSteps: 12
		delay: 15.
	formerOwner addMorph: self.
	self morphPosition: formerPosition.
	self justDroppedInto: formerOwner event: evt! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/11/2011 23:28' prior: 16897556!
 handleMouseOver: anEvent
	"System level event handling."
	anEvent hand mouseFocus == self ifTrue:[
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: anEvent eventPosition event: anEvent) ifFalse:[^self]].
	anEvent hand noticeMouseOver: self event: anEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/11/2011 23:29' prior: 16897704!
                             rejectDropEvent: anEvent
	"This hook allows the receiver to repel a drop operation currently executed. The method is called prior to checking children so the receiver must validate that the event was really designated for it.
	Note that the ordering of the tests below is designed to avoid a (possibly expensive) #fullContainsPoint: test. If the receiver doesn't want to repel the morph anyways we don't need to check after all."
	(self repelsMorph: anEvent contents event: anEvent) ifFalse:[^self]. "not repelled"
	(self fullContainsPoint: anEvent eventPosition) ifFalse:[^self]. "not for me"
	"Throw it away"
	anEvent wasHandled: true.
	anEvent contents rejectDropMorphEvent: anEvent.! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:49' prior: 16897802!
 align: aPoint1 with: aPoint2
	"Translate by aPoint2 - aPoint1."

	^ self morphPosition: self morphPosition + (aPoint2 - aPoint1)! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:52' prior: 16897828!
               bounds: newBounds
	| oldExtent newExtent |
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPosition: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPosition: newBounds topLeft; extent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self extent: newExtent; morphPosition: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 12/12/2011 10:52' prior: 16897925!
                       referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	self morphPosition: aPoint - (bounds extent // 2)! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/12/2011 10:49' prior: 16898093!
 editBalloonHelpContent: aString
	| reply |
	reply _ FillInTheBlank
		multiLineRequest: 'Edit the balloon help text for ' , (self printStringLimitedTo: 40)
		centerAt: self world activeHand morphPosition
		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])
		answerHeight: 200.
	reply ifNil: [^ self].  "User cancelled out of the dialog"
	(reply isEmpty or: [reply asString = self noHelpString])
		ifTrue: [self setBalloonText: nil]
		ifFalse: [self setBalloonText: reply]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/11/2011 23:29' prior: 16898232!
                     transferHalo: event from: formerHaloOwner
	"Progressively transfer the halo to the next likely recipient"
	| w |

	"Never transfer halo to top-most world"
	(self isWorldMorph and:[owner isNil]) ifFalse: [
		(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 
			ifTrue:[^self addHalo: event from: formerHaloOwner]].

	event shiftPressed ifTrue: [
		"Pass it outwards"
		owner ifNotNil:[^owner transferHalo: event from: formerHaloOwner].
		"We're at the top level; throw the event back in to find recipient"
		formerHaloOwner removeHalo.
		^self processEvent: event copy resetHandlerFields.
	].
	self submorphsDo: [ :m |
		(m fullContainsPoint: event eventPosition) 
			ifTrue:[^m transferHalo: event from: formerHaloOwner].
	].
	"We're at the bottom most level; throw the event back up to the root to find recipient"
	formerHaloOwner removeHalo.
	(w _ self world) ifNil: [ ^self ].
	^w processEvent: event copy resetHandlerFields.
! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:49' prior: 16898352!
 openInWorld: aWorld
	"Add this morph to the requested World."
	(aWorld viewBox origin ~= (0@0) and: [self morphPosition = (0@0)]) ifTrue: [
		self morphPosition: aWorld viewBox origin].
	aWorld addMorph: self.
	aWorld startSteppingSubmorphsOf: self! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 12/12/2011 10:49' prior: 16898838!
                   changeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand
	"Put up a color picker for changing some kind of color.  May be modal or modeless, depending on #modalColorPickers setting"
	self flag: #arNote. "Simplify this due to anObject == self for almost all cases"
	^ ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: aHand;
		target: anObject;
		selector: aSymbol;
		originalColor: aColor;
		putUpFor: anObject near: ((anObject is: #Morph)
					ifTrue: [ Rectangle center: self morphPosition extent: 20 ]
					ifFalse: [ anObject == self world
								ifTrue: [ anObject viewBox bottomLeft + (20@-20) extent: 200 ]
								ifFalse: [ anObject fullBounds ]]);
		yourself! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/12/2011 10:51' prior: 16899455!
                               addMorphFront: aMorph fromWorldPosition: aPoint

	self addMorphFront: aMorph.
	aMorph morphPosition: aPoint! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/12/2011 10:49' prior: 16899461!
                        addMorphFrontFromWorldPosition: aMorph
	^self addMorphFront: aMorph fromWorldPosition: aMorph morphPosition.! !
!Morph methodsFor: 'testing' stamp: 'jmv 12/11/2011 23:36' prior: 16899658!
    shouldDropOnMouseUp
	| former |
	"
	former _ self formerPosition ifNil:[^false].
	^(former dist: self zzposition) > 10
	"^true! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:51' prior: 16783581!
                              setCompleter: anAutoCompleter position: aPoint 
	completer _ anAutoCompleter.
	self morphPosition: aPoint.
	self resetMenu.
	self openInWorld! !
!AutoCompleterMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:13' prior: 16783707!
               mouseUp: evt
	(self containsPoint: evt eventPosition)
		ifTrue: [
			self selected: 
				((evt eventPosition y - bounds top // self class itemHeight) + 
					self firstVisible).
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!FillInTheBlankMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:14' prior: 16852801!
                           mouseDown: evt
	(self containsPoint: evt eventPosition) ifFalse:[^ Beeper beep]. "sent in response to outside modal click"
	evt hand grabMorph: self. "allow repositioning"! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 10:45' prior: 16852995!
       request: queryString
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph request: 'What is your favorite color?'"

	^ self
		request: queryString
		initialAnswer: ''
		centerAt: World activeHand morphPosition! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 10:45' prior: 16853010!
              request: queryString initialAnswer: defaultAnswer 
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'"

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: World activeHand morphPosition! !
!HaloMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:45' prior: 16863637!
        startDrag: evt with: dragHandle
	"Drag my target without removing it from its owner."

	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dragHandle.
	positionOffset _ dragHandle referencePosition - target morphPosition! !
!HaloMorph methodsFor: 'event handling' stamp: 'jmv 12/12/2011 10:51' prior: 16863647!
       mouseMove: evt
	"Drag our target around"
	| thePoint |
	thePoint _ evt eventPosition - positionOffset.
	target morphPosition: thePoint! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 12/12/2011 10:45' prior: 16863654!
       popUpFor: aMorph event: evt
	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."

	| hand anEvent |
	self flag: #workAround.	"We should really have some event/hand here..."
	anEvent _ evt
				ifNil: [
					hand _ aMorph world activeHand.
					hand ifNil: [ hand _ aMorph world firstHand ]. 
					hand lastEvent ]
				ifNotNil: [
					hand _ evt hand.
					evt ].
	self target: aMorph.
	hand halo: self.
	hand world addMorphFront: self.
	positionOffset _ anEvent eventPosition - aMorph morphPosition.
	self startStepping! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 12/11/2011 23:27' prior: 16863687!
            containsPoint: aPoint event: anEvent
	"mouseButton3 events are handled by the halo"
	(anEvent isMouse and: [ anEvent isMouseDown and: [ anEvent mouseButton3Pressed ]])
		ifFalse:  [^super containsPoint: aPoint event: anEvent ].
	^self fullBounds containsPoint: anEvent eventPosition! !
!HaloMorph methodsFor: 'meta-actions' stamp: 'jmv 12/12/2011 10:45' prior: 16863915!
             mouseButton3Down: event
	"Transfer the halo to the next likely recipient"
	target ifNil:[^self delete].
	event hand obtainHalo: self.
	positionOffset _ event eventPosition - target morphPosition.
	"wait for drags or transfer"
	event hand 
		waitForClicksOrDrag: self 
		event: event
		clkSel: #transferHalo:
		dblClkSel: nil! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 12/12/2011 10:51' prior: 16863927!
       step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target bounds]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = bounds
		ifTrue: [^ self].
	newBounds extent = bounds extent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating
		ifFalse: [submorphs size > 1
				ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self bounds: newBounds! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/30/2011 23:40' prior: 16863963!
addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse aMorph |
	aPoint := self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	handle := HaloHandleMorph new.
	self addMorph: handle.
	handle 
		bounds: (Rectangle center: aPoint extent: HandleSize asPoint);
		color: (colorToUse := Color colorFrom: handleSpec color).
	(iconName := handleSpec iconSymbol) ifNotNil: [
			| form |
			form := Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				aMorph _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				aMorph morphPosition: aPoint - (form extent // 2).
				handle addMorphFront: aMorph.
				]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864040!
                    addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w |
	w := self world ifNil: [target world].
	nameMorph := StringMorph contents: aString.
	nameMorph color: Color magenta.
	namePosition := outerRectangle bottomCenter 
				- ((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph 
		morphPosition: (namePosition min: w viewBox bottomRight - nameMorph extent y + 5).
	self addMorph: (RectangleMorph new
		bounds: (nameMorph bounds outsetBy: 2);
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9)).
	self addMorph: nameMorph.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864096!
        doDrag: evt with: dragHandle
	| thePoint |
	evt hand obtainHalo: self.
	thePoint _ evt eventPosition - positionOffset.
	target morphPosition: thePoint! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864126!
                      doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target extent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle extent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:15' prior: 16864158!
                       doRecolor: evt with: aHandle
	"The mouse went down in the 'recolor' halo handle.  Allow the user to change the color of the innerTarget"

	evt hand obtainHalo: self.
	(aHandle containsPoint: evt eventPosition)
		ifFalse: [  "only do it if mouse still in handle on mouse up"
			self delete.
			target addHalo: evt]
		ifTrue: [
			innerTarget changeColor]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864171!
           doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle extent // 2).
	self someSubmorphPositionOrExtentChanged! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:15' prior: 16864211!
                    maybeCollapse: evt with: collapseHandle 
	"Ask hand to collapse my target if mouse comes up in it."

	evt hand obtainHalo: self.
	self delete.
	(collapseHandle containsPoint: evt eventPosition) 
		ifFalse: [
			target addHalo: evt ]
		ifTrue: [
			target collapse ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864222!
   maybeDismiss: evt with: dismissHandle
	"Ask hand to dismiss my target if mouse comes up in it."

	evt hand obtainHalo: self.
	(dismissHandle containsPoint: evt eventPosition)
		ifFalse: [
			self delete.
			target addHalo: evt]
		ifTrue: [
			target resistsRemoval ifTrue: [
				(PopUpMenu
					confirm: 'Really throw this away'
					trueChoice: 'Yes'
					falseChoice: 'Um, no, let me reconsider') ifFalse: [^ self]].

			self delete.
			target dismissViaHalo]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864285!
                               setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle containsPoint: evt eventPosition)
		ifFalse: [ Color red muchLighter ]
		ifTrue: [ Color lightGray ].
	dismissHandle color: colorToUse! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864298!
  startGrow: evt with: growHandle
	"Initialize resizing of my target.  Launch a command representing it, to support Undo"

	| botRt |
	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.
	botRt _ target bounds bottomRight.
	positionOffset _ (self world viewBox containsPoint: botRt)
		ifTrue: [evt eventPosition - botRt]
		ifFalse: [0@0]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864311!
                startRot: evt with: rotHandle
	"Initialize rotation of my target if it is rotatable.  Launch a command object to represent the action"

	self obtainHaloForEvent: evt andRemoveAllHandlesBut: rotHandle.
	growingOrRotating _ true.

	self removeAllHandlesBut: rotHandle.  "remove all other handles"
	angleOffset _ evt eventPosition - target referencePosition.
	angleOffset _ Point
			r: angleOffset r
			degrees: angleOffset degrees - target rotationDegrees

! !
!HandMorph methodsFor: 'cursor' stamp: 'jmv 12/12/2011 10:46' prior: 16864626!
      cursorBounds

	^self morphPosition extent: CursorWithMask normal extent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 12/12/2011 10:46' prior: 16865010!
                           handleEvent: anEvent
	| evt |
	owner ifNil: [ ^ self ].
	evt _ anEvent.
	evt isMouseOver ifTrue: [ ^ self sendMouseEvent: evt ].

	"Notify listeners"
	self sendListenEvent: evt to: self eventListeners.
	
	evt isWindowEvent ifTrue: [
		self sendEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent ].

	evt isKeyboard ifTrue: [
		self sendListenEvent: evt to: self keyboardListeners.
		self sendKeyboardEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	evt isDropEvent ifTrue: [
		self sendEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	evt isMouse ifTrue: [
		self sendListenEvent: evt to: self mouseListeners.
		lastMouseEvent _ evt.	
		lastMouseEventTime _ Time millisecondClockValue].

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: evt from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	evt isMove ifTrue: [
		self morphPosition: evt eventPosition.
		self sendMouseEvent: evt.
	] ifFalse: [
		"Issue a synthetic move event if we're not at the position of the event"
		evt eventPosition = self morphPosition ifFalse: [ self moveToEvent: evt ].
		"Drop submorphs on button events"
		self hasSubmorphs
			ifTrue: [ self dropMorphs: evt ]
			ifFalse: [ self sendMouseEvent: evt ].
	].
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 12/12/2011 10:46' prior: 16865120!
           newMouseFocus: aMorph event: event 
	aMorph ifNotNil: [ 
		targetOffset _ event eventPosition - aMorph morphPosition].
	^self newMouseFocus: aMorph! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/12/2011 10:46' prior: 16865187!
               attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	delta _ m bounds extent // 2.
	m morphPosition: (self morphPosition - delta).
	m formerPosition: m morphPosition.
	targetOffset _ m morphPosition - self morphPosition.
	self addMorphBack: m.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/12/2011 10:46' prior: 16865201!
                          dropMorph: aMorph event: anEvent
	"Drop the given morph which was carried by the hand"
	| event |
	(anEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue:[^self].

	"Note: For robustness in drag and drop handling we remove the morph BEFORE we drop him, but we keep his owner set to the hand. This prevents system lockups when there is a problem in drop handling (for example if there's an error in #wantsToBeDroppedInto:). THIS TECHNIQUE IS NOT RECOMMENDED FOR CASUAL USE."
	self privateRemove: aMorph.
	aMorph privateOwner: self.

	event _ DropEvent new setPosition: self morphPosition contents: aMorph hand: self.
	self sendEvent: event.
	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].
	aMorph owner == self ifTrue:[aMorph delete].
	self mouseOverHandler processMouseOver: anEvent.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/12/2011 10:46' prior: 16865237!
                          grabMorph: aMorph from: formerOwner
	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."

	self releaseMouseFocus. "Break focus"
	"And compute distance from hand's position"
	targetOffset _ aMorph morphPosition - self morphPosition.
	self addMorphBack: aMorph.
	aMorph justGrabbedFrom: formerOwner.! !
!HandMorph methodsFor: 'paste buffer' stamp: 'jmv 12/12/2011 10:47' prior: 16865483!
  pasteMorph

	| pastee |
	pastee _ Clipboard retrieveMorph.
	pastee ifNil: [^ self inform: 'Nothing to paste.'].
	self attachMorph: pastee.
	pastee align: pastee referencePosition with: self morphPosition
! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 12/12/2011 10:46' prior: 16865496!
                         generateKeyboardEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [stamp _ Time millisecondClockValue].
	(evtBuf sixth <= 0 or: [
		(keyValue _ (Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth)) isNil ])
			ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue].
	pressType = EventSensor eventKeyUp ifTrue: [type _ #keyUp].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [		"Control key pressed"
			keyValue < 27 ifTrue: [
				
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [		"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ 	"If Equal, Ctrl-alphabetic in Windows => do translate"
							lastKeyDownValue < 47 ]) ifTrue: [		"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifFalse: [ keyValue + 96 ]	"shift not pressed: conver to lowercase letter"
							ifTrue: [ keyValue + 64 ]].	"shift pressed: conver to uppercase letter"
					]
				].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [
				modifiers _ modifiers bitOr: 8 ]
			]].
	buttons _ modifiers bitShift: 3.
	^KeyboardEvent new 
		setType: type
		buttons: buttons
		position: self morphPosition
		keyValue: keyValue
		hand: self
		stamp: stamp! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 12/12/2011 10:46' prior: 16865642!
             moveToEvent: anEvent
	"Issue a mouse move event to make the receiver appear at the given position"
	self handleEvent: (MouseMoveEvent new
		setType: #mouseMove 
		startPoint: self morphPosition 
		endPoint: anEvent eventPosition 
		trail: (Array with: self morphPosition with: anEvent eventPosition)
		buttons: anEvent buttons
		hand: self
		stamp: anEvent timeStamp)! !
!HandleMorph methodsFor: 'event handling' stamp: 'jmv 4/10/2012 14:29' prior: 16865778!
                     keyStroke: evt
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ evt keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - (1@0) ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + (1@0) ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - (0@1) ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + (0@1) ].
	"Special case for return"
	evt isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:47' prior: 16867371!
                              popUpForHand: aHand
	"Pop up the receiver as balloon help for the given hand"

	| xcess |
	(contents isNil or: [ contents isEmpty ]) ifTrue: [ ^self ].
	self morphPosition: aHand morphPosition + (-6@20).
	xcess _ bounds right - aHand world bounds right.
	xcess > 0 ifTrue: [
		self morphPosition: self morphPosition - (xcess@0) ].
	aHand world addMorphFront: self.
	aHand balloonHelp: self! !
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:17' prior: 16870032!
  enterClickableRegion: evt
	| index isLink |
	evt hand hasSubmorphs ifTrue: [ ^self ].
	paragraph ifNotNil:[
		index _ (paragraph characterBlockAtPoint: evt eventPosition) stringIndex.
		isLink _ (model actualContents attributesAt: index) 
					anySatisfy: [ :attr | attr mayActOnClick ].
		isLink ifTrue: [ Cursor webLink show ] ifFalse: [ Cursor normal show ]]! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:17' prior: 16870178!
                       mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt translatedBy: bounds topLeft negated)].
	(evt eventPosition y between: owner bounds top and: owner bounds bottom) ifFalse: [
		WorldState addDeferredUIMessage: [
			owner scrollSelectionIntoView: evt ]
	]! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:47' prior: 16879765!
            handPoint
	^ hand morphPosition adhereTo: owner bounds! !
!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 12/12/2011 10:47' prior: 16879781!
          step
	"got the #mouseLeave: message"
	| p |
	hand ifNil: [
		indicator ifNotNil: [
			indicator delete.
			indicator _ nil ].
		Cursor currentCursor == self cursor ifTrue: [
			Cursor normal show ].
		^self stopStepping ].

	"hasn't got the #mouseLeave: message (yet)"
	p _ self handPoint.
	hand lastEvent mouseButton1Pressed
		ifTrue: [
			indicator
				ifNil: [ self adjustOwnerAt: p ]
				ifNotNil: [ self adjustIndicatorAt: p ]]
		ifFalse: [
			indicator ifNotNil: [
				indicator delete.
				indicator _ nil.
				self adjustOwnerAt: p ].
			"If the button was unpressed outside the morph (can happen if you try to go outside container),
			we might not get the #mouseLeave: message"
			(self containsPoint: hand morphPosition) ifFalse: [
				hand _ nil.
				Cursor normal show.
				self stopStepping ]]! !
!LayoutAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 12/12/2011 10:47' prior: 16879814!
                        adjustIndicatorAt: aPoint
	owner direction = #vertical
		ifTrue: [
			indicator morphPosition: indicator morphPosition x @ (aPoint y-(indicator height//2)) ]
		ifFalse: [
			indicator morphPosition: (aPoint x-(indicator width//2)) @ indicator morphPosition y ]! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 12/12/2011 10:48' prior: 50338976!
      chooseMagnification: evt
	| handle origin aHand currentMag |
	currentMag _ magnification.
	aHand _ evt ifNil: [ self world activeHand ] ifNotNil: [evt hand].
	origin _ aHand morphPosition y.
	handle _ HandleMorph new forEachPointDo:
		[ :newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag ].
	aHand attachMorph: handle.
	handle startStepping.
	self redrawNeeded. ! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 12/12/2011 10:48' prior: 16885245!
    sourcePoint
	"If we are being dragged use our center, otherwise use pointer position"
	^ (trackPointer not or: [owner notNil and: [owner is: #HandMorph]])
		ifTrue: [ bounds center ]
		ifFalse: [ self activeHand morphPosition ]! !
!MagnifierMorph methodsFor: 'round view' stamp: 'jmv 12/11/2011 23:35' prior: 16885274!
 toggleRoundness
	| |
"	w _ self world.
	self isRound
		ifTrue: [owner delete.
				w addMorph: self]
		ifFalse: [sm _ ScreeningMorph new position: self zzposition.
				sm addMorph: self.
				sm addMorph: (EllipseMorph newBounds: self bounds).
				w addMorph: sm]
			"! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:51' prior: 16886778!
                            contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	marker morphPosition: bounds left @ (bounds top + 2).
	self addMorphFront: marker! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16886907!
                      activateOwnerMenu: evt
	"Activate our owner menu; e.g., pass control to it"
	owner ifNil:[^false]. "not applicable"
	(owner fullContainsPoint: evt eventPosition) ifFalse:[^false].
	owner activate: evt.
	^true! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16886916!
                         activateSubmenu: evt
	"Activate our submenu; e.g., pass control to it"
	subMenu ifNil:[^false]. "not applicable"
	(subMenu fullContainsPoint: evt eventPosition) ifFalse:[^false].
	subMenu activate: evt.
	self removeAlarm: #deselectTimeOut:.
	^true! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 4/10/2012 14:30' prior: 16887473!
                 addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s p w |
	
	titleMorph _ RectangleMorph new.
	self setTitleParametersFor: titleMorph.
	p _ titleMorph morphPosition + (8@2).
	aString asString linesDo: [ :line | 
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		s morphPosition: p.
		titleMorph addMorphBack: s.
		p _ p + (0@(s height+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each width ].
	titleMorph height: p y; width: w + 8.
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/12/2011 10:49' prior: 16887634!
 popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |

	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil:[self items first]) morphPosition - self morphPosition.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.
		(delta x = 0 or: [ mustFit ]) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			sourceItem owner owner addMorphFront: self.
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last  - (self width @ 0) value: false;
		value: rightOrLeftPoint first value: true

	! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/12/2011 10:49' prior: 16887698!
                            popUpForHand: hand in: aWorld
	| p |
	"Present this menu under control of the given hand."

	p _ hand morphPosition truncated.
	^self popUpAt: p forHand: hand in: aWorld
! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/12/2011 10:49' prior: 16887712!
  popUpInWorld: aWorld
	"Present this menu under control of the given hand."
	^self
		popUpAt: aWorld activeHand morphPosition
		forHand: aWorld activeHand
		in: aWorld
! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16887796!
      mouseDown: evt
	"Handle a mouse down event."
	(stayUp or:[self fullContainsPoint: evt eventPosition]) 
		ifFalse:[^self deleteIfPopUp: evt]. "click outside"
	self isSticky ifTrue: [^self].
	"Grab the menu and drag it to some other place"
	evt hand grabMorph: self.! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16887807!
     mouseUp: evt
	"Handle a mouse up event.
	Note: This might be sent from a modal shell."
	(self fullContainsPoint: evt eventPosition) ifFalse:[
		"Mouse up outside. Release eventual focus and delete if pop up."
		evt hand releaseMouseFocus: self.
		^self deleteIfPopUp: evt].
	stayUp ifFalse:[
		"Still in pop-up transition; keep focus"
		evt hand newMouseFocus: self].! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 12/12/2011 10:48' prior: 16887856!
                    displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m isKindOf: MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		feedbackMorph morphPosition: self morphPosition - (0@20).
		self
			 addLine;
			 addMorphBack: feedbackMorph lock.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self submorphs last delete.
		self removeProperty: #feedbackMorph ].
	matches size = 1 ifTrue: [
		self
			selectItem: matches first
			event: evt ].! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 12/12/2011 10:51' prior: 16888036!
                        sightTarget: event 
	| bullseye menu newTarget |
	owner
		ifNil: [^ self ].
	bullseye _ Point fromUserWithCursor: Cursor target.
	ActiveHand morphPosition: bullseye.
	menu _ CustomMenu new.
	(owner morphsAt: bullseye) do: [ :m |
		menu add: m printString action: m ].
	menu title: self printString, ' targets... '.
	newTarget _ menu startUp.
	newTarget
		ifNil: [^ self].
	self target: newTarget! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 12/12/2011 10:48' prior: 16888084!
                           invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu"

	^ self invokeModalAt: ActiveHand morphPosition in: ActiveWorld allowKeyboard: allowKeyboardControl! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16888140!
             adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each width])].

	w _ w + 4.
	tl _ bounds topLeft.
	p _ tl + 5.
	submorphs do: [ :m |
		m width: w.
		m morphPosition: p.
		p _ m bounds bottomLeft +(0@1) ].
	
	self extent: submorphs last bounds bottomRight - tl + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:49' prior: 16888172!
     positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub height ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	bounds right > aWorld world bounds right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ bounds amountToTranslateWithin:
		(aWorld world bounds withHeight: ((aWorld world bounds height - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!MenuMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:51' prior: 16888218!
         moveRight: aNumber
	self morphPosition: ((aNumber - bounds width) @ bounds top)! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 12/12/2011 10:48' prior: 16884746!
                         informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ ActiveWorld.
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph width: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 12/11/2011 23:29' prior: 16900281!
                      dispatchDefault: anEvent with: aMorph
	"Dispatch the given event. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside |
	"See if we're fully outside aMorphs bounds"
	(aMorph fullBounds containsPoint: anEvent eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: anEvent eventPosition event: anEvent ].
	inside ifTrue: [ ^aMorph handleEvent: anEvent ].
	^ #rejected! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 12/11/2011 23:31' prior: 16900308!
                   dispatchDropEvent: anEvent with: aMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside |

	"Try to get out quickly"
	(aMorph fullBounds containsPoint: anEvent eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: anEvent.
	anEvent wasHandled ifTrue:[^self].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: anEvent eventPosition event: anEvent ].
	inside ifTrue: [ ^aMorph handleEvent: anEvent ].
	^#rejected! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 12/11/2011 23:31' prior: 16900369!
      dispatchMouseDown: anEvent with: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
"
	| globalPt handler inside lastHandler |
	"Try to get out quickly"
	globalPt _ anEvent eventPosition.
	(aMorph fullBounds containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ anEvent handler. "in case the mouse wasn't even in the receiver"
	handler _ aMorph handlerForMouseDown: anEvent.
	handler ifNotNil: [ anEvent handler: handler ].

	"Now give our submorphs a chance to handle the event"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				"Some child did contain the point so we're part of the top-most chain."
				inside _ true.
			]]].

	(inside or: [ aMorph containsPoint: anEvent eventPosition event: anEvent ]) ifTrue:[
		"Receiver is in the top-most unlocked, visible chain."
		handler ifNotNil: [ handler handleEvent: anEvent ].
		"Note: Re-installing the handler is not really necessary but good style."
		anEvent handler: lastHandler.
		^self ].

	"Mouse was not on receiver nor any of its children"
	anEvent handler: lastHandler.
	^#rejected! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 12/12/2011 10:52' prior: 16900611!
                    placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph width)@
				(lineY+ line baseline - anchoredFormOrMorph height)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph width @ (destY + line baseline - anchoredFormOrMorph height)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 12/30/2011 23:41' prior: 16900948!
                            handleEvent: evt from: aHand
	"Process the given mouse event to detect a click, double-click, or drag.
	Return true if the event should be processed by the sender, false if it shouldn't.
	NOTE: This method heavily relies on getting *all* mouse button events."

	| timedOut distance |
	timedOut _ (evt timeStamp - lastClickDown timeStamp) > DoubleClickTimeout.
	distance _ (evt eventPosition - lastClickDown eventPosition) r.
	"Real action dispatch might be done after the triggering event, for example, because of waiting for timeout.
	So, count the button downs and ups(clicks), to be processed, maybe later, maybe in a mouseMove..."
	evt isMouseDown ifTrue: [
		lastClickDown _ evt.
		buttonDownCount _ buttonDownCount + 1 ].
	evt isMouseUp ifTrue: [
		buttonUpCount _ buttonUpCount + 1 ].

	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."
	(buttonDownCount = 1 and: [ buttonUpCount = 0]) ifTrue: [
		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [
			aHand dontWaitForMoreClicks.
			clickClient mouseButton2Activity.
			^ false ].
		"If we have already moved, then it won't be a double or triple click... why wait?"
		distance > 0 ifTrue: [
			aHand dontWaitForMoreClicks.
			self click.
			^ false ]].

	"If we're over triple click, or timed out, or mouse moved, don't allow more clicks."
	(buttonDownCount = 4 or: [ timedOut or: [ distance > 0 ]]) ifTrue: [
		aHand dontWaitForMoreClicks.
		^ false ].

	"Simple click."
	(buttonDownCount = 1 and: [ buttonUpCount = 1 ]) ifTrue: [
		self click ].

	"Click & hold"
	(buttonDownCount = 2 and: [ buttonUpCount = 1]) ifTrue: [
		self clickAndAHalf ].

	"Double click."
	(buttonDownCount = 2 and: [ buttonUpCount = 2]) ifTrue: [
		self doubleClick ].

	"Double click & hold."
	(buttonDownCount = 3 and: [ buttonUpCount = 2]) ifTrue: [
		self doubleClickAndHalf ].

	"Triple click"
	(buttonDownCount = 3 and: [ buttonUpCount = 3]) ifTrue: [
		self tripleClick ].

	"This means: if a mouseDown, then don't further process this event (so we can turn it into a double or triple click on next buttonUp)"
	^ evt isMouseDown! !
!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:42' prior: 16906472!
               mouseDown: event
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	event hand newKeyboardFocus: self.

	self handleInteraction: [
		self editor mouseDown: event index: (self characterIndexAtPoint: event eventPosition) ].

	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: #clickAndHalf:
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:42' prior: 16906497!
        mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self].
	self handleInteraction: [
		self editor mouseMove: evt index: (self characterIndexAtPoint: evt eventPosition) ]! !
!Parser methodsFor: 'public access' stamp: 'jmv 12/11/2011 22:42' prior: 16911313!
                              parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock
	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	| methNode repeatNeeded myStream s p |
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		p _ myStream position.
		s _ myStream upToEnd.
		myStream position: p.
		self encoder init: class context: ctxt notifying: self.
		self init: myStream notifying: req failBlock: [
			^ aBlock value ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern context: ctxt ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ sourceStreamGetter notNil 	"Cuis specific. Do not remove!!"
					ifTrue: [ requestor perform: sourceStreamGetter ]
					ifFalse: [ ReadStream on: requestor text string ]].
		repeatNeeded
	] whileTrue: [
		encoder _ self encoder class new ].
	methNode sourceText: s.
	^ methNode! !
!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:52' prior: 16911627!
                 acceptDroppingMorph: dropped event: evt 
	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"

	| aMorph |
	aMorph := self morphToDropFrom: dropped.
	self isWorldMorph 
		ifTrue: [	"Add the given morph to this world and start stepping it if it wants to be."

			self addMorphFront: aMorph.
			(aMorph fullBounds intersects: self viewBox) 
				ifFalse: [
					Beeper beep.
					aMorph morphPosition: bounds center]]
		ifFalse: [super acceptDroppingMorph: aMorph event: evt].
	aMorph submorphsDo: [ :m | (m isKindOf: HaloMorph) ifTrue: [ m delete ]].
	self world startSteppingSubmorphsOf: aMorph! !
!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:30' prior: 16911698!
         morphToGrab: event
	"Return the morph to grab from a mouse down event. If none, return nil."
	self submorphsDo: [ :m |
		((m rejectsEvent: event) not and:[m fullContainsPoint: event eventPosition]) ifTrue:[^m].
	].
	^nil! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/12/2011 10:52' prior: 16912032!
       viewBox: newViewBox
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	super morphPosition: newViewBox topLeft.
	fullBounds _ bounds _ newViewBox.! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/12/2011 10:52' prior: 16912372!
                     addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.
	delta _ trialRect amountToTranslateWithin: bounds.
	aMorph morphPosition: trialRect origin + delta.
	self addMorph: aMorph.
! !
!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:17' prior: 16913714!
            mouseUp: evt
	isPressed _ false.
	mouseIsOver _ false.
	(actWhen == #buttonUp and: [self containsPoint: evt eventPosition])
		ifTrue: [ self performAction ].
	self redrawNeeded! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 12/12/2011 10:50' prior: 16914904!
                   addToScroller: aMorph

	aMorph morphPosition: scroller morphPosition.
	scroller addMorph: aMorph! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:50' prior: 16915100!
 scrollerOffset
	^self viewableBounds topLeft - scroller morphPosition! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:52' prior: 16915105!
                            scrollerOffset: newOffset
	scroller morphPosition: self viewableBounds topLeft - newOffset! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:43' prior: 16866476!
                               mouseDown: evt

	| aMorph |
	evt hand newKeyboardFocus: self.
	aMorph _ self itemFromPoint: evt eventPosition.
	(aMorph notNil and: [ aMorph inToggleArea: evt eventPosition ])
		ifTrue: [ ^self toggleExpandedState: aMorph event: evt ]. 
	evt mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [ ^ self mouseButton2Activity ].
	aMorph ifNil: [ ^super mouseDown: evt ].
	aMorph highlightForMouseDown.
	evt hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: evt 
		clkSel: #click:
		clkNHalf: nil
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:28' prior: 16866504!
               mouseUp: event 
	| aMorph |
	aMorph := self itemFromPoint: event eventPosition.
	aMorph ifNil: [^self].
	aMorph highlightedForMouseDown ifFalse: [^self].
	aMorph highlightForMouseDown: false.
	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	((autoDeselect isNil or: [autoDeselect]) and: [aMorph == selectedMorph]) 
		ifTrue: [self setSelectedMorph: nil]
		ifFalse: [self setSelectedMorph: aMorph].
	Cursor normal show! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:30' prior: 16914057!
                            doubleClick: event
	| index |
	doubleClickSelector ifNil: [^super doubleClick: event].
	index _ self rowAtLocation: event eventPosition.
	index = 0 ifTrue: [^super doubleClick: event].
	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."
	^ self model perform: doubleClickSelector! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/30/2011 23:43' prior: 16914069!
        mouseDown: evt

	| row |
	evt mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [^ self mouseButton2Activity].
	self hasKeyboardFocus ifFalse: [
		evt hand newKeyboardFocus: self.
		"If we are focusing, deselect, so that later selection doesn't result in deselect."
		self listMorph noSelection].
	row _ self rowAtLocation: evt eventPosition.
	row = 0  ifTrue: [^super mouseDown: evt].
	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."
	evt hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: evt
		clkSel: #click:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:30' prior: 16914093!
                              mouseUp: event
	"The mouse came up within the list; take appropriate action"

	| row |
	row _ self rowAtLocation: event eventPosition.
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	(autoDeselect == false and: [row = 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"
	"No change if model is locked"
	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])
		ifTrue: [self changeModelSelection: 0]
		ifFalse: [self changeModelSelection: row].
	Cursor normal show.
! !
!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:44' prior: 16914630!
 mouseDown: event

	| oldIndex oldVal row w |
	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].

	self hasKeyboardFocus ifFalse: [
		event hand newKeyboardFocus: self ].

	row _ self rowAtLocation: event eventPosition.

	row = 0 ifTrue: [^super mouseDown: event].

	w _ self ownerThatIsA: SystemWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Set or clear new primary selection (listIndex)"
		dragOnOrOff
			ifTrue: [self changeModelSelection: row]
			ifFalse: [self changeModelSelection: 0].

		"Need to restore the old one, due to how model works, and set new one."
		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
		self listSelectionAt: row put: dragOnOrOff.
		"event hand releaseMouseFocus: aMorph."
		"aMorph changed"
	].
	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:30' prior: 16914671!
                         mouseMove: event 
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (event eventPosition y < bounds top and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: bounds topLeft) + 2 ]
		ifFalse: [
			(event eventPosition y > bounds bottom and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: bounds bottomLeft) - 3 ]
				ifFalse: [ self rowAtLocation: event eventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:17' prior: 16916622!
                dragVertex: ix event: evt fromHandle: handle
	| p |
	p _ evt eventPosition.
	handle referencePosition: p.
	self verticesAt: ix put: p.
! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:18' prior: 16916645!
  mouseDown: evt

	^ evt shiftPressed
		ifTrue: [((owner isKindOf: PolygonMorph) and: [owner includesHandle: self])
					ifTrue: ["Prevent insertion handles from getting edited"
							^ super mouseDown: evt].
				self toggleHandles.
				handles ifNil: [^ self].
				vertices withIndexDo:  "Check for click-to-drag at handle site"
					[:vertPt :vertIndex |
					((handles at: vertIndex*2-1 ifAbsent: [ ^self ]) containsPoint: evt eventPosition) ifTrue:
						["If clicked near a vertex, jump into drag-vertex action"
						evt hand newMouseFocus: (handles at: vertIndex*2-1)]]]
		ifFalse: [super mouseDown: evt]! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:18' prior: 16916667!
       newVertex: ix event: evt fromHandle: handle
	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."

	| pt |
	(self hasProperty: #noNewVertices) ifFalse: [
		pt _ evt eventPosition.
		self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).
		evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1)]
! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/12/2011 10:52' prior: 16916682!
                          updateHandles
	| newVert oldVert midPts nextVertIx tweens |
	smoothCurve
		ifTrue: [
			handles first referencePosition: vertices first.
			handles last referencePosition: vertices last.
			midPts _ OrderedCollection new.
			nextVertIx _ 2.
			tweens _ OrderedCollection new.
			self
				lineSegmentsDo: [:p1 :p2 | 
					tweens addLast: p2 asIntegerPoint.
					p2
							= (vertices atWrap: nextVertIx)
						ifTrue: ["Found endPoint."
							midPts addLast: (tweens at: tweens size // 2)
									+ (tweens at: tweens size + 1 // 2) // 2.
							tweens _ OrderedCollection new.
							nextVertIx _ nextVertIx + 1]].
			midPts
				withIndexDo: [:midPt :vertIndex | (closed
							or: [vertIndex < vertices size])
						ifTrue: [newVert _ handles at: vertIndex * 2.
							newVert referencePosition: midPt ]]]
		ifFalse: [vertices
				withIndexDo: [:vertPt :vertIndex | 
					oldVert _ handles at: vertIndex * 2 - 1.
					oldVert referencePosition: vertPt.
					(closed
							or: [vertIndex < vertices size])
						ifTrue: [newVert _ handles at: vertIndex * 2.
							newVert morphPosition: vertPt
									+ (vertices atWrap: vertIndex + 1) - newVert bounds extent // 2 + (1 @ -1)]]]! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:50' prior: 16917278!
         borderForm
	"A form must be created for drawing the border whenever the borderColor is translucent."

	| borderCanvas |
	borderForm ifNotNil: [^ borderForm].
	borderCanvas _ Display defaultCanvasClass forShadowOver: bounds.
	self drawBorderOn: borderCanvas.
	borderForm _ borderCanvas form.
	self arrowForms do:
		[:f |  "Eliminate overlap between line and arrowheads if transparent."
		borderForm copy: f boundingBox from: f to: f offset - self morphPosition rule: Form erase].
	^ borderForm! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:50' prior: 16917330!
                             computeBounds
	| oldBounds delta excludeHandles |
	vertices ifNil: [^ self].

	self redrawNeeded.
	oldBounds _ bounds.
	self releaseCachedState.
	bounds _ self curveBounds truncated.
	self arrowForms do: [ :f |
		bounds _ bounds merge: (f offset extent: f extent)].
	handles ifNotNil: [ self updateHandles ].

	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"
	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [
		excludeHandles _ IdentitySet new.
		handles ifNotNil: [excludeHandles addAll: handles].
		self submorphsDo: [ :each |
			(excludeHandles includes: each) ifFalse: [
				each morphPosition: each morphPosition + delta ] ] ].
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!PolygonMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 10:52' prior: 16917481!
    fromHand: hand
	"Let the user draw a polygon, clicking at each vertex, and ending
		by clicking within 5 of the first point..."
	| p1 poly oldVerts pN opposite |
	Cursor crossHair showWhile:
		[[Sensor anyButtonPressed] whileFalse:
			[self currentWorld displayWorldSafely; runStepMethods].
		p1 _ Sensor mousePoint].
	opposite _ (Display colorAt: p1) negated.
	opposite = Color transparent ifTrue: [opposite _ Color red].
	(poly _ LineMorph from: p1 to: p1 color: opposite width: 2) openInWorld.
	oldVerts _ {p1}.
	self currentWorld displayWorldSafely; runStepMethods.
	[true] whileTrue:
		[[Sensor anyButtonPressed] whileTrue:
			[pN _ Sensor mousePoint.
			poly setVertices: (oldVerts copyWith: pN).
			self currentWorld displayWorldSafely; runStepMethods].
		(oldVerts size > 1 and: [(pN dist: p1) < 5]) ifTrue: [
			hand morphPosition: Sensor mousePoint.  "Done -- update hand pos"
			^ (poly setVertices: (poly vertices copyWith: p1)) delete].
		oldVerts _ poly vertices.
		[Sensor anyButtonPressed] whileFalse:
			[pN _ Sensor mousePoint.
			poly setVertices: (oldVerts copyWith: pN).
			self currentWorld displayWorldSafely; runStepMethods]].
! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 12/12/2011 10:50' prior: 16917691!
                              startUpWithoutKeyboard
	"Display and make a selection from the receiver as long as the button  is pressed. Answer the current selection.  Do not allow keyboard input into the menu"
	
	^ self startUpWithCaption: nil at: ActiveHand morphPosition allowKeyboard: false! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:52' prior: 16934905!
   computeSlider
	| r |
	r _ self roomToMove.
	slider morphPosition:
		(bounds isWide
			ifTrue: [r topLeft + ((r width * value) asInteger @ 0)]
			ifFalse: [r topLeft + (0 @ (r height * value)  asInteger)])! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 12/11/2011 23:31' prior: 16935077!
                              setNextDirectionFromEvent: event

	nextPageDirection _ bounds isWide
		ifTrue: [ event eventPosition x >= slider referencePosition x ]
		ifFalse: [ event eventPosition y >= slider referencePosition y ]! !
!SketchMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:50' prior: 16939928!
                               form: aForm
	"Set the receiver's form"

	| oldForm |
	oldForm _ originalForm.
	originalForm _ aForm.
	self basicExtent: originalForm extent.

	oldForm ifNotNil: [ self morphPosition: self morphPosition + (oldForm extent - aForm extent // 2) ]! !
!ColorPickerMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:14' prior: 16821097!
            mouseDown: evt
	| localPt |
	localPt _ evt eventPosition - bounds topLeft.
	self deleteAllBalloons.
	clickedTranslucency _ TransparentBox containsPoint: localPt.
	self inhibitDragging ifFalse: [
		(DragBox containsPoint: localPt)
			ifTrue: [^ evt hand grabMorph: self].
	].
	(RevertBox containsPoint: localPt)
		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].
	self inhibitDragging ifFalse: [self comeToFront].
	sourceHand _ evt hand.
	self startStepping.
! !
!ColorPickerMorph methodsFor: 'menu' stamp: 'jmv 12/12/2011 10:45' prior: 16821230!
     pickUpColorFor: aMorph
	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"

      | aHand localPt oldCursor |
	aHand _ aMorph isNil
		ifTrue: [self world activeHand] 
		ifFalse: [ aMorph activeHand].
	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullBounds.
	self owner ifNil: [^ self].

	oldCursor _ Sensor currentCursor.
	ColorPickerMorph eyeDropperCursor show.

	self updateContinuously: false.
	[Sensor anyButtonPressed]
		whileFalse: 
			 [self trackColorUnderMouse].
	self deleteAllBalloons.

	localPt _World activeHand morphPosition - bounds topLeft.
	self inhibitDragging ifFalse: [
		(DragBox containsPoint: localPt) ifTrue:
			["Click or drag the drag-dot means to anchor as a modeless picker"
			^ self anchorAndRunModeless: aHand].
	].
	(clickedTranslucency _ TransparentBox containsPoint: localPt)
		ifTrue: [selectedColor _ originalColor].

	self updateContinuously: true.
	[Sensor anyButtonPressed]
		whileTrue:
			 [self updateTargetColorWith: self indicateColorUnderMouse].
	aHand newMouseFocus: nil;
		flushEvents.
	oldCursor show.
	self delete.
		 
 ! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/12/2011 10:51' prior: 16821278!
                       addToWorld: world near: box
	| goodLocation |
	goodLocation _ self bestPositionNear: box inWorld: world.
	world allMorphsDo:
		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:
		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:
			[(p selector == selector and: [p argument == argument])
				ifTrue: [^ p comeToFront  "uncover existing picker"]
				ifFalse: ["place second picker relative to first"
						goodLocation _ self bestPositionNear: p bounds inWorld: world]]]].
	self morphPosition: goodLocation.
	world addMorphFront: self.
	self redrawNeeded! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/12/2011 10:45' prior: 16821314!
              indicateColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	self pickColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPosition: pt.
		self world displayWorldSafely; runStepMethods].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/12/2011 10:45' prior: 16821356!
       trackColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	selectedColor _ originalColor.
	self trackColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPosition: pt.
		self world displayWorldSafely; runStepMethods.
		self modalBalloonHelpAtPoint: pt].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'stepping and presenter' stamp: 'jmv 12/12/2011 10:45' prior: 16821374!
                    step

	sourceHand ifNotNil: [
		self pickColorAt: sourceHand morphPosition ]! !
!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16821382!
                         anchorAndRunModeless: aHand
	"If user clicks on the drag-dot of a modal picker,
	anchor it, and change to modeless operation."

	self initializeModal: false; originalColor: originalColor.  "reset as modeless"
	aHand flushEvents.  "Drop any events gathered during modal loop"
	aHand morphPosition: Sensor mousePoint; grabMorph: self.  "Slip into drag operation"
! !
!Sonogram methodsFor: 'all' stamp: 'jmv 12/12/2011 10:50' prior: 16947376!
        plotColumn: dataArray

	| chm1 i normVal r |
	columnForm unhibernate.
	chm1 _ columnForm height - 1.
	0 to: chm1 do:
		[:y | 
		i _ y*(dataArray size-1)//chm1 + 1.
		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).
		normVal < 0.0 ifTrue: [normVal _ 0.0].
		normVal > 1.0 ifTrue: [normVal _ 1.0].
		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].
	(lastX _ lastX + 1) > (image width - 1) ifTrue:
		[self scroll].
	image copy: (r _ (lastX@0 extent: 1@image height))
			from: (32//image depth-1)@0
			in: columnForm rule: Form over.
	"self changed."
	self invalidRect: (r translateBy: self morphPosition)! !
!StarMorph methodsFor: 'editing' stamp: 'jmv 12/12/2011 10:50' prior: 16952212!
   dragVertex: label event: evt fromHandle: handle
	| ext oldR pt center |
	label == #center ifTrue: [
		self morphPosition: self morphPosition + (evt eventPosition - handle referencePosition)].

	label == #outside ifTrue: [
		center _ handles first referencePosition.
		pt _ center - evt eventPosition.
		ext _ pt r.
		oldR _ ext.
		vertices _ (0 to: 359 by: (360//vertices size)) collect: [ :angle |
			(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext])
					degrees: angle + pt degrees)
				+ center].
		handle align: handle referencePosition with: evt eventPosition ].

	self computeBounds.
! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/12/2011 10:50' prior: 16965017!
           makeMeVisible 

	self world extent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world extent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [ self morphPosition: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [ self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].

! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:50' prior: 16965086!
    justDroppedInto: aMorph event: anEvent
	isCollapsed
		ifTrue: [
			self morphPosition: (self morphPosition max: 0@0).
			collapsedFrame _ bounds]
		ifFalse: [
			fullFrame _ bounds.
			TopWindow ~~ self ifTrue: [self activate]].
	^super justDroppedInto: aMorph event: anEvent! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:52' prior: 16965255!
               initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing |
	spacing _ self boxExtent x + 2.

	self
		addMorph: (self createCloseBox morphPosition: 2@2);
		addMorph: (self createCollapseBox morphPosition: spacing+2@2);
		addMorph: (self createExpandBox morphPosition: spacing*2+2@2);
		addMorph: (self createMenuBox morphPosition: spacing*3+2@2)! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/12/2011 10:52' prior: 16965463!
               openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; extent: extent.
	^self openAsIsIn: aWorld! !
!SystemWindow methodsFor: 'top window' stamp: 'jmv 12/12/2011 10:50' prior: 16965697!
                               activateAndForceLabelToShow
	self activate.
	bounds top < 0 ifTrue: [
		self morphPosition: (self morphPosition x @ 0)]! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/30/2011 23:31' prior: 16971740!
                     doubleClickAndHalf: evt

	| here b interval |
	b _ paragraph characterBlockAtPoint: evt eventPosition.
	here _ b stringIndex.
	interval _ self privateCurrentString encompassParagraph: (here to: here).
	self selectFrom: interval first to: interval last.

	doWordSelection _ false.
	doParagraphSelection _ true.
	initialSelectionStart _ self startBlock.
	initialSelectionStop _ self stopBlock! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/30/2011 23:44' prior: 16971755!
      mouseDown: evt 
	| clickPoint b |

	initialSelectionStart _ nil.
	initialSelectionStop _ nil.
	doWordSelection _ false.
	doParagraphSelection _ false.

	"Multiple selection of text.
	Windows uses Control, Mac uses Command (i.e. commandAlt)
	On the Mac, command-button1 is translated to command-button3 by the VM. do:
		Preferences disable: #commandClickOpensHalo
	to disable this behavior and make command-button1 work for multiple selection. "
	(evt controlKeyPressed or: [ evt commandAltKeyPressed ]) ifTrue: [
		self selectionInterval size > 0 ifTrue: [
			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.
			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]
	ifFalse: [
		selectionStartBlocks _ #().
		selectionStopBlocks _ #() ].

	clickPoint _ evt eventPosition.
	b _ paragraph characterBlockAtPoint: clickPoint.

	(paragraph clickAt: clickPoint) ifTrue: [
		markBlock _ b.
		pointBlock _ b.
		evt hand releaseKeyboardFocus: self.
		^ self ].
	
	evt shiftPressed
		ifFalse: [
			(self markIndex = b stringIndex and: [ self pointIndex = b stringIndex ])
				ifTrue: [
					markBlock _ b.
					pointBlock _ b ]
				ifFalse: [
					markBlock _ b.
					pointBlock _ b.	
					self setEmphasisHereFromText ]]! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/30/2011 23:48' prior: 16971797!
          mouseMove: evt
	"Change the selection in response to mouse-down drag"

	| b interval i1 i2 |

	doWordSelection ifTrue: [
		pointBlock _ (paragraph characterBlockAtPoint: (evt eventPosition)).
		self selectWordLeftDelimiters: '' rightDelimiters: ''.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	doParagraphSelection ifTrue: [
		b _ paragraph characterBlockAtPoint: evt eventPosition.
		i1 _ b stringIndex min: initialSelectionStart stringIndex.
		i2 _ b stringIndex max: initialSelectionStop stringIndex-1.
		interval _ self privateCurrentString encompassParagraph: (i1 to: i2).
		self selectFrom: interval first to: interval last.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	pointBlock _ (paragraph characterBlockAtPoint: (evt eventPosition)).
	self storeSelectionInParagraph! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/11/2011 23:19' prior: 16971831!
                          mouseUp: evt
	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |

	evt shiftPressed
		ifTrue: [
			"Squeak classic behavior for click, move, shift-click sequence "
			"pointBlock _(paragraph characterBlockAtPoint: (evt eventPosition))."

			"Mac behavior"
			cursorBlock _ paragraph characterBlockAtPoint: evt eventPosition.
			cursorIndex _ cursorBlock stringIndex.
			startBlock _ self startBlock min: cursorBlock.
			startIndex _ startBlock stringIndex.
			stopBlock _ self stopBlock max: cursorBlock.
			stopIndex _ stopBlock stringIndex.
			(stopIndex - cursorIndex) < (cursorIndex - startIndex)
				ifTrue: [
					markBlock _ startBlock.
					pointBlock _ cursorBlock ]
				ifFalse: [
					markBlock _ stopBlock.
					pointBlock _ cursorBlock ]].
	self storeSelectionInParagraph! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 12/11/2011 23:32' prior: 16973778!
                              scrollSelectionIntoView: event
	"Scroll my text into view if necessary and return true, else return false"
	| selRects rectToTest cpHere |
	selRects _ self textMorph selectionRects.
	selRects isEmpty ifTrue: [ ^ self ].
	rectToTest _ selRects first merge: selRects last.
	(event notNil and: [ event anyButtonPressed ]) ifTrue: [  "Check for autoscroll"
		cpHere _ event eventPosition.
		cpHere y <= bounds top
			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]
			ifFalse: [
				cpHere y >= bounds bottom
					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]
					ifFalse: [ ^ self ]]].
	^ self scrollToShow: rectToTest! !
!MouseEvent methodsFor: 'comparing' stamp: 'jmv 12/11/2011 23:29' prior: 16901120!
   = aMorphicEvent
	super = aMorphicEvent ifFalse:[^false].
	position = aMorphicEvent eventPosition ifFalse: [^ false].
	buttons = aMorphicEvent buttons ifFalse: [^ false].
	^ true
! !
!MouseEvent methodsFor: 'printing' stamp: 'jmv 12/11/2011 23:37' prior: 16901181!
                        printOn: aStream

	aStream nextPut: $[.
	aStream nextPutAll: self eventPosition printString; space.
	aStream nextPutAll: type; space.
	aStream nextPutAll: self modifierString.
	aStream nextPutAll: self buttonString.
	aStream nextPutAll: timeStamp printString.
	aStream nextPut: $].! !
!MouseMoveEvent methodsFor: 'comparing' stamp: 'jmv 12/11/2011 23:29' prior: 16901270!
            = aMorphicEvent
	super = aMorphicEvent ifFalse:[^false].
	position = aMorphicEvent eventPosition ifFalse: [^ false].
	startPoint = aMorphicEvent startPoint ifFalse: [^ false].
	buttons = aMorphicEvent buttons ifFalse: [^ false].
	^ true
! !
!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:50' prior: 16985939!
              handPoint
	^ hand morphPosition! !

MouseEvent removeSelector: #position!

MouseEvent removeSelector: #position!

UserInputEvent removeSelector: #position!

UserInputEvent removeSelector: #position!

SystemWindow removeSelector: #position:!

SystemWindow removeSelector: #position:!

PasteUpMorph removeSelector: #position:!

PasteUpMorph removeSelector: #position:!

HaloMorph removeSelector: #position:!

HaloMorph removeSelector: #position:!

Morph removeSelector: #position!

Morph removeSelector: #position!

Morph removeSelector: #position:!

Morph removeSelector: #position:!

DropEvent removeSelector: #position!

DropEvent removeSelector: #position!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1319-M3Prep-positionFalsePolymorphism-jmv.9.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 2:37:37 pm'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!Morph methodsFor: 'as yet unclassified' stamp: 'jmv 12/12/2011 11:15'!
               initPosExtent
"
Morph allSubInstancesDo: [ :m | m initPosExtent ]
"
	position ifNil: [
		position _ owner
			ifNil: [ bounds topLeft ]
			ifNotNil: [
				owner initPosExtent.
				owner internalizeFromWorld: bounds topLeft ]].
	extent ifNil: [ extent _ bounds extent ].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 23:00'!
                   externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates."
	^owner
		ifNotNil: [ owner internalizeFromWorld: aPoint + position ]
		ifNil: [ aPoint + position ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 22:59'!
                               internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	^(owner
		ifNotNil: [ owner internalizeFromWorld: aPoint ]
		ifNil: [ aPoint ])
			- position! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 22:59'!
                            externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates."
	^self isWorldMorph
		ifTrue: [ aPoint ]
		ifFalse: [ super externalizeToWorld: aPoint ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 22:59'!
    internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	^self isWorldMorph
		ifTrue: [ aPoint ]
		ifFalse: [ super internalizeFromWorld: aPoint ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 19:05' prior: 16897808!
                       basicExtent: aPoint

	bounds extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	bounds _ bounds topLeft extent: aPoint.
	extent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 13:22' prior: 50342304!
    morphPosition: aPoint
	"Change the position of this morph and and all of its submorphs."

	"Detesto el falso polimorfismo con streams. Ponerle otro nombre a esto!!
	Igual, todavia esta #position, el getter, que es igual de feo..."
	
	"
	VER SENDERS. Acomodar. el argumento es en coord del owner o del world?
	Convertir los senders a senders de #zzpositionInOwner: o #zzpositionInWorld
	Espero que pocos hablen en coordenadas del world!!
	"

	| delta |
	delta _ aPoint - bounds topLeft.
	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.
	self privateFullMoveBy: delta.

	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].

	self redrawNeeded
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/11/2011 19:08' prior: 16898319!
          initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	bounds _ self defaultBounds.
	position _ bounds topLeft.
	extent _ bounds extent.
	color _ self defaultColor! !
!Morph methodsFor: 'private' stamp: 'jmv 12/12/2011 11:16' prior: 16899783!
               privateBounds: boundsRect
	"Private!! Use position: and/or extent: instead."

	fullBounds _ nil.
	bounds _ boundsRect.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/11/2011 19:22' prior: 16865312!
            initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	bounds _ 0@0 extent: CursorWithMask normal extent.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 12/11/2011 19:20' prior: 16887838!
  initialize
	super initialize.
	bounds _ 0@0 corner: 40@10.
	position _ 0@0.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 19:21' prior: 16911766!
                             extent: aPoint

	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/12/2011 11:19' prior: 50344081!
                   viewBox: newViewBox
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	super morphPosition: newViewBox topLeft.
	fullBounds _ bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.! !

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

| p |
World allMorphsDo: [ :m | m initPosExtent ].
Morph allSubInstancesDo: [ :m | m initPosExtent ].
p _ Processor activeProcess.
p == ProjectX uiProcessX ifTrue: [
	[
		p terminate.
		p _ nil.
		ProjectX spawnNewProcessX.
		Display restore ] forkAt: Processor userInterruptPriority ]!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1320-M3Prep-positionAndExtentIvars-jmv.8.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 2:48:24 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:06'!
   morphHeight
"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ bounds height! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:06'!
                              morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self extent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:02'!
                      morphPositionInOwner
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"

	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.

	^ position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:47'!
                     morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = bounds topLeft ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

owner ifNil: [
	'-----trying to set position before setting owner... bad idea!!-----' print.
	thisContext printStack: 10 ].


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:02'!
                               morphPositionInWorld
	| answer1 answer2 |
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.
	{ answer1 . answer2 }.

	^answer2! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:47'!
                 morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
owner ifNil: [
	'-----trying to set position before setting owner... bad idea!!-----' print.
	thisContext printStack: 10 ].

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - bounds topLeft.
		^ self ].		"Null change"


	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:09'!
        morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ bounds width! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:09'!
                               morphWidth: aNumber
"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self extent: aNumber asInteger@bounds height.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:01'!
                       validateOwnerNotNil
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
	owner ifNil: [
		'-----Still no owner, but this stuff kind of requires it!!-----' print.
		thisContext printStack: 10 ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:38'!
                validatePositionAndBounds
	"To be removed. Just to check consistency"
	| answer1 answer2 |
	self flag: #jmvVer2.

	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.

	answer1 = answer2 ifFalse: [
		#validatePositionAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 16:14'!
             morphPositionInWorld

	self flag: #jmvVer2. "Solo para evitar los warning por falta de owner... pensar despues este caso"
	self isWorldMorph ifTrue: [ ^ 0@0 ].
	^super morphPositionInWorld! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:39'!
                            windowBottom: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self bounds: (bounds bottom: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:40'!
                             windowBottomLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (aPoint x @ bounds top corner: bounds right @ aPoint y)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:41'!
                     windowBottomRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (bounds origin corner: aPoint)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:41'!
             windowLeft: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self bounds: (bounds left: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:42'!
 windowRight: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self bounds: (bounds right: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:42'!
                               windowTop: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self bounds: (bounds top: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:43'!
   windowTopLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (aPoint corner: bounds corner)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:43'!
                 windowTopRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (bounds left @ aPoint y corner: aPoint x @ bounds bottom)! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                          forBottom
	^self new initializeBottom! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                        forBottomLeft
	^self new initializeBottomLeft! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                forBottomRight
	^self new initializeBottomRight! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
              forLeft
	^self new initializeLeft! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                            forRight
	^self new initializeRight! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:58'!
                          forTop
	^self new initializeTop! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:58'!
                              forTopLeft
	^self new initializeTopLeft! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:58'!
                      forTopRight
	^self new initializeTopRight! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 12/13/2011 23:33' prior: 16803680!
                           placeEmbeddedObject: anchoredFormOrMorph
	"Place the anchoredMorph or return false if it cannot be placed.
	In any event, advance destX by its width."

	destX _ destX + anchoredFormOrMorph morphWidth.
	(destX > rightMargin and: [ lastIndex ~= line first ])
		"Won't fit, but  not at start of a line. Start a new line with it"
		ifTrue: [ ^ false].
	lastIndex _ lastIndex + 1.
	^ true! !
!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 12/13/2011 23:33' prior: 16803579!
placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	specialWidth _ anchoredFormOrMorph morphWidth.
	^ true! !
!CompositionScanner methodsFor: 'stop conditions' stamp: 'jmv 12/13/2011 23:35' prior: 16825773!
                    placeEmbeddedObject: anchoredFormOrMorph
	| descent |

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [
		line stop: lastIndex-1.
		^ false].
	descent _ lineHeight - baseline.
	baseline _ baseline max: anchoredFormOrMorph morphHeight.
	lineHeight _ baseline + descent.
	line stop: lastIndex.
	^ true! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/13/2011 23:35' prior: 16880957!
                  fixedOrMorphHeight: aNumber
	"aNumber is taken as the fixed height to use.
	No proportional part."
	fixedHeight
		ifNotNil: [ fixedHeight _ aNumber ]
		ifNil: [ morph morphHeight: aNumber ].
	proportionalHeight _ nil! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/13/2011 23:34' prior: 16880966!
                 fixedOrMorphWidth: aNumber
	"aNumber is taken as the fixed width to use.
	No proportional part."
	fixedWidth
		ifNotNil: [ fixedWidth _ aNumber ]
		ifNil: [ morph morphWidth: aNumber ].
	proportionalWidth _ nil! !
!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/13/2011 23:35' prior: 16881091!
                          fixedHeight
	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)
	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."
	proportionalHeight ifNotNil: [
		^0 ].
	^ fixedHeight ifNil: [ morph morphHeight ]! !
!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/13/2011 23:33' prior: 16881104!
                     fixedWidth
	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)
	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."
	proportionalWidth ifNotNil: [
		^0 ].
	^ fixedWidth ifNil: [ morph morphWidth ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:01' prior: 50345058!
                            basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	
	
	bounds extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	bounds _ bounds topLeft extent: aPoint.
	extent _ aPoint.
	self validatePositionAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:10' prior: 16897816!
  bounds
	"Return the bounds of this morph."
	"Note: It is best not to override this method because many methods in Morph and its subclasses use the instance variable directly rather than 'self bounds'. Instead, subclasses should be sure that the bounds instance variable is correct."

	"remove senders and implementors"
	self flag: #jmvVer2.

	^ bounds
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:10' prior: 50342604!
               bounds: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPosition: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPosition: newBounds topLeft; extent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self extent: newExtent; morphPosition: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:11' prior: 16897847!
                               extent
"
?
'' print.
thisContext printStack: 10.
"
"Needs to be turned into extentInOwner and extentInWorld"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	^ bounds extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:11' prior: 16897850!
        extent: aPoint
"
?
'' print.
thisContext printStack: 10.
"
"Needs to be turned into extentInOwner: and extentInWorld:"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self basicExtent: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 16:01' prior: 50345023!
                     externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates."
	self flag: #jmvVer2.
	^owner
		ifNotNil: [ owner externalizeToWorld: aPoint + position ]
		ifNil: [ aPoint + position ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:08' prior: 16897853!
                           height
	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphHeight"
'' print.
thisContext printStack: 10.
	^ bounds height! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:07' prior: 16897856!
                            height: aNumber
	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphHeight:"
'' print.
thisContext printStack: 10.
	self extent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:07' prior: 16897860!
                    innerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

"In own's coordinates!!"
	self flag: #jmvVer2.
	^ bounds! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 16:01' prior: 50345032!
           internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	self flag: #jmvVer2.
	^(owner
		ifNotNil: [ owner internalizeFromWorld: aPoint ]
		ifNil: [ aPoint ])
			- position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:06' prior: 16897868!
                             minimumExtent
	| ext |
	"This returns the minimum extent that the morph may be shrunk to.  Not honored in too many places yet, but respected by the resizeToFit feature, at least.  copied up from SystemWindow 6/00"
	self flag: #jmvVer2.	"in owner's coordinates?"
	(ext _ self valueOfProperty: #minimumExtent)
		ifNotNil:
			[^ ext].
	^ 100 @ 80! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 15:45' prior: 50342294!
                        morphPosition
"
Ver que senders quieren #morphPositionInOwner y quienes #morphPosirionInWorld (espero que pocos!!)
Eventualmente eliminar los senders a este...
"
	self flag: #jmvVer2.
	^ self morphPositionInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 15:45' prior: 50345067!
                           morphPosition: newPositionInWorld
"Cuando terminemos, el arg es en coords del owner
entonces: Warning: argument is in owner's coordinate system. When creating new morphs, first add to owner, then set position."
	"Change the position of this morph."
	"
	Para morphs que estan en el mundo, da lo mismo!! Y para los que estan en otro morph, la mayoria de las veces usaremos un layout. Y las veces que no, usaremos coordenadas del owner tambien!!
	Podemos hacer que por default, #morphPosition y #morphPosition: sean en el owner, y chequear los senders...
	Quizas el camino es ir cambiando los senders a isOwner, y cuando todos sean ahi, eliminar los demas... suena razonable, no?
	Lo mismo para setter.
	Lo mismo para extent, height, width... aunque aqui, hasta que no introduzca factor de escala, no es tan urgente (i.e. no se rompe ya mismo!!) Eso quiere decir que no necesito pasar por los sufijos provisorios InOwner e InWorld!!
	Y en algun momento de todo esto, empezar a atacar los usos directos de la ivar bounds!!
	"
	
	"
Ver que senders quieren #morphPositionInOwner: y quienes #morphPosirionInWorld: (espero que pocos!!)
Eventualmente eliminar los senders a este...
NO OLVIDARSE que hay redefiniciones de este metodo... Redefinir los 2 setters que quedan?
	"
	self flag: #jmvVer2.
	^self morphPositionInWorld: newPositionInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:08' prior: 16897895!
                        width

	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphWidth"
'' print.
thisContext printStack: 10.
	^ bounds width! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:08' prior: 16897898!
                              width: aNumber

	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphWidth:"
'' print.
thisContext printStack: 10.
	self extent: aNumber asInteger@bounds height.
! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 12/14/2011 15:51' prior: 50342625!
               referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	self flag: #jmvVer2.
	self morphPosition: aPoint - (bounds extent // 2)! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/14/2011 16:04' prior: 16898303!
                   inATwoWayScrollPane
	"Answer a two-way scroll pane that allows the user to scroll the receiver in either direction.  It will have permanent scroll bars unless you take some special action."

	| widget |
	self flag: #jmvVer2.
	widget _ PluggableScrollPane new.
	widget addToScroller: self.
	widget extent: (self morphWidth min: 300 max: 100) @ (self morphHeight min: 150 max: 100).
	widget setScrollDeltas.
	widget color: self color darker darker.
	^widget! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/15/2011 20:43' prior: 50345096!
  initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	bounds _ self defaultBounds.

	position _ bounds topLeft.
	extent _ bounds extent.
	self validatePositionAndBounds.
	color _ self defaultColor! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 09:03' prior: 16899789!
                           privateFullMoveBy: delta
	"Private!! Relocate me and all of my subMorphs by recursion. Subclasses that implement different coordinate systems may override this method."

	"All these will die soon!!"
	self flag: #jmvVer2.

	self privateMoveBy: delta.
	submorphs do: [ :m |
		m privateFullMoveBy: delta ]! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 09:03' prior: 16899799!
  privateMoveBy: delta
	"Private!! Use 'position:' instead."

	"All these will die soon!!"

	self flag: #jmvVer2.
	self validateOwnerNotNil.

	bounds _ bounds translateBy: delta.
	fullBounds ifNotNil: [ fullBounds _ fullBounds translateBy: delta ].! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 09:04' prior: 16899806!
                          privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"
		
	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			bounds _ position extent: bounds extent.
			fullBounds _ nil.
			self validatePositionAndBounds
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					bounds _ (owner externalizeToWorld: position) extent: bounds extent.
					fullBounds _ nil.
					self validatePositionAndBounds
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self validatePositionAndBounds
					]]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 19:56' prior: 50342924!
                      addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w |
	w := self world ifNil: [target world].
	nameMorph := StringMorph contents: aString.
	nameMorph color: Color magenta.
	namePosition := outerRectangle bottomCenter 
				- ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph 
		morphPosition: (namePosition min: w viewBox bottomRight - nameMorph extent y + 5).
	self addMorph: (RectangleMorph new
		bounds: (nameMorph bounds outsetBy: 2);
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9)).
	self addMorph: nameMorph.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 19:56' prior: 16864064!
   basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self handleSize.
	anExtent _ ((self morphWidth + self handleSize + 8) max: minSide) @
				((self morphHeight + self handleSize + 8) max: minSide).
	aBox _ Rectangle center: bounds center extent: anExtent.
	w _ self world ifNil: [ target outermostWorldMorph ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: 8@8) ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/14/2011 15:56' prior: 50342956!
                              doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target extent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle extent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/14/2011 15:56' prior: 50342991!
 doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle extent // 2).
	self someSubmorphPositionOrExtentChanged! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/15/2011 20:46' prior: 50345116!
                       initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	bounds _ 0@0 extent: CursorWithMask normal extent.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	self validatePositionAndBounds.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:31' prior: 16869456!
                      adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ bounds topLeft..
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m privateBounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self extent: w@y! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 14:19' prior: 16869890!
model: aTextModel wrappedTo: width
	"Accept new text contents.  Lay it out, wrapping to width.
	Then fit my height to the result."
	wrapFlag _ true.
	self basicExtent: width truncated@self morphHeight.
	self model: aTextModel! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 12/12/2011 14:18' prior: 16880116!
          adjustHorizontallyBy: aLayoutAdjustMorph at: aPoint
	| delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |
	doNotResizeBelow _ self minPaneWidthForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	l _ self submorphs at: i +1.
	ls _ l layoutSpec.
	lCurrentWidth _ l morphWidth max: 1.	"avoid division by zero"
	r _ self submorphs at: i - 1.
	rs _ r layoutSpec.
	rCurrentWidth _ r morphWidth max: 1.	"avoid division by zero"
	delta _ aPoint x - aLayoutAdjustMorph referencePosition x.
	delta _ delta max: doNotResizeBelow - lCurrentWidth.
	delta _ delta min: rCurrentWidth - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	rNewWidth _ rCurrentWidth - delta.
	lNewWidth _ lCurrentWidth + delta.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [	"If both proportional, update them"
			ls setProportionalWidth: (1.0 * lNewWidth / lCurrentWidth * ls proportionalWidth).
			rs setProportionalWidth: (1.0 * rNewWidth / rCurrentWidth * rs proportionalWidth) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	self layoutSubmorphs.
	fullBounds _ bounds! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 12/12/2011 14:18' prior: 16880158!
                        adjustVerticallyBy: aLayoutAdjustMorph at: aPoint
	| delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |
	doNotResizeBelow _ self minPaneHeightForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	t _ self submorphs at: i +1.
	ts _ t layoutSpec.
	tCurrentHeight _ t morphHeight max: 1.	"avoid division by zero"
	b _ self submorphs at: i - 1.
	bs _ b layoutSpec.
	bCurrentHeight _ b morphHeight max: 1.	"avoid division by zero"
	delta _ aPoint y - aLayoutAdjustMorph referencePosition y.
	delta _ delta max: doNotResizeBelow - tCurrentHeight.
	delta _ delta min: bCurrentHeight - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	tNewHeight _ tCurrentHeight + delta.
	bNewHeight _ bCurrentHeight - delta.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [	"If both proportional, update them"
			ts setProportionalHeight: (1.0 * tNewHeight / tCurrentHeight * ts proportionalHeight).
			bs setProportionalHeight: (1.0 * bNewHeight / bCurrentHeight * bs proportionalHeight) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	self layoutSubmorphs.
	fullBounds _ bounds! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 14:20' prior: 16887230!
                 initialize
	super initialize.
	self morphHeight: 2! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 12/12/2011 14:27' prior: 16887433!
                     addStayUpIcons
	| closeBox pinBox w |
	
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 42.
	self addMorphFront: 
		(LayoutMorph newRow
			morphHeight: (titleMorph morphHeight max: 19);
			morphWidth: w;	"Make room for buttons"
			color: Color transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleMorph new borderWidth: 0; color: Color transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleMorph new borderWidth: 0; color: Color transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 3/14/2012 13:47' prior: 50343516!
                     addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ RectangleMorph new.
	self setTitleParametersFor: titleMorph.
	pp _ 8@2.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s.
		s morphPositionInOwner: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphHeight: pp y; morphWidth: w + 8.
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 12/15/2011 20:45' prior: 50345127!
                       initialize
	super initialize.
	bounds _ 0@0 corner: 40@10.
	position _ 0@0.
	self validatePositionAndBounds.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 14:25' prior: 50343676!
adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each morphWidth])].

	w _ w + 4.
	tl _ bounds topLeft.
	p _ tl + 5.
	submorphs do: [ :m |
		m morphWidth: w.
		m morphPosition: p.
		p _ m bounds bottomLeft +(0@1) ].
	
	self extent: submorphs last bounds bottomRight - tl + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 14:21' prior: 50343698!
                           positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	bounds right > aWorld world bounds right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ bounds amountToTranslateWithin:
		(aWorld world bounds withHeight: ((aWorld world bounds height - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:46' prior: 50345136!
 extent: aPoint

	self flag: #jmvVer2.
	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/15/2011 20:46' prior: 50345152!
                           viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
"	super morphPosition: newViewBox topLeft."
	fullBounds _ bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.
	self validatePositionAndBounds.! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 12/13/2011 14:44' prior: 50332959!
                          bringWindowsFullOnscreen
	"Make ever SystemWindow on the desktop be totally on-screen, whenever possible."
	
	(SystemWindow windowsIn: self satisfying: [ :w | true]) do:
		[ :aWindow | 
			aWindow windowRight: (aWindow bounds right min: bounds right).
			aWindow windowBottom: (aWindow bounds bottom min: bounds bottom).
			aWindow windowLeft: (aWindow bounds left max: bounds left).
			aWindow windowTop: (aWindow bounds top max: bounds top)]! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:14' prior: 16915064!
      hTotalScrollRange
	"Return the width extent of the receiver's scrollable area"
	^scroller morphWidth! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:14' prior: 16915181!
                             vTotalScrollRange
	"Return the height extent of the receiver's scrollable area"
	^scroller morphHeight! !
!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:15' prior: 16866576!
                         scrollDeltaHeight
	scroller hasSubmorphs ifFalse: [ ^1].
	^ scroller firstSubmorph morphHeight! !
!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:20' prior: 16881445!
innerHeight: aNumber
	"Adjust height and scrollbar to the new contents height."
	self morphHeight: (aNumber + 10 min: maxHeight)! !
!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 14:17' prior: 16914165!
                            initialize
	super initialize.
	scroller morphWidth: self morphWidth.
	scroller color: self textColor.! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/15/2011 20:45' prior: 50344440!
    computeBounds
	| oldBounds delta excludeHandles |

	self flag: #jmvVer2.
	vertices ifNil: [^ self].

	self redrawNeeded.
	oldBounds _ bounds.
	self releaseCachedState.
	bounds _ self curveBounds truncated.
	self arrowForms do: [ :f |
		bounds _ bounds merge: (f offset extent: f extent)].
	handles ifNotNil: [ self updateHandles ].

	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"
	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [
		excludeHandles _ IdentitySet new.
		handles ifNotNil: [excludeHandles addAll: handles].
		self submorphsDo: [ :each |
			(excludeHandles includes: each) ifFalse: [
				each morphPosition: each morphPosition + delta ] ] ].
	self validatePositionAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:17' prior: 16934914!
                              expandSlider
	"Compute the new size of the slider (use the old sliderThickness as a minimum)."
	| r |
	r _ self totalSliderArea.
	slider extent: (bounds isWide
		ifTrue: [((r width * interval) asInteger max: 7) @ slider morphHeight]
		ifFalse: [slider morphWidth @ ((r height * interval) asInteger max: 7)])! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/12/2011 13:58' prior: 16965222!
               initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	self extent: 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985872!
           initializeBottom
	selector _ #windowBottom:.
	coordinateGetter _ #y.
	cursorGetter _ #resizeBottom! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985878!
                    initializeBottomLeft
	selector _ #windowBottomLeft:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeBottomLeft! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985885!
 initializeBottomRight
	selector _ #windowBottomRight:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeBottomRight! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985892!
                              initializeLeft
	selector _ #windowLeft:.
	coordinateGetter _ #x.
	cursorGetter _ #resizeLeft! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985898!
                          initializeRight
	selector _ #windowRight:.
	coordinateGetter _ #x.
	cursorGetter _ #resizeRight! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985904!
                       initializeTop
	selector _ #windowTop:.
	coordinateGetter _ #y.
	cursorGetter _ #resizeTop! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985910!
                             initializeTopLeft
	selector _ #windowTopLeft:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeTopLeft! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985916!
          initializeTopRight
	selector _ #windowTopRight:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeTopRight! !
!WindowEdgeAdjustingMorph methodsFor: 'geometry testing' stamp: 'jmv 12/13/2011 14:46' prior: 16985961!
     containsPoint: aPoint
	| sensitiveBorder |
	(bounds containsPoint: aPoint) ifFalse: [ ^false ].
	sensitiveBorder _ 4.
	selector caseOf: {
		[ #windowTopLeft: ] -> [ ^ aPoint x - bounds left < sensitiveBorder or: [ aPoint y - bounds top < sensitiveBorder ]].
		[ #windowTopRight: ] -> [ ^ bounds right - aPoint x <= sensitiveBorder or: [ aPoint y - bounds top < sensitiveBorder ]].
		[ #windowBottomLeft: ] -> [ ^ aPoint x - bounds left < sensitiveBorder or: [ bounds bottom - aPoint y <= sensitiveBorder ]].
		[ #windowBottomRight: ] -> [ ^ bounds right - aPoint x <= sensitiveBorder or: [ bounds bottom - aPoint y <= sensitiveBorder ]].
	}
	otherwise: [
		"all the morph is sensitive for horizontal and vertical (i.e. non corner) instances."
		^true ]! !

WindowEdgeAdjustingMorph class removeSelector: #bottom!

WindowEdgeAdjustingMorph class removeSelector: #bottom!

WindowEdgeAdjustingMorph class removeSelector: #bottomLeft!

WindowEdgeAdjustingMorph class removeSelector: #bottomLeft!

WindowEdgeAdjustingMorph class removeSelector: #bottomRight!

WindowEdgeAdjustingMorph class removeSelector: #bottomRight!

WindowEdgeAdjustingMorph class removeSelector: #left!

WindowEdgeAdjustingMorph class removeSelector: #left!

WindowEdgeAdjustingMorph class removeSelector: #right!

WindowEdgeAdjustingMorph class removeSelector: #right!

WindowEdgeAdjustingMorph class removeSelector: #top!

WindowEdgeAdjustingMorph class removeSelector: #top!

WindowEdgeAdjustingMorph class removeSelector: #topLeft!

WindowEdgeAdjustingMorph class removeSelector: #topLeft!

WindowEdgeAdjustingMorph class removeSelector: #topRight!

WindowEdgeAdjustingMorph class removeSelector: #topRight!

SystemWindow removeSelector: #bottom:!

SystemWindow removeSelector: #bottom:!

SystemWindow removeSelector: #bottomLeft:!

SystemWindow removeSelector: #bottomLeft:!

SystemWindow removeSelector: #bottomRight:!

SystemWindow removeSelector: #bottomRight:!

SystemWindow removeSelector: #left:!

SystemWindow removeSelector: #left:!

SystemWindow removeSelector: #right:!

SystemWindow removeSelector: #right:!

SystemWindow removeSelector: #top:!

SystemWindow removeSelector: #top:!

SystemWindow removeSelector: #topLeft:!

SystemWindow removeSelector: #topLeft:!

SystemWindow removeSelector: #topRight:!

SystemWindow removeSelector: #topRight:!

Morph removeSelector: #initPosExtent!

Morph removeSelector: #initPosExtent!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1321-M3Prep-positionSettersAndFixes-jmv.6.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 3:03:39 pm'!
!InnerTextMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/13/2011 23:05'!
       addMorphFrontFromWorldPosition: aMorph
	"Overridden for more specific re-layout and positioning"
	| positionInWorld |
	positionInWorld _ aMorph morphPosition.
	^self anchorMorph: aMorph at: positionInWorld! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/13/2011 20:42'!
               positionAt: aPoint relativeTo: aMenuItem
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	bounds right > owner world bounds right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ bounds amountToTranslateWithin:
		(owner world bounds withHeight: ((owner world bounds height - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 23:36'!
                             openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self bounds: (0@0 extent: w@h).
	labelMorph fitContents.
	subLabelMorph fitContents.
	self layoutSubmorphs.
	self align: self fullBounds center with: Display boundingBox center.
	aWorld startSteppingSubmorphsOf: self.! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/13/2011 21:12' prior: 16897989!
             addHalo: evt
	| halo prospectiveHaloClass |
	prospectiveHaloClass _ Smalltalk at: self haloClass ifAbsent: [HaloMorph].
	halo _ prospectiveHaloClass new.
	halo popUpFor: self event: evt.
	halo bounds: self worldBoundsForHalo.
	^halo! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 23:12' prior: 50342684!
 openInWorld: aWorld
	"Add this morph to the requested World."
	aWorld addMorph: self.
	aWorld startSteppingSubmorphsOf: self! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/13/2011 23:05' prior: 50342728!
       addMorphFrontFromWorldPosition: aMorph
	| positionInWorld |
	positionInWorld _ aMorph morphPosition.
	self addMorphFront: aMorph.
	aMorph morphPosition: positionInWorld! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/14/2011 16:48' prior: 50342742!
                    setCompleter: anAutoCompleter position: aPoint 
	completer _ anAutoCompleter.
	self resetMenu.
	self openInWorld.
	self morphPositionInOwner: aPoint.! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/13/2011 19:44' prior: 50344607!
                  addToWorld: world near: box
	| goodLocation |
	goodLocation _ self bestPositionNear: box inWorld: world.
	world allMorphsDo:
		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:
		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:
			[(p selector == selector and: [p argument == argument])
				ifTrue: [^ p comeToFront  "uncover existing picker"]
				ifFalse: ["place second picker relative to first"
						goodLocation _ self bestPositionNear: p bounds inWorld: world]]]].
	world addMorphFront: self.
	self morphPositionInOwner: goodLocation.
	self redrawNeeded! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/13/2011 19:44' prior: 50344628!
       indicateColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	self pickColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPositionInOwner: pt.
		self world displayWorldSafely; runStepMethods].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/13/2011 19:45' prior: 50344644!
trackColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	selectedColor _ originalColor.
	self trackColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPositionInOwner: pt.
		self world displayWorldSafely; runStepMethods.
		self modalBalloonHelpAtPoint: pt].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 12/13/2011 19:44' prior: 50344669!
                            anchorAndRunModeless: aHand
	"If user clicks on the drag-dot of a modal picker,
	anchor it, and change to modeless operation."

	self initializeModal: false; originalColor: originalColor.  "reset as modeless"
	aHand flushEvents.  "Drop any events gathered during modal loop"
	aHand morphPositionInOwner: Sensor mousePoint; grabMorph: self.  "Slip into drag operation"
! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 4/10/2012 14:59' prior: 50335426!
            createAcceptButton
	"create the [accept] button"
	| result buttonColor theme |
	theme _ Theme current.
	theme useUniformColors
		ifTrue: [ buttonColor _ theme buttonColorFrom: theme defaultWindowColor ]
		ifFalse: [ buttonColor _ theme acceptButton].
	result _ PluggableButtonMorph new
		 model: self;
		 color: buttonColor;
		 label: 'Accept';
		 action: #acceptClicked.
	self addMorph: result.
	result bounds: (29@90 corner: 122@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 4/10/2012 14:59' prior: 50335438!
                              createCancelButton
	"create the [cancel] button"
	| result buttonColor theme |
	theme _ Theme current.
	theme useUniformColors
		ifTrue: [ buttonColor _ theme buttonColorFrom: theme defaultWindowColor ]
		ifFalse: [ buttonColor _ theme buttonColorFrom: theme cancelButton ].
	result _ PluggableButtonMorph new
		 model: self;
		 color: buttonColor;
		 label: 'Cancel';
		 action: #cancelClicked.
	self addMorph: result.
	result bounds: (149@90 corner: 242@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 22:52' prior: 16852848!
    createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	self addMorph: result.
	result bounds: ( 30@7 corner: 269@22).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 22:52' prior: 16852858!
       createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result extent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result bounds: (14@25 corner: 257@84).
	^ result! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 12/13/2011 21:12' prior: 50342821!
                          popUpFor: aMorph event: evt
	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."

	| hand anEvent |
	self flag: #workAround.	"We should really have some event/hand here..."
	anEvent _ evt
				ifNil: [
					hand _ aMorph world activeHand.
					hand ifNil: [ hand _ aMorph world firstHand ]. 
					hand lastEvent ]
				ifNotNil: [
					hand _ evt hand.
					evt ].
	hand halo: self.
	hand world addMorphFront: self.
	self target: aMorph.
	positionOffset _ anEvent eventPosition - aMorph morphPosition.
	self startStepping! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/31/2011 00:15' prior: 50342884!
                      addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint := self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle bounds: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPositionInOwner: 0@0 ]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/13/2011 20:24' prior: 50345914!
                 addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleMorph new
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph extent y + 5).
	nameBackground bounds: (nameMorph bounds outsetBy: 2).
	^nameMorph! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/13/2011 20:28' prior: 50343154!
     attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m bounds extent // 2.
	m morphPosition: (self morphPosition - delta).
	m formerPosition: m morphPosition.
	targetOffset _ m morphPosition - self morphPosition.! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 20:29' prior: 50343332!
                        popUpForHand: aHand
	"Pop up the receiver as balloon help for the given hand"

	| xcess |
	(contents isNil or: [ contents isEmpty ]) ifTrue: [ ^self ].
	aHand world addMorphFront: self.
	self morphPosition: aHand morphPosition + (-6@20).
	xcess _ bounds right - aHand world bounds right.
	xcess > 0 ifTrue: [
		self morphPosition: self morphPosition - (xcess@0) ].
	aHand balloonHelp: self! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 18:14' prior: 50346015!
                     adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ bounds topLeft..
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m bounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self extent: w@y! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 12/13/2011 20:30' prior: 50343458!
        contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker.
	marker morphPosition: bounds left @ (bounds top + 2).! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/13/2011 23:07' prior: 50343543!
                        popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition - self morphPosition.
	sourceItem owner owner addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last - (self width @ 0) value: false;
		value: rightOrLeftPoint first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/13/2011 20:42' prior: 16887672!
      popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [:m | m isKindOf: UpdatingMenuItemMorph]) 
		do: [:m | m updateContents].
	aWorld addMorphFront: self.
	self 
		positionAt: aPoint
		relativeTo: (selectedItem ifNil: [self items first]).
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [hand newKeyboardFocus: self].
	evt := hand lastEvent.
	(evt isKeyboard or: [evt isMouse and: [evt anyButtonPressed not]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt]! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 12/13/2011 22:55' prior: 50343615!
displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m isKindOf: MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock.
		feedbackMorph morphPosition: self morphPosition - (0@20).
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self submorphs last delete.
		self removeProperty: #feedbackMorph ].
	matches size = 1 ifTrue: [
		self
			selectItem: matches first
			event: evt ].! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 12/13/2011 23:34' prior: 50343734!
  informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ ActiveWorld.
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph morphWidth: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 12/13/2011 23:36' prior: 50343879!
                            placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph morphWidth)@
				(lineY+ line baseline - anchoredFormOrMorph morphHeight)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph morphWidth @ (destY + line baseline - anchoredFormOrMorph morphHeight)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/13/2011 22:53' prior: 50344093!
       addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.
	delta _ trialRect amountToTranslateWithin: bounds.
	self addMorph: aMorph.
	aMorph morphPosition: trialRect origin + delta.! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 12/13/2011 23:56' prior: 50344119!
                      addToScroller: aMorph

	scroller addMorph: aMorph.
	aMorph morphPosition: scroller morphPosition! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:18' prior: 16915261!
hHideScrollBar
	hScrollBar hide.
	scroller adjustExtent! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:18' prior: 16915291!
         hShowScrollBar

	hScrollBar show.
	scroller adjustExtent! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:19' prior: 16915367!
        vHideScrollBar
	scrollBar hide.
	scroller adjustExtent! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:19' prior: 16915391!
          vShowScrollBar

	scrollBar show.
	scroller adjustExtent! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/13/2011 23:58' prior: 50344381!
                  updateHandles
	| newVert oldVert midPts nextVertIx tweens |
	smoothCurve
		ifTrue: [
			handles first referencePosition: vertices first.
			handles last referencePosition: vertices last.
			midPts _ OrderedCollection new.
			nextVertIx _ 2.
			tweens _ OrderedCollection new.
			self
				lineSegmentsDo: [:p1 :p2 | 
					tweens addLast: p2 asIntegerPoint.
					p2 = (vertices atWrap: nextVertIx)
						ifTrue: ["Found endPoint."
							midPts addLast: (tweens at: tweens size // 2)
									+ (tweens at: tweens size + 1 // 2) // 2.
							tweens _ OrderedCollection new.
							nextVertIx _ nextVertIx + 1]].
			midPts withIndexDo: [:midPt :vertIndex |
				(closed or: [vertIndex < vertices size]) ifTrue: [
					newVert _ handles at: vertIndex * 2.
					newVert referencePosition: midPt ]]]
		ifFalse: [
			vertices
				withIndexDo: [ :vertPt :vertIndex | 
					oldVert _ handles at: vertIndex * 2 - 1.
					oldVert referencePosition: vertPt.
					(closed or: [vertIndex < vertices size])
						ifTrue: [
							newVert _ handles at: vertIndex * 2.
							newVert morphPosition: vertPt
									+ (vertices atWrap: vertIndex + 1) - newVert bounds extent // 2 + (1 @ -1)]]]! !
!ProgressMorph methodsFor: 'accessing' stamp: 'jmv 12/13/2011 23:20' prior: 16923490!
                label: aString subLabel: otherString
	labelMorph contents: aString.
	subLabelMorph contents: otherString! !
!ProgressMorph class methodsFor: 'example' stamp: 'jmv 12/13/2011 23:38' prior: 16923548!
                          example
	"
	ProgressMorph example
	"
	| progress |
	progress _ ProgressMorph label: 'Test progress' subLabel: 'this is the subheading'.
	progress openInWorld.
	[
		100 timesRepeat: [
			(Delay forMilliseconds: 20) wait.
			progress incrDone: 0.01 ].
		progress delete] fork! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965176!
                 createCloseBox
	^ (PluggableButtonMorph model: self action: #closeBoxHit)
		icon: Theme current closeIcon;
		setBalloonText: 'close this window'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965184!
                  createCollapseBox
	^(PluggableButtonMorph model: self action: #collapseOrExpand)
		icon: Theme current collapseIcon;
		setBalloonText: 'collapse this window'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965193!
     createExpandBox
	^ (PluggableButtonMorph model: self action: #expandBoxHit)
		icon: Theme current expandIcon;
		setBalloonText: 'expand to full screen'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965201!
           createMenuBox
	^ (PluggableButtonMorph model: self action: #offerWindowMenu)
		icon: Theme current windowMenuIcon;
		setBalloonText: 'window menu'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 50344759!
                initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing box |
	spacing _ self boxExtent x + 2.

	box _ self createCloseBox.
	self addMorph: box.
	box morphPosition: 2@2.
	box extent: self boxExtent.

	box _ self createCollapseBox.
	self addMorph: box.
	box morphPosition: spacing+2@2.
	box extent: self boxExtent.

	box _ self createExpandBox.
	self addMorph: box.
	box morphPosition: spacing*2+2@2.
	box extent: self boxExtent.

	box _ self createMenuBox.
	self addMorph: box.
	box morphPosition: spacing*3+2@2.
	box extent: self boxExtent.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/13/2011 21:06' prior: 16965454!
         openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self bounds: (RealEstateAgent initialFrameFor: self world: aWorld).
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/13/2011 21:07' prior: 50344774!
                       openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; extent: extent.
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !

SystemWindow removeSelector: #openAsIsIn:!

SystemWindow removeSelector: #openAsIsIn:!

ProgressMorph removeSelector: #setupMorphs!

ProgressMorph removeSelector: #setupMorphs!

MenuMorph removeSelector: #positionAt:relativeTo:inWorld:!

MenuMorph removeSelector: #positionAt:relativeTo:inWorld:!

InnerTextMorph removeSelector: #addMorphFront:fromWorldPosition:!

InnerTextMorph removeSelector: #addMorphFront:fromWorldPosition:!

Morph removeSelector: #addMorphFront:fromWorldPosition:!

Morph removeSelector: #addMorphFront:fromWorldPosition:!

Morph removeSelector: #privateBounds:!

Morph removeSelector: #privateBounds:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1322-M3Prep-FirstAddMorphThenPosition-jmv.5.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 3:14:11 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:43'!
               morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ bounds extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:43'!
                             morphExtent: aPoint
"assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self basicExtent: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:31'!
             validateNotSent
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
	Count ifNil: [ Count _ 0 ].
	Count _ Count + 1.
	Count < 10 ifTrue: [
		'-----False polymorphism. Should not be sent!!-----' print.
		thisContext printStack: 10 ]! !
!ImageMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:21'!
    morphExtent: aPoint
	"Do nothing; my extent is determined by my image Form."
! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:27'!
         morphExtent: aPoint
	| newExtent |
	"Resist changing the extent if no wordwrap.. this should be checked."
	wrapFlag ifFalse: [ ^ self ].
	newExtent _ aPoint truncated max: self minimumExtent.
	
	"No change of wrap width"
	newExtent x = bounds extent x ifTrue: [ ^ self ].

	super morphExtent: newExtent.
	
	self resetParagraph.
	self editor recomputeSelection.	
	self updateFromParagraph.! !
!MagnifierMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32'!
                  morphExtent: aPoint
	"Round to multiples of magnification"
	srcExtent _ (aPoint - (2 * borderWidth)) // magnification.
	^super morphExtent: self defaultExtent! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32'!
                          morphExtent: aPoint

	self flag: #jmvVer2.
	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
   morphExtent: aPoint
	super morphExtent: aPoint.
	magnifiedIcon _ nil.
	self redrawNeeded! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
                         morphExtent: newExtent
	
	| minH minW |
	"Figure out the minimum width and height for this pane so that scrollbars will appear"
	minH _ Preferences scrollbarThickness * 2.
	minW _ minH.
	super morphExtent: (newExtent max: (minW@minH)).

	"Now reset widget sizes"
	scroller adjustExtent.
	self updateScrollBarsBounds.
	self setScrollDeltas! !
!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:27'!
                            morphExtent: aPoint
	maxHeight _ aPoint y.
	super morphExtent: aPoint.! !
!PolygonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:21'!
                  morphExtent: newExtent 
	"Not really advisable, but we can preserve most of the geometry if we don't
	shrink things too small."
	| safeExtent center |
	center _ self referencePosition.
	safeExtent _ newExtent max: 20@20.
	self setVertices: (vertices collect:
		[:p | p - center * (safeExtent asFloatPoint / (bounds extent max: 1@1)) + center])! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/10/2012 15:10'!
     morphExtent: newExtent
	| newExtentToUse |
	newExtent = bounds extent ifTrue: [^ self].
	newExtentToUse _ bounds isWide
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = bounds extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!Sonogram methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:22'!
  morphExtent: newExtent
	super image: (Form extent: newExtent depth: Display depth).
	lastX _ -1.
	columnForm _ Form extent: (32//image depth)@(image height) depth: image depth.
	pixValMap _ ((1 to: 256) collect:
			[:i | columnForm pixelValueFor: (Color gray: (256-i)/255.0)])
		as: Bitmap.
! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:26'!
                     setWidth: width

	self morphExtent: width @ (font ifNil: [StrikeFont default]) height! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
   morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = bounds extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent].
	isCollapsed
		ifTrue: [collapsedFrame _ bounds]
		ifFalse: [fullFrame _ bounds]! !
!TranscriptMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
              morphExtent: aPoint
	super morphExtent: aPoint.
	(form isNil or: [ form extent ~= aPoint ]) ifTrue: [
		form _ Form extent: aPoint depth: Display depth ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:34' prior: 50345627!
                      bounds: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPosition: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPosition: newBounds topLeft; morphExtent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self morphExtent: newExtent; morphPosition: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:43' prior: 50345650!
                     extent
"Needs to be turned into extentInOwner and extentInWorld"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self validateNotSent.
	^ bounds extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 14:57' prior: 50345660!
                             extent: aPoint
"Needs to be turned into extentInOwner: and extentInWorld:"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
"(when deleting, delete all inheritance!!)"
	self flag: #jmvVer2.
	self validateNotSent.
	self basicExtent: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50345681!
                              height
	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphHeight"
	self validateNotSent.
	^ bounds height! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50345689!
          height: aNumber
	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphHeight:"
	self validateNotSent.
	self morphExtent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:25' prior: 50345211!
                             morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50345231!
 morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = bounds topLeft ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	self validateOwnerNotNil.


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50345285!
                morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - bounds topLeft.
		^ self ].		"Null change"


	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:25' prior: 50345375!
                         morphWidth: aNumber
"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: aNumber asInteger@bounds height.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:36' prior: 50345787!
  width

	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphWidth"
	self validateNotSent.
	^ bounds width! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:37' prior: 50345795!
            width: aNumber

	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphWidth:"
	self validateNotSent.
	self morphExtent: aNumber asInteger@bounds height! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 12/16/2011 10:25' prior: 16898966!
                           resizeMorph: evt 
	| handle |
	handle := HandleMorph new 
				forEachPointDo: [:newPoint | self morphExtent: newPoint - bounds topLeft].
	evt hand attachMorph: handle.
	handle startStepping! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:27' prior: 50346776!
                              createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result morphExtent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result bounds: (14@25 corner: 257@84).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:23' prior: 16852887!
   initialize

	super initialize.
	self morphExtent: 271@121.
	responseUponCancel := ''
	! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:36' prior: 50346855!
                      addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleMorph new
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph morphExtent y + 5).
	nameBackground bounds: (nameMorph bounds outsetBy: 2).
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:41' prior: 50345954!
          doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target morphExtent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle extent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:43' prior: 50345975!
                            doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle morphExtent // 2).
	self someSubmorphPositionOrExtentChanged! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:44' prior: 16864328!
                         strokeGrow: evt with: growHandle
	| dir |
	evt keyValue = 28 ifTrue:[dir _ -1@0].
	evt keyValue = 29 ifTrue:[dir _ 1@0].
	evt keyValue = 30 ifTrue:[dir _ 0@-1].
	evt keyValue = 31 ifTrue:[dir _ 0@1].
	dir ifNil:[^self].
	evt hand obtainHalo: self.
	evt hand newKeyboardFocus: growHandle.
	target morphExtent: target morphExtent + dir.
	self someSubmorphPositionOrExtentChanged.! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:23' prior: 16865798!
          initialize
	"initialize the state of the receiver"
	super initialize.
	self morphExtent: 12 @ 12! !
!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:23' prior: 16867385!
     contents: aString
	contents _ aString.
	paragraph _ Paragraph new.
	paragraph
		setModel: (TextModel withText: contents asText);
		extentForComposing: 9999999@9999999.
	paragraph composeAll.
	self morphExtent: paragraph usedExtent + 8! !
!ImageMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:33' prior: 16867769!
extent: aPoint
	"Do nothing; my extent is determined by my image Form."

	self validateNotSent.! !
!InnerPluggableMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 16869736!
  adjustExtent

	self submorphBounds ifNotNil: [ :r |
		self morphExtent: r bottomRight - bounds topLeft ]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 50346913!
                  adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ bounds topLeft..
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m bounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self morphExtent: w@y! !
!InnerListMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 16869701!
   adjustExtent
	"Adjust our height to match the underlying list,
	but make it wider if neccesary to fill the available width in our PluggableListMorph
	(this is needed to make the selection indicator no narrower than the list)"
	self morphExtent:
		self desiredWidth @ ((listItems size max: 1) * font height)
! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 16870247!
                   adjustExtent
	"This is just a suggestion. If we do wordwrap, the width will be honored.
	But the height is whatever is appropriate for the contents!!"
	self morphExtent: owner viewableBounds extent! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:24' prior: 16870331!
  extentForComposing
	self flag: #jmvVer2.	"like #extent ..."
	^wrapFlag
		ifTrue: [ bounds width @ 9999999 ]
		ifFalse: [ 9999999@9999999 ]! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:25' prior: 16885073!
                      initialize
	super initialize.
	trackPointer _ true.
	magnification _ 2.
	lastPos _ self sourcePoint.
	self morphExtent: 128@128! !
!MagnifierMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28' prior: 16885080!
       borderWidth: anInteger
	"Grow outwards preserving innerBounds"
	| c |  
	c _ self referencePosition.
	super borderWidth: anInteger.
	super morphExtent: self defaultExtent.
	self referencePosition: c.! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 12/16/2011 10:25' prior: 16885148!
   chooseMagnification
	| result |
	result _ (SelectionMenu selections: #(1.5 2 4 8))
		startUpWithCaption: 'Choose magnification
(currently ', magnification printString, ')'.
	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].
	magnification _ result.
	self morphExtent: bounds extent. "round to new magnification"
	self redrawNeeded. "redraw even if extent wasn't changed"! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 12/16/2011 10:28' prior: 16885187!
 magnification: aNumber
	| c |  
	magnification _ aNumber min: 8 max: 0.5.
	magnification _ magnification roundTo:
		(magnification < 3 ifTrue: [0.5] ifFalse: [1]).
	srcExtent _ srcExtent min: (512@512) // magnification. "to prevent accidents"
	c _ self referencePosition.
	super morphExtent: self defaultExtent.
	self referencePosition: c.! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:25' prior: 50346207!
                         adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each morphWidth])].

	w _ w + 4.
	tl _ bounds topLeft.
	p _ tl + 5.
	submorphs do: [ :m |
		m morphWidth: w.
		m morphPosition: p.
		p _ m bounds bottomLeft +(0@1) ].
	
	self morphExtent: submorphs last bounds bottomRight - tl + 5! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:25' prior: 16894905!
           fitContents

	| newBounds boundsChanged |
	newBounds _ self measureContents.
	boundsChanged _ bounds extent ~= newBounds.
	self morphExtent: newBounds.		"default short-circuits if bounds not changed"
	boundsChanged ifFalse: [ self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:25' prior: 16906283!
            fitContents

	| newBounds boundsChanged |
	newBounds _ self measureContents.
	boundsChanged _ bounds extent ~= newBounds.
	self morphExtent: newBounds.		"default short-circuits if bounds not changed"
	boundsChanged ifFalse: [ self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32' prior: 50346260!
                   extent: aPoint

	self validateNotSent.
	self flag: #jmvVer2.
	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:25' prior: 16913734!
                           initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	self morphExtent: 20 @ 15! !
!PolygonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32' prior: 16916744!
                 extent: newExtent 
	"Not really advisable, but we can preserve most of the geometry if we don't
	shrink things too small."
	| safeExtent center |
	self validateNotSent.
	center _ self referencePosition.
	safeExtent _ newExtent max: 20@20.
	self setVertices: (vertices collect:
		[:p | p - center * (safeExtent asFloatPoint / (bounds extent max: 1@1)) + center])! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:39' prior: 16923517!
                        initialize
	super initialize.
	self separation: 0.
	labelMorph _ StringMorph contents: '' font: AbstractFont default.
	subLabelMorph _ StringMorph contents: '' font: AbstractFont default.
	progress_ ProgressBarMorph new.
	progress morphExtent: 200 @ 15.
	self addMorph: labelMorph.
	self addMorph: subLabelMorph.
	self addMorph: progress fixedHeight: 15.! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:33' prior: 50346377!
         expandSlider
	"Compute the new size of the slider (use the old sliderThickness as a minimum)."
	| r |
	r _ self totalSliderArea.
	slider morphExtent: (bounds isWide
		ifTrue: [((r width * interval) asInteger max: 7) @ slider morphHeight]
		ifFalse: [slider morphWidth @ ((r height * interval) asInteger max: 7)])! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/10/2012 15:11' prior: 16934926!
                    extent: newExtent
	| newExtentToUse |
	self validateNotSent.
	newExtent = bounds extent ifTrue: [^ self].
	newExtentToUse _ bounds isWide
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = bounds extent ifTrue: [^ self].
	super extent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!SketchMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:26' prior: 16939955!
                            initializeWith: aForm

	super initialize.
	originalForm _ aForm.
	self morphExtent: originalForm extent.
! !
!Sonogram methodsFor: 'all' stamp: 'jmv 12/16/2011 10:26' prior: 16947359!
        extent: extent minVal: min maxVal: max scrollDelta: d
	minVal _ min.
	maxVal _ max.
	scrollDelta _ d.
	self morphExtent: extent.

" try following with scrolldelta = 1, 20, 200
	| s data |
	s _ Sonogram new extent: 200@50
				minVal: 0.0 maxVal: 1.0 scrollDelta: 20.
	World addMorph: s.
	data _ (1 to: 133) collect: [:i | 0.0].
	1 to: 300 do:
		[:i | data at: (i\\133)+1 put: 1.0.
		s plotColumn: data.
		data at: (i\\133)+1 put: 0.0.
		World doOneCycleNow].
	s delete	
"! !
!Sonogram methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:33' prior: 16947407!
                      extent: newExtent
	self validateNotSent.
	super image: (Form extent: newExtent depth: Display depth).
	lastX _ -1.
	columnForm _ Form extent: (32//image depth)@(image height) depth: image depth.
	pixValMap _ ((1 to: 256) collect:
			[ :i | columnForm pixelValueFor: (Color gray: (256-i)/255.0)])
		as: Bitmap.
! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:26' prior: 16957368!
                  fitContents

	| newBounds boundsChanged |
	newBounds _ self measureContents.
	boundsChanged _ bounds extent ~= newBounds.
	self morphExtent: newBounds.		"default short-circuits if bounds not changed"
	boundsChanged ifFalse: [self redrawNeeded]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/16/2011 10:48' prior: 50344728!
                      makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [ self morphPosition: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [ self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].

! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:26' prior: 50346390!
                    initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	self morphExtent: 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:35' prior: 50347228!
                  initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing box |
	spacing _ self boxExtent x + 2.

	box _ self createCloseBox.
	self addMorph: box.
	box morphPosition: 2@2.
	box morphExtent: self boxExtent.

	box _ self createCollapseBox.
	self addMorph: box.
	box morphPosition: spacing+2@2.
	box morphExtent: self boxExtent.

	box _ self createExpandBox.
	self addMorph: box.
	box morphPosition: spacing*2+2@2.
	box morphExtent: self boxExtent.

	box _ self createMenuBox.
	self addMorph: box.
	box morphPosition: spacing*3+2@2.
	box morphExtent: self boxExtent.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/16/2011 10:41' prior: 50347260!
                     openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; morphExtent: extent.
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 12/16/2011 10:26' prior: 16969050!
                              buildMorphicWindow
	"TestRunner new openAsMorph"

	self layoutMorph
		addMorph: self buildUpperControls proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.75.
	self setLabel: 'SUnit Test Runner'.
	self refreshWindow.
	self morphExtent: 460 @ 400! !

FillInTheBlankMorph removeSelector: #morphExtent:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1323-M3Prep-extentFalsePolymorphism-jmv.4.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 3:16:49 pm'!
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/16/2011 15:24' prior: 50342529!
                       aboutToBeGrabbedBy: aHand
	"The receiver is being grabbed by a hand.
	Perform necessary adjustments (if any) and return the actual morph
	that should be added to the hand."

	^self "Grab me"! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/16/2011 15:23' prior: 16896895!
        justDroppedInto: aMorph event: anEvent 
	"This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"

	aMorph activateWindow.
	self isInWorld  ifTrue: [
		self world startSteppingSubmorphsOf: self ].
	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/16/2011 15:22' prior: 16896924!
                   rejectDropMorphEvent: evt
	"The receiver has been rejected, and must be put back somewhere. 
	Just keep it in the hand"

	^evt hand grabMorph: self! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/16/2011 14:58' prior: 16899514!
                removeAllMorphs
	| oldMorphs |
	submorphs isEmpty ifTrue: [ ^self ].
	self redrawNeeded.
	submorphs do: [ :m |
		m privateOwner: nil ].
	oldMorphs _ submorphs.
	submorphs _ #().
	oldMorphs do: [ :m |
		self removedMorph: m ].
	self someSubmorphPositionOrExtentChanged! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/16/2011 15:27' prior: 16899529!
                        removeAllMorphsIn: aCollection
	"greatly speeds up the removal of *lots* of submorphs"
	| set |
	aCollection isEmpty ifTrue: [ ^self ].
	set _ IdentitySet new: aCollection size * 4 // 3.
	aCollection do: [ :each | each owner == self ifTrue: [ set add: each ]].
	set isEmpty ifTrue: [ ^self ].
	self redrawNeeded.
	set do: [ :m | m privateOwner: nil ].
	submorphs _ submorphs reject: [ :each | set includes: each].
	set do: [ :m | self removedMorph: m ].
	self someSubmorphPositionOrExtentChanged! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/16/2011 15:24' prior: 50346881!
                   attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m bounds extent // 2.
	m morphPosition: (self morphPosition - delta).
	targetOffset _ m morphPosition - self morphPosition.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/16/2011 15:20' prior: 50343170!
                              dropMorph: aMorph event: anEvent
	"Drop the given morph which was carried by the hand"
	| event |
	(anEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue: [ ^self ].
	event _ DropEvent new setPosition: self morphPosition contents: aMorph hand: self.
	self sendEvent: event.
	event wasHandled ifFalse: [ aMorph rejectDropMorphEvent: event ].
	self mouseOverHandler processMouseOver: anEvent! !
!MenuItemMorph methodsFor: 'grabbing' stamp: 'jmv 12/16/2011 15:24' prior: 16887044!
                         aboutToBeGrabbedBy: aHand
	"Don't allow the receiver to act outside a Menu"
	| menu box |
	(owner notNil and: [ owner submorphs size = 1]) ifTrue:[
		"I am a lonely menuitem already; just grab my owner"
		owner stayUp.
		^owner aboutToBeGrabbedBy: aHand ].
	box _ bounds.
	menu _ MenuMorph new defaultTarget: nil.
	menu addMorphFront: self.
	menu bounds: box.
	menu stayUp.
	self isSelected: false.
	^menu! !

Morph removeSelector: #formerOwner!

Morph removeSelector: #formerOwner!

Morph removeSelector: #formerOwner:!

Morph removeSelector: #formerOwner:!

Morph removeSelector: #formerPosition!

Morph removeSelector: #formerPosition!

Morph removeSelector: #formerPosition:!

Morph removeSelector: #formerPosition:!

Morph removeSelector: #slideBackToFormerSituation:!

Morph removeSelector: #slideBackToFormerSituation:!

Morph removeSelector: #vanishAfterSlidingTo:event:!

Morph removeSelector: #vanishAfterSlidingTo:event:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1324-M3Prep-Cleanup-jmv.3.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1261] on 10 April 2012 at 3:33:56 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:41'!
                 validateExtentAndBounds
	"To be removed. Just to check consistency"
	| answer1 answer2 |
	self flag: #jmvVer2.

"	answer1 _ owner
		ifNotNil: [ owner externalizeDistanceToWorld: extent ]
		ifNil: [ extent ]."
	answer1 _ extent.
	answer2 _ bounds extent.

	answer1 = answer2 ifFalse: [
		#validateExtentAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]! !
!Morph methodsFor: 'change reporting' stamp: 'jmv 12/16/2011 15:54' prior: 16896355!
        privateInvalidateMorph: aMorph
	"Private. Invalidate the given morph after adding or removing.
	This method is private because a) we're invalidating the morph 'remotely'
	and b) it forces a fullBounds computation which should not be necessary
	for a general morph c) the morph may or may not actually invalidate
	anything (if it's not in the world nothing will happen) and d) the entire
	mechanism should be rewritten."

	"Is this needed at all?"
	self flag: #jmvVer2.
	aMorph layoutSubmorphsAndComputeFullBounds.

	aMorph redrawNeeded! !
!Morph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 16:39' prior: 16896621!
                         drawErrorOn: aCanvas
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	w _ 10.
	r _ bounds truncated.
	aCanvas
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	aCanvas line: r topLeft +w to: r bottomRight -w width: w color: Color yellow.
	aCanvas line: r topRight + (w negated @ w) to: r bottomLeft + (w @ w negated) width: w color: Color yellow.! !
!Morph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 16:51' prior: 16896670!
   fullDrawOn: aCanvas
	"Draw the full Morphic structure on the given Canvas"

	self visible ifFalse: [^ self].
	(aCanvas isVisible: self fullBounds) ifFalse:[^self].		"Needs fullBounds 'in owner' if inside a scroller"
	self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].

	"Draw receiver itself"
	(aCanvas isVisible: bounds) ifTrue: [
		aCanvas clipBy: bounds during: [ :c | self drawOn: c ]].	"Needs bounds 'in owner' if inside a scroller"
	self drawSubmorphsOn: aCanvas.
	self drawDropHighlightOn: aCanvas.
	self drawMouseDownHighlightOn: aCanvas! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:54' prior: 50345596!
       basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	
	
	self validateExtentAndBounds.
	extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	bounds _ bounds topLeft extent: aPoint.
	extent _ aPoint.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:45' prior: 50347298!
           morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	self validateExtentAndBounds.
	^ extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:50' prior: 50345205!
                     morphHeight

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self validateExtentAndBounds.
	^ extent y! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:47' prior: 50347523!
                   morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!
Besides, #asInteger???"
	self flag: #jmvVer2.
	self morphExtent: self morphWidth@aNumber asInteger! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:42' prior: 50345218!
         morphPositionInOwner
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"

	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	^ position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:42' prior: 50347530!
      morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = bounds topLeft ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	self validateOwnerNotNil.


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:43' prior: 50345267!
              morphPositionInWorld
	| answer1 answer2 |
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.
	{ answer1 . answer2 }.

	^answer2! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:43' prior: 50347563!
  morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - bounds topLeft.
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:48' prior: 50345369!
                        morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self validateExtentAndBounds.
	^ extent x! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:49' prior: 50347645!
                    morphWidth: aNumber

"Ensure everybody wants owner's coordinates!!
Besides, #asInteger???"
	self flag: #jmvVer2.
	self morphExtent: aNumber asInteger@self morphHeight! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:36' prior: 50347312!
         validateNotSent
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
"	Count ifNil: [ Count _ 0 ].
	Count _ Count + 1.
	Count < 10 ifTrue: ["
		'-----False polymorphism. Should not be sent!!-----' print.
		thisContext printStack: 10 
	"]"! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 12/16/2011 16:30' prior: 16897947!
           fullContainsPoint: aPoint
"
	This alternative implementation is included in this comment because it could be useful someday.
	If we start to rely heavily on the use of #ownShadowForm in #containsPoint, this could be cheaper.
	
	| shadow |
	self clipSubmorphs
		ifTrue: [ ^self containsPoint: aPoint ]
		ifFalse: [
			(self fullBounds containsPoint: aPoint) ifFalse: [^ false].
			(self containsPoint: aPoint) ifTrue: [^ true].
			shadow _ self shadowForm.
			^(shadow pixelValueAt: aPoint - shadow offset) > 0 ]
"
	
	self flag: #jmvVer2.
	"Is the comment relevant now?"
	
	(self fullBounds containsPoint: aPoint) ifFalse: [ ^ false ].  "quick elimination"
	(self containsPoint: aPoint) ifTrue: [ ^ true ].  "quick acceptance"
	submorphs do: [:m | (m fullContainsPoint: aPoint) ifTrue: [ ^ true ]].
	^ false
! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 16:42' prior: 50345830!
  initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	bounds _ self defaultBounds.

	position _ bounds topLeft.
	extent _ bounds extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	color _ self defaultColor! !
!Morph methodsFor: 'layout' stamp: 'jmv 12/16/2011 15:56' prior: 16898429!
                             computeFullBounds
	"Private. Compute the actual full bounds of the receiver"

	"Remove when removing fullBounds"
	self flag: #jmvVer2.

	(submorphs isEmpty or: [ self clipsSubmorphs ]) ifTrue: [ ^bounds ].
	^ bounds quickMerge: self submorphBounds! !
!Morph methodsFor: 'layout' stamp: 'jmv 12/16/2011 15:56' prior: 16898456!
                          layoutSubmorphsAndComputeFullBounds
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.

	fullBounds ifNotNil: [ ^self ].

	"Errors at this point can be critical so make sure we catch 'em all right"
	[
		self layoutSubmorphs.
		fullBounds _ self computeFullBounds.
	] on: Exception do: [ :ex |
		"This should do it unless you don't screw up the bounds"
		fullBounds _ bounds.
		ex pass ]! !
!Morph methodsFor: 'layout' stamp: 'jmv 12/16/2011 16:31' prior: 16898480!
                   submorphBounds
	"Private. Compute the actual full bounds of the receiver"

	"Remove when removing fullBounds? Reimplement?"
	self flag: #jmvVer2.

	^submorphs inject: nil into: [ :prevBox :m |
		m visible
			ifTrue: [ m fullBounds quickMerge: prevBox ]
			ifFalse: [ prevBox ] ]! !
!Morph methodsFor: 'updating' stamp: 'jmv 12/16/2011 16:00' prior: 16899672!
                         redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Just ours, or include submorphs if we don't clip.
	Think about it. We don't to know about a specific rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"
	
	"This method is the only real use of ivar fullBounds, other than senders of #fullBounds"

	self invalidRect: (fullBounds ifNil: [ bounds ])! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:07' prior: 50345869!
      privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
			
	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			bounds _ position extent: extent.
			fullBounds _ nil.
			self validatePositionAndBounds.
			self validateExtentAndBounds.
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					bounds _ (owner externalizeToWorld: position) extent: extent.
					fullBounds _ nil.
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]]! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:09' prior: 16863547!
                        drawOn: aCanvas
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: (color alpha: 0.57)
		at: bounds topLeft.! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 12/16/2011 17:08' prior: 50342868!
                step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target bounds]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = bounds
		ifTrue: [^ self].
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newBounds extent = extent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating ifFalse: [
		submorphs size > 1
			ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self bounds: newBounds! !
!HaloMorph methodsFor: 'updating' stamp: 'jmv 12/16/2011 17:09' prior: 16863947!
      redrawNeeded
	"Quicker to invalidate handles individually if target is large (especially the world)"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
	extent > (200@200)
		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [
					"Invalidate 4 outer strips first, thus subsuming separate damage."
					(self fullBounds areasOutside: target bounds) do:
						[ :r | self invalidRect: r ]].
				self submorphsDo: [:m | m redrawNeeded]]
		ifFalse: [ super redrawNeeded ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:09' prior: 50347728!
                               doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target morphExtent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle morphExtent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 16:42' prior: 50346002!
                initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	bounds _ 0@0 extent: CursorWithMask normal extent.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 17:11' prior: 16867738!
      borderWidth: bw
	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ 2 * bw + image extent.
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ]! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:11' prior: 50347327!
     morphExtent: aPoint
	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	"Resist changing the extent if no wordwrap.. this should be checked."
	wrapFlag ifFalse: [ ^ self ].
	newExtent _ aPoint truncated max: self minimumExtent.
	
	"No change of wrap width"
	newExtent x = extent x ifTrue: [ ^ self ].

	super morphExtent: newExtent.
	
	self resetParagraph.
	self editor recomputeSelection.	
	self updateFromParagraph.! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:11' prior: 16870337!
          fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).
	extent = newExtent ifFalse: [
		self basicExtent: newExtent.
		self redrawNeeded.	"Too conservative: only paragraph composition
								should cause invalidation."
		].

	owner innerHeight: newExtent y! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 12/16/2011 17:00' prior: 50347879!
              chooseMagnification
	| result |
	result _ (SelectionMenu selections: #(1.5 2 4 8))
		startUpWithCaption: 'Choose magnification
(currently ', magnification printString, ')'.
	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].
	magnification _ result.
	self morphExtent: extent. "round to new magnification"
	self redrawNeeded. "redraw even if extent wasn't changed"! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 16:42' prior: 50346198!
         initialize
	super initialize.
	bounds _ 0@0 corner: 40@10.
	position _ 0@0.
	extent _ 40@10.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 17:00' prior: 50347931!
                      fitContents

	| newExtent |
	newExtent _ self measureContents.
	self validateExtentAndBounds.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 17:11' prior: 50347942!
                fitContents

	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ self measureContents.
	self validateExtentAndBounds.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:10' prior: 50347350!
                       morphExtent: aPoint

	self flag: #jmvVer2.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self validateExtentAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PasteUpMorph methodsFor: 'misc' stamp: 'jmv 12/16/2011 17:10' prior: 16911938!
      buildMagnifiedBackgroundImage
	| image old |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	old _ backgroundImage.
	backgroundImageData
		ifNil: [ backgroundImage _ nil ]
		ifNotNil: [ 
			image _ Form fromBinaryStream: backgroundImageData readStream.
			backgroundImage _ image magnifyTo: extent.
			self canvas ifNotNil: [ :c |
				(backgroundImage depth = 32 and: [ c depth < 32 ]) ifTrue: [
					backgroundImage _ backgroundImage orderedDither32To16 ]]
		].
	old == backgroundImage ifFalse: [
		self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/16/2011 16:43' prior: 50346278!
           viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
"	super morphPosition: newViewBox topLeft."
	fullBounds _ bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/16/2011 15:45' prior: 16912487!
                          restoreMorphicDisplay
	DisplayScreen startUp.
	self
		morphExtent: Display extent;
		viewBox: Display boundingBox;
		handsDo: [ :h | h visible: true ];
		fullRepaintNeeded.
	WorldState addDeferredUIMessage: [ Cursor normal show ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 1/3/2012 16:22' prior: 50335464!
                              draw3DLookOn: aCanvas

	| w f center x y borderStyleSymbol c availableW l labelMargin |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: bounds
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:03' prior: 16913532!
  drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ bounds center.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawStringEmbossed: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: colorForLabel ]! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:03' prior: 16913780!
                               magnifiedIcon
	| b |
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		self isRoundButton
			ifFalse: [ ^ magnifiedIcon ].
		b _ extent x max: extent y.
		b < icon extent x ifTrue: [
			magnifiedIcon _ icon magnifyTo: b@b ].
		b /  icon extent x > 1.7
			ifTrue: [	
				b _ b * 3 // 4.
				magnifiedIcon _ icon magnifyTo: b @ b]].
	^magnifiedIcon! !
!PolygonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:09' prior: 50347392!
              morphExtent: newExtent 
	"Not really advisable, but we can preserve most of the geometry if we don't
	shrink things too small."
	| safeExtent center |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	center _ self referencePosition.
	safeExtent _ newExtent max: 20@20.
	self setVertices: (vertices collect:
		[:p | p - center * (safeExtent asFloatPoint / (extent max: 1@1)) + center])! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 16:43' prior: 50346347!
                         computeBounds
	| oldBounds delta excludeHandles |

	self flag: #jmvVer2.
	vertices ifNil: [^ self].

	self redrawNeeded.
	oldBounds _ bounds.
	self releaseCachedState.
	bounds _ self curveBounds truncated.
	self arrowForms do: [ :f |
		bounds _ bounds merge: (f offset extent: f extent)].
	handles ifNotNil: [ self updateHandles ].

	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"
	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [
		excludeHandles _ IdentitySet new.
		handles ifNotNil: [excludeHandles addAll: handles].
		self submorphsDo: [ :each |
			(excludeHandles includes: each) ifFalse: [
				each morphPosition: each morphPosition + delta ] ] ].
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 4/10/2012 15:31' prior: 16917386!
                              filledForm
	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."
	| bb origin |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	closed ifFalse: [^ filledForm _ nil].
	filledForm ifNotNil: [^ filledForm].
	filledForm _ ColorForm extent: extent+2.

	"Draw the border..."
	bb _ (BitBlt current toForm: filledForm) sourceForm: nil; fillColor: Color black;
			combinationRule: Form over; width: 1; height: 1.
	origin _ bounds topLeft asIntegerPoint-1.
	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin
										to: p2 asIntegerPoint-origin].

	"Fill it in..."
	filledForm _ ColorForm mappingWhiteToTransparentFrom: filledForm anyShapeFill.

	borderColor mightBeTranslucent ifTrue: [
		"If border is stored as a form, then erase any overlap now."
		filledForm
			copy: self borderForm boundingBox
			from: self borderForm
			to: 1@1
			rule: Form erase ].

	^ filledForm! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/10/2012 15:31' prior: 50347405!
                      morphExtent: newExtent

	| newExtentToUse |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent = extent ifTrue: [^ self].
	newExtentToUse _ bounds isWide
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 16:56' prior: 50348082!
                           fitContents

	| newExtent |
	newExtent _ self measureContents.
	self validateExtentAndBounds.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:04' prior: 50348093!
                        makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [ self morphPosition: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [ self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft].

! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:04' prior: 50347437!
 morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent].
	isCollapsed
		ifTrue: [collapsedFrame _ bounds]
		ifFalse: [fullFrame _ bounds]! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 12/16/2011 15:50' prior: 16965787!
          layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| bl br h thickness tl tr w cornerExtent |
	thickness _ 4.
	cornerExtent _ 20.
	tl _ bounds topLeft.
	tr _ bounds topRight.
	bl _ bounds bottomLeft.
	br _ bounds bottomRight.
	w _ bounds width - cornerExtent - cornerExtent.
	h _ bounds height - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) bounds: (tl + (cornerExtent@0) extent: w@thickness).
	(adjusters at: #bottomAdjuster) bounds: (bl+ (cornerExtent @ thickness negated) extent: w@thickness).
	(adjusters at: #leftAdjuster) bounds: (tl+ (0@cornerExtent) extent: thickness@h).
	(adjusters at: #rightAdjuster) bounds: (tr + (thickness negated@ cornerExtent) extent: thickness@h).
	(adjusters at: #topLeftAdjuster) bounds: (tl extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomLeftAdjuster) bounds: (bl-(0@cornerExtent) extent: cornerExtent@cornerExtent).
	(adjusters at: #topRightAdjuster) bounds: (tr+(cornerExtent negated@0) extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomRightAdjuster) bounds: (br-cornerExtent extent: cornerExtent@cornerExtent).

	layoutMorph ifNotNil: [
		layoutMorph bounds: self layoutBounds ]! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:10' prior: 16978408!
                              drawOn: aCanvas
	"
	Transcript
		showOnDisplay: true;
		bounds: bounds;
		displayOn: aCanvas form.
	"
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	Transcript
		showOnDisplay: true;
		bounds: (0@0 extent: extent);
		displayOn: form;
		bounds: bounds.
	aCanvas image: form at: bounds origin! !

TranscriptMorph removeSelector: #extent:!

TranscriptMorph removeSelector: #extent:!

SystemWindow removeSelector: #extent:!

SystemWindow removeSelector: #extent:!

Sonogram removeSelector: #extent:!

Sonogram removeSelector: #extent:!

ScrollBar removeSelector: #extent:!

ScrollBar removeSelector: #extent:!

PolygonMorph removeSelector: #extent:!

PolygonMorph removeSelector: #extent:!

LimitedHeightTextMorph removeSelector: #extent:!

LimitedHeightTextMorph removeSelector: #extent:!

PluggableScrollPane removeSelector: #extent:!

PluggableScrollPane removeSelector: #extent:!

PluggableButtonMorph removeSelector: #extent:!

PluggableButtonMorph removeSelector: #extent:!

PasteUpMorph removeSelector: #extent:!

PasteUpMorph removeSelector: #extent:!

MagnifierMorph removeSelector: #extent:!

MagnifierMorph removeSelector: #extent:!

InnerTextMorph removeSelector: #extent:!

InnerTextMorph removeSelector: #extent:!

ImageMorph removeSelector: #extent:!

ImageMorph removeSelector: #extent:!

Morph removeSelector: #extent!

Morph removeSelector: #extent!

Morph removeSelector: #extent:!

Morph removeSelector: #extent:!

Morph removeSelector: #height!

Morph removeSelector: #height!

Morph removeSelector: #height:!

Morph removeSelector: #height:!

Morph removeSelector: #width!

Morph removeSelector: #width!

Morph removeSelector: #width:!

Morph removeSelector: #width:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1325-M3Prep-StartUsingNewIvars-jmv.4.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1261] on 10 April 2012 at 3:48:51 pm'!
!CodeProvider methodsFor: 'categories' stamp: 'jmv 1/2/2012 14:32' prior: 16813859!
            methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!CodeProvider methodsFor: 'contents' stamp: 'jmv 1/2/2012 14:31' prior: 16813872!
              acceptedContentsChanged

	self changed: #acceptedContents.
	self changed: #decorateButtons.
	self triggerEvent: #annotationChanged! !
!Browser methodsFor: 'accessing' stamp: 'jmv 1/2/2012 14:31' prior: 16793751!
            contents: input notifying: aController
	"The retrieved information has changed and its source must now be
	 updated. The information can be a variety of things, depending on
	 the list selections (such as templates for class or message definition,
	 methods) or the user menu commands (such as definition, comment,
	 hierarchy).  Answer the result of updating the source."

	| aString aText theClass |
	aString _ input asString.
	aText _ input asText.
	editSelection == #editSystemCategories ifTrue: [ ^ self changeSystemCategories: aString ].
	editSelection == #editClass | (editSelection == #newClass) ifTrue: [ ^ self defineClass: aString notifying: aController ].
	editSelection == #editComment
		ifTrue: [
			theClass _ self selectedClass.
			theClass
				ifNil: [
					self inform: 'You must select a class
before giving it a comment.'.
					^ false].
			theClass comment: aText stamp: Utilities changeStamp.
			self changed: #classCommentText.
			^ true].
	editSelection == #hierarchy ifTrue: [ ^ true ].
	editSelection == #editMessageCategories ifTrue: [ ^ self changeMessageCategories: aString ].
	editSelection == #editMessage | (editSelection == #newMessage)
		ifTrue: [
			^ self okayToAccept
				ifFalse:[ false ]
				ifTrue: [
					(self compileMessage: aText notifying: aController)
						ifTrue: [ self triggerEvent: #annotationChanged ];
						yourself ]].
	editSelection == #none
		ifTrue: [
			self inform: 'This text cannot be accepted
in this part of the browser.'.
			^ false].
	self error: 'unacceptable accept'! !
!Browser methodsFor: 'initialize-release' stamp: 'jmv 1/2/2012 14:32' prior: 16794358!
       methodCategoryChanged
	self changed: #messageCategoryList.
	self changed: #messageList.
	self triggerEvent: #annotationChanged.
	self messageListIndex: 0! !
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/4/2012 19:01' prior: 16861541!
   buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ RectangleMorph new.
	outerBox
		extent: finalSizeInteger asPoint * resizeFactor;
		borderWidth: 0;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox bounds.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPosition: outerBox bounds center - (arrowMorph morphExtent // 2).
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!MessageSet methodsFor: 'message functions' stamp: 'jmv 1/2/2012 14:33' prior: 16890744!
                   methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!MessageSet methodsFor: 'private' stamp: 'jmv 1/2/2012 14:34' prior: 16890886!
                 contents: aString notifying: aController 
	"Compile the code in aString. Notify aController of any syntax errors. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."

	| category selector class oldSelector |
	self okayToAccept ifFalse: [^ false].
	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].
	class ifNil: [^ false].
	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue:
		[oldSelector == #Comment ifTrue:
			[class comment: aString stamp: Utilities changeStamp.
			self triggerEvent: #annotationChanged.
 			self changed: #clearUserEdits.
			^ false].
		oldSelector == #Definition ifTrue:
			["self defineClass: aString notifying: aController."
			class subclassDefinerClass
				evaluate: aString
				notifying: aController
				logged: true.
			self changed: #clearUserEdits.
 			^ false].
		oldSelector == #Hierarchy ifTrue:
			[self inform: 'To change the hierarchy, edit the class definitions'. 
			^ false]].
	"Normal method accept"
	category _ class organization categoryOfElement: oldSelector.
	selector _ class compile: aString
				classified: category
				notifying: aController.
	selector
		ifNil: [^ false].
	selector == oldSelector ifFalse: [
		self reformulateListNoting: selector].
	self triggerEvent: #annotationChanged.
	^ true! !
!Morph methodsFor: 'geometry' stamp: 'jmv 1/2/2012 15:13' prior: 50348342!
                  validateExtentAndBounds
	"To be removed. Just to check consistency"
	| answer1 answer2 |
	self flag: #jmvVer2.

"	answer1 _ owner
		ifNotNil: [ owner externalizeDistanceToWorld: extent ]
		ifNil: [ extent ]."
	answer1 _ extent.
	answer2 _ bounds extent.

	answer1 = answer2 rounded ifFalse: [
		#validateExtentAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 1/1/2012 23:28' prior: 50345382!
          validateOwnerNotNil
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
"
	owner ifNil: [
		'-----Still no owner, but this stuff kind of requires it!!-----' print.
		thisContext printStack: 10 ]
	"! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 1/4/2012 18:59' prior: 16783547!
                 resetMenu
	| w f |
	firstVisible _ 1.
	self selected: 1.
	w _ 120.
	f _ self class listFont.
	1
		to: completer entryCount
		do: [ :index |
			w _ w max: (f widthOfString: (completer entries at: index) asString)].
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w + ScrollBar scrollbarThickness ].
	self morphExtent: w + 4 @ (self visibleItemsCount * self itemHeight+2)! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 1/2/2012 14:31' prior: 16814856!
      buildMorphicAnnotationsPane

	| aTextMorph |
	aTextMorph _ TextModelMorph
		textProvider: model
		textGetter: #annotation.
	model when: #annotationChanged send: #redrawNeeded to: aTextMorph.
	aTextMorph
		askBeforeDiscardingEdits: false;
		hideScrollBarsIndefinitely.
	^aTextMorph! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 1/2/2012 13:46' prior: 50343362!
          mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt translatedBy: bounds topLeft negated)].
	(evt eventPosition y between: owner bounds top and: owner bounds bottom) ifFalse: [
		owner scrollSelectionIntoView: evt ]! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 1/2/2012 13:09' prior: 16870415!
                               updateFromParagraph
	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, and current typing emphasis."

	paragraph ifNotNil: [
		editor storeSelectionInParagraph.
		self fit.
	].

	owner
		updateScrollBarsBounds;
		setScrollDeltas! !
!LayoutAdjustingMorph methodsFor: 'testing' stamp: 'jmv 1/3/2012 14:10' prior: 16879830!
        isOpaqueMorph
	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)
	but is not an opaque rectangle covering bounds MUST answer false to this message"
	color mightBeTranslucent ifTrue: [
		^false ].
	^true! !
!MessageSetWindow methodsFor: 'top window' stamp: 'jmv 1/2/2012 15:36' prior: 16891448!
                  activateAndSendTopToBack: aBoolean
	super activateAndSendTopToBack: aBoolean.
	self isCollapsed 
		ifFalse: [
			(model messageListIndex = 0 and: [ model messageList notEmpty ])
				ifTrue: [	
					"Not really pretty... Cleanup some day"
					model messageListIndex: 1.
					model autoSelectString ifNotNil: [
						[ model acceptedContentsChanged ]
							forkAt: Processor userBackgroundPriority  ]
				]]! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 1/3/2012 16:40' prior: 16913899!
      example
	"PluggableButtonMorph example openInWorld"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Color lightRed.
	b2 color: Color lightRed.
	b3 color: Color lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: 120@35.
	^ row
! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/4/2012 19:00' prior: 50347373!
                               morphExtent: newExtent
	
	| minH minW |
	"Figure out the minimum width and height for this pane so that scrollbars will appear"
	minH _ self scrollBarClass scrollbarThickness * 2.
	minW _ minH.
	super morphExtent: (newExtent max: (minW@minH)).

	"Now reset widget sizes"
	scroller adjustExtent.
	self updateScrollBarsBounds.
	self setScrollDeltas! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 1/2/2012 13:49' prior: 16914420!
         selectionIndex: index
	"Called internally to select the index-th item."
	| row |
	self unhighlightSelection.
	row _ index ifNil: [ 0 ].
	row _ row min: self getListSize.  "make sure we don't select past the end"
	self listMorph selectedRow: row.
	self highlightSelection.
	self scrollSelectionIntoView! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 1/2/2012 13:49' prior: 50344913!
                      scrollSelectionIntoView: event
	"Scroll my text into view if necessary and return true, else return false"
	| selRects rectToTest cpHere |
	selRects _ self textMorph selectionRects.
	selRects isEmpty ifTrue: [ ^ self ].
	rectToTest _ selRects first merge: selRects last.
	event ifNotNil: [  "Check for autoscroll"
		cpHere _ event eventPosition.
		cpHere y <= bounds top
			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]
			ifFalse: [
				cpHere y >= bounds bottom
					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]
					ifFalse: [ ^ self ]]].
	^ self scrollToShow: rectToTest! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1326-M3Prep-LottaFixes-jmv.10.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1261] on 10 April 2012 at 3:51:44 pm'!
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 1/6/2012 15:31' prior: 50348906!
                         fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ].

	self redrawNeeded.	"Too conservative: only paragraph composition
							should cause invalidation."
	owner innerHeight: newExtent y! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/6/2012 14:52' prior: 50349677!
            morphExtent: newExtent
	
	| minH minW |
	"Figure out the minimum width and height for this pane so that scrollbars will appear"
	minH _ self vIsScrollbarShowing
		ifTrue: [self scrollBarClass scrollbarThickness * 2]
		ifFalse: [0].
	minW _ self hIsScrollbarShowing
		ifTrue: [self scrollBarClass scrollbarThickness * 2]
		ifFalse: [0].
	super morphExtent: (newExtent max: (minW@minH)).

	"Now reset widget sizes"
	scroller adjustExtent.
	self updateScrollBarsBounds.
	self setScrollDeltas! !

StringMorph removeSelector: #setWidth:!

StringMorph removeSelector: #setWidth:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1327-M3Prep-AccountForLaterCuis4Changes-jmv.5.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4209] on 11 April 2012 at 9:35:50 pm'!
!HandMorph methodsFor: 'private events' stamp: 'jmv 4/11/2012 21:35' prior: 16865561!
           generateMouseEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| pos buttons modifiers type trail stamp oldButtons |
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].
	pos := evtBuf third @ evtBuf fourth.
	buttons := evtBuf fifth.
	modifiers := evtBuf sixth.
	type := buttons = 0 
		ifTrue: [
			lastEventBuffer fifth = 0 ifTrue: [#mouseMove] ifFalse: [#mouseUp]]
		ifFalse: [
			lastEventBuffer fifth = 0 
						ifTrue: [#mouseDown]
						ifFalse: [#mouseMove]].
	buttons := buttons bitOr: (modifiers bitShift: 3).
	oldButtons := lastEventBuffer fifth 
				bitOr: (lastEventBuffer sixth bitShift: 3).
	lastEventBuffer := evtBuf.
	type == #mouseMove 
		ifTrue: [
			trail := self mouseTrailFrom: evtBuf.
			^MouseMoveEvent new 
				setType: type
				startPoint: trail first
				endPoint: trail last
				trail: trail
				buttons: buttons
				hand: self
				stamp: stamp].
	^MouseButtonEvent new 
		setType: type
		position: pos
		which: (oldButtons bitXor: buttons)
		buttons: buttons
		hand: self
		stamp: stamp! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1328-M3Prep-CleanAShadowedVar-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4209] on 11 April 2012 at 10:01:23 pm'!
!CodeProvider methodsFor: 'commands' stamp: 'jmv 4/11/2012 21:54' prior: 16813947!
                     hierarchyBrowser
	"Create and schedule a new hierarchy browser on the currently selected class or meta."

	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |
	(selectedClassOrMetaClass _ self selectedClassOrMetaClass)
		ifNil: [^ nil].
	newBrowser _ HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.
	((aSymbol _ self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])
		ifTrue: [
			aBehavior _ selectedClassOrMetaClass.
			messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.
			messageCatIndex = 0 ifFalse: [
				newBrowser messageCategoryListIndex: messageCatIndex + 1.
				newBrowser messageListIndex:
					((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol) ]].
	^newBrowser! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/11/2012 21:56' prior: 16861019!
  drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c
	| font |
	port colorMap: nil.
	font _ fontOrNil ifNil: [StrikeFont default].
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (origin + aPoint)
		strikeFont: font
		kern: font baseKern negated! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/11/2012 21:56' prior: 16861037!
               drawString: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: c
	| font portRect |
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [port clipRect: portRect. ^self].
	port clipWidth = 0 ifTrue: [port clipRect: portRect. ^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin)
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/11/2012 21:58' prior: 16861070!
                   drawStringEmbossed: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: aColor
	| font portRect insideColor |
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	insideColor _ shadowColor ifNil: [ aColor ].
	insideColor = Color black ifFalse: [ | topColor |
		topColor _ insideColor alphaMixed: 0.25 with: Color black.
		port installStrikeFont: font foregroundColor: topColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin)
			strikeFont: font
			kern: font baseKern negated ].
	insideColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ insideColor alphaMixed: 0.22 with: Color white.
		port installStrikeFont: font foregroundColor: bottomColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin + (0@2))
			strikeFont: font
			kern: font baseKern negated ].
	port installStrikeFont: font foregroundColor: insideColor.
	port
		displayString: aString asString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin + (0@1))
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/11/2012 21:51' prior: 16900483!
           displayBulletParagraphTopLeft: paragraphTopLeft number: bulletNumber
	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern _ paragraphStyle listBulletPattern.
	bullet _ pattern.
	(i _ pattern indexOf: $%) > 0
		ifTrue: [ bullet _ bulletNumber asString]
		ifFalse: [
			(i _ pattern indexOf: $z) > 0
				ifTrue: [ bullet _ (Character value: 96 + bulletNumber) asString ]
				ifFalse: [
					(i _ pattern indexOf: $Z) > 0
						ifTrue: [ bullet _ (Character value: 64 + bulletNumber) asString ]]].
	prefix _ 0.
	i > 0 ifTrue: [
		c _ pattern at: i.
		j _ i.
		s _ pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].
		j _ j - 1.
		bulletSize _ j-i+1.
		prefix _ bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos _ paragraphStyle firstIndent + paragraphTopLeft x + ((font widthOf: $9) * prefix)@destY.
	canvas grafPort displayString: bullet from: 1 to: bullet size at: bulletPos strikeFont: font kern: kern! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/11/2012 21:56' prior: 16900521!
             displayLine: textLine paragraphTopLeft: paragraphTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."
	| done stopCondition nowLeftInRun startIndex string lastPos priorFont |

	line _ textLine.
	paraTopLeft _ paragraphTopLeft + canvas origin.
	lineY _ line top + paraTopLeft y.
	lineHeight _ line lineHeight.
	rightMargin _ line rightMargin + paraTopLeft x.
	lastIndex _ line first.
	leftInRun <= 0 ifTrue: [self setStopConditions].
	leftMargin _ (line leftMarginForAlignment: alignment) + paraTopLeft x.
	destX _ runX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				""
				foregroundColor _ paragraphColor.
				priorFont _ font.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				priorFont ifNotNil: [ destX _ destX + priorFont descentKern ].
				destX _ destX - font descentKern.
				kern _ 0 - font baseKern.
				spaceWidth _ font widthOf: Character space.
				xTable _ font xTable.
				map _ font characterToGlyphMap.
				stopConditions _ DefaultStopConditions.
				canvas grafPort installStrikeFont: font foregroundColor: foregroundColor.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]
				""
			]
		].
		self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paraTopLeft.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paraTopLeft.

	lastIndex _ line first.
	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	done _ false.
	string _ text string.

	self placeEmbeddedObject.
	[ done ] whileFalse: [
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions
			kern: kern.
		lastIndex >= startIndex ifTrue: [
			canvas grafPort 
				displayString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				strikeFont: font
				kern: kern ].
		"see setStopConditions for stopping conditions for displaying."
		done _ self perform: stopCondition ].
	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !
!MorphicScanner methodsFor: 'private' stamp: 'jmv 4/11/2012 21:57' prior: 16900633!
             setFont 
	foregroundColor _ paragraphColor.
	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"
	canvas grafPort installStrikeFont: font foregroundColor: foregroundColor.
	text ifNotNil: [ destY _ lineY + line baseline - font ascent ]! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 4/11/2012 21:57' prior: 16978297!
   displayOn: aForm
	"
	Transcript displayOn: Display
	"
	| font port count i string x y fh f bw r |
	bw _ self borderWidth  .
	r _ innerRectangle outsetBy: bw + self padding.
	aForm border: r width: bw. 
	aForm fill: r fillColor: Color white.
	port _ BitBlt toForm: aForm.
	port clipWidth: innerRectangle right.
	font _ StrikeFont default.
	port installStrikeFont: font foregroundColor: Color veryDarkGray.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.
	y _ innerRectangle top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	[
		string _ entries at: i.	
		port displayString: string from: 1 to: string size at: x@y strikeFont: font kern: font baseKern negated.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.	
	port displayString: string from: 1 to: string size at: x@y strikeFont: font kern: font baseKern negated.! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 4/11/2012 21:57' prior: 16978340!
               displayUnfinishedEntryOn: aForm

	| font port count string x y fh |
	port _ BitBlt toForm: aForm.
	port clipWidth: innerRectangle right.
	font _ StrikeFont default.
	port installStrikeFont: font foregroundColor: Color black.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.

	string _ unfinishedEntry contents.
	y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerRectangle top.
	port displayString: string from: 1 to: string size at: x@y strikeFont: font kern: font baseKern negated.! !

StrikeFont removeSelector: #characters:in:displayAt:clippedBy:rule:fillColor:!

StrikeFont removeSelector: #characters:in:displayAt:clippedBy:rule:fillColor:!

StrikeFont removeSelector: #displayLine:at:!

StrikeFont removeSelector: #displayLine:at:!

StrikeFont removeSelector: #displayString:on:from:to:at:kern:!

StrikeFont removeSelector: #displayString:on:from:to:at:kern:!

StrikeFont removeSelector: #installOn:foregroundColor:!

StrikeFont removeSelector: #installOn:foregroundColor:!

AbstractFont removeSelector: #displayString:on:from:to:at:kern:!

AbstractFont removeSelector: #displayString:on:from:to:at:kern:!

AbstractFont removeSelector: #installOn:foregroundColor:!

AbstractFont removeSelector: #installOn:foregroundColor:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1329-M3Prep-SmallTextRenderCleanup-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 7:55:17 am'!
!Theme class methodsFor: 'user interface' stamp: 'jmv 4/12/2012 07:54' prior: 50336140!
                  changeTheme

	| themes set menu result |
		themes _ Theme allSubclasses copyWith: Theme.
		set _ themes collect: [ :i | { i asString . i } ].
		menu _ SelectionMenu fromArray: set asArray.
		result _ menu startUpWithCaption: 'Choose a theme'.

	result ifNotNil: [
		result beCurrent ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1330-M3Prep-ThemeSelectionWalkbackFix-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 8:28:36 am'!
!HaloMorph methodsFor: 'private' stamp: 'jmv 4/12/2012 08:02' prior: 50346816!
                  addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle bounds: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPositionInOwner: 0@0 ]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 4/12/2012 08:11' prior: 50346962!
                   popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition - self morphPosition.
	sourceItem owner owner addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last - (self morphWidth @ 0) value: false;
		value: rightOrLeftPoint first value: true! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/12/2012 08:24' prior: 50334609!
                           cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(simpleMenus false)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/12/2012 08:24' prior: 50334628!
                             slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic true)
		(menuKeyboardControl false)
		(optionalButtons false)
		(simpleMenus false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/12/2012 08:24' prior: 50334646!
                              smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak in recent years. Caution: this theme removes the standard Squeak flaps, turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more."

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(simpleMenus false)
		(smartUpdating false)
		(thoroughSenders false)
	)! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/12/2012 08:08' prior: 50342352!
                               morphPosition: newPos

	super morphPosition: newPos.

	self flag: #jmvVer2. "Maybe this would be better done in methods storing in #bounds...
	Better yet would be to remove this crap"
	isCollapsed
		ifTrue: [ collapsedFrame _ bounds ]
		ifFalse: [ fullFrame _ bounds ]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:25' prior: 16965536!
                      collapse

	| cf |
		
	self isCollapsed ifFalse: [

		"Collapse -- remove panes from morphics structure"

		isCollapsed _ true.
		fullFrame _ bounds.

		"First save latest fullFrame"
		layoutMorph ifNotNil: [ layoutMorph hide ].
		cf := RealEstateAgent assignCollapseFrameFor: self.
		collapsedFrame ifNil: [
			collapsedFrame _ cf].
		self bounds: cf.
	
		Taskbar visible ifTrue: [ Taskbar minimize: self ]
	]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:24' prior: 16965573!
         expand
	self isCollapsed
		ifTrue: [
		
			"Expand -- restore panes to morphics structure"
	
			isCollapsed _ false.
			self activate.  "Bring to front first"

			collapsedFrame _ bounds.

			self bounds: fullFrame.
			layoutMorph ifNotNil: [ layoutMorph show ].
			
			Taskbar visible ifTrue: [ Taskbar restore: self. ]
		]! !

SystemWindow removeSelector: #getCollapsedFrame!

SystemWindow removeSelector: #getCollapsedFrame!

Preferences class removeSelector: #collapseWindowsInPlace!

Preferences class removeSelector: #collapseWindowsInPlace!

PasteUpMorph removeSelector: #morphPosition:!

PasteUpMorph removeSelector: #morphPosition:!

HaloMorph removeSelector: #morphPosition:!

HaloMorph removeSelector: #morphPosition:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1331-M3Prep-SimplifyWindowCollapse-jmv.3.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 8:42:41 am'!

!classDefinition: #SystemWindow category: #'Morphic-Views for Models'!
PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString collapsedFrame fullFrame isCollapsed updatablePanes widgetsColor layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString collapsedFrame fullFrame isCollapsed updatablePanes widgetsColor layoutMorph adjusters '
	classVariableNames: 'TopWindow '
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 4/12/2012 08:36' prior: 50349238!
         makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/12/2012 08:39' prior: 50344747!
                    justDroppedInto: aMorph event: anEvent
	isCollapsed
		ifTrue: [
			self morphPosition: (self morphPosition max: 0@0) ]
		ifFalse: [
			TopWindow ~~ self ifTrue: [self activate]].
	^super justDroppedInto: aMorph event: anEvent! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/12/2012 08:39' prior: 50349257!
        morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:41' prior: 50350335!
                    collapse
		
	self isCollapsed ifFalse: [

		"Collapse -- remove panes from morphics structure"

		isCollapsed _ true.
		layoutMorph ifNotNil: [ layoutMorph hide ].
		self morphExtent: 400@(self labelHeight + 2).
	
		Taskbar visible ifTrue: [ Taskbar minimize: self ]
	]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:33' prior: 50350351!
                     expand
	self isCollapsed
		ifTrue: [
		
			"Expand -- restore panes to morphics structure"
	
			isCollapsed _ false.
			self activate.  "Bring to front first"

			self morphExtent: 400@300.

			layoutMorph ifNotNil: [ layoutMorph show ].
			
			Taskbar visible ifTrue: [ Taskbar restore: self. ]
		]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:38' prior: 16965590!
                       expandBoxHit
	"The full screen expand box has been hit"

	isCollapsed ifTrue: [
		self hide.
		self collapseOrExpand.
		self fullScreen.
		^ self show].
	self fullScreen! !

SystemWindow removeSelector: #collapsedExtent!

SystemWindow removeSelector: #collapsedExtent!

SystemWindow removeSelector: #collapsedFrame!

SystemWindow removeSelector: #collapsedFrame!

SystemWindow removeSelector: #morphPosition:!

SystemWindow removeSelector: #morphPosition:!

SystemWindow removeSelector: #unexpandedFrame!

SystemWindow removeSelector: #unexpandedFrame!

SystemWindow removeSelector: #unexpandedFrame:!

SystemWindow removeSelector: #unexpandedFrame:!

!classDefinition: #SystemWindow category: #'Morphic-Views for Models'!
PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString isCollapsed updatablePanes widgetsColor layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString isCollapsed updatablePanes widgetsColor layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

RealEstateAgent class removeSelector: #assignCollapseFrameFor:!

RealEstateAgent class removeSelector: #assignCollapseFrameFor:!

RealEstateAgent class removeSelector: #assignCollapsePointFor:!

RealEstateAgent class removeSelector: #assignCollapsePointFor:!

RealEstateAgent class removeSelector: #initialFrameFor:!

RealEstateAgent class removeSelector: #initialFrameFor:!

RealEstateAgent class removeSelector: #initialFrameFor:initialExtent:!

RealEstateAgent class removeSelector: #initialFrameFor:initialExtent:!

RealEstateAgent class removeSelector: #standardPositions!

RealEstateAgent class removeSelector: #standardPositions!

RealEstateAgent class removeSelector: #strictlyStaggeredInitialFrameFor:initialExtent:!

RealEstateAgent class removeSelector: #strictlyStaggeredInitialFrameFor:initialExtent:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1332-M3Prep-AdditionalCollapseSimplification-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 8:58:08 am'!
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 4/12/2012 08:56' prior: 50349449!
   buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ RectangleMorph new.
	outerBox
		morphExtent: finalSizeInteger asPoint * resizeFactor;
		borderWidth: 0;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox bounds.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPositionInOwner: 12@8.	"not a clue why these numbers work..."
	
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1333-M3Prep-SmallCleanup-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 9:04:10 am'!
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 4/12/2012 09:01' prior: 50347111!
                               addToScroller: aMorph

	scroller addMorph: aMorph.
	aMorph morphPositionInOwner: 0@0! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:03' prior: 50344131!
              scrollerOffset: newOffset
	| delta |
	delta _ borderWidth + self xtraBorder.
	scroller morphPositionInOwner: delta@delta - newOffset! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1334-M3Prep-SmallCleanup2-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 9:15:45 am'!
!Morph methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:11' prior: 50342597!
                         align: aPoint1 with: aPoint2
	"Translate by aPoint2 - aPoint1."

	^ self morphPositionInOwner: self morphPositionInOwner + (aPoint2 - aPoint1)! !
!Morph methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:12' prior: 50347462!
  bounds: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPositionInWorld: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPositionInWorld: newBounds topLeft; morphExtent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self morphExtent: newExtent; morphPositionInWorld: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 4/12/2012 09:13' prior: 16897917!
                            referencePosition
	"Return the current reference position of the receiver"
	"a rather ugly way to say #center . At least, we avoid false polymorphism"
	"remove some day"
	self flag: #jmvVer2.
	^bounds center! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 4/12/2012 09:13' prior: 50345804!
                            referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	"remove some day"
	self flag: #jmvVer2.
	self morphPositionInWorld: aPoint - (bounds extent // 2)! !
!SketchMorph methodsFor: 'accessing' stamp: 'jmv 4/12/2012 09:14' prior: 50344539!
                         form: aForm
	"Set the receiver's form"

	| oldForm |
	oldForm _ originalForm.
	originalForm _ aForm.
	self basicExtent: originalForm extent.

	oldForm ifNotNil: [ self morphPositionInOwner: self morphPositionInOwner + (oldForm extent - aForm extent // 2) ]! !
!StarMorph methodsFor: 'editing' stamp: 'jmv 4/12/2012 09:14' prior: 50344706!
             dragVertex: label event: evt fromHandle: handle
	| ext oldR pt center |
	label == #center ifTrue: [
		self morphPositionInOwner: self morphPositionInOwner + (evt eventPosition - handle referencePosition)].

	label == #outside ifTrue: [
		center _ handles first referencePosition.
		pt _ center - evt eventPosition.
		ext _ pt r.
		oldR _ ext.
		vertices _ (0 to: 359 by: (360//vertices size)) collect: [ :angle |
			(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext])
					degrees: angle + pt degrees)
				+ center].
		handle align: handle referencePosition with: evt eventPosition ].

	self computeBounds.
! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1335-M3Prep-SmallCleanup3-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 10:41:12 am'!
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:38'!
                            freeSliderRoom
	"Answer the length or height of the free slider area, i.e. substract the slider itself"

	^ (self isHorizontal
		ifTrue: [ self morphExtent x - slider morphExtent x]
		ifFalse: [ self morphExtent y - slider morphExtent y])
			- (borderWidth * 2) - (self buttonExtent * 2).! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:38'!
                            totalSliderRoom
	"Answer the length or height of the slider area"

	^ (self isHorizontal
		ifTrue: [ self morphExtent x ]
		ifFalse: [ self morphExtent y ])
			- (borderWidth * 2) - (self buttonExtent * 2).! !
!ScrollBar methodsFor: 'testing' stamp: 'jmv 4/12/2012 09:51'!
               isHorizontal
	| e |
	e _ self morphExtent.
	^e x > e y! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:27' prior: 50344519!
                      computeSlider

	| delta |
	delta _ self buttonExtent + (self freeSliderRoom * value) asInteger.
	self isHorizontal
		ifTrue: [
			slider morphPositionInOwner: borderWidth +  delta @ borderWidth ]
		ifFalse: [
			slider morphPositionInOwner: borderWidth @ (borderWidth + delta) ] ! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:20' prior: 50348015!
                     expandSlider
	"Compute the new size of the slider (use the old sliderThickness as a minimum)."

	| e |
	e _ (self totalSliderRoom * interval) asInteger max: 7.
	slider morphExtent: (self isHorizontal
		ifTrue: [ e @ self buttonExtent ]
		ifFalse: [ self buttonExtent @ e ])! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:52' prior: 50349211!
                           morphExtent: newExtent

	| newExtentToUse |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent = extent ifTrue: [^ self].
	newExtentToUse _ self isHorizontal
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 4/12/2012 09:57' prior: 16934969!
                         initializeDownButton
	"initialize the receiver's downButton"

	| e |
	e _ self buttonExtent.
	downButton _ self buttonClass new.
	downButton model: self.
	self addMorph: downButton.
	downButton
		morphPositionInOwner: self morphExtent - borderWidth - e;
		morphExtent: e.
	self isHorizontal
		ifTrue: [ downButton updateRightButtonImage ]
		ifFalse: [ downButton updateDownButtonImage ]! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 4/12/2012 10:02' prior: 16934983!
        initializeSlider
	"initialize the receiver's slider"

	sliderShadow _ RectangleMorph new.
	sliderShadow borderWidth: 0.
	self addMorph: sliderShadow.
	sliderShadow hide.
		
	slider _ self sliderClass new.
	slider model: self.
	slider grabSelector: #sliderGrabbed.
	slider dragSelector: #scrollAbsolute:.
	slider action: #sliderReleased.
	self addMorph: slider.

	self computeSlider! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 4/12/2012 09:56' prior: 16935000!
             initializeUpButton
	"initialize the receiver's upButton"

	upButton _ self buttonClass new.
	upButton model: self.
	self addMorph: upButton.
	upButton
		morphPositionInOwner: borderWidth@borderWidth;
		morphExtent: self buttonExtent.
	self isHorizontal
		ifTrue: [ upButton updateLeftButtonImage ]
		ifFalse: [ upButton updateUpButtonImage ].! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/12/2012 10:38' prior: 16935039!
                     scrollAbsolute: aPoint
	| relativePoint v |
	relativePoint _ aPoint - bounds topLeft.
	v _ (self isHorizontal
		ifTrue: [ relativePoint x ]
		ifFalse: [ relativePoint y ])
			- borderWidth - self buttonExtent * 1.0
				/ self freeSliderRoom.
	self setValue: v! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/12/2012 09:53' prior: 50344529!
        setNextDirectionFromEvent: event

	nextPageDirection _ self isHorizontal
		ifTrue: [ event eventPosition x >= slider referencePosition x ]
		ifFalse: [ event eventPosition y >= slider referencePosition y ]! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/12/2012 09:30' prior: 16935086!
                              sliderGrabbed

	| delta e |
	sliderShadow
		morphPositionInOwner: slider morphPositionInOwner;
		morphExtent: slider morphExtent;
		show! !

ScrollBar removeSelector: #freeSliderSpace!

ScrollBar removeSelector: #roomToMove!

ScrollBar removeSelector: #roomToMove!

ScrollBar removeSelector: #sliderExtent!

ScrollBar removeSelector: #sliderExtent!

ScrollBar removeSelector: #totalSliderArea!

ScrollBar removeSelector: #totalSliderArea!

ScrollBar removeSelector: #totalSliderHeight!

ScrollBar removeSelector: #totalSliderSpace!

ScrollBar removeSelector: #totalSliderWidth!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1336-M3Prep-ScrollBarCleanup-jmv.7.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4218] on 20 April 2012 at 2:50:57 pm'!
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/20/2012 14:45'!
        dismissMorph
	| w |
	w _ self world ifNil:[^self].
	w deleteAllHalos; stopStepping: self.
	self delete
! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/20/2012 14:46'!
                     resizeMorph
	| handle |
	handle := HandleMorph new 
				forEachPointDo: [:newPoint | self morphExtent: newPoint - bounds topLeft].
	self activeHand attachMorph: handle.
	handle startStepping! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/20/2012 14:46' prior: 16898960!
              resizeFromMenu
	"Commence an interaction that will resize the receiver"

	self resizeMorph! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 4/20/2012 14:45' prior: 16899493!
          dismissViaHalo
	"The user has clicked in the delete halo-handle.  This provides a hook in case some concomitant action should be taken, or if the particular morph is not one which should be put in the trash can, for example."

	^ self dismissMorph! !
!HandMorph methodsFor: 'event handling' stamp: 'jmv 4/20/2012 14:47' prior: 16864966!
               processEvents
	"Process user input events from the local input devices."

	| evt evtBuf type hadAny |

	hadAny := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		evt := nil.	"for unknown event types"
		type := evtBuf first.
		type = EventSensor eventTypeMouse
			ifTrue: [ evt := self generateMouseEvent: evtBuf ].
		type = EventSensor eventTypeKeyboard 
			ifTrue: [ evt := self generateKeyboardEvent: evtBuf ].
		type = EventSensor eventTypeWindow
			ifTrue: [ evt _ self generateWindowEvent: evtBuf ].
		"All other events are ignored"
		evt
			ifNil: [
				^hadAny]
			ifNotNil: [
				"Finally, handle it"
				self handleEvent: evt.
				hadAny := true.
				"For better user feedback, return immediately after a mouse event has been processed."
				evt isMouse ifTrue: [ ^hadAny ]]].
	"note: if we come here we didn't have any mouse events"
	mouseClickState 
		ifNotNil: [ 
			"No mouse events during this cycle. Make sure click states time out accordingly"
			mouseClickState
				handleEvent: (lastMouseEvent asMouseMove: (Time millisecondClockValue - lastMouseEventTime max: 0))
				from: self ].
	^hadAny! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 4/20/2012 14:47' prior: 16865656!
  sendEvent: anEvent
	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."

	^owner processEvent: anEvent! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 4/20/2012 14:48' prior: 16865666!
                    sendFocusEvent: anEvent to: focusHolder in: world
	"Send the event to focusHolder, the morph currently holding the focus"
	| result |
	world becomeActiveDuring: [
		ActiveHand _ self.
		result _ focusHolder handleFocusEvent: anEvent ].
	^result! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 4/20/2012 14:48' prior: 16879952!
                        layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight r t b |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableWidth _ boundsForLayout width - ((submorphs size + 1) * xSep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth _ usableWidth - sumOfFixed.
	padding ifNil: [	"shrink"
		availableForPropWidth = 0 ifFalse: [
			self flag: #jmvVer2.
			self width: self width - availableForPropWidth.
			^ self layoutSubmorphsAndComputeFullBounds ]].
	normalizationFactor _ self proportionalWidthNormalizationFactor.
	availableForPropWidth _ availableForPropWidth * normalizationFactor.
	widths _ submorphs collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + xSep max: 0) +  boundsForLayout left.
	usableHeight _ boundsForLayout height - (2*ySep) max: 0.
	boundsTop _ boundsForLayout top.	
	boundsRight _ boundsForLayout right.
	submorphs size to: 1 by: -1 do: [ :index | | m w h ls |
		m _ submorphs at: index.
		w _ widths at: index.
		"major direction"
		r _ l + w min: boundsRight.
		"minor direction"
		ls _ m layoutSpec.
		h _ (ls heightFor: usableHeight) min: usableHeight.
		t _ (usableHeight - h) * ls minorDirectionPadding + ySep + boundsTop.
		b _ t + h.
		"Set bounds and adjust major direction for next step"
		m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).
		w > 0 ifTrue: [
			l _ r + xSep min: boundsRight ]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 4/20/2012 14:48' prior: 16880005!
                     layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom b l r |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableHeight _ boundsForLayout height - ((submorphs size + 1) * ySep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight _ usableHeight - sumOfFixed.
	padding ifNil: [	"shrink"
		availableForPropHeight = 0 ifFalse: [
			self flag: #jmvVer2.
			self height: self height - availableForPropHeight.
			^ self layoutSubmorphsAndComputeFullBounds ]].
	normalizationFactor _ self proportionalHeightNormalizationFactor.
	availableForPropHeight _ availableForPropHeight * normalizationFactor.
	heights _ submorphs collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + ySep max: 0) +  boundsForLayout top.
	usableWidth _ boundsForLayout width - (2*xSep) max: 0.
	boundsLeft _ boundsForLayout left.	
	boundsBottom _ boundsForLayout bottom.
	submorphs size to: 1 by: -1 do: [ :index | | m h w ls |
		m _ submorphs at: index.
		h _ heights at: index.
		"major direction"
		b _ t + h min: boundsBottom.
		"minor direction"
		ls _ m layoutSpec.
		w _ (ls widthFor: usableWidth) min: usableWidth.
		l _ (usableWidth - w) * ls minorDirectionPadding + xSep + boundsLeft.
		r _ l + w.
		"Set bounds and adjust major direction for next step"
		m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).
		h > 0 ifTrue: [
			t _ b + ySep min: boundsBottom ]]! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 4/20/2012 14:49' prior: 16911793!
                        becomeActiveDuring: aBlock
	"Make the receiver the ActiveWorld during the evaluation of aBlock.
	Note that this method does deliberately *not* use #ensure: to prevent
	re-installation of the world on project switches."
	| priorWorld priorHand |
	priorWorld _ ActiveWorld.
	priorHand _ ActiveHand.
	ActiveWorld _ self.
	ActiveHand _ self hands first. "default"
	aBlock
		on: Error
		do: [:ex | 
			ActiveWorld _ priorWorld.
			ActiveHand _ priorHand.
			ex pass]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 4/20/2012 14:50' prior: 16912464!
                         install
	owner := nil.	"since we may have been inside another world previously"
	ActiveWorld := self.
	ActiveHand := self hands first.	"default"
	submorphs do: [:ss | ss owner ifNil: [ss privateOwner: self]].
	"Transcript that was in outPointers and then got deleted."
	self viewBox: Display boundingBox.
	Sensor flushAllButDandDEvents.
	worldState handsDo: [:h | h initForEvents].
	self borderWidth: 0.	"default"
	SystemWindow noteTopWindowIn: self.
	self displayWorldSafely! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 4/20/2012 14:50' prior: 16923664!
 interruptNameX: labelString
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess projectProcess |
	
	ActiveHand ifNotNil:[ActiveHand interrupted].
	ActiveWorld _ World. "reinstall active globals"
	ActiveHand _ World activeHand.
	ActiveHand interrupted. "make sure this one's interrupted too"

	projectProcess _ ProjectX uiProcessX.	"we still need the accessor for a while"
	preemptedProcess _ Processor preemptedProcess.
	"Only debug preempted process if its priority is >= projectProcess' priority"
	preemptedProcess priority < projectProcess priority ifTrue:[
		projectProcess suspend.
		preemptedProcess _ projectProcess.
	] ifFalse:[
		preemptedProcess suspend.
	].
	Debugger openInterrupt: labelString onProcess: preemptedProcess
! !

Morph removeSelector: #dismissMorph:!

Morph removeSelector: #dismissMorph:!

Morph removeSelector: #resizeMorph:!

Morph removeSelector: #resizeMorph:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1337-M3Prep-KillActiveEvent-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #4219] on 11 May 2012 at 3:17:29 pm'!
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 4/27/2012 16:38' prior: 50346296!
               bringWindowsFullOnscreen
	"Make ever SystemWindow on the desktop be totally on-screen, whenever possible."
	
	(SystemWindow windowsIn: self satisfying: [:w | true]) do: [ :each |
		each makeMeFullyVisible ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1338-M3Prep-CuisCore-JuanVuletich-2012May11-15h11m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #4220] on 15 May 2012 at 6:04:54 pm'!
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/15/2012 16:50' prior: 50345511!
            placeEmbeddedObject: anchoredFormOrMorph
	"Place the anchoredMorph or return false if it cannot be placed.
	In any event, advance destX by its width."

	| w |
	w _ (anchoredFormOrMorph is: #Morph)
		ifTrue: [ anchoredFormOrMorph morphWidth ]
		ifFalse: [ anchoredFormOrMorph width ].
	destX _ destX + w.
	(destX > rightMargin and: [ lastIndex ~= line first ])
		"Won't fit, but  not at start of a line. Start a new line with it"
		ifTrue: [ ^ false].
	lastIndex _ lastIndex + 1.
	^ true! !
!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 5/15/2012 16:52' prior: 50345526!
                          placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	specialWidth _ (anchoredFormOrMorph is: #Morph)
		ifTrue: [ anchoredFormOrMorph morphWidth ]
		ifFalse: [ anchoredFormOrMorph width ].
	^ true! !
!CompositionScanner methodsFor: 'stop conditions' stamp: 'jmv 5/15/2012 16:51' prior: 50345535!
                             placeEmbeddedObject: anchoredFormOrMorph
	| descent h |

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [
		line stop: lastIndex-1.
		^ false].
	descent _ lineHeight - baseline.
	h _ (anchoredFormOrMorph is: #Morph)
		ifTrue: [ anchoredFormOrMorph morphHeight ]
		ifFalse: [ anchoredFormOrMorph height ].
	baseline _ baseline max: h.
	lineHeight _ baseline + descent.
	line stop: lastIndex.
	^ true! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 5/15/2012 16:39' prior: 16880599!
          example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane color: Color lightGreen; bounds: (120 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '1').

rect1 := RectangleMorph new color: (Color lightOrange); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect1.
rect2 := RectangleMorph new color: (Color cyan); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect2.
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "2"
pane color: Color lightGreen; bounds: (320 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '2').

rect1 := RectangleMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := RectangleMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane color: Color lightGreen; bounds: (520 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '3').

rect1 := RectangleMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := RectangleMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane openInWorld.! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 5/15/2012 17:49' prior: 16880657!
                             testLayout1
	"
	self new testLayout1
	"
	| pane row1 row2 row3 r1c1 r1c2 r1c3 r1c4 r1c5 r2c1 r2c2 r2c3 r3c1 r3c2 r3c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row1 _ LayoutMorph newRow separation: 5.
	row1 color: Color red;
		addMorph: (r1c1 _ RectangleMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 10);
		addMorph: (r1c2 _ RectangleMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r1c3 _ RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r1c4 _ RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.15);
		addMorph: (r1c5 _ RectangleMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
	pane addMorph: row1 layoutSpec: LayoutSpec useAll.
	row2 _ LayoutMorph newRow separation: 5.
	row2 color: Color red;
		addMorph: (r2c1 _ RectangleMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r2c2 _ RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r2c3 _ RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.2).
	pane addMorph: row2 layoutSpec: LayoutSpec useAll.
	row3 _ LayoutMorph newRow separation: 5.
	row3 color: Color red;
		addMorph: (r3c1 _ RectangleMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
		addMorph: (r3c2 _ RectangleMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40);
		addMorph: (r3c3 _ RectangleMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row3 layoutSpec: (LayoutSpec fixedHeight: 60).
	pane openInWorld; morphExtent: 408@300.
	World doOneCycleNow.

	self assert: row1 morphWidth = (pane morphWidth - 10).
	self assert: r1c1 morphWidth class == SmallInteger.
	self assert: r1c1 morphHeight class == SmallInteger.
	self assert: r1c1 morphWidth = 10.
	self assert: r1c1 morphHeight = (row1 morphHeight - 10).
	self assert: r1c2 morphWidth = 200.
	self assert: r1c2 morphHeight = (row1 morphHeight - 10).
	self assert: r1c3 morphWidth = (r1c2 morphWidth / 0.8 * 0.4) rounded.
	self assert: r1c3 morphHeight = (row1 morphHeight - 10).
	self assert: r1c4 morphWidth = (r1c2 morphWidth / 0.8 * 0.15) rounded.
	self assert: r1c4 morphHeight = (row1 morphHeight - 10).
	self assert: r1c5 morphWidth = 20.
	self assert: r1c5 morphHeight = 20.

	self assert: row2 morphWidth = (pane morphWidth - 10).
	self assert: r2c1 morphWidth = 216.
	self assert: r2c1 morphHeight = (row2 morphHeight - 10).
	self assert: r2c2 morphWidth = (r2c1 morphWidth / 0.8 * 0.4) rounded.
	self assert: r2c2 morphHeight = (row2 morphHeight - 10).
	self assert: r2c3 morphWidth = (r2c1 morphWidth / 0.8 * 0.2) rounded.
	self assert: r2c3 morphHeight = (row2 morphHeight - 10).

	self assert: row3 morphWidth = (pane morphWidth - 10).
	self assert: row3 morphHeight = 60.
	self assert: r3c1 morphWidth = 20.
	self assert: r3c1 morphHeight = (row3 morphHeight - 10 * 0.8) rounded.
	self assert: r3c2 morphWidth = (row3 morphWidth - 10 - 20 - 10 - 30 * 0.5) rounded.
	self assert: r3c2 morphHeight = 40.
	self assert: r3c3 morphWidth = 30.
	self assert: r3c3 morphHeight = (row3 morphHeight - 10).

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 5/15/2012 17:47' prior: 16880764!
    testLayout2
	"
	self new testLayout2
	"
	| pane row c1 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (c1 _ RectangleMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (c2 _ RectangleMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ RectangleMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane openInWorld; morphExtent: 400@300.
	World doOneCycleNow.

	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = (pane morphHeight - 10 * 0.9) rounded.
	self assert: c1 bounds bottom = (row bounds bottom - 5) description: 'Should be at bottom'.
	self assert: c1 morphWidth = 20.
	self assert: c1 morphHeight = (row morphHeight - 10 * 0.8) rounded.
	self assert: c2 bounds top = (row bounds top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = 256.
	self assert: c2 morphHeight = 40.
	self assert: ((c3 bounds top - row bounds top) - (row bounds bottom - c3 bounds bottom)) abs < 2 description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (c1 morphHeight / 0.8 * 0.7) rounded.

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 5/15/2012 17:45' prior: 16880814!
                  testLayout3
	"
	self new testLayout3
	"
	| pane row innerRow i1 i2 i3 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	innerRow _ LayoutMorph newRow color: Color red;  separation: 5.
	innerRow
		addMorph: (i1 _ RectangleMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i2 _ RectangleMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i3 _ RectangleMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 minorDirectionPadding: #center);
		addMorph: (c2 _ RectangleMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ RectangleMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 200).
	pane openInWorld; morphExtent: 400@300.
	World doOneCycleNow.

	self assert: row bounds left = (pane bounds left + 5).
	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = 200.
	self assert: innerRow bounds left = (row bounds left + 5).
	self assert: (innerRow bounds top - row bounds top) = (row bounds bottom - innerRow bounds bottom) description: 'Should be centered'.
	self assert: innerRow morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: innerRow morphHeight = 30.

	self assert: i1 bounds left = (innerRow bounds left + 5).
	self assert: (i1 bounds top - innerRow bounds top) = (innerRow bounds bottom - i1 bounds bottom) description: 'Should be centered'.
	self assert: i1 morphWidth = 10.
	self assert: i1 morphHeight = 10.
	self assert: i2 bounds left = (innerRow bounds left + 20).
	self assert: (i2 bounds top - innerRow bounds top) = (innerRow bounds bottom - i2 bounds bottom) description: 'Should be centered'.
	self assert: i2 morphWidth = 10.
	self assert: i2 morphHeight = 10.
	self assert: i3 bounds left = (innerRow bounds left + 35).
	self assert: (i3 bounds top - innerRow bounds top) = (innerRow bounds bottom - i3 bounds bottom) description: 'Should be centered'.
	self assert: i3 morphWidth = (innerRow morphWidth - 40).
	self assert: i3 morphHeight = 10.

	self assert: c2 bounds top = (row bounds top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: c2 morphHeight = 40.
	self assert: (c3 bounds top - row bounds top) = (row bounds bottom - c3 bounds bottom) description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (row morphHeight - 10).

	pane delete! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 5/15/2012 16:54' prior: 50347071!
                         placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph morphWidth)@
				(lineY+ line baseline - anchoredFormOrMorph morphHeight)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph width @ (destY + line baseline - anchoredFormOrMorph height)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 5/15/2012 17:09' prior: 50350768!
                      initializeDownButton
	"initialize the receiver's downButton"

	| e |
	e _ self buttonExtent.
	downButton _ self buttonClass new.
	downButton model: self.
	self addMorph: downButton.
	downButton
		morphPositionInOwner: self morphExtent - borderWidth - e;
		morphExtent: e@e.
	self isHorizontal
		ifTrue: [ downButton updateRightButtonImage ]
		ifFalse: [ downButton updateDownButtonImage ]! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 5/15/2012 17:09' prior: 50350798!
      initializeUpButton
	"initialize the receiver's upButton"

	| e |
	e _ self buttonExtent.
	upButton _ self buttonClass new.
	upButton model: self.
	self addMorph: upButton.
	upButton
		morphPositionInOwner: borderWidth@borderWidth;
		morphExtent: e@e.
	self isHorizontal
		ifTrue: [ upButton updateLeftButtonImage ]
		ifFalse: [ upButton updateUpButtonImage ].! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 5/15/2012 17:41' prior: 16967428!
 testHeight
	
	self should: [ taskbar morphHeight = 18 ]! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 5/15/2012 17:41' prior: 16967461!
                 testWidth
	
	self should: [ taskbar morphWidth = World morphWidth ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1339-M3Prep-CuisCore-JuanVuletich-2012May15-16h29m-jmv.9.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1309] on 23 May 2012 at 10:05:41 pm'!
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 22:02' prior: 50346730!
             createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	self addMorph: result.
	result bounds: (29@90 corner: 122@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 22:03' prior: 50346748!
             createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	self addMorph: result.
	result bounds: (149@90 corner: 242@117).
	^ result! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 22:04' prior: 50335384!
                  drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1340-M3Prep-CuisCore-JuanVuletich-2012May23-22h01m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #2310] on 12 June 2012 at 5:14:20 pm'!
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:31' prior: 50349041!
        draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: bounds
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	self drawRegularLabelOn: aCanvas! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1341-M3Prep-CuisCore-JuanVuletich-2012Jun12-17h02m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1341] on 23 July 2012 at 10:28:44 am'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 7/23/2012 10:28' prior: 50332866!
                         okayToDiscardUnsavedCodeSaving: wouldSave
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk okayToDiscardUnsavedCodeSaving: true
	Smalltalk okayToDiscardUnsavedCodeSaving: false
	"

	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSorter allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any hasUnsavedChanges and: [ any isEmpty not ]]].
	dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ].

	baseCSdirty & dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'      (would need to be saved on next run), ', String newLineString,
				'and unsaved Changes to Cuis core', String newLineString,
				'      (they would be lost as a separate ChangeSet).', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'and unsaved Changes to Cuis core.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core might have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Continue?' ].

	dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will need to be saved on next run.', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	^true! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1342-DontWarnForEmptyCSs-JuanVuletich-2012Jul23-08h55m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1342] on 23 July 2012 at 4:27:12 pm'!
!RemoteString commentStamp: 'jmv 7/23/2012 16:10' prior: 16928424!
                               My instances provide an external file reference to a piece of text.  It may be the sourceCode of a method, or the class comments of a class.

The changes file or file-in file usually has a chunk that is just the source string of a method:

max: aNumber
	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!
!
!ChangeListElement methodsFor: 'accessing' stamp: 'jmv 7/23/2012 16:10'!
  text
	"In Cuis, all source code is plain Strings"
	^self string! !
!Categorizer methodsFor: 'fileIn/Out' stamp: 'jmv 7/23/2012 15:55' prior: 16797913!
         scanFrom: aStream
	"Reads in the organization from the next chunk on aStream.
	Categories or elements not found in the definition are not affected.
	New elements are ignored."

	self changeFromString: aStream nextChunk! !
!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:02' prior: 16784719!
         classComment
	classComment
		ifNil: [^ ''].
	^ classComment text ifNil: ['']! !
!BasicClassOrganizer methodsFor: 'fileIn/Out' stamp: 'jmv 3/13/2012 12:14' prior: 16784805!
                    fileOutCommentOn: aFileStream moveSource: moveSource toFile: fileIndex
	"Copy the class comment to aFileStream.  If moveSource is true (as in compressChanges or compressSources, then update classComment to point to the new file."
	| fileComment |
	classComment ifNotNil: [
			aFileStream newLine.
			fileComment _ RemoteString newString: classComment text
							onFileNumber: fileIndex toFile: aFileStream.
			moveSource ifTrue: [classComment _ fileComment]]! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 7/23/2012 15:57' prior: 16798156!
scanCategory
	"Scan anything that involves more than one chunk; method name is historical only"

	| itemPosition item item2 tokens firstToken secondToken stamp isComment anIndex def isMeta name record methodReference doItOnlyIfInBaseSystem |
	itemPosition _ file position.
	item _ file nextChunk.
	isComment _ (item includesSubString: 'commentStamp:').
	((isComment
	or: [item includesSubString: 'methodsFor:']
	or: [item includesSubString: 'classDefinition:']
	or: [item includesSubString: 'classRemoval:']
	or: [item includesSubString: 'methodRemoval:'])
	or: [item includesSubString: 'methodMoveToSomePackage:']
	or: [item includesSubString: 'classMoveToSomePackage:'])
		ifFalse: [
			"Maybe a preamble, but not one we recognize; bail out with the preamble trick"
			^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)
				 text: ('preamble: ' , item contractTo: 160)].

	tokens _ Smalltalk actualScannerClass new scanTokens: item.
	tokens size >= 2 ifTrue: [
		stamp _ ''.
		anIndex _ tokens indexOf: #stamp: ifAbsent: nil.
		anIndex ifNotNil: [stamp _ tokens at: (anIndex + 1)].
		firstToken _ tokens first.
		secondToken _ tokens second.

		firstToken == #classDefinition: ifTrue: [
			itemPosition _ file position.
			isMeta _ secondToken includesSubString: ' class'.
			name _ isMeta ifTrue: [secondToken substrings first] ifFalse: [secondToken].
			def _ file nextChunk.
			record _ ChangeRecord new file: file position: itemPosition type: #classDefinition
				class: name asSymbol category: tokens last meta: isMeta stamp: nil.
			self addItem: record text: 'classDefinition: ', def.
			^ self ].

		(firstToken == #classRemoval: or: [ firstToken == #classMoveToSomePackage: ]) ifTrue: [
			doItOnlyIfInBaseSystem _ firstToken == #classMoveToSomePackage:.
			itemPosition _ file position.
			item2 _ file nextChunk.
			item2 size > 0 ifTrue: [
				self 
					addItem: (ClassDeletionChangeRecord new
						clsName: secondToken;
						doItOnlyIfInBaseSystem: doItOnlyIfInBaseSystem)
					text: 
						(doItOnlyIfInBaseSystem ifTrue: ['clase move to some package: '] ifFalse: ['class removal: ']), secondToken ].
			^ self ].

		(firstToken == #methodRemoval: or: [ firstToken == #methodMoveToSomePackage: ]) ifTrue: [
			doItOnlyIfInBaseSystem_ firstToken == #methodMoveToSomePackage:.
			itemPosition _ file position.
			item2 _ file nextChunk.
			item2 size > 0 ifTrue: [
				isMeta _ tokens third == #class.
				isMeta ifTrue: [secondToken substrings first] ifFalse: [secondToken].
				methodReference _ (MethodReference new
					setClassSymbol: secondToken
					classIsMeta: isMeta
					methodSymbol: tokens last
					stringVersion: secondToken, ' ', (isMeta ifTrue: ['class '] ifFalse: ['']), tokens last).
				self
					addItem: (MethodDeletionChangeRecord new
						methodReference: methodReference;
						doItOnlyIfInBaseSystem: doItOnlyIfInBaseSystem)
					text: 
						(doItOnlyIfInBaseSystem ifTrue: ['method move to some package: '] ifFalse: ['method removal: ']), 
							methodReference asStringOrText ].
			^ self ].
		
		secondToken == #methodsFor: ifTrue: [
			^ self scanCategory: tokens third class: firstToken meta: false stamp: stamp].

		tokens third == #methodsFor: ifTrue: [
			^ self scanCategory: tokens fourth class: firstToken meta: true stamp: stamp]].

	secondToken == #commentStamp:
		ifTrue: [
			stamp _ tokens third.
			self addItem:
					(ChangeRecord new file: file position: file position type: #classComment
									class: firstToken category: nil meta: false stamp: stamp)
					text: 'class comment for ' , firstToken, 
						  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).
			file nextChunk.
			^ self]! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 7/23/2012 15:59' prior: 16798276!
                              scanCategory: category class: class meta: meta stamp: stamp
	| itemPosition method |
	[
		itemPosition _ file position.
		method _ file nextChunk.
		method size > 0 ]						"done when double terminators"
			whileTrue: [
				self
					addItem: (ChangeRecord new file: file position: itemPosition type: #method
							class: class category: category meta: meta stamp: stamp)
					text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])
						, (Smalltalk actualParserClass new parseSelector: method)
						, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 7/23/2012 15:59' prior: 16798297!
                scanFile: aFile from: startPosition to: stopPosition

	file _ aFile.
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	file position: startPosition.
	'Scanning ', aFile localName, '...'
		displayProgressAt: Sensor mousePoint
		from: startPosition to: stopPosition
		during: [ :bar |
			[file position < stopPosition] whileTrue: [ | prevChar |
				bar value: file position.
				[file atEnd not and: [file peek isSeparator]]
					whileTrue: [prevChar _ file next].
				(file peekFor: $!!)
					ifTrue: [
						(prevChar notNil and: [ prevChar isLineSeparator ])
							ifTrue: [self scanCategory]]
					ifFalse: [
						| itemPosition item |
						itemPosition _ file position.
						item _ file nextChunk.
						item size > 0 ifTrue: [
							self
								addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)
								text: 'do it: ' , (item contractTo: 160)]]]].
	self clearSelections! !
!ChangeRecord methodsFor: 'access' stamp: 'jmv 7/23/2012 16:17' prior: 16799523!
fileOutOn: aFileStream
	"File the receiver out on the given file stream"

	| aString |
	type == #method
		ifTrue: [
			aFileStream newLine; nextPut: $!!.
			aString _  class asString
							, (meta ifTrue: [' class methodsFor: ']
									ifFalse: [' methodsFor: '])
							, category asString printString.
			stamp ifNotNil: [
				aString _ aString, ' stamp: ''', stamp, ''''].
			aFileStream nextChunkPut: aString.
			aFileStream newLine ].

	type == #preamble ifTrue: [ aFileStream nextPut: $!! ].

	type == #classComment
		ifTrue: [
			aFileStream nextPut: $!!.
			aFileStream nextChunkPut: class asString, ' commentStamp: ', stamp storeString.
			aFileStream newLine ].
		
	type == #classDefinition ifTrue: [
		aFileStream nextPut: $!!.
		aFileStream nextChunkPut: 
			'classDefinition: ', 
			(self isMetaClassChange ifTrue: [self methodClassName, ' class'] ifFalse: [self methodClassName]) printString,
			' category: ', self category printString.
		aFileStream newLine ].

	aFileStream nextChunkPut: self string.
	
	type == #method ifTrue: [ aFileStream nextChunkPut: ' '; newLine ].
	type == #classComment ifTrue: [ aFileStream newLine ].
	aFileStream newLine! !
!ChangeRecord methodsFor: 'access' stamp: 'jmv 7/23/2012 16:18' prior: 16799595!
                           originalChangeSetForSelector: methodSelector
	"Returns the original changeset which contained this method version.  If it is contained in the .sources file, return #sources.  If it is in neither (e.g. its changeset was deleted), return nil.  (The selector is passed in purely as an optimization.)"

	| likelyChangeSets originalChangeSet |
	(file localName findTokens: '.') last = 'sources'
		ifTrue: [^ #sources].
	likelyChangeSets _ ChangeSorter allChangeSets select: [ :cs |
		(cs atSelector: methodSelector class: self methodClass) ~~ #none].
	originalChangeSet _ likelyChangeSets
		detect: [ :cs | cs containsMethodAtPosition: position ]
		ifNone: nil.
	^ originalChangeSet  "(still need to check for sources file)"! !
!ChangeRecord methodsFor: 'access' stamp: 'jmv 7/23/2012 16:26' prior: 16799641!
                            string
	"The file is usually closed. But if it happens to be open, leave it like that."
	| string mustOpenAndClose |
	mustOpenAndClose _ file closed.
	mustOpenAndClose ifTrue: [
		file openReadOnly ].
	file position: position.
	string _ file nextChunk.
	mustOpenAndClose ifTrue: [
		file close].
	^ string! !
!ChangeRecord methodsFor: 'initialization' stamp: 'jmv 7/23/2012 16:22' prior: 16799671!
                  file: f position: p type: t
	file _ f.
	position _ p.
	type _ t.
"
file closed ifFalse: [
	'' print.
	file print.
	self print.
	thisContext printStack: 10 ]
"! !
!ClassCategoryReader methodsFor: 'fileIn/Out' stamp: 'jmv 7/23/2012 16:01' prior: 16806353!
  scanFrom: aStream 
	"File in methods from the stream, aStream."
	| methodText |
	[
		methodText _ aStream nextChunk.
		methodText size > 0] whileTrue: [
		class compile: methodText classified: category
			withStamp: changeStamp
			notifying: nil ]! !
!ClassCommentReader methodsFor: 'as yet unclassified' stamp: 'jmv 7/23/2012 16:01' prior: 16806771!
 scanFrom: aStream 
	"File in the class comment from aStream.  Not string-i-fied, just a text, exactly as it is in the browser.  Move to changes file."

	class theNonMetaClass classComment: aStream nextChunk stamp: changeStamp
		"Writes it on the disk and saves a RemoteString ref"! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 7/23/2012 15:55' prior: 16808614!
           printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."
	| preamble method oldPos newPos sourceFile endPos |
	doPreamble 
		ifTrue: [preamble _ self name , ' methodsFor: ' ,
					(self organization categoryOfElement: selector) asString printString]
		ifFalse: [preamble _ ''].
	method _ self methodDict at: selector ifAbsent: [
		outStream nextPutAll: selector; newLine.
		outStream tab; nextPutAll: '** ERROR!!  THIS SCRIPT IS MISSING ** '; newLine; newLine.
		outStream nextPutAll: '  '.
		^ outStream].

	((method fileIndex = 0
		or: [(SourceFiles at: method fileIndex) == nil])
		or: [(oldPos _ method filePosition) = 0])
	ifTrue: [
		"The source code is not accessible.  We must decompile..."
		preamble size > 0 ifTrue: [ outStream newLine; nextPut: $!!; nextChunkPut: preamble; newLine].
		outStream nextChunkPut: method decompileString]
	ifFalse: [
		sourceFile _ SourceFiles at: method fileIndex.
		preamble size > 0
			ifTrue:    "Copy the preamble"
				[outStream copyPreamble: preamble from: sourceFile at: oldPos]
			ifFalse:
				[sourceFile position: oldPos].
		"Copy the method chunk"
		fileIndex = 0 ifFalse: [
			outStream padTo: SourceFiles pointerScaleForWriting put: $  ].
		newPos _ outStream position.
		outStream copyMethodChunkFrom: sourceFile.
		moveSource ifTrue: [    "Set the new method source pointer"
			endPos _ outStream position.
			method checkOKToAdd: endPos - newPos at: newPos in: method fileIndex.
			method setSourcePosition: newPos inFile: fileIndex]].
	preamble size > 0 ifTrue: [ outStream nextChunkPut: ' ' ].
	^ outStream newLine! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 7/23/2012 16:02' prior: 16918386!
          copyMethodChunkFrom: aStream
	"Copy the next chunk from aStream (must be different from the receiver)."

	self nextChunkPut: aStream nextChunk! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 7/23/2012 16:00' prior: 16918406!
                   fileInAnnouncing: announcement 
	"This is special for reading expressions from text that has been formatted 
	with exclamation delimitors. The expressions are read and passed to the 
	Compiler. Answer the result of compilation.  Put up a progress report with
     the given announcement as the title."

	| val chunk |
	announcement 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self size
		during: [ :bar | 
			[ self atEnd ] whileFalse: [
					bar value: self position.
					self skipSeparators.
					
					[
						val := (self peekFor: $!!) 
								ifTrue: [
									chunk := self nextChunk.
									"These are the ones that should do nothing, because next line is a doit that does the stuff"
									(chunk beginsWith: 'classDefinition: ')
									| (chunk beginsWith: 'classRemoval: ')
									| (chunk beginsWith: 'methodRemoval: ')
									| (chunk beginsWith: 'classMoveToSomePackage: ')
									| (chunk beginsWith: 'methodMoveToSomePackage: ')
										ifFalse: [(Smalltalk actualCompilerClass evaluate: chunk logged: false) scanFrom: self]]
								ifFalse: [
									chunk := self nextChunk.
									self checkForPreamble: chunk.
									[ Smalltalk actualCompilerClass evaluate: chunk logged: true ]
										on: Error
										do: [ :ex |
											ex print.
											('while evaluating: ', chunk) print.
											ex resume: true ]
										]] 
							on: InMidstOfFileinNotification
							do: [ :ex | ex resume: true] ].
			self close ].
	"Note:  The main purpose of this banner is to flush the changes file."
	Smalltalk logChange: '----End fileIn of ' , self name , '----'.
	^val! !
!RemoteString methodsFor: 'accessing' stamp: 'jmv 7/23/2012 16:10' prior: 16928507!
               text 
	"In Cuis, all source code is plain Strings"
	^self string! !

PositionableStream removeSelector: #nextChunkText!

PositionableStream removeSelector: #nextChunkText!

MethodDeletionChangeRecord removeSelector: #text!

MethodDeletionChangeRecord removeSelector: #text!

ClassDeletionChangeRecord removeSelector: #text!

ClassDeletionChangeRecord removeSelector: #text!

ChangeRecord removeSelector: #class:category:method:sourceFiles:!

ChangeRecord removeSelector: #class:category:method:sourceFiles:!

ChangeRecord removeSelector: #headerFor:!

ChangeRecord removeSelector: #headerFor:!

ChangeRecord removeSelector: #readStamp!

ChangeRecord removeSelector: #readStamp!

ChangeRecord removeSelector: #text!

ChangeRecord removeSelector: #text!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1343-CuisCore-JuanVuletich-2012Jul23-15h49m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1343] on 23 July 2012 at 4:30:54 pm'!

PositionableStream removeSelector: #skipStyleChunk!

PositionableStream removeSelector: #skipStyleChunk!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1344-CuisCore-JuanVuletich-2012Jul23-16h30m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1344] on 24 July 2012 at 3:13:03 pm'!
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 7/24/2012 09:15' prior: 50335780!
                               buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.47;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 7/24/2012 08:40' prior: 50334820!
                       initialExtent
	^540@300! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 7/24/2012 09:14' prior: 50335542!
     buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton backColor labelBackground |
	backColor _ self textBackgroundColor.	
	labelBackground _ Theme current background.
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.5;
		addAdjusterAndMorph: summary proportionalHeight: 0.18;
		addAdjusterAndMorph: description proportionalHeight: 0.22;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.1.
	self setLabel: 'Installed Packages'! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 7/24/2012 08:40' prior: 16813510!
                               initialExtent
	^540@300! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1345-CuisCore-JuanVuletich-2012Jul24-15h12m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1344] on 24 July 2012 at 3:13:10 pm'!
!Matrix methodsFor: 'copying' stamp: 'jmv 7/24/2012 09:02'!
    postCopy
	elements _ elements copy! !

Matrix removeSelector: #copy!

Matrix removeSelector: #copy!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1346-CuisCore-JuanVuletich-2012Jul24-15h13m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1344] on 29 July 2012 at 3:21:22 pm'!
!TextEditor methodsFor: 'accessing' stamp: 'jmv 7/29/2012 11:31'!
                     pointBlock
	^pointBlock! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 7/29/2012 15:14' prior: 16869496!
         drawBoundsForRow: row
	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"
	| topLeft |

	topLeft _ bounds left @ (bounds top + ((row - 1) * (font height))).
	^topLeft extent: bounds width @ font height! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 7/29/2012 15:11' prior: 16870082!
                   clickAndHalf: evt
	self handleInteraction: [
		editor clickAndHalf: (evt translatedBy: bounds topLeft negated) ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 7/29/2012 15:10' prior: 16870090!
                 doubleClickAndHalf: evt
	self handleInteraction: [
		editor doubleClickAndHalf: (evt translatedBy: bounds topLeft negated) ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 7/29/2012 15:10' prior: 50349593!
     mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt translatedBy: bounds topLeft negated)].
	(evt eventPosition y between: owner bounds top and: owner bounds bottom) ifFalse: [
		owner scrollSelectionIntoView ]! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 7/29/2012 15:10' prior: 16870191!
                            mouseUp: evt
	super mouseUp: evt.
	self pauseBlinking.
	self handleInteraction: [editor mouseUp: (evt translatedBy: bounds topLeft negated)].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'selection' stamp: 'jmv 7/29/2012 15:12' prior: 16870542!
                          scrollSelectionIntoView

	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ]! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 7/29/2012 15:19' prior: 16973771!
     scrollSelectionIntoView
	"Scroll my text into view if necessary and return true, else return false"

	| rectToTest |
	rectToTest _ self editor pointBlock translateBy: self textMorph bounds topLeft.
	self scrollToShow: rectToTest! !

TextModelMorph removeSelector: #scrollSelectionIntoView:!

TextModelMorph removeSelector: #scrollSelectionIntoView:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1347-CuisCore-JuanVuletich-2012Jul29-15h09m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1347] on 30 July 2012 at 5:26:56 pm'!
!Character class methodsFor: 'instance creation' stamp: 'jmv 4/28/2011 15:35'!
              safeValue: asciiCodeOrCodePoint 
	"Answer the Character whose value is anInteger.
	Handle unicode code points > 255 without errors, trying to answer something reasonable"

	"Note: senders of #value:or: in '1002-RTFParser.cs' has many automatic conversion to ISO-8859-15 characters, that would be valuable here."
	(#(16r2019 16r201B) includes: asciiCodeOrCodePoint) ifTrue: [
		^$' ].
	(#(16r201C 16r201D 16r201F) includes: asciiCodeOrCodePoint) ifTrue: [
		^$" ].
	^(self unicodeCodePoint: asciiCodeOrCodePoint)
		ifNil: [Character value: 255 ]! !
!PositionableStream methodsFor: '*SVG-Morphic' stamp: 'jmv 4/27/2010 15:01'!
               nextNumber
	"Answer a number from the stream."

	|element|
	[(element := self next) isNil or: [element isDigit or: [element = $- or: [element = $)]]]] whileFalse.
	element ifNil: [^nil].
	self skip: -1.
	element = $) ifTrue: [^nil].
	^Number readFrom: self! !
!String methodsFor: 'converting' stamp: 'jmv 12/1/2009 15:20'!
                             asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in out char rest did inString |

	"Hack in some minimal workaround for Unicode stuff"
	inString _ self copyReplaceAll: '' with: $' asString.
	"Check if we can handle this in #safeValue: in some way..."
	inString = self ifFalse: [ self halt ].
	
	in _ ReadStream on: inString.
	out _ WriteStream on: (String new: self size).
	[ in atEnd ] whileFalse: [
		in peek = $<
			ifTrue: [in unCommand] 	"Absorb <...><...>"
			ifFalse: [(char _ in next) = $&
						ifTrue: [rest _ in upTo: $;.
								did _ out position.
								rest = 'lt' ifTrue: [out nextPut: $<].
								rest = 'gt' ifTrue: [out nextPut: $>].
								rest = 'amp' ifTrue: [out nextPut: $&].
								rest = 'deg' ifTrue: [out nextPut: $].
								rest = 'quot' ifTrue: [out nextPut: $"].
								rest first = $# ifTrue: [ out nextPut: (Character value: rest asInteger) ].
								did = out position ifTrue: [
									out nextPut: $&; nextPutAll: rest.
									"self error: 'unknown encoded HTML char'."
									"Please add it to this method"]]
						ifFalse: [out nextPut: char]].
		].
	^ out contents! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 7/30/2012 17:26' prior: 16917872!
    crLfNextLine
	"Answer next line (may be empty), or nil if at end.
	Support any line ending convention"

	| answer lineSeparators c |
	self atEnd ifTrue: [^nil].
	lineSeparators _ {Character crCharacter. Character lfCharacter}.
	answer _ self upToAny: lineSeparators.
	c _ self peek.
	c = Character crCharacter ifTrue: [self next].
	c = Character lfCharacter ifTrue: [self next].
	^answer! !
!PositionableStream methodsFor: '*SVG-Morphic' stamp: 'gvc 10/3/2005 10:14' prior: 16918164!
                            upToAny: aCollection 
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given coellection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."
	| newStream element |
	newStream := WriteStream on: (collection species new: 100).
	[self atEnd or: [aCollection includes: (element := self next)]]
		whileFalse: [newStream nextPut: element].
	(aCollection includes: element)
		ifTrue: [self skip: -1].
	^newStream contents! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/30/2012 17:24' prior: 16951150!
                       upToAny: aCollection 
	"Similar to upTo:, but find any of the objects in aCollection"
	| newStream element |
	newStream _ WriteStream on: (buffer1 species new: 100).
	[self atEnd or: [aCollection includes: (element _ self next)]]
		whileFalse: [newStream nextPut: element].
	(aCollection includes: element)
		ifTrue: [self skip: -1].
	^newStream contents! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1348-CuisCore-JuanVuletich-2012Jul30-17h17m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1348] on 3 August 2012 at 1:31:06 pm'!
!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 8/3/2012 13:24'!
 textProvider: aTextProvider textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter allowStyler: aBoolean

	| newModel answer |
	answer _ self new.
	(aBoolean and: [
		Preferences syntaxHighlightingAsYouType and: [ aTextProvider is: #ShoutEnabled ]])
			ifTrue: [ answer styler: SHTextStylerST80 new ].

	newModel _ PluggableTextModel on: aTextProvider.
	newModel textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter.
	aTextProvider addDependent: newModel.

	answer model: newModel.
	answer autoCompleter: newModel autoCompleter.
	^answer! !
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 8/3/2012 13:11' prior: 16813629!
                             annotationForClassDefinitionFor: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at the class definition of the given class."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'Class definition for ';
			nextPutAll: aClass name;
			nextPutAll: '. '.
		aClass theNonMetaClass selectors size printOn: strm.
		strm nextPutAll: ' instance methods. '.
		aClass theMetaClass selectors size printOn: strm.
		strm nextPutAll: ' class methods. '.
		aClass theNonMetaClass linesOfCode printOn: strm.
		strm nextPutAll: ' total lines of code.' ]! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 8/3/2012 13:27' prior: 50349581!
                          buildMorphicAnnotationsPane

	| aTextMorph |
	aTextMorph _ TextModelMorph
		textProvider: model
		textGetter: #annotation
		textSetter: nil
		selectionGetter: nil
		allowStyler: false.
	model when: #annotationChanged send: #redrawNeeded to: aTextMorph.
	aTextMorph
		askBeforeDiscardingEdits: false;
		hideScrollBarsIndefinitely.
	^aTextMorph! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 8/3/2012 13:25' prior: 16814865!
                  buildMorphicCodePane
	"Construct the pane that shows the code.
	Respect the Preference for standardCodeFont."
.
	^TextModelMorph
		textProvider: model
		textGetter: #acceptedContents
		textSetter: #contents:notifying:
		selectionGetter: #contentsSelection
		allowStyler: true! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 8/3/2012 13:27' prior: 16795472!
                  buildMorphicCommentPane
	"Construct the pane that shows the class comment."

	| commentPane |
	commentPane _ BrowserCommentTextMorph
				textProvider: model
				textGetter: #classCommentText
				textSetter: #newClassComment:
				selectionGetter: nil
				allowStyler: false.
	^ commentPane! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 8/3/2012 13:26' prior: 16834815!
    buildMorphicWindow
	"Open a full morphic debugger with the given label"

	| upperMorph bottomMorph1 bottomMorph2 bottomMorph3 bottomMorph4 bottomMorph |

	upperMorph _ PluggableListMorph
		model: model 
		listGetter: #contextStackList
		indexGetter: #contextStackIndex
		indexSetter: #toggleContextStackIndex:
		mainView: self
		menuGetter: #contextStackMenu
		keystrokeAction: #contextStackKey:from:.

	bottomMorph1 _ PluggableListMorph
			model: model receiverInspector
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #receiverFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	bottomMorph2 _ TextModelMorph
			textProvider: model receiverInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection
			allowStyler: true.
	bottomMorph3 _ PluggableListMorph
			model: model contextVariablesInspector 
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #contextFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	bottomMorph4 _ TextModelMorph
			textProvider: model contextVariablesInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection
			allowStyler: true.

	bottomMorph _ LayoutMorph newRow.
	bottomMorph
		addMorph: bottomMorph1 proportionalWidth: 0.2;
		addAdjusterAndMorph: bottomMorph2 proportionalWidth: 0.3;
		addAdjusterAndMorph: bottomMorph3 proportionalWidth: 0.2;
		addAdjusterAndMorph: bottomMorph4 proportionalWidth: 0.3.

	self layoutMorph
		addMorph: upperMorph proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55;
		addAdjusterAndMorph: bottomMorph proportionalHeight: 0.2! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 8/3/2012 13:25' prior: 16851950!
           morphicFileContentsPane

	^TextModelMorph
		textProvider: model
		textGetter: #acceptedContents 
		textSetter: #put:
		selectionGetter: #contentsSelection
		allowStyler: true! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/3/2012 13:25' prior: 50347678!
               createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval
				allowStyler: true.
	result morphExtent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result bounds: (14@25 corner: 257@84).
	^ result! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 8/3/2012 13:25' prior: 16871607!
                     buildMorphicWindow
	" Inspector openAsMorphOn: SystemOrganization "
	| contentsText list upperRow evaluatorText |
	list _ PluggableListMorph
			model: model 
			listGetter: #fieldList
			indexGetter: #selectionIndex
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #fieldListMenu
			keystrokeAction: #inspectorKey:from:.
	contentsText _ TextModelMorph
			textProvider: model
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection
			allowStyler: true.
	evaluatorText _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: list proportionalWidth: 0.3;
		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.
	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.7;
		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.
	self setLabel: ([model object printStringLimitedTo: 64] on: Error do: [ model object class name, ' (printing failed)']).
	self setUpdatablePanesFrom: #(fieldList)! !
!MessageNamesWindow methodsFor: 'GUI building' stamp: 'jmv 8/3/2012 13:29' prior: 16888676!
                          buildMorphicWindow
	"Answer a morphic window with the given initial search string, nil if none"

"MessageNames openMessageNames"

	| selectorListView firstRow searchButton secondRow |
	textMorph _ TextModelMorph
		textProvider: model
		textGetter: #searchString 
		textSetter: #searchString:
		selectionGetter: #contentsSelection
		allowStyler: false.
	textMorph textMorph setProperty: #alwaysAccept toValue: true.
	textMorph askBeforeDiscardingEdits: false.
	textMorph acceptOnCR: true.
	textMorph setTextColor: Color brown.
	textMorph hideScrollBarsIndefinitely.

	searchButton _ PluggableButtonMorph new 
		model: textMorph textMorph;
		label: 'Search';
		action: #acceptContents.
	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.

	firstRow _ LayoutMorph newRow.
	firstRow
		addMorph: searchButton proportionalWidth: 0.25;
		addMorph: textMorph proportionalWidth: 0.75.

	selectorListView _ PluggableListMorph
		model: model
		listGetter: #selectorList
		indexGetter: #selectorListIndex
		indexSetter: #selectorListIndex:
		mainView: self
		menuGetter: #selectorListMenu
		keystrokeAction: #selectorListKey:from:.
	secondRow _  LayoutMorph newRow.
	secondRow
		addMorph: selectorListView proportionalWidth: 0.5;
		addAdjusterAndMorph: self buildMorphicMessageList proportionalWidth: 0.5.

	self layoutMorph
		addMorph: firstRow fixedHeight: self defaultButtonPaneHeight+4;
		addAdjusterAndMorph: secondRow proportionalHeight: 0.5;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.
	model changed: #editSelection! !
!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 8/3/2012 13:25' prior: 16974038!
              textProvider: aTextProvider
	^ self
		textProvider: aTextProvider
		textGetter: nil
		textSetter: nil
		selectionGetter: nil
		allowStyler: true! !
!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 8/3/2012 13:25' prior: 16974045!
         textProvider: aTextProvider textGetter: getTextSel
	^ self
		textProvider: aTextProvider
		textGetter: getTextSel
		textSetter: nil
		selectionGetter: nil
		allowStyler: true! !
!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 8/3/2012 13:25' prior: 16974053!
           textProvider: aTextProvider textGetter: getTextSel textSetter: setTextSel
	^ self
		textProvider: aTextProvider
		textGetter: getTextSel
		textSetter: setTextSel
		selectionGetter: nil
		allowStyler: true! !

TextModelMorph class removeSelector: #textProvider:textGetter:textSetter:selectionGetter:!

TextModelMorph class removeSelector: #textProvider:textGetter:textSetter:selectionGetter:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1349-CuisCore-JuanVuletich-2012Aug03-13h09m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1349] on 5 August 2012 at 1:12:21 am'!

!classDefinition: #HandMorph category: #'Morphic-Kernel'!
Morph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: 'DoubleClickTime'
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds '
	classVariableNames: 'DoubleClickTime '
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!Morph methodsFor: 'geometry' stamp: 'jmv 8/4/2012 15:58'!
         externalizeDistanceToWorld: aPoint
	"aPoint is a distance in own coordinates. Answer is in world coordinates."
	"Add scale factor!!"
	self flag: #jmvVer2.
	^aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/4/2012 16:12'!
                              morphBoundsInWorld
	"Return the bounds of this morph."
	
	"WORLD absolute bounds :("

	"remove senders and implementors"
	| answer |
	self flag: #jmvVer2.
	answer _ self morphPositionInWorld extent: self morphExtentInWorld.
	bounds = answer ifFalse: [
		#validateExtentAndBounds print.
		answer print.
		bounds print.
		thisContext printStack: 10 ].
	^answer
	! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/4/2012 16:04'!
                         morphExtentInWorld
	"eventually, remove"
	self flag: #jmvVer2.
	^self morphExtent! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:53' prior: 16896565!
 addPossiblyUncoveredAreasIn: aRectangle to: aCollection
	"Answer an array of rectangles encompassing those areas in aRectangle not completely
	covered by self.
	All areas that might possibly be uncovered must be included."
	(self isOrthoRectangularMorph and: [ self isOpaqueMorph ]) ifTrue: [
		aRectangle areasOutside: self morphBoundsInWorld do: [ :r |  aCollection add: r ].
		^self ].
	aCollection add: aRectangle! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:53' prior: 50348377!
                 drawErrorOn: aCanvas
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	w _ 10.
	r _ self morphBoundsInWorld truncated.
	aCanvas
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	aCanvas line: r topLeft +w to: r bottomRight -w width: w color: Color yellow.
	aCanvas line: r topRight + (w negated @ w) to: r bottomLeft + (w @ w negated) width: w color: Color yellow.! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:19' prior: 16896643!
                    drawOn: aCanvas

	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: self color! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:54' prior: 50348393!
                  fullDrawOn: aCanvas
	"Draw the full Morphic structure on the given Canvas"

	self visible ifFalse: [^ self].
	(aCanvas isVisible: self fullBounds) ifFalse:[^self].		"Needs fullBounds 'in owner' if inside a scroller"
	self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].

	"Draw receiver itself"
	(aCanvas isVisible: self morphBoundsInWorld) ifTrue: [
		aCanvas clipBy: self morphBoundsInWorld during: [ :c | self drawOn: c ]].	"Needs bounds 'in owner' if inside a scroller"
	self drawSubmorphsOn: aCanvas.
	self drawDropHighlightOn: aCanvas.
	self drawMouseDownHighlightOn: aCanvas! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:55' prior: 16896743!
        ownShadowForm
	"Return a form representing the 'shadow' of the receiver, without including submorphs 
	regardless of clipping"
	| canvas |
	canvas _ Display defaultCanvasClass forShadowOver: self morphBoundsInWorld.
	canvas clipBy: self morphBoundsInWorld during: [ :c | self drawOn: c ].
	^ canvas formWithOffset! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/4/2012 15:35' prior: 50345613!
                        bounds
	"Return the bounds of this morph."
	
	"WORLD absolute bounds :("

	"remove senders and implementors"
	self flag: #jmvVer2.

	^ bounds
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/4/2012 15:38' prior: 50345698!
   innerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

"would be better In own coordinates!!"
	self flag: #jmvVer2.
	^ self bounds! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/4/2012 16:55' prior: 16897903!
                          worldBoundsForHalo
	"Answer the rectangle to be used as the inner dimension of my halos.
	Allow for showing either bounds or fullBounds, and compensate for the optional bounds rectangle."

	^ Preferences haloEnclosesFullBounds
		ifFalse: [ self morphBoundsInWorld ]
		ifTrue: [ self fullBounds ]! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 8/5/2012 00:44' prior: 50350640!
     referencePosition
	"Return the current reference position of the receiver"
	"a rather ugly way to say #center . At least, we avoid false polymorphism"
	"remove some day"
	self flag: #jmvVer2.
	^self morphExtentInWorld // 2 + self morphPositionInWorld! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 8/5/2012 00:44' prior: 50350650!
                  referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	"remove some day"
	self flag: #jmvVer2.
	self morphPositionInWorld: aPoint - (self morphExtentInWorld // 2)! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 8/4/2012 16:53' prior: 16897933!
               containsPoint: aPoint
	| shadow |
	"Most morphs answer true to to #isOrthoRectangularMorph, or redefine this method..."
	self isOrthoRectangularMorph ifTrue: [
		^ self morphBoundsInWorld containsPoint: aPoint ].
	
	"...But for those who not, provide correct albeit expensive behavior."
	shadow _ self ownShadowForm.
	^(shadow pixelValueAt: aPoint - shadow offset) > 0! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/4/2012 15:35' prior: 50348694!
   layoutSubmorphsAndComputeFullBounds
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.

	fullBounds ifNotNil: [ ^self ].

	"Errors at this point can be critical so make sure we catch 'em all right"
	[
		self layoutSubmorphs.
		fullBounds _ self computeFullBounds.
	] on: Exception do: [ :ex |
		"This should do it unless you don't screw up the bounds"
		fullBounds _ self  bounds.
		ex pass ]! !
!Morph methodsFor: 'macpal' stamp: 'jmv 8/4/2012 16:53' prior: 16898514!
               flash
	Display flash: self morphBoundsInWorld! !
!Morph methodsFor: 'updating' stamp: 'jmv 8/4/2012 16:55' prior: 50348727!
    redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Just ours, or include submorphs if we don't clip.
	Think about it. We don't to know about a specific rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"
	
	"This method is the only real use of ivar fullBounds, other than senders of #fullBounds"

	self invalidRect: (fullBounds ifNil: [ self morphBoundsInWorld ])! !
!BorderedMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:52' prior: 16793233!
               drawOn: aCanvas

	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:32' prior: 16783629!
                      drawOn: aCanvas
	| rectangle w x0 y0 h y1 y2 scrollbarThickness p0 e |
	p0 _ self morphPositionInWorld.
	e _ self morphExtentInWorld.
	aCanvas frameAndFillRectangle: (p0 extent: e) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	x0 _ p0 x+1.
	y0 _ p0 y+1.
	w _ e x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (p0 x + e x - scrollbarThickness@p0 y
				extent: scrollbarThickness @ e y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (FormCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: p0 x + e x - scrollbarThickness@p0 y.
		aCanvas
			image: (FormCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: p0 + e - scrollbarThickness.
		h _ e y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (p0 x + e x - scrollbarThickness+2@y1 corner: p0 x + e x-2 @ y2)
			colorOrInfiniteForm: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ x0@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle colorOrInfiniteForm: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				in: rectangle
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!AutoCompleterMorph methodsFor: 'event handling' stamp: 'jmv 8/5/2012 01:02' prior: 50342750!
  mouseUp: evt
	(self containsPoint: evt eventPosition)
		ifTrue: [
			self selected: 
				((evt eventPosition y - self morphPositionInWorld y // self class itemHeight) + 
					self firstVisible).
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!EllipseMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:55' prior: 16842449!
                          drawOn: aCanvas 

	| r |
	r _ self morphBoundsInWorld.
	aCanvas isShadowDrawing
		ifTrue: [^ aCanvas fillOval: r color:  color borderWidth: 0 borderColor: nil].
	aCanvas fillOval: r color: color borderWidth: borderWidth borderColor: borderColor.
! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 8/5/2012 00:55' prior: 16842459!
            containsPoint: aPoint

	| radius other delta xOverY e |
	(self morphBoundsInWorld containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"
	self morphExtentInWorld > (1@1)
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	e _ self morphExtentInWorld.
	radius _ e y asFloat / 2.
	other _ e x asFloat / 2.
	delta _ aPoint - self morphPositionInWorld - (other@radius).
	xOverY _ e x asFloat / e y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:18' prior: 50335450!
            drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				roundRect: self morphBoundsInWorld
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		fillRectangle: textPane morphBoundsInWorld
		colorOrInfiniteForm: (Theme current paneBackgroundFrom: color)! !
!FrameRateMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:11' prior: 50339226!
            drawOn: aCanvas
	super drawOn: aCanvas.
	meanStepDelta ifNotNil: [ | tl |
		tl _ self morphPositionInWorld.
		aCanvas drawString: lastStepDelta rounded printString at: tl font: StrikeFont default color: Color black.
		aCanvas drawString: meanStepDelta rounded printString at: tl + (0@14) font: StrikeFont default color: Color black.
		"aCanvas drawString: lastStepStamp printString at: bounds topLeft + (0@28) font: StrikeFont default color: Color black "
		]! !
!HaloMorph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 15:18' prior: 16863625!
   drawOn: aCanvas 
	"Draw this morph only if it has no target."

	target ifNil: [^super drawOn: aCanvas]! !
!HaloMorph methodsFor: 'updating' stamp: 'jmv 8/5/2012 00:35' prior: 50348826!
       redrawNeeded
	"Quicker to invalidate handles individually if target is large (especially the world)"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
	extent > (200@200)
		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [
					"Invalidate 4 outer strips first, thus subsuming separate damage."
					(self fullBounds areasOutside: target morphPositionInWorld) do:
						[ :r | self invalidRect: r ]].
				self submorphsDo: [:m | m redrawNeeded]]
		ifFalse: [ super redrawNeeded ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 00:35' prior: 50348845!
                   doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target morphPositionInWorld.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target morphExtent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle morphExtent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:05' prior: 16864751!
                   drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	 aCanvas
		stencil: Cursor move
		at: self morphPositionInWorld
		color: Color black .
	! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 8/4/2012 16:31' prior: 50346897!
            popUpForHand: aHand
	"Pop up the receiver as balloon help for the given hand"

	| xcess |
	(contents isNil or: [ contents isEmpty ]) ifTrue: [ ^self ].
	aHand world addMorphFront: self.
	self morphPosition: aHand morphPosition + (-6@20).
	xcess _ self morphPositionInWorld x + self morphExtentInWorld x - aHand world morphWidth.
	xcess > 0 ifTrue: [
		self morphPosition: self morphPosition - (xcess@0) ].
	aHand balloonHelp: self! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:27' prior: 16867395!
                           drawOn: aCanvas

	| b |
	b _ self morphBoundsInWorld.
	aCanvas roundRect: b color: self color radius: 2.
	aCanvas
		paragraph: paragraph
		bounds: (b insetBy: 4)
		color: Color black
		selectionColor: (Theme current textHighlightFocused: false)! !
!ImageMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:04' prior: 16867765!
                         drawOn: aCanvas

	aCanvas image: image at: self morphPositionInWorld! !
!InnerPluggableMorph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 01:05' prior: 50347814!
                               adjustExtent

	self submorphBounds ifNotNil: [ :r |
		self morphExtent: r bottomRight - self morphPositionInWorld ]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 01:06' prior: 50347821!
         adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ self morphPositionInWorld.
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m bounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self morphExtent: w@y! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 8/5/2012 01:08' prior: 50352447!
                    drawBoundsForRow: row
	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"
	| topLeft |
	topLeft _ self morphPositionInWorld + (0 @ (row - 1 * font height)).
	^ topLeft extent: self morphExtentInWorld x @ font height! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 8/5/2012 01:06' prior: 16869517!
     rowAtLocation: aPoint
	"return the number of the row at aPoint"
	| y y0 |
	y0 _ self morphPositionInWorld y.
	y _ aPoint y.
	y < y0 ifTrue: [ ^ 1 ].
	^((y - y0 // (font height)) + 1) min: listItems size max: 0! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:08' prior: 16869555!
                        draw: item atRow: row on: canvas
	"display the given item at row row"
	| drawBounds f |
	drawBounds _ self drawBoundsForRow: row.
	drawBounds _ drawBounds intersect: self morphBoundsInWorld.
	f _ (item is: #Text) ifTrue: [ font emphasized: (item emphasisAt: 1) ] ifFalse: [ font ].
	canvas drawString: item in: drawBounds font: f color: (self colorForRow: row)! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:06' prior: 16869569!
 drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"

	selectionDrawBounds _ self drawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: self morphBoundsInWorld.
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas fillRectangle: selectionDrawBounds colorOrInfiniteForm: c! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:06' prior: 16869602!
                            drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: self morphBoundsInWorld.
	aCanvas
		fillRectangle: selectionDrawBounds
		colorOrInfiniteForm: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'anchors' stamp: 'jmv 8/5/2012 01:09' prior: 16869920!
         anchorMorph: aMorph at: aPoint
	| relPt |
	aMorph owner == self ifTrue: [ self removeMorph: aMorph ].
	self addMorphFront: aMorph.
	relPt _ aPoint - self morphPositionInWorld.
	editor insertMorph: aMorph at: relPt.
	self fit.! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:10' prior: 16869940!
        debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"
	| tl |
	tl _ self morphPositionInWorld.
	self paragraph lines do: [ :line |
		aCanvas frameRectangle: (line rectangle translateBy: tl) borderWidth: 1 color: Color brown ]
! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:32' prior: 16869950!
                       drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		paragraph: self paragraph
		bounds: self morphBoundsInWorld
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/5/2012 01:10' prior: 50352458!
                    clickAndHalf: evt
	self handleInteraction: [
		editor clickAndHalf: (evt translatedBy: self morphPositionInWorld negated) ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/5/2012 01:08' prior: 50352466!
       doubleClickAndHalf: evt
	self handleInteraction: [
		editor doubleClickAndHalf: (evt translatedBy: self morphPositionInWorld negated) ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/5/2012 01:10' prior: 16870153!
                           mouseDown: event
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].

	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"
	self hasKeyboardFocus ifFalse: [
		^event hand newKeyboardFocus: self].

	super mouseDown: event.

	self handleInteraction: [editor mouseDown: (event translatedBy: self morphPositionInWorld negated)].

	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: #clickAndHalf:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:
		tripleClkSel: nil! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/4/2012 16:37' prior: 50352474!
                        mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt translatedBy: self morphPositionInWorld negated)].
	(evt eventPosition y - owner morphPositionInWorld y between: 0 and: owner morphExtentInWorld y) ifFalse: [
		owner scrollSelectionIntoView ]! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/5/2012 01:10' prior: 50352487!
                           mouseUp: evt
	super mouseUp: evt.
	self pauseBlinking.
	self handleInteraction: [editor mouseUp: (evt translatedBy: self morphPositionInWorld negated)].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 01:09' prior: 50347855!
                  extentForComposing
	self flag: #jmvVer2.	"like #extent ..."
	^wrapFlag
		ifTrue: [ self morphExtentInWorld x @ 9999999 ]
		ifFalse: [ 9999999@9999999 ]! !
!InnerTextMorph methodsFor: 'selection' stamp: 'jmv 8/5/2012 01:08' prior: 16870548!
                selectionRects
	"Paragraph assumes its topLeft is 0@0. We don't"
	| tl |
	tl _ self morphPositionInWorld.
	^self paragraph selectionRects collect: [ :r | r translateBy: tl ]! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 8/4/2012 16:39' prior: 50343376!
                    handPoint

	^ hand morphPositionInWorld adhereTo: owner morphBoundsInWorld! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 8/5/2012 01:04' prior: 16879770!
                       initialIndicatorBounds
	^self morphBoundsInWorld outsetBy: 1! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:04' prior: 16879774!
       drawOn: aCanvas
	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: color borderWidth: 2 borderStyleSymbol: #raised! !
!MagnifierMorph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:40' prior: 16885111!
     hasTranslucentColor
	"I may show what's behind me, so tell the hand to don't cache"
	^self sourceRect intersects: self morphBoundsInWorld! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 8/4/2012 16:44' prior: 16885200!
                             magnifiedForm
	| srcRect form neededExtent |
	lastPos _ self sourcePoint.
	srcRect _ self sourceRectFrom: lastPos.
	((srcRect intersects: self morphBoundsInWorld) and: [ RecursionLock == nil ])
		ifTrue: [
			RecursionLock _ self.
			"try to reuse form if appropriate"
			auxCanvas _ (auxCanvas notNil and: [ auxCanvas extent = srcExtent ])
				ifTrue: [
					"Just in case we go out of the Display"
					srcRect origin > (0@0) ifFalse: [
						auxCanvas form fillBlack ].
					FormCanvas on: auxCanvas form over: srcRect ]
				ifFalse: [ FormCanvas depth: 32 over: srcRect ].
			World drawOn: auxCanvas.
			World drawSubmorphsOn: auxCanvas.
			form _ auxCanvas form.
			RecursionLock _ nil]
		ifFalse: [
			"cheaper method if the source is not occluded"
			form _ Display copy: srcRect].
	"smooth if non-integer scale"
	neededExtent _ (srcExtent * magnification ) truncated.
	(magnifiedForm isNil or: [ magnifiedForm extent ~=  neededExtent ])
		ifTrue: [ magnifiedForm _ Form extent: neededExtent depth: 32 ].
	(WarpBlt current toForm: magnifiedForm)
		sourceForm: form;
		colorMap: (form colormapIfNeededFor: magnifiedForm);
		cellSize: (magnification isInteger ifTrue: [1] ifFalse: [2]);  "installs a new colormap if cellSize > 1"
		combinationRule: 3;
		copyQuad: form boundingBox innerCorners toRect: magnifiedForm boundingBox.
	^magnifiedForm.! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 8/4/2012 16:41' prior: 16885255!
sourceRect
	"world global coordinates, etc"
	self flag: #jmvVer2.
	^self sourceRectFrom: self sourcePoint! !
!MenuLineMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:45' prior: 16887218!
 drawOn: aCanvas 
	| baseColor r |
	baseColor := owner color.
	r _ self morphBoundsInWorld.
	aCanvas
		fillRectangle: (r topLeft corner: r rightCenter)
		colorOrInfiniteForm: baseColor twiceDarker.
			
	aCanvas
		fillRectangle: (r leftCenter corner: r bottomRight)
		colorOrInfiniteForm: baseColor twiceLighter! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 8/4/2012 16:51' prior: 50350232!
                         popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition - self morphPosition.
	sourceItem owner owner addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last - (self morphWidth @ 0) value: false;
		value: rightOrLeftPoint first value: true! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 8/4/2012 16:50' prior: 50347908!
                       adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each morphWidth])].

	w _ w + 4.
	tl _ self morphPositionInWorld.
	p _ tl + 5.
	submorphs do: [ :m |
		m morphWidth: w.
		m morphPosition: p.
		p _ m morphPositionInWorld + (0@(m morphExtentInWorld y + 1)) ].
	
	self morphExtent: submorphs last morphBoundsInWorld bottomRight - tl + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 8/4/2012 16:52' prior: 50346575!
  positionAt: aPoint relativeTo: aMenuItem
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	self morphBoundsInWorld right > owner world morphBoundsInWorld right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ self morphBoundsInWorld amountToTranslateWithin:
		(owner world morphBoundsInWorld withHeight: ((owner world morphExtentInWorld y - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!MenuMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:58' prior: 16888204!
                         drawOn: aCanvas
	
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas roundRect: self morphBoundsInWorld color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #raised baseColorForBorder: color ]! !
!MinimalStringMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:51' prior: 16894888!
     drawOn: aCanvas

	aCanvas drawString: contents in: self morphBoundsInWorld font: self fontToUse color: color! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:04' prior: 16906380!
                         drawOn: aCanvas
	self hasSelection ifTrue: [
		self drawSelectionOn: aCanvas ].
	self hasVisibleCaret ifTrue: [
		self drawCaretOn: aCanvas].
	aCanvas drawString: contents in: self morphBoundsInWorld font: self fontToUse color: color! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:03' prior: 16906390!
                            drawSelectionOn: aCanvas
	| rightX leftX top bottom tl |

	tl _ self morphPositionInWorld.
	top _ tl y.
	bottom _ top + self baseFont height.
	leftX _ (self fontToUse widthOfString: contents from: 1 to: editor startIndex-1) + tl x.
	rightX _ (self fontToUse widthOfString: contents from: 1 to: editor stopIndex-1) + tl x.

	aCanvas
		fillRectangle: (leftX @ top corner: rightX @ bottom)
		colorOrInfiniteForm: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!Paragraph methodsFor: 'editing' stamp: 'jmv 8/4/2012 16:56' prior: 16908992!
                         clickAt: clickPoint
	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."
	| startBlock action target range boxes box t |
	action _ false.
	startBlock _ self characterBlockAtPoint: clickPoint.
	t _ model actualContents.
	(t attributesAt: startBlock stringIndex) do: [ :att | 
		att mayActOnClick ifTrue:
				[(target _ model) ifNil: [ target _ editor morph].
				range _ t rangeOf: att startingAt: startBlock stringIndex.
				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 
							to: (self characterBlockForIndex: range last+1).
				box _ boxes detect: [:each | each containsPoint: clickPoint] ifNone: nil.
				box ifNotNil: [
					box _ editor morph morphBoundsInWorld.
					editor morph allOwnersDo: [ :m | box _ box intersect: (m morphBoundsInWorld) ].
					Utilities
						awaitMouseUpIn: box
						repeating: nil
						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action _ true]].
					Cursor currentCursor == Cursor webLink ifTrue:[Cursor normal show].
				]]].
	^ action! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:01' prior: 16913568!
           drawInconOn: aCanvas

	| theIcon |
	theIcon _ self magnifiedIcon.
	aCanvas
		image: theIcon
		multipliedBy: self iconColor
		at: self morphBoundsInWorld center - (theIcon extent //2)! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:00' prior: 50335478!
             drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	rect _ self morphBoundsInWorld insetBy: 1@3.
	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/4/2012 17:01' prior: 16915010!
                   focusIndicatorRectangle

	| topLeft bottomRight |
	topLeft _ self morphPositionInWorld.
	bottomRight _ topLeft + self morphExtentInWorld.
	topLeft _ topLeft + borderWidth.
	bottomRight _ bottomRight - borderWidth.
	self vIsScrollbarShowing ifTrue: [
		bottomRight _ scrollBar morphPositionInWorld x -1@ bottomRight y].
	self hIsScrollbarShowing ifTrue: [
		bottomRight _ bottomRight x @ 
			(bottomRight y - self scrollBarClass scrollbarThickness)].
	^topLeft corner: bottomRight! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:20' prior: 16866352!
   drawLinesOn: aCanvas 
	| lColor |
	lColor _ self lineColor.
	scroller submorphs do: [ :submorph | 
		(submorph isExpanded or: [
			(aCanvas isVisible: submorph morphBoundsInWorld) or: [
				submorph nextSibling notNil and: [ aCanvas isVisible: submorph nextSibling morphBoundsInWorld ] ] ]) ifTrue: [
			submorph
				drawLinesOn: aCanvas
				lineColor: lColor ] ]! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 8/4/2012 16:20' prior: 16866366!
                       drawOn: aCanvas

	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle 
			borderWidth: Preferences focusIndicatorWidth
			color: Theme current focusIndicator ].

	selectedMorph  ifNotNil: [
		aCanvas
			fillRectangle: (selectedMorph morphBoundsInWorld intersect: scroller morphBoundsInWorld)
			colorOrInfiniteForm: (Theme current listHighlightFocused: self hasKeyboardFocus)].

	Preferences showLinesInHierarchyViews ifTrue:[
		self drawLinesOn: aCanvas ]! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 8/4/2012 16:25' prior: 16866411!
              itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last |
	scroller hasSubmorphs ifFalse: [ ^nil ].
	(scroller fullBounds containsPoint: aPoint) ifFalse: [ ^nil ].
	ptY _ aPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	scroller firstSubmorph morphPositionInWorld y > ptY ifTrue: [ ^nil ].
	last _ scroller lastSubmorph.
	last morphPositionInWorld y + last morphExtentInWorld y < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^scroller 
		findSubmorphBinary: [ :m |
			(m morphPositionInWorld y <= ptY and: [ m morphPositionInWorld y + m morphExtentInWorld y >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPositionInWorld y + (m morphExtentInWorld y // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 8/4/2012 16:26' prior: 16866749!
 scrollSelectionIntoView
	selectedMorph ifNotNil: [
		self scrollToShow: selectedMorph morphBoundsInWorld ]! !
!PolygonMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:58' prior: 16916494!
 drawClippedBorderOn: aCanvas usingEnds: anArray 
	aCanvas clipBy: self morphBoundsInWorld during:[:cc| self drawBorderOn: cc usingEnds: anArray].! !
!PolygonMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:58' prior: 16916546!
                          drawOn: aCanvas 
	"Display the receiver, a spline curve, approximated by straight line segments."
	| lineColor bigClipRect brush p1i p2i |
	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].
	closed & color isTransparent not ifTrue: [
		self filledForm colors: (Array with: Color transparent with: color).
		aCanvas image: self filledForm at: self morphPositionInWorld -1 ].
	lineColor _ borderColor. 
	bigClipRect _ aCanvas clipRect expandBy: borderWidth+1//2.
	brush _ nil.
	self lineSegmentsDo: [ :p1 :p2 |
		p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.
		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"
					((p1i min: p2i) max: bigClipRect origin) <=
					((p1i max: p2i) min: bigClipRect corner)]) ifTrue: [
			borderWidth > 3
			ifTrue: [brush ifNil: [
						brush _ (ColorForm dotOfSize: borderWidth)
								colors: (Array with: Color transparent with: borderColor)].
					aCanvas line: p1i to: p2i brushForm: brush]
			ifFalse: [aCanvas line: p1i to: p2i
							width: borderWidth color: lineColor]]].
	self arrowForms ifNotNil: [
		self arrowForms do: [ :f |
			f colors: (Array with: Color transparent with: borderColor).
			aCanvas image: f at: f offset]]! !
!PolygonMorph methodsFor: 'geometry testing' stamp: 'jmv 8/5/2012 00:57' prior: 16916836!
                           containsPoint: aPoint

	(self morphBoundsInWorld containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"

	closed & color isTransparent not ifTrue:
		[^ (self filledForm pixelValueAt: aPoint - self morphPositionInWorld + 1) > 0].

	self lineSegmentsDo:
		[:p1 :p2 |
		(aPoint onLineFrom: p1 to: p2 within: (3 max: borderWidth+1//2) asFloat)
				ifTrue: [^ true]].

	self arrowForms do:
		[:f | (f pixelValueAt: aPoint - f offset) > 0 ifTrue: [^ true]].

	^ false! !
!PolygonMorph methodsFor: 'halo control' stamp: 'jmv 8/5/2012 00:57' prior: 16916871!
                rotationDegrees: degrees 
	| center |
	center _ self morphBoundsInWorld center.
	self setVertices: (vertices collect: [ :v |
		v inverseRotateBy: (degrees - self forwardDirection) degreesToRadians negated about: center ]).
	self forwardDirection: degrees! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 00:57' prior: 50344421!
             borderForm
	"A form must be created for drawing the border whenever the borderColor is translucent."

	| borderCanvas |
	borderForm ifNotNil: [^ borderForm].
	borderCanvas _ Display defaultCanvasClass forShadowOver: self morphBoundsInWorld.
	self drawBorderOn: borderCanvas.
	borderForm _ borderCanvas form.
	self arrowForms do:
		[:f |  "Eliminate overlap between line and arrowheads if transparent."
		borderForm copy: f boundingBox from: f to: f offset - self morphPosition rule: Form erase].
	^ borderForm! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 00:58' prior: 50349171!
              filledForm
	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."
	| bb origin |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	closed ifFalse: [^ filledForm _ nil].
	filledForm ifNotNil: [^ filledForm].
	filledForm _ ColorForm extent: extent+2.

	"Draw the border..."
	bb _ (BitBlt current toForm: filledForm) sourceForm: nil; fillColor: Color black;
			combinationRule: Form over; width: 1; height: 1.
	origin _ self morphPositionInWorld asIntegerPoint-1.
	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin
										to: p2 asIntegerPoint-origin].

	"Fill it in..."
	filledForm _ ColorForm mappingWhiteToTransparentFrom: filledForm anyShapeFill.

	borderColor mightBeTranslucent ifTrue: [
		"If border is stored as a form, then erase any overlap now."
		filledForm
			copy: self borderForm boundingBox
			from: self borderForm
			to: 1@1
			rule: Form erase ].

	^ filledForm! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 8/4/2012 17:02' prior: 16926301!
                     initialFrameFor: aView initialExtent: initialExtent world: aWorld 
	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."

	| allOrigins screenRight screenBottom putativeOrigin putativeFrame allowedArea staggerOrigin otherFrames |
	Preferences reverseWindowStagger 
		ifTrue: 
			[^self 
				strictlyStaggeredInitialFrameFor: aView
				initialExtent: initialExtent
				world: aWorld].
	allowedArea := self maximumUsableAreaInWorld: aWorld.
	screenRight := allowedArea right.
	screenBottom := allowedArea bottom.
	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not]) 
						collect: [:w | w morphBoundsInWorld].
	allOrigins := otherFrames collect: [:f | f origin].
	(self standardPositionsInWorld: aWorld) do: 
			[:aPosition | 
			"First see if one of the standard positions is free"

			(allOrigins includes: aPosition) 
				ifFalse: 
					[^(aPosition extent: initialExtent) 
						translatedAndSquishedToBeWithin: allowedArea]].
	staggerOrigin := (self standardPositionsInWorld: aWorld) first.	"Fallback: try offsetting from top left"
	putativeOrigin := staggerOrigin.
	
	[putativeOrigin := putativeOrigin + StaggerOffset.
	putativeFrame := putativeOrigin extent: initialExtent.
	putativeFrame bottom < screenBottom 
		and: [putativeFrame right < screenRight]] 
			whileTrue: 
				[(allOrigins includes: putativeOrigin) 
					ifFalse: 
						[^(putativeOrigin extent: initialExtent) 
							translatedAndSquishedToBeWithin: allowedArea]].
	^(self scrollBarSetback @ self screenTopSetback extent: initialExtent) 
		translatedAndSquishedToBeWithin: allowedArea! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 8/4/2012 17:02' prior: 16926489!
                        strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld 
	"This method implements a staggered window placement policy that I (di) like.
	Basically it provides for up to 4 windows, staggered from each of the 4 corners.
	The windows are staggered so that there will always be a corner visible."

	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |
	allowedArea := (self maximumUsableAreaInWorld: aWorld) 
				insetBy: (self scrollBarSetback @ self screenTopSetback extent: 0 @ 0).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].
	initialFrame := 0 @ 0 extent: initialExtent.
	"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))
							min: 600@400"
	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not]) 
						collect: [:w | w morphBoundsInWorld].
	0 to: maxLevel
		do: 
			[:level | 
			1 to: 4
				do: 
					[:ci | 
					cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft) at: ci.
					corner := allowedArea perform: cornerSel.
					"The extra grid//2 in delta helps to keep title tabs distinct"
					delta := ((maxLevel - level) * grid + (grid // 2)) @ (level * grid).
					1 to: ci - 1 do: [ :i | delta _ delta y negated @ delta x ].	"slow way"
					putativeCorner := corner + delta.
					free := true.
					otherFrames 
						do: [:w | free := free & ((w perform: cornerSel) ~= putativeCorner)].
					free 
						ifTrue: 
							[^(initialFrame align: (initialFrame perform: cornerSel)
								with: putativeCorner) translatedAndSquishedToBeWithin: allowedArea]]].
	"If all else fails..."
	^(self scrollBarSetback @ self screenTopSetback 
		extent: initialFrame extent) translatedAndSquishedToBeWithin: allowedArea! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 8/5/2012 01:01' prior: 50350812!
        scrollAbsolute: aPoint
	| relativePoint v |
	relativePoint _ aPoint - self morphPositionInWorld.
	v _ (self isHorizontal
		ifTrue: [ relativePoint x ]
		ifFalse: [ relativePoint y ])
			- borderWidth - self buttonExtent * 1.0
				/ self freeSliderRoom.
	self setValue: v! !
!ScrollBar methodsFor: 'drawing' stamp: 'jmv 8/5/2012 01:02' prior: 16935106!
drawOn: aCanvas

	aCanvas
		fillRectangle: self morphBoundsInWorld
		colorOrInfiniteForm: (color alphaMixed: 0.3 with: Color white)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!SketchMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:50' prior: 16939938!
               drawOn: aCanvas
	aCanvas image: originalForm at: self morphPositionInWorld! !
!SketchMorph methodsFor: 'geometry testing' stamp: 'jmv 8/5/2012 00:50' prior: 16939943!
                         containsPoint: aPoint

	^ (self morphBoundsInWorld containsPoint: aPoint) and: [
		(originalForm isTransparentAt: aPoint - self morphPositionInWorld ) not ]
! !
!ColorPickerMorph methodsFor: 'accessing' stamp: 'jmv 8/5/2012 00:51' prior: 16821031!
        originalColor: colorOrSymbol 
	"Set the receiver's original color.  It is at this point that a command is launched to represent the action of the picker, in support of Undo."

	originalColor := (colorOrSymbol is: #Color) 
				ifTrue: [colorOrSymbol]
				ifFalse: [Color lightGreen].
	originalForm fill: RevertBox fillColor: originalColor.
	selectedColor := originalColor.
	self locationIndicator 
		referencePosition: self morphPositionInWorld + (self positionOfColor: originalColor)! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 8/5/2012 00:29' prior: 50346659!
      addToWorld: world near: box
	| goodLocation |
	goodLocation _ self bestPositionNear: box inWorld: world.
	world allMorphsDo:
		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:
		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:
			[(p selector == selector and: [p argument == argument])
				ifTrue: [^ p comeToFront  "uncover existing picker"]
				ifFalse: ["place second picker relative to first"
						goodLocation _ self bestPositionNear: p morphBoundsInWorld inWorld: world]]]].
	world addMorphFront: self.
	self morphPositionInOwner: goodLocation.
	self resizeMorph! !
!StringMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:45' prior: 16957405!
 drawOn: aCanvas

	aCanvas drawString: contents in: self morphBoundsInWorld font: self fontToUse color: color.! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:47' prior: 16868240!
                    drawLinesToFirstChildOn: aCanvas lineColor: lineColor 
	"Draw line from me to next sibling"

	| vLineX vLineTop vLineBottom childBounds childCenter |
	childBounds := self firstChild toggleBounds.
	childCenter := childBounds center.
	vLineX := childCenter x - 1.
	vLineTop := self morphPositionInWorld y + self morphExtentInWorld y.
	self firstChild hasToggle
		ifTrue: [vLineBottom := childCenter y - 7]
		ifFalse: [vLineBottom := childCenter y].
	aCanvas
		line: vLineX @ vLineTop
		to: vLineX @ vLineBottom
		width: 1
		color: lineColor! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 00:46' prior: 16868281!
       drawOn: aCanvas

	| tRect sRect columnRect columnScanner columnData columnLeft colorToUse |

	tRect := self toggleRectangle.
	sRect := self morphBoundsInWorld withLeft: tRect right + 4.
	self drawToggleOn: aCanvas in: tRect.
	colorToUse _ complexContents preferredColor ifNil: [color].
	(container columns isNil or: [(contents asString indexOf: Character tab) = 0]) ifTrue: [
		aCanvas drawString: contents asString in: sRect font: self fontToUse color: colorToUse.
	] ifFalse: [
		columnLeft _ sRect left.
		columnScanner _ ReadStream on: contents asString.
		container columns do: [ :width |
			columnRect _ columnLeft @ sRect top extent: width @ sRect height.
			columnData _ columnScanner upTo: Character tab.
			columnData isEmpty ifFalse: [
				aCanvas drawString: columnData in: columnRect font: self fontToUse color: colorToUse.
			].
			columnLeft _ columnRect right + 5.
		].
	]
! !
!IndentingListItemMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 00:48' prior: 16868365!
        toggleRectangle

	^self morphPositionInWorld + (12*indentLevel @ 0) extent: 12@self morphExtentInWorld y! !
!Taskbar methodsFor: 'stepping' stamp: 'jmv 8/4/2012 17:02' prior: 16967251!
       step

	"My dimensions are constrained live."
	| r |
	r _ World morphBoundsInWorld.
	r _ r left @ (r bottom -18) extent: r width@18.
	self morphBoundsInWorld = r ifFalse: [
		self bounds: r]! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 8/4/2012 17:03' prior: 16967432!
            testHorizontalAlignment
	
	self should: [ taskbar morphPositionInWorld x = World morphPositionInWorld x ]! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 8/4/2012 17:04' prior: 16967456!
testVerticalAlignment
	
	self should: [ taskbar morphBoundsInWorld bottom = World morphBoundsInWorld bottom ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'jmv 8/4/2012 17:04' prior: 16971320!
                    visibleHeight

	^morph owner morphExtentInWorld y! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 8/4/2012 17:04' prior: 50352502!
                  scrollSelectionIntoView
	"Scroll my text into view if necessary and return true, else return false"

	| rectToTest |
	rectToTest _ self editor pointBlock translateBy: self textMorph morphPositionInWorld.
	self scrollToShow: rectToTest! !
!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 8/4/2012 17:05' prior: 16985943!
                   initialIndicatorBounds
	^owner morphBoundsInWorld! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 8/4/2012 17:05' prior: 16986956!
                            drawHand: aHandMorph

	| bw r |
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth // 2.
		r _ aHandMorph fullBounds.
		canvas frameRectangle: r borderWidth: bw color: Color black.
		canvas frameRectangle: (r insetBy: bw) borderWidth: bw color: Color white.
		canvas clipBy: aHandMorph morphBoundsInWorld during: [ :c | aHandMorph drawOn: c ]]
	ifFalse: [
		aHandMorph fullDrawOn: canvas ]! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 8/4/2012 17:05' prior: 16986972!
      drawInvalidAreasWorld: aWorld submorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |
	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ OrderedCollection new.
	(damageRecorder invalidRectsFullBounds: aWorld viewBox) do: [ :r |
		r ifNotNil: [ initialRectsToRepair addLast: r ]].
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _morph fullBounds.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			(canvas copyClipRect: r) clipBy: aWorld morphBoundsInWorld during: [ :c | aWorld drawOn: c ]]].
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could merge all xrects into just one call... Most likely, that would be slower, though."
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			m fullDrawOn: (canvas copyClipRect: r)
		].
"		(canvas copyClipRect: rr) fullDrawMorph: m "
	].
	
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !

Preferences class removeSelector: #showBoundsInHalo!

Preferences class removeSelector: #showBoundsInHalo!

HandMorph class removeSelector: #doubleClickTime!

HandMorph class removeSelector: #doubleClickTime!

HandMorph class removeSelector: #doubleClickTime:!

HandMorph class removeSelector: #doubleClickTime:!

HandMorph class removeSelector: #initialize!

HandMorph class removeSelector: #initialize!

HandMorph initialize!

HandMorph removeSelector: #cursorBounds!

HandMorph removeSelector: #cursorBounds!

HandMorph removeSelector: #savePatchFrom:!

HandMorph removeSelector: #savePatchFrom:!

!classDefinition: #HandMorph category: #'Morphic-Kernel'!
Morph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1350-CuisCore-JuanVuletich-2012Aug05-00h15m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1350] on 5 August 2012 at 8:15:48 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 19:32'!
       morphFullBoundsInWorld
	"Morphs should know nothing about absolute coordinates..."
	"Should implement in some reasonable way... including submorphs?"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds.

	self flag: #jmvVer2.
	^self morphBoundsInWorld! !
!HandMorph methodsFor: 'layout' stamp: 'jmv 8/5/2012 19:42'!
                        morphFullBoundsInWorld
	"Extend my bounds by the shadow offset when carrying morphs."
"
	self layoutSubmorphsAndComputeFullBounds.
	^submorphs isEmpty
		ifTrue: [ fullBounds ]
	
		ifFalse: [ fullBounds topLeft corner: fullBounds bottomRight + self shadowOffset ].
"

	"Morphs should know nothing about absolute coordinates..."
	"In addition, considering just first submorph... should include all of them"
	| r |
	self flag: #jmvVer2.
	^submorphs isEmpty
		ifTrue: [ super morphFullBoundsInWorld ]
		ifFalse: [
			r _ super morphFullBoundsInWorld merge: submorphs first morphFullBoundsInWorld.
			r origin corner: r corner + self shadowOffset ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:37' prior: 16896614!
               drawDropHighlightOn: aCanvas
	self highlightedForDrop ifTrue: [
		aCanvas frameRectangle: self morphFullBoundsInWorld borderWidth: 1 color: self dropHighlightColor ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:37' prior: 16896635!
             drawMouseDownHighlightOn: aCanvas
	self highlightedForMouseDown ifTrue: [
		aCanvas frameRectangle: self morphFullBoundsInWorld borderWidth: 1 color: self color darker darker ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:38' prior: 50353052!
  fullDrawOn: aCanvas
	"Draw the full Morphic structure on the given Canvas"

	self visible ifFalse: [^ self].
	(aCanvas isVisible: self morphFullBoundsInWorld) ifFalse:[^self].		"Needs fullBounds 'in owner' if inside a scroller"
	self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].

	"Draw receiver itself"
	(aCanvas isVisible: self morphBoundsInWorld) ifTrue: [
		aCanvas clipBy: self morphBoundsInWorld during: [ :c | self drawOn: c ]].	"Needs bounds 'in owner' if inside a scroller"
	self drawSubmorphsOn: aCanvas.
	self drawDropHighlightOn: aCanvas.
	self drawMouseDownHighlightOn: aCanvas! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:38' prior: 16896720!
                            imageForm

	^ self imageForm: Display depth forRectangle: self morphFullBoundsInWorld! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:38' prior: 16896725!
                             imageForm: depth

	^ self imageForm: depth forRectangle: self morphFullBoundsInWorld! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:38' prior: 16896759!
                              shadowForm
	"Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."
	| bnds canvas |
	bnds _ self morphFullBoundsInWorld.
	canvas _ Display defaultCanvasClass forShadowOver: bnds.
	self fullDrawOn: canvas.
	^ canvas formWithOffset! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/5/2012 19:37' prior: 16897396!
             containsPoint: aPoint event: anEvent
	"Return true if aPoint is considered to be inside the receiver for the given event.
	The default implementation treats locked children as integral part of their owners."
	(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [ ^false ].
	(self containsPoint: aPoint) ifTrue: [ ^true ].
	self submorphsDo: [ :m |
		(m isLocked and: [ m fullContainsPoint: aPoint ]) ifTrue: [ ^true ]].
	^false! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 19:39' prior: 50353104!
                             worldBoundsForHalo
	"Answer the rectangle to be used as the inner dimension of my halos.
	Allow for showing either bounds or fullBounds, and compensate for the optional bounds rectangle."

	^ Preferences haloEnclosesFullBounds
		ifFalse: [ self morphBoundsInWorld ]
		ifTrue: [ self morphFullBoundsInWorld ]! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 8/5/2012 19:37' prior: 50348638!
                      fullContainsPoint: aPoint
"
	This alternative implementation is included in this comment because it could be useful someday.
	If we start to rely heavily on the use of #ownShadowForm in #containsPoint, this could be cheaper.
	
	| shadow |
	self clipSubmorphs
		ifTrue: [ ^self containsPoint: aPoint ]
		ifFalse: [
			(self fullBounds containsPoint: aPoint) ifFalse: [^ false].
			(self containsPoint: aPoint) ifTrue: [^ true].
			shadow _ self shadowForm.
			^(shadow pixelValueAt: aPoint - shadow offset) > 0 ]
"
	
	self flag: #jmvVer2.
	"Is the comment relevant now?"
	
	(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [ ^ false ].  "quick elimination"
	(self containsPoint: aPoint) ifTrue: [ ^ true ].  "quick acceptance"
	submorphs do: [:m | (m fullContainsPoint: aPoint) ifTrue: [ ^ true ]].
	^ false
! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/5/2012 16:40' prior: 50353151!
layoutSubmorphsAndComputeFullBounds
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.

	fullBounds ifNotNil: [ ^self ].

	self layoutSubmorphs.
	fullBounds _ self computeFullBounds.
	fullBounds _ bounds! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/5/2012 19:38' prior: 50348715!
            submorphBounds
	"Private. Compute the actual full bounds of the receiver"

	"Remove when removing morphFullBoundsInWorld? Reimplement?"
	self flag: #jmvVer2.

	^submorphs inject: nil into: [ :prevBox :m |
		m visible
			ifTrue: [ m morphFullBoundsInWorld quickMerge: prevBox ]
			ifFalse: [ prevBox ] ]! !
!Morph methodsFor: 'menus' stamp: 'jmv 8/5/2012 19:37' prior: 16898693!
      changeColor
	"Change the color of the receiver -- triggered, e.g. from a menu"

	ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: self activeHand;
		target: self;
		selector: #color:;
		originalColor: self color;
		putUpFor: self near: self morphFullBoundsInWorld! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 8/5/2012 19:37' prior: 50342695!
                     changeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand
	"Put up a color picker for changing some kind of color.  May be modal or modeless, depending on #modalColorPickers setting"
	self flag: #arNote. "Simplify this due to anObject == self for almost all cases"
	^ ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: aHand;
		target: anObject;
		selector: aSymbol;
		originalColor: aColor;
		putUpFor: anObject near: ((anObject is: #Morph)
					ifTrue: [ Rectangle center: self morphPosition extent: 20 ]
					ifFalse: [ anObject == self world
								ifTrue: [ anObject viewBox bottomLeft + (20@-20) extent: 200 ]
								ifFalse: [ anObject morphFullBoundsInWorld ]]);
		yourself! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 8/5/2012 19:38' prior: 16899297!
                      morphsAt: aPoint behind: aMorph unlocked: aBool 
	"Return all morphs at aPoint that are behind frontMorph; if aBool is true return only unlocked, visible morphs."

	| isBack found all |
	all _ (aMorph isNil or: [owner isNil]) 
				ifTrue: [
					"Traverse down"
					(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [^#()].
					(aBool and: [self isLocked or: [self visible not]]) ifTrue: [^#()].
					nil]
				ifFalse: ["Traverse up"
					all _ owner 
								morphsAt: aPoint
								behind: self
								unlocked: aBool.
					WriteStream with: all].
	isBack _ aMorph isNil.
	self submorphsDo: [ :m |
			isBack 
				ifTrue: [
					found _ m 
								morphsAt: aPoint
								behind: nil
								unlocked: aBool.
					found notEmpty 
						ifTrue: 
							[all ifNil: [all _ WriteStream on: #()].
							all nextPutAll: found]].
			m == aMorph ifTrue: [isBack _ true]].
	(isBack and: [self containsPoint: aPoint]) 
		ifTrue: 
			[all ifNil: [^Array with: self].
			all nextPut: self].
	^all ifNil: [#()] ifNotNil: [all contents]! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 8/5/2012 19:38' prior: 16899345!
                     morphsAt: aPoint unlocked: aBool do: aBlock
	"Evaluate aBlock with all the morphs starting at the receiver which appear at aPoint. If aBool is true take only visible, unlocked morphs into account."
	| |
	(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse:[^self].
	(aBool and:[self isLocked or:[self visible not]]) ifTrue:[^self].
	self submorphsDo: [ :m |
		m morphsAt: aPoint unlocked: aBool do: aBlock].
	(self containsPoint: aPoint) ifTrue:[aBlock value: self].! !
!Morph methodsFor: 'private' stamp: 'jmv 8/5/2012 20:15' prior: 50345858!
                        privateMoveBy: delta
	"Private!! Use 'position:' instead."

	"All these will die soon!!"

	self flag: #jmvVer2.
	self validateOwnerNotNil.

	bounds _ bounds translateBy: delta.
	fullBounds ifNotNil: [ 
		fullBounds _ fullBounds translateBy: delta.
		fullBounds _ bounds ]! !
!ColorPickerMorph methodsFor: 'menu' stamp: 'jmv 8/5/2012 19:35' prior: 50344568!
                           pickUpColorFor: aMorph
	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"

      | aHand localPt oldCursor |
	aHand _ aMorph isNil
		ifTrue: [self world activeHand] 
		ifFalse: [ aMorph activeHand].
	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) morphFullBoundsInWorld.
	self owner ifNil: [^ self].

	oldCursor _ Sensor currentCursor.
	ColorPickerMorph eyeDropperCursor show.

	self updateContinuously: false.
	[Sensor anyButtonPressed]
		whileFalse: 
			 [self trackColorUnderMouse].
	self deleteAllBalloons.

	localPt _World activeHand morphPosition - bounds topLeft.
	self inhibitDragging ifFalse: [
		(DragBox containsPoint: localPt) ifTrue:
			["Click or drag the drag-dot means to anchor as a modeless picker"
			^ self anchorAndRunModeless: aHand].
	].
	(clickedTranslucency _ TransparentBox containsPoint: localPt)
		ifTrue: [selectedColor _ originalColor].

	self updateContinuously: true.
	[Sensor anyButtonPressed]
		whileTrue:
			 [self updateTargetColorWith: self indicateColorUnderMouse].
	aHand newMouseFocus: nil;
		flushEvents.
	oldCursor show.
	self delete.
		 
 ! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 8/5/2012 19:35' prior: 16821329!
             putUpFor: aMorph near: aRectangle
	"Put the receiver up on the screen.   Note highly variant behavior depending on the setting of the #modalColorPickers preference"
	| layerNumber |
	(aMorph is: #Morph) ifTrue: [
		layerNumber _ aMorph morphicLayerNumber.
		aMorph allOwnersDo: [ : m|
			layerNumber _ layerNumber min: m morphicLayerNumber].
		self setProperty: #morphicLayerNumber toValue: layerNumber - 0.1 ].

	isModal == true "backward compatibility"
		ifTrue: [
			self pickUpColorFor: aMorph]
		ifFalse: [
			self addToWorld:
				((aMorph notNil and: [aMorph world notNil])
					ifTrue: [ aMorph world ]
					ifFalse: [ self currentWorld ])
		  		near:
					(aRectangle ifNil:
						[aMorph ifNil: [100@100 extent: 1@1] ifNotNil: [ aMorph morphFullBoundsInWorld ]])]! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 8/5/2012 19:35' prior: 50342843!
containsPoint: aPoint event: anEvent
	"mouseButton3 events are handled by the halo"
	(anEvent isMouse and: [ anEvent isMouseDown and: [ anEvent mouseButton3Pressed ]])
		ifFalse:  [^super containsPoint: aPoint event: anEvent ].
	^self morphFullBoundsInWorld containsPoint: anEvent eventPosition! !
!HaloMorph methodsFor: 'updating' stamp: 'jmv 8/5/2012 19:36' prior: 50353338!
       redrawNeeded
	"Quicker to invalidate handles individually if target is large (especially the world)"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
	extent > (200@200)
		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [
					"Invalidate 4 outer strips first, thus subsuming separate damage."
					(self morphFullBoundsInWorld areasOutside: target morphBoundsInWorld) do:
						[ :r | self invalidRect: r ]].
				self submorphsDo: [:m | m redrawNeeded]]
		ifFalse: [ super redrawNeeded ]! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:36' prior: 16864758!
         fullDrawOn: aCanvas 
	"A HandMorph has unusual drawing requirements:
		1. the hand itself (i.e., the cursor) appears in front of its submorphs
		2. morphs being held by the hand cast a shadow on the world/morphs below
	The illusion is that the hand plucks up morphs and carries them above the world."

	self visible ifFalse: [^self].
	(aCanvas isVisible: self morphFullBoundsInWorld) ifFalse: [^self].
	self nonCachingFullDrawOn: aCanvas.
! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:40' prior: 16864897!
                       savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| ownBnds fullBnds bw |
	ownBnds _ self bounds.
	fullBnds _ self morphFullBoundsInWorld.
	(savedPatch isNil or: [savedPatch extent ~= fullBnds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBnds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: (fullBnds translateBy: aCanvas origin)
		into: savedPatch.
	savedPatch offset: fullBnds topLeft.
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth.
		aStream nextPut: ownBnds.
		prevBounds ifNotNil: [ aStream nextPut: prevBounds ].
		(fullBnds areasOutside: (fullBnds insetBy: bw)) do: [ :r |
			aStream nextPut: r ].
		prevFullBounds ifNotNil: [
			(prevFullBounds areasOutside: (prevFullBounds insetBy: bw)) do: [ :r |
				aStream nextPut: r ]]]
	ifFalse: [
		prevFullBounds ifNil: [
			aStream nextPut: fullBnds ]
		ifNotNil: [
			aStream nextPut: (fullBnds merge: prevFullBounds)]].
	prevBounds _ ownBnds.
	prevFullBounds _ fullBnds! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:36' prior: 16864938!
                              shadowForm
	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"
	| bnds canvas |
	bnds _ Rectangle merging: (submorphs collect: [:m | m morphFullBoundsInWorld]).
	canvas _ Display defaultCanvasClass forShadowOver: bnds.
	self drawSubmorphsOn: canvas.
	^ canvas formWithOffset! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 8/5/2012 19:36' prior: 50353995!
                   itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last |
	scroller hasSubmorphs ifFalse: [ ^nil ].
	(scroller morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [ ^nil ].
	ptY _ aPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	scroller firstSubmorph morphPositionInWorld y > ptY ifTrue: [ ^nil ].
	last _ scroller lastSubmorph.
	last morphPositionInWorld y + last morphExtentInWorld y < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^scroller 
		findSubmorphBinary: [ :m |
			(m morphPositionInWorld y <= ptY and: [ m morphPositionInWorld y + m morphExtentInWorld y >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPositionInWorld y + (m morphExtentInWorld y // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 8/5/2012 19:37' prior: 50353718!
   popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition - self morphPosition.
	sourceItem owner owner addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last - (self morphWidth @ 0) value: false;
		value: rightOrLeftPoint first value: true! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 8/5/2012 19:39' prior: 50343756!
                          dispatchDefault: anEvent with: aMorph
	"Dispatch the given event. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside |
	"See if we're fully outside aMorphs bounds"
	(aMorph morphFullBoundsInWorld containsPoint: anEvent eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: anEvent eventPosition event: anEvent ].
	inside ifTrue: [ ^aMorph handleEvent: anEvent ].
	^ #rejected! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 8/5/2012 19:39' prior: 50343784!
         dispatchDropEvent: anEvent with: aMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside |

	"Try to get out quickly"
	(aMorph morphFullBoundsInWorld containsPoint: anEvent eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: anEvent.
	anEvent wasHandled ifTrue:[^self].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: anEvent eventPosition event: anEvent ].
	inside ifTrue: [ ^aMorph handleEvent: anEvent ].
	^#rejected! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 8/5/2012 19:39' prior: 50343816!
                            dispatchMouseDown: anEvent with: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
"
	| globalPt handler inside lastHandler |
	"Try to get out quickly"
	globalPt _ anEvent eventPosition.
	(aMorph morphFullBoundsInWorld containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ anEvent handler. "in case the mouse wasn't even in the receiver"
	handler _ aMorph handlerForMouseDown: anEvent.
	handler ifNotNil: [ anEvent handler: handler ].

	"Now give our submorphs a chance to handle the event"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				"Some child did contain the point so we're part of the top-most chain."
				inside _ true.
			]]].

	(inside or: [ aMorph containsPoint: anEvent eventPosition event: anEvent ]) ifTrue:[
		"Receiver is in the top-most unlocked, visible chain."
		handler ifNotNil: [ handler handleEvent: anEvent ].
		"Note: Re-installing the handler is not really necessary but good style."
		anEvent handler: lastHandler.
		^self ].

	"Mouse was not on receiver nor any of its children"
	anEvent handler: lastHandler.
	^#rejected! !
!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 8/5/2012 19:39' prior: 50344047!
   acceptDroppingMorph: dropped event: evt 
	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"

	| aMorph |
	aMorph := self morphToDropFrom: dropped.
	self isWorldMorph 
		ifTrue: [	"Add the given morph to this world and start stepping it if it wants to be."

			self addMorphFront: aMorph.
			(aMorph morphFullBoundsInWorld intersects: self viewBox) 
				ifFalse: [
					Beeper beep.
					aMorph morphPosition: bounds center]]
		ifFalse: [super acceptDroppingMorph: aMorph event: evt].
	aMorph submorphsDo: [ :m | (m isKindOf: HaloMorph) ifTrue: [ m delete ]].
	self world startSteppingSubmorphsOf: aMorph! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 8/5/2012 19:39' prior: 50347094!
  addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect _ Rectangle center: aPoint extent: aMorph morphFullBoundsInWorld extent.
	delta _ trialRect amountToTranslateWithin: bounds.
	self addMorph: aMorph.
	aMorph morphPosition: trialRect origin + delta.! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 8/5/2012 19:39' prior: 50346605!
          openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self bounds: (0@0 extent: w@h).
	labelMorph fitContents.
	subLabelMorph fitContents.
	self layoutSubmorphs.
	self align: self morphBoundsInWorld center with: Display boundingBox center.
	aWorld startSteppingSubmorphsOf: self.! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 8/5/2012 19:39' prior: 16965341!
                  changeColor
	"Change the color of the receiver -- triggered, e.g. from a menu.  This variant allows the recolor triggered from the window's halo recolor handle to have the same result as choosing change-window-color from the window-title menu"

	ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: self activeHand;
		target: self;
		selector: #setWindowColor:;
		originalColor: self color;
		putUpFor: self near: self morphFullBoundsInWorld! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 8/5/2012 19:39' prior: 16965396!
        setWindowColor
	"Allow the user to select a new basic color for the window"

	ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: self activeHand;
		target: self;
		selector: #setWindowColor:;
		originalColor: self widgetsColor;
		putUpFor: self near: self morphFullBoundsInWorld! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 8/5/2012 19:39' prior: 16971495!
   chooseColor
	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"

	| attribute |
	(ColorPickerMorph new)
		choseModalityFromPreference;
		sourceHand: morph activeHand;
		target: (attribute := TextColor color: Color black);
		selector: #color:;
		originalColor: Color black;
		putUpFor: morph near: morph morphFullBoundsInWorld.	"default"
	^attribute! !
!WorldState methodsFor: 'hands' stamp: 'jmv 8/5/2012 19:39' prior: 16986467!
               selectHandsToDrawForDamage: damageList
	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."

	| result hBnds |
	result _ OrderedCollection new.
	hands do: [:h |
		h needsToBeDrawn ifTrue: [
			h hasChanged
				ifTrue: [result add: h]
				ifFalse: [
					hBnds _ h morphFullBoundsInWorld.
					(damageList detect: [:r | r intersects: hBnds] ifNone: nil)
						ifNotNil: [result add: h]]]].
	^ result
! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:39' prior: 50354472!
  drawHand: aHandMorph

	| bw r |
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth // 2.
		r _ aHandMorph morphFullBoundsInWorld.
		canvas frameRectangle: r borderWidth: bw color: Color black.
		canvas frameRectangle: (r insetBy: bw) borderWidth: bw color: Color white.
		canvas clipBy: aHandMorph morphBoundsInWorld during: [ :c | aHandMorph drawOn: c ]]
	ifFalse: [
		aHandMorph fullDrawOn: canvas ]! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 8/5/2012 19:39' prior: 50354488!
                          drawInvalidAreasWorld: aWorld submorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |
	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ OrderedCollection new.
	(damageRecorder invalidRectsFullBounds: aWorld viewBox) do: [ :r |
		r ifNotNil: [ initialRectsToRepair addLast: r ]].
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			(canvas copyClipRect: r) clipBy: aWorld morphBoundsInWorld during: [ :c | aWorld drawOn: c ]]].
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could merge all xrects into just one call... Most likely, that would be slower, though."
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			m fullDrawOn: (canvas copyClipRect: r)
		].
"		(canvas copyClipRect: rr) fullDrawMorph: m "
	].
	
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !

HandMorph removeSelector: #fullBounds!

HandMorph removeSelector: #fullBounds!

Morph removeSelector: #fullBounds!

Morph removeSelector: #fullBounds!

Morph removeSelector: #nearestOwnerThat:!

Morph removeSelector: #nearestOwnerThat:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1351-CuisCore-JuanVuletich-2012Aug05-20h11m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1351] on 5 August 2012 at 8:30:34 pm'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent layoutNeeded '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!Morph methodsFor: 'fileIn/out' stamp: 'jmv 8/5/2012 19:49' prior: 16897737!
                 prepareToBeSaved
	"Prepare this morph to be saved to disk. Subclasses should nil out any instance variables that holds state that should not be saved, such as cached Forms. Note that this operation may take more drastic measures than releaseCachedState; for example, it might discard the transcript of an interactive chat session."

	self releaseCachedState.
	fullBounds _ nil.
	layoutNeeded _ true! !
!Morph methodsFor: 'private' stamp: 'jmv 8/5/2012 19:48' prior: 50348745!
    privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
			
	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			bounds _ position extent: extent.
			fullBounds _ nil.
			layoutNeeded _ true.
			self validatePositionAndBounds.
			self validateExtentAndBounds.
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					bounds _ (owner externalizeToWorld: position) extent: extent.
					fullBounds _ nil.
					layoutNeeded _ true.
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 8/5/2012 19:50' prior: 16879939!
             layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [	
		layoutNeeded _ false.
		^fullBounds _ bounds].

	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self layoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self layoutBounds ]! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 8/5/2012 19:49' prior: 50346037!
                         adjustHorizontallyBy: aLayoutAdjustMorph at: aPoint
	| delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |
	doNotResizeBelow _ self minPaneWidthForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	l _ self submorphs at: i +1.
	ls _ l layoutSpec.
	lCurrentWidth _ l morphWidth max: 1.	"avoid division by zero"
	r _ self submorphs at: i - 1.
	rs _ r layoutSpec.
	rCurrentWidth _ r morphWidth max: 1.	"avoid division by zero"
	delta _ aPoint x - aLayoutAdjustMorph referencePosition x.
	delta _ delta max: doNotResizeBelow - lCurrentWidth.
	delta _ delta min: rCurrentWidth - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	rNewWidth _ rCurrentWidth - delta.
	lNewWidth _ lCurrentWidth + delta.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [	"If both proportional, update them"
			ls setProportionalWidth: (1.0 * lNewWidth / lCurrentWidth * ls proportionalWidth).
			rs setProportionalWidth: (1.0 * rNewWidth / rCurrentWidth * rs proportionalWidth) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	self layoutSubmorphs.
	fullBounds _ bounds.
	layoutNeeded _ false.! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 8/5/2012 19:49' prior: 50346080!
  adjustVerticallyBy: aLayoutAdjustMorph at: aPoint
	| delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |
	doNotResizeBelow _ self minPaneHeightForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	t _ self submorphs at: i +1.
	ts _ t layoutSpec.
	tCurrentHeight _ t morphHeight max: 1.	"avoid division by zero"
	b _ self submorphs at: i - 1.
	bs _ b layoutSpec.
	bCurrentHeight _ b morphHeight max: 1.	"avoid division by zero"
	delta _ aPoint y - aLayoutAdjustMorph referencePosition y.
	delta _ delta max: doNotResizeBelow - tCurrentHeight.
	delta _ delta min: bCurrentHeight - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	tNewHeight _ tCurrentHeight + delta.
	bNewHeight _ bCurrentHeight - delta.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [	"If both proportional, update them"
			ts setProportionalHeight: (1.0 * tNewHeight / tCurrentHeight * ts proportionalHeight).
			bs setProportionalHeight: (1.0 * bNewHeight / bCurrentHeight * bs proportionalHeight) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	self layoutSubmorphs.
	fullBounds _ bounds.
	layoutNeeded _ false.! !

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1352-CuisCore-JuanVuletich-2012Aug05-20h29m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1351] on 5 August 2012 at 10:00:35 pm'!
!Morph methodsFor: 'layout' stamp: 'jmv 8/5/2012 19:45' prior: 50354773!
                    layoutSubmorphsAndComputeFullBounds
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.

	fullBounds ifNotNil: [ ^self ].
	layoutNeeded ifNil: [ layoutNeeded _ true ].
	layoutNeeded ifFalse: [ ^self ].

	self layoutSubmorphs.
	fullBounds _ self computeFullBounds.
	fullBounds _ bounds.
	layoutNeeded _ false! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/5/2012 19:46' prior: 16898471!
     someSubmorphPositionOrExtentChanged
	"In some submorph or in self"
	fullBounds ifNil: [ ^self ]. "layout will be recomputed so don't bother"
	fullBounds _ nil.
	layoutNeeded ifNil: [ layoutNeeded _ true ].
	layoutNeeded ifTrue: [ ^self ].
	layoutNeeded _ true.	"layout will be recomputed so don't bother"
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'updating' stamp: 'jmv 8/5/2012 22:00' prior: 50353176!
  redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Just ours, or include submorphs if we don't clip.
	Think about it. We don't to know about a specific rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"
	
	"This method is the only real use of ivar fullBounds, other than senders of #fullBounds"

	layoutNeeded ifNil: [ layoutNeeded _ true ].
	self invalidRect: (layoutNeeded
		ifFalse: [ self morphFullBoundsInWorld ]
		ifTrue: [ self morphBoundsInWorld ])! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1353-CuisCore-JuanVuletich-2012Aug05-20h30m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1351] on 5 August 2012 at 10:06:30 pm'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent layoutNeeded '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!Morph methodsFor: 'fileIn/out' stamp: 'jmv 8/5/2012 22:03' prior: 50355505!
                              prepareToBeSaved
	"Prepare this morph to be saved to disk. Subclasses should nil out any instance variables that holds state that should not be saved, such as cached Forms. Note that this operation may take more drastic measures than releaseCachedState; for example, it might discard the transcript of an interactive chat session."

	self releaseCachedState.
	layoutNeeded _ true! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/5/2012 22:03' prior: 50355698!
                        layoutSubmorphsAndComputeFullBounds
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.

	layoutNeeded ifNil: [ layoutNeeded _ true ].
	layoutNeeded ifFalse: [ ^self ].

	self layoutSubmorphs.
	
	"useful someday?"
	self computeFullBounds.

	layoutNeeded _ false! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/5/2012 22:04' prior: 50355716!
                   someSubmorphPositionOrExtentChanged
	"In some submorph or in self"
	layoutNeeded ifNil: [ layoutNeeded _ true ].
	layoutNeeded ifTrue: [ ^self ].
	layoutNeeded _ true.	"layout will be recomputed so don't bother"
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'private' stamp: 'jmv 8/5/2012 22:03' prior: 50354892!
privateMoveBy: delta
	"Private!! Use 'position:' instead."

	"All these will die soon!!"

	self flag: #jmvVer2.
	self validateOwnerNotNil.

	bounds _ bounds translateBy: delta! !
!Morph methodsFor: 'private' stamp: 'jmv 8/5/2012 22:03' prior: 50355520!
   privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
			
	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			bounds _ position extent: extent.
			layoutNeeded _ true.
			self validatePositionAndBounds.
			self validateExtentAndBounds.
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					bounds _ (owner externalizeToWorld: position) extent: extent.
					layoutNeeded _ true.
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 8/5/2012 22:04' prior: 50355575!
                         layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [	
		layoutNeeded _ false.
		^self].

	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self layoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self layoutBounds ]! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 8/5/2012 22:04' prior: 50355589!
        adjustHorizontallyBy: aLayoutAdjustMorph at: aPoint
	| delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |
	doNotResizeBelow _ self minPaneWidthForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	l _ self submorphs at: i +1.
	ls _ l layoutSpec.
	lCurrentWidth _ l morphWidth max: 1.	"avoid division by zero"
	r _ self submorphs at: i - 1.
	rs _ r layoutSpec.
	rCurrentWidth _ r morphWidth max: 1.	"avoid division by zero"
	delta _ aPoint x - aLayoutAdjustMorph referencePosition x.
	delta _ delta max: doNotResizeBelow - lCurrentWidth.
	delta _ delta min: rCurrentWidth - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	rNewWidth _ rCurrentWidth - delta.
	lNewWidth _ lCurrentWidth + delta.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [	"If both proportional, update them"
			ls setProportionalWidth: (1.0 * lNewWidth / lCurrentWidth * ls proportionalWidth).
			rs setProportionalWidth: (1.0 * rNewWidth / rCurrentWidth * rs proportionalWidth) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	self layoutSubmorphs.
	layoutNeeded _ false! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 8/5/2012 22:04' prior: 50355632!
                         adjustVerticallyBy: aLayoutAdjustMorph at: aPoint
	| delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |
	doNotResizeBelow _ self minPaneHeightForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	t _ self submorphs at: i +1.
	ts _ t layoutSpec.
	tCurrentHeight _ t morphHeight max: 1.	"avoid division by zero"
	b _ self submorphs at: i - 1.
	bs _ b layoutSpec.
	bCurrentHeight _ b morphHeight max: 1.	"avoid division by zero"
	delta _ aPoint y - aLayoutAdjustMorph referencePosition y.
	delta _ delta max: doNotResizeBelow - tCurrentHeight.
	delta _ delta min: bCurrentHeight - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	tNewHeight _ tCurrentHeight + delta.
	bNewHeight _ bCurrentHeight - delta.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [	"If both proportional, update them"
			ts setProportionalHeight: (1.0 * tNewHeight / tCurrentHeight * ts proportionalHeight).
			bs setProportionalHeight: (1.0 * bNewHeight / bCurrentHeight * bs proportionalHeight) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	self layoutSubmorphs.
	layoutNeeded _ false! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/5/2012 22:05' prior: 50349011!
                    viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
"	super morphPosition: newViewBox topLeft."
	bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.! !

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1354-CuisCore-JuanVuletich-2012Aug05-22h00m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1351] on 5 August 2012 at 10:12:45 pm'!
!Morph methodsFor: 'initialization' stamp: 'jmv 8/5/2012 22:08' prior: 50348666!
            initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	bounds _ self defaultBounds.

	position _ bounds topLeft.
	extent _ bounds extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	color _ self defaultColor.
	layoutNeeded _ false! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/5/2012 22:11' prior: 50355789!
        layoutSubmorphsAndComputeFullBounds
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.
	layoutNeeded ifNil: [ layoutNeeded _ false ].
	layoutNeeded ifTrue: [

		self layoutSubmorphs.
	
		"useful someday?"
		self computeFullBounds.

		layoutNeeded _ false ]! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/5/2012 22:11' prior: 50355806!
                       someSubmorphPositionOrExtentChanged
	"In some submorph or in self"
	layoutNeeded ifFalse: [
		layoutNeeded _ true.	"layout will be recomputed so don't bother"
		owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]]! !
!Morph methodsFor: 'updating' stamp: 'jmv 8/5/2012 22:09' prior: 50355730!
                  redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Just ours, or include submorphs if we don't clip.
	Think about it. We don't to know about a specific rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"
	
	self invalidRect: (layoutNeeded
		ifFalse: [ self morphFullBoundsInWorld ]
		ifTrue: [ self morphBoundsInWorld ])! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1355-CuisCore-JuanVuletich-2012Aug05-22h06m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1351] on 5 August 2012 at 10:59:33 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:32'!
          morphBoundsInWorld: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ self morphExtentInWorld.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPositionInWorld: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPositionInWorld: newBounds topLeft; morphExtent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self morphExtent: newExtent; morphPositionInWorld: newBounds topLeft.
	].! !
!Transcript class methodsFor: 'preferred protocol' stamp: 'jmv 8/5/2012 22:18'!
       morphBoundsInWorld: aRectangle
	innerRectangle _ aRectangle insetBy: self borderWidth + self padding.! !
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 8/5/2012 22:17' prior: 50350541!
                       buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ RectangleMorph new.
	outerBox
		morphExtent: finalSizeInteger asPoint * resizeFactor;
		borderWidth: 0;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox morphBoundsInWorld.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPositionInOwner: 12@8.	"not a clue why these numbers work..."
	
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!FormCanvas class methodsFor: 'private' stamp: 'jmv 8/5/2012 22:17' prior: 16861654!
        buildArrowIn: aRectangle 
	"PRIVATE - create an arrow bounded in aRectangle"
	"
	(self buildArrowOfDirection: #up size: 20) display
	"

	| arrow vertices |
	vertices _ self verticesForSimpleArrow: aRectangle.
	arrow _ PolygonMorph 
		vertices: vertices
		color: Color darkGray
		borderWidth: 0
		borderColor: Color black.
	"arrow bounds: (arrow bounds insetBy: (aRectangle width / 6) rounded)."
	^arrow! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 8/5/2012 22:22' prior: 50351364!
                        testLayout2
	"
	self new testLayout2
	"
	| pane row c1 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (c1 _ RectangleMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (c2 _ RectangleMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ RectangleMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane openInWorld; morphExtent: 400@300.
	World doOneCycleNow.

	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = (pane morphHeight - 10 * 0.9) rounded.
	self assert: c1 morphBoundsInWorld bottom = (row morphBoundsInWorld bottom - 5) description: 'Should be at bottom'.
	self assert: c1 morphWidth = 20.
	self assert: c1 morphHeight = (row morphHeight - 10 * 0.8) rounded.
	self assert: c2 morphBoundsInWorld top = (row morphBoundsInWorld top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = 256.
	self assert: c2 morphHeight = 40.
	self assert: ((c3 morphBoundsInWorld top - row morphBoundsInWorld top) - (row morphBoundsInWorld bottom - c3 morphBoundsInWorld bottom)) abs < 2 description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (c1 morphHeight / 0.8 * 0.7) rounded.

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 8/5/2012 22:24' prior: 50351417!
                   testLayout3
	"
	self new testLayout3
	"
	| pane row innerRow i1 i2 i3 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	innerRow _ LayoutMorph newRow color: Color red;  separation: 5.
	innerRow
		addMorph: (i1 _ RectangleMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i2 _ RectangleMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i3 _ RectangleMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 minorDirectionPadding: #center);
		addMorph: (c2 _ RectangleMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ RectangleMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 200).
	pane openInWorld; morphExtent: 400@300.
	World doOneCycleNow.

	self assert: row morphBoundsInWorld left = (pane morphBoundsInWorld left + 5).
	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = 200.
	self assert: innerRow morphBoundsInWorld left = (row morphBoundsInWorld left + 5).
	self assert: (innerRow morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - innerRow morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: innerRow morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: innerRow morphHeight = 30.

	self assert: i1 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 5).
	self assert: (i1 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i1 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i1 morphWidth = 10.
	self assert: i1 morphHeight = 10.
	self assert: i2 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 20).
	self assert: (i2 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i2 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i2 morphWidth = 10.
	self assert: i2 morphHeight = 10.
	self assert: i3 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 35).
	self assert: (i3 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i3 morphWidth = (innerRow morphWidth - 40).
	self assert: i3 morphHeight = 10.

	self assert: c2 morphBoundsInWorld top = (row morphBoundsInWorld top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: c2 morphHeight = 40.
	self assert: (c3 morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - c3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (row morphHeight - 10).

	pane delete! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:19' prior: 50353093!
   innerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

"would be better In own coordinates!!"
	self flag: #jmvVer2.
	^ self morphBoundsInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:30' prior: 50348526!
              morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - self morphPositionInWorld.
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - self morphPositionInWorld.

	position _ newPositionInOwner.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 8/5/2012 22:25' prior: 50346625!
                      addHalo: evt
	| halo prospectiveHaloClass |
	prospectiveHaloClass _ Smalltalk at: self haloClass ifAbsent: [HaloMorph].
	halo _ prospectiveHaloClass new.
	halo popUpFor: self event: evt.
	halo morphBoundsInWorld: self worldBoundsForHalo.
	^halo! !
!Morph methodsFor: 'menus' stamp: 'jmv 8/5/2012 22:37' prior: 50354800!
changeColor
	"Change the color of the receiver -- triggered, e.g. from a menu"

	"ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: self activeHand;
		target: self;
		selector: #color:;
		originalColor: self color;
		putUpFor: self near: self morphFullBoundsInWorld"! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 8/5/2012 22:37' prior: 50354812!
                   changeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand
	"Put up a color picker for changing some kind of color.  May be modal or modeless, depending on #modalColorPickers setting"
	self flag: #arNote. "Simplify this due to anObject == self for almost all cases"
	"^ ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: aHand;
		target: anObject;
		selector: aSymbol;
		originalColor: aColor;
		putUpFor: anObject near: ((anObject is: #Morph)
					ifTrue: [ Rectangle center: self morphPosition extent: 20 ]
					ifFalse: [ anObject == self world
								ifTrue: [ anObject viewBox bottomLeft + (20@-20) extent: 200 ]
								ifFalse: [ anObject morphFullBoundsInWorld ]]);
		yourself"! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 8/5/2012 22:31' prior: 50350866!
                           resizeMorph
	| handle |
	handle := HandleMorph new 
				forEachPointDo: [:newPoint | self morphExtent: newPoint - self morphPositionInWorld].
	self activeHand attachMorph: handle.
	handle startStepping! !
!BorderedMorph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:41' prior: 16793241!
innerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

	^ self morphBoundsInWorld insetBy: borderWidth! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/5/2012 22:25' prior: 50351582!
  createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	self addMorph: result.
	result morphBoundsInWorld: (29@90 corner: 122@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/5/2012 22:25' prior: 50351594!
  createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	self addMorph: result.
	result morphBoundsInWorld: (149@90 corner: 242@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/5/2012 22:25' prior: 50346766!
 createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	self addMorph: result.
	result morphBoundsInWorld: ( 30@7 corner: 269@22).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/5/2012 22:25' prior: 50352804!
                             createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval
				allowStyler: true.
	result morphExtent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result morphBoundsInWorld: (14@25 corner: 257@84).
	^ result! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:41' prior: 50348799!
              drawOn: aCanvas
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: (color alpha: 0.57)
		at: self morphPositionInWorld! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 8/5/2012 22:20' prior: 50348808!
        step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target morphBoundsInWorld]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = self morphBoundsInWorld
		ifTrue: [^ self].
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newBounds extent = extent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating ifFalse: [
		submorphs size > 1
			ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self morphBoundsInWorld: newBounds! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 22:25' prior: 50350193!
addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPositionInOwner: 0@0 ]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 22:25' prior: 16864002!
        addHandles
	| box |
	target isWorldMorph ifTrue: [ ^ self addHandlesForWorldHalos ].

	self removeAllMorphs.  "remove old handles, if any"
	self morphBoundsInWorld: target worldBoundsForHalo.  "update my size"
	box _ self basicBox.

	target addHandlesTo: self box: box.

	self addName.
	growingOrRotating _ false.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 22:18' prior: 16864016!
                       addHandlesForWorldHalos
	"Add handles for world halos, like the man said"

	| box w |
	w _ self world ifNil:[target world].
	self removeAllMorphs.  "remove old handles, if any"
	self morphBoundsInWorld: target morphBoundsInWorld.
	box _ w morphBoundsInWorld insetBy: 9.
	target addWorldHandlesTo: self box: box.

	self
		addNameBeneath: (box insetBy: (0@0 corner: 0@10))
		string: (innerTarget printStringLimitedTo: 40).
	growingOrRotating _ false.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 22:18' prior: 50347702!
                addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleMorph new
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph morphExtent y + 5).
	nameBackground morphBoundsInWorld: (nameMorph morphBoundsInWorld outsetBy: 2).
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 22:57' prior: 50345938!
                    basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self handleSize.
	anExtent _ ((self morphWidth + self handleSize + 8) max: minSide) @
				((self morphHeight + self handleSize + 8) max: minSide).
	aBox _ Rectangle center: self morphBoundsInWorld extent: anExtent.
	w _ self world ifNil: [ target outermostWorldMorph ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: 8@8) ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 22:19' prior: 50343059!
                      startGrow: evt with: growHandle
	"Initialize resizing of my target.  Launch a command representing it, to support Undo"

	| botRt |
	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.
	botRt _ target morphPositionInWorld + target morphExtentInWorld.
	positionOffset _ (self world viewBox containsPoint: botRt)
		ifTrue: [evt eventPosition - botRt]
		ifFalse: [0@0]! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:20' prior: 50355018!
                    savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| ownBnds fullBnds bw |
	ownBnds _ self morphBoundsInWorld.
	fullBnds _ self morphFullBoundsInWorld.
	(savedPatch isNil or: [savedPatch extent ~= fullBnds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBnds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: (fullBnds translateBy: aCanvas origin)
		into: savedPatch.
	savedPatch offset: fullBnds topLeft.
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth.
		aStream nextPut: ownBnds.
		prevBounds ifNotNil: [ aStream nextPut: prevBounds ].
		(fullBnds areasOutside: (fullBnds insetBy: bw)) do: [ :r |
			aStream nextPut: r ].
		prevFullBounds ifNotNil: [
			(prevFullBounds areasOutside: (prevFullBounds insetBy: bw)) do: [ :r |
				aStream nextPut: r ]]]
	ifFalse: [
		prevFullBounds ifNil: [
			aStream nextPut: fullBnds ]
		ifNotNil: [
			aStream nextPut: (fullBnds merge: prevFullBounds)]].
	prevBounds _ ownBnds.
	prevFullBounds _ fullBnds! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 8/5/2012 22:19' prior: 50348273!
        attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m morphExtentInWorld // 2.
	m morphPosition: (self morphPosition - delta).
	targetOffset _ m morphPosition - self morphPosition.! !
!HandleMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 8/5/2012 22:41' prior: 16865766!
                         justDroppedInto: aMorph event: anEvent
	"So that when the hand drops me (into the world) I go away"
	lastPointBlock ifNotNil: [lastPointBlock value: self morphBoundsInWorld center].
	self flag: #arNote. "Probably unnecessary"
	anEvent hand releaseKeyboardFocus: self.
	self redrawNeeded.
	self delete! !
!HandleMorph methodsFor: 'stepping and presenter' stamp: 'jmv 8/5/2012 22:41' prior: 16865817!
                 step
	pointBlock value: self morphBoundsInWorld center! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:25' prior: 50353428!
      adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ self morphPositionInWorld.
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m morphBoundsInWorld: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self morphExtent: w@y! !
!LayoutAdjustingMorph methodsFor: 'event handling' stamp: 'jmv 8/5/2012 22:25' prior: 16879729!
   mouseDown: anEvent
	super mouseDown: anEvent.
	self cursor show.
	hand _ anEvent hand.
	self startStepping.
	Preferences fastDragWindowForMorphic ifTrue: [
		indicator _ RectangleIndicatorMorph new.
		indicator morphBoundsInWorld: self initialIndicatorBounds.
		indicator openInWorld ]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 8/5/2012 22:25' prior: 50350949!
                layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight r t b |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableWidth _ boundsForLayout width - ((submorphs size + 1) * xSep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth _ usableWidth - sumOfFixed.
	padding ifNil: [	"shrink"
		availableForPropWidth = 0 ifFalse: [
			self flag: #jmvVer2.
			self width: self width - availableForPropWidth.
			^ self layoutSubmorphsAndComputeFullBounds ]].
	normalizationFactor _ self proportionalWidthNormalizationFactor.
	availableForPropWidth _ availableForPropWidth * normalizationFactor.
	widths _ submorphs collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + xSep max: 0) +  boundsForLayout left.
	usableHeight _ boundsForLayout height - (2*ySep) max: 0.
	boundsTop _ boundsForLayout top.	
	boundsRight _ boundsForLayout right.
	submorphs size to: 1 by: -1 do: [ :index | | m w h ls |
		m _ submorphs at: index.
		w _ widths at: index.
		"major direction"
		r _ l + w min: boundsRight.
		"minor direction"
		ls _ m layoutSpec.
		h _ (ls heightFor: usableHeight) min: usableHeight.
		t _ (usableHeight - h) * ls minorDirectionPadding + ySep + boundsTop.
		b _ t + h.
		"Set bounds and adjust major direction for next step"
		m morphBoundsInWorld: (l rounded @ t rounded corner: r rounded @ b rounded).
		w > 0 ifTrue: [
			l _ r + xSep min: boundsRight ]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 8/5/2012 22:25' prior: 50351003!
          layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom b l r |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableHeight _ boundsForLayout height - ((submorphs size + 1) * ySep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight _ usableHeight - sumOfFixed.
	padding ifNil: [	"shrink"
		availableForPropHeight = 0 ifFalse: [
			self flag: #jmvVer2.
			self height: self height - availableForPropHeight.
			^ self layoutSubmorphsAndComputeFullBounds ]].
	normalizationFactor _ self proportionalHeightNormalizationFactor.
	availableForPropHeight _ availableForPropHeight * normalizationFactor.
	heights _ submorphs collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + ySep max: 0) +  boundsForLayout top.
	usableWidth _ boundsForLayout width - (2*xSep) max: 0.
	boundsLeft _ boundsForLayout left.	
	boundsBottom _ boundsForLayout bottom.
	submorphs size to: 1 by: -1 do: [ :index | | m h w ls |
		m _ submorphs at: index.
		h _ heights at: index.
		"major direction"
		b _ t + h min: boundsBottom.
		"minor direction"
		ls _ m layoutSpec.
		w _ (ls widthFor: usableWidth) min: usableWidth.
		l _ (usableWidth - w) * ls minorDirectionPadding + xSep + boundsLeft.
		r _ l + w.
		"Set bounds and adjust major direction for next step"
		m morphBoundsInWorld: (l rounded @ t rounded corner: r rounded @ b rounded).
		h > 0 ifTrue: [
			t _ b + ySep min: boundsBottom ]]! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/5/2012 22:27' prior: 50351197!
              example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane color: Color lightGreen; morphBoundsInWorld: (120 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '1').

rect1 := RectangleMorph new color: (Color lightOrange); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect1.
rect2 := RectangleMorph new color: (Color cyan); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect2.
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "2"
pane color: Color lightGreen; morphBoundsInWorld: (320 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '2').

rect1 := RectangleMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := RectangleMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane color: Color lightGreen; morphBoundsInWorld: (520 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '3').

rect1 := RectangleMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := RectangleMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane openInWorld.! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 8/5/2012 22:47' prior: 50343436!
                      sourcePoint
	"If we are being dragged use our center, otherwise use pointer position"
	^ (trackPointer not or: [owner notNil and: [owner is: #HandMorph]])
		ifTrue: [ self morphBoundsInWorld center ]
		ifFalse: [ self activeHand morphPosition ]! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 8/5/2012 22:33' prior: 50346925!
                    contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker.
	marker morphPosition: self morphPositionInWorld + (0@2)! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:58' prior: 16886877!
                    drawOn: aCanvas 
	| stringColor stringBounds leftEdge b |

	b _ self morphBoundsInWorld.
	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas fillRectangle: b colorOrInfiniteForm: Theme current menuHighlight].
	leftEdge := 0.
	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ].
			aCanvas image: iconForm at: b left+1 @ (b top + (b height - iconForm height // 2)).
			leftEdge _ iconForm width + self iconSeparation].

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + self submorphBounds width + 8 ].

	stringBounds _ b left + leftEdge @ (b top + 1) corner: b corner.

	aCanvas
		drawString: contents
		in: stringBounds
		font: self fontToUse
		color: stringColor.
	subMenu
		ifNotNil: [ aCanvas image: SubMenuMarker at: b right - 8 @ (b top + b bottom - SubMenuMarker height // 2) ]! !
!MenuItemMorph methodsFor: 'grabbing' stamp: 'jmv 8/5/2012 22:33' prior: 50348304!
    aboutToBeGrabbedBy: aHand
	"Don't allow the receiver to act outside a Menu"
	| menu box |
	(owner notNil and: [ owner submorphs size = 1]) ifTrue:[
		"I am a lonely menuitem already; just grab my owner"
		owner stayUp.
		^owner aboutToBeGrabbedBy: aHand ].
	box _ self morphBoundsInWorld.
	menu _ MenuMorph new defaultTarget: nil.
	menu addMorphFront: self.
	menu morphBoundsInWorld: box.
	menu stayUp.
	self isSelected: false.
	^menu! !
!MenuItemMorph methodsFor: 'grabbing' stamp: 'jmv 8/5/2012 22:33' prior: 16887059!
                       duplicateMorph: evt
	"Make and return a duplicate of the receiver's argument"
	| dup menu |
	dup _ self duplicate isSelected: false.
	menu _ MenuMorph new defaultTarget: nil.
	menu addMorphFront: dup.
	menu morphBoundsInWorld: self morphBoundsInWorld.
	menu stayUp.
	evt hand grabMorph: menu from: owner. "duplicate was ownerless so use #grabMorph:from: here"
	^menu! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 8/5/2012 22:34' prior: 16887131!
                          select: evt
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphPositionInWorld topRight + (10@0)
									with: self morphPositionInWorld topLeft)
			forHand: evt hand
			from: self.
		subMenu selectItem: nil event: evt].! !
!MenuMorph methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:42' prior: 50343728!
                moveRight: aNumber
	self morphPosition: ((aNumber - self morphExtentInWorld x) @ self morphPositionInWorld y)! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:48' prior: 16906322!
                        characterIndexAtPoint: aPoint

	| line block f |
	f _ self fontToUse.
	
	line _ TextLine 
		start: 1
		stop: contents size
		internalSpaces: 0
		paddingWidth: 0.
	line
		rectangle: self morphBoundsInWorld;
		lineHeight: f height baseline: f ascent.
		
	block _ (CharacterBlockScanner new text: 
			(contents asText font: font))
		characterBlockAtPoint: aPoint index: nil
		in: line.

	^ block stringIndex! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:51' prior: 16906337!
                 displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas
	| caretColor x1 isBold isItalic x0 h w halfW r d |
	isBold _ emphasis allMask: 1.
	isItalic _ emphasis allMask: 2.
	caretColor _ Theme current insertionPoint.
	h _ bottom - top.
	w _ isBold
		ifTrue: [ h // 25 + 2 ]
		ifFalse: [ h // 30 + 1 ].
	halfW _ w // 2.
	isItalic
		ifTrue: [	
			"Keep tweaking if needed!!"
			d _ isBold ifTrue: [ 3 ] ifFalse: [ h // 24].
			x0 _ x- (h*5//24) + d.
			x1 _ x + d ]
		ifFalse: [
			x0 _ x.
			x1 _ x].
	x0 < halfW ifTrue: [
		x1 _ x1 - x0 + halfW.
		x0 _ halfW ].
	r _ self morphBoundsInWorld right-halfW-1.
	r < x1 ifTrue: [
		x0 _ x0 + r - x1.
		x1 _ r ].
	caretRect _ x0-halfW-1@ top corner: x1+halfW+1+1 @ bottom.
	aCanvas
		line: x0@(bottom-halfW) to: x1@(top+halfW)
		width: w color: caretColor! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:48' prior: 16906365!
              drawCaretOn: aCanvas
	"Essentially copied from #displayInsertionMarkAtX:top:bottom:emphasis:on:"
	|  top bottom x tl |

	showCaret ifTrue: [
		tl _ self morphPositionInWorld.
		top _ tl y.
		bottom _ top + self baseFont height.
		x _ (self fontToUse widthOfString: contents from: 1 to: editor startIndex-1) + tl x.
		self displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas ]! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 8/5/2012 22:43' prior: 16911557!
             invalidRect: damageRect from: aMorph
        "Clip damage reports to my bounds, since drawing is clipped to my bounds."

        self == self outermostWorldMorph 
                ifTrue: [worldState recordDamagedRect: (damageRect intersect: self morphBoundsInWorld )]
                ifFalse: [super invalidRect: damageRect from: aMorph]
! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:57' prior: 16911588!
                         drawOn: aCanvas

	"draw background image."
	| b |
	b _ self morphBoundsInWorld.
	backgroundImage
		ifNotNil: [
			"self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"
			self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage at: b topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage at: b topLeft ]]

		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [color class == TranslucentColor])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt current toForm: Display)
						clipRect: aCanvas clipRect;
						copy: b
						from: 0@0 in: nil
						fillColor: color rule: Form over]
				ifFalse: [ super drawOn: aCanvas ]]! !
!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 8/5/2012 22:43' prior: 50355256!
                         acceptDroppingMorph: dropped event: evt 
	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"

	| aMorph |
	aMorph := self morphToDropFrom: dropped.
	self isWorldMorph 
		ifTrue: [	"Add the given morph to this world and start stepping it if it wants to be."

			self addMorphFront: aMorph.
			(aMorph morphFullBoundsInWorld intersects: self viewBox) 
				ifFalse: [
					Beeper beep.
					aMorph morphPosition: self morphBoundsInWorld center]]
		ifFalse: [super acceptDroppingMorph: aMorph event: evt].
	aMorph submorphsDo: [ :m | (m isKindOf: HaloMorph) ifTrue: [ m delete ]].
	self world startSteppingSubmorphsOf: aMorph! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/5/2012 22:42' prior: 50355979!
               viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
"	super morphPosition: newViewBox topLeft."
	bounds _ newViewBox.
	position _ owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ].
	extent _ newViewBox extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 8/5/2012 22:43' prior: 50355280!
                             addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect _ Rectangle center: aPoint extent: aMorph morphFullBoundsInWorld extent.
	delta _ trialRect amountToTranslateWithin: self morphBoundsInWorld.
	self addMorph: aMorph.
	aMorph morphPosition: trialRect origin + delta.! !
!PasteUpMorph methodsFor: 'private' stamp: 'jmv 8/5/2012 22:43' prior: 16912508!
 privateMoveBy: delta

	super privateMoveBy: delta.
	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox: self morphBoundsInWorld 
		].
	].! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:44' prior: 50351637!
                               draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: self morphBoundsInWorld
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:55' prior: 50349073!
                            drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y b |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		b _ self morphBoundsInWorld.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ b center.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ b width-labelMargin-labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ b left + labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawStringEmbossed: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: colorForLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:54' prior: 50351606!
               drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin b |

	f _ self fontToUse.
	b _ self morphBoundsInWorld.
	center _ b center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ b width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ b left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'jmv 8/5/2012 22:44' prior: 16913818!
                           containsPoint: aPoint

	| iconOrigin |
	(self morphBoundsInWorld containsPoint: aPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin _ self morphBoundsInWorld center - (magnifiedIcon extent // 2).
			(magnifiedIcon isTransparentAt: aPoint - iconOrigin) not ]]! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:44' prior: 16915033!
        hScrollBarWidth
	"Return the width of the horizontal scrollbar"

	| w |	
	w _ self morphExtentInWorld x - (2 * borderWidth).
	self vIsScrollbarShowing
		ifTrue: [ w _ w - self scrollBarClass scrollbarThickness ].
	^w! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:54' prior: 16915131!
           updateScrollBarsBounds
	
	| t topLeft b |
	hideScrollBars ifTrue: [^self].
	t _ self scrollBarClass scrollbarThickness.

	b _ self morphBoundsInWorld.

	topLeft _ b topRight + (0-t-borderWidth @ borderWidth).
	scrollBar morphBoundsInWorld: (topLeft extent: t @ self vScrollBarHeight).

	topLeft _ b bottomLeft + (borderWidth @ (t + borderWidth) negated).
	hScrollBar morphBoundsInWorld: (topLeft extent: self hScrollBarWidth@ t)! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:44' prior: 16915154!
                       vScrollBarHeight
	^self morphExtentInWorld y - (2 * borderWidth)! !
!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 8/5/2012 22:53' prior: 50344278!
                        mouseMove: event 
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row b |
	b _ self morphBoundsInWorld.
	row _ (event eventPosition y < b top and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: b topLeft) + 2 ]
		ifFalse: [
			(event eventPosition y > b bottom and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: b bottomLeft) - 3 ]
				ifFalse: [ self rowAtLocation: event eventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 8/5/2012 22:26' prior: 16916587!
      addHandles
	| handle newVert tri |
	self removeHandles.
	handles _ OrderedCollection new.
	tri _ Array with: 0@-4 with: 4@3 with: -3@3.
	vertices withIndexDo:
		[ :vertPt :vertIndex |
		handle _ EllipseMorph new.
		handle on: #mouseMove send: #dragVertex:event:fromHandle:
				to: self withValue: vertIndex.
		handle on: #mouseUp send: #dropVertex:event:fromHandle:
				to: self withValue: vertIndex.
		self addMorph: handle.
		handle
			morphBoundsInWorld: (Rectangle center: vertPt extent: 8@8);
			color: Color yellow.
		handles addLast: handle.
		(closed or: [vertIndex < vertices size]) ifTrue: [
			newVert _ PolygonMorph
					vertices: (tri collect: [:p | p + (vertPt + (vertices atWrap: vertIndex+1) // 2)])
					color: Color green borderWidth: 1 borderColor: Color black.
			newVert on: #mouseDown send: #newVertex:event:fromHandle:
					to: self withValue: vertIndex.
			self addMorph: newVert.
			handles addLast: newVert]].
	smoothCurve ifTrue: [self updateHandles; someSubmorphPositionOrExtentChanged].
	self redrawNeeded! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 8/5/2012 22:21' prior: 50347137!
 updateHandles
	| newVert oldVert midPts nextVertIx tweens |
	smoothCurve
		ifTrue: [
			handles first referencePosition: vertices first.
			handles last referencePosition: vertices last.
			midPts _ OrderedCollection new.
			nextVertIx _ 2.
			tweens _ OrderedCollection new.
			self
				lineSegmentsDo: [:p1 :p2 | 
					tweens addLast: p2 asIntegerPoint.
					p2 = (vertices atWrap: nextVertIx)
						ifTrue: ["Found endPoint."
							midPts addLast: (tweens at: tweens size // 2)
									+ (tweens at: tweens size + 1 // 2) // 2.
							tweens _ OrderedCollection new.
							nextVertIx _ nextVertIx + 1]].
			midPts withIndexDo: [:midPt :vertIndex |
				(closed or: [vertIndex < vertices size]) ifTrue: [
					newVert _ handles at: vertIndex * 2.
					newVert referencePosition: midPt ]]]
		ifFalse: [
			vertices
				withIndexDo: [ :vertPt :vertIndex | 
					oldVert _ handles at: vertIndex * 2 - 1.
					oldVert referencePosition: vertPt.
					(closed or: [vertIndex < vertices size])
						ifTrue: [
							newVert _ handles at: vertIndex * 2.
							newVert morphPosition: vertPt
									+ (vertices atWrap: vertIndex + 1) - newVert morphExtentInWorld // 2 + (1 @ -1)]]]! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 8/5/2012 22:26' prior: 50355297!
        openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self morphBoundsInWorld: (0@0 extent: w@h).
	labelMorph fitContents.
	subLabelMorph fitContents.
	self layoutSubmorphs.
	self align: self morphBoundsInWorld center with: Display boundingBox center.
	aWorld startSteppingSubmorphsOf: self.! !
!RectangleIndicatorMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:49' prior: 16927479!
                        drawOn: aCanvas
	| bw b |
	bw _ self defaultBorderWidth.
	b _ self morphBoundsInWorld.
	aCanvas frameRectangle: b borderWidth: bw color: Color black.
	aCanvas frameRectangle: (b insetBy: bw) borderWidth: bw color: Color white! !
!StarMorph methodsFor: 'handles' stamp: 'jmv 8/5/2012 22:27' prior: 16952267!
             addHandles
	| center handle1 handle2 |
	self removeHandles.
	center _ vertices sum // vertices size.   "Average vertices to get the center"
	handle1 _ EllipseMorph new.
	handle1
		on: #mouseDown send: #dragVertex:event:fromHandle: to: self withValue: #center;
		on: #mouseMove send: #dragVertex:event:fromHandle: to: self withValue: #center.
	self addMorph: handle1.
	handle1 morphBoundsInWorld: (Rectangle center: center extent: 8@8); color: Color yellow.			
	handle2 _ EllipseMorph new.
	handle2
		on: #mouseDown send: #dragVertex:event:fromHandle: to: self withValue: #outside;
		on: #mouseMove send: #dragVertex:event:fromHandle: to: self withValue: #outside.
	self addMorph: handle2.
	handle2 morphBoundsInWorld: (Rectangle center: vertices second extent: 8@8); color: Color yellow.	
	handles _ { handle1 . handle2 }.
	self redrawNeeded! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 8/5/2012 22:39' prior: 16961675!
                            reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	ClassicTheme beCurrent.
	World backgroundImageData: nil.
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	FormCanvas clearFormsCache.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	CursorWithAlpha class removeSelector: #buildBiggerNormal.
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	World submorphsDo: [ :a | a delete ].
	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	"????
	Smalltalk organization removeCategoriesMatching: 'Signal Processing*'.
	SystemOrganization removeSystemCategory: 'LinearAlgebra'.
	Smalltalk organization removeCategoriesMatching: 'Sound-*'
	"

	Beeper setDefault: nil.
	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(ZipConstants GZipConstants ZipFileConstants ChronologyConstants SpaceTally).
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSorter zapAllChangeSets.
	Smalltalk garbageCollect.


	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:47' prior: 16964914!
                          addPossiblyUncoveredAreasIn: aRectangle to: aCollection
	"Answer an array of rectangles encompassing those areas in aRectangle not completely
	covered by self. These are the areas that might require further drawing (of morphs below us)
	All areas that might possibly be uncovered must be included."
	 | r |
	color mightBeTranslucent ifTrue: [
		aCollection add: aRectangle.
		^self ].

	"Solid rectangle.
	This will be the fastest in many cases. So, please disable rounded corners if on slow hardware!!"
	Theme current roundWindowCorners ifFalse: [
		aRectangle areasOutside: self morphBoundsInWorld do: [ :rr |  aCollection add: rr ].
		^self ].

	"The solid rectangle does not include the corners.
	Report a couple of rows (top and bottom) or columns (left and right) as uncovered areas.
	We could also try to be more careful and answer each rounded corner...
	Right now, report top and bottom rows as uncovered areas"
	r _ Theme current roundedWindowRadius.
	aRectangle areasOutside: (self morphBoundsInWorld insetBy: 0@r) do: [ :rr |  aCollection add: rr ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:45' prior: 16964949!
       drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	aCanvas fillRectangle: self titleAreaInnerRect colorOrInfiniteForm: titleColor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:46' prior: 16964995!
                        drawRoundedFrameOn: aCanvas color: widgetsColor
	"Title area is not inside window borders"
	| bottomFactor topFactor |
	Theme current useWindowTitleGradient
		ifTrue: [
			topFactor _ Theme current titleGradientTopFactor.
			bottomFactor _ Theme current titleGradientBottomFactor ]
		ifFalse: [
			topFactor _ 1.
			bottomFactor _ 1 ].
	aCanvas
		windowFrame: self morphBoundsInWorld 
		color: widgetsColor * Theme current titleGradientExtraLightness
		radius: Theme current roundedWindowRadius
		border: borderWidth
		labelHeight: self labelHeight + borderWidth
		gradientTop: topFactor
		gradientBottom: bottomFactor
		insideColor: color! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:47' prior: 50332931!
            makeMeFullyVisible 

	self world extent > (0@0) ifFalse: [^ self].

	(self position >= (0@0) and: [ self position < (self world extent-self extent)]) ifTrue: [
		^ self "OK -- visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [self position: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [self position: (RealEstateAgent initialFrameFor: self initialExtent: self morphBoundsInWorld world: self world) topLeft].

! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:45' prior: 16965079!
          innerBounds
	"Exclude the label area"

	^ self morphBoundsInWorld insetBy: (borderWidth @ (self labelHeight+borderWidth) corner: borderWidth @ borderWidth)! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:46' prior: 16965097!
               labelRectangle
	"Actually the whole label area"

	| tl br e x0 y0 x1 y1 b |
	b _ self morphBoundsInWorld.
	tl _ b topLeft.
	br _ b bottomRight.
	e _ self boxExtent.
	x0 _ tl x + ( e x * 4 + 14).
	y0 _ tl y + 2.
	x1 _ br x - 1.
	y1 _ tl y + e y + 1.
	^x0@y0 corner: x1@y1
	
	
	
! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:46' prior: 16965108!
                     labelRectangleForEmbossed
	"Actually the whole label area"

	| tl br e x0 y0 x1 y1 b |
	b _ self morphBoundsInWorld.
	tl _ b topLeft.
	br _ b bottomRight.
	e _ self boxExtent.
	x0 _ tl x + ( e x * 4 + 14).
	y0 _ tl y + 1.
	x1 _ br x - 1.
	y1 _ tl y + e y + 2.
	^x0@y0 corner: x1@y1
	
	
	
! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 8/5/2012 22:45' prior: 16965143!
          titleAreaInnerRect
	"Assumes a border will be drawn at the left, top and right of the title area.
	The look is that the title area is inside the window"
	^ (self morphBoundsInWorld insetBy: borderWidth) withHeight: self labelHeight! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 8/5/2012 22:37' prior: 50355317!
       changeColor
	"Change the color of the receiver -- triggered, e.g. from a menu.  This variant allows the recolor triggered from the window's halo recolor handle to have the same result as choosing change-window-color from the window-title menu"

	"ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: self activeHand;
		target: self;
		selector: #setWindowColor:;
		originalColor: self color;
		putUpFor: self near: self morphFullBoundsInWorld"! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 8/5/2012 22:26' prior: 16965357!
      fullScreen
	"Zoom Window to Full World size with possible DeskMargins"

	"SystemWindow fullScreen"

	| left right possibleBounds |
	left := right := 0.
	possibleBounds := (RealEstateAgent maximumUsableAreaInWorld: self world) 
				insetBy: (left @ 0 corner: right @ 0).
	Preferences fullScreenLeavesDeskMargins 
		ifTrue: [ possibleBounds := possibleBounds insetBy: 22 ].
	self morphBoundsInWorld: possibleBounds! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 8/5/2012 22:37' prior: 50355334!
                  setWindowColor
	"Allow the user to select a new basic color for the window"

	"ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: self activeHand;
		target: self;
		selector: #setWindowColor:;
		originalColor: self widgetsColor;
		putUpFor: self near: self morphFullBoundsInWorld"! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 8/5/2012 22:38' prior: 16965407!
       setWindowColor: incomingColor
	| existingColor aColor |
	incomingColor ifNil: [^ self].  "it happens"
	aColor _ incomingColor asNontranslucentColor.
	aColor = Color black ifTrue: [^ self].
	existingColor _ self widgetsColor.
	existingColor ifNil: [^ Beeper beep].
	self widgetsColor: aColor.
	self redrawNeeded! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 8/5/2012 22:26' prior: 50347249!
                  openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self morphBoundsInWorld: (RealEstateAgent initialFrameFor: self world: aWorld).
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !
!SystemWindow methodsFor: 'top window' stamp: 'jmv 8/5/2012 22:46' prior: 50344785!
             activateAndForceLabelToShow
	self activate.
	self morphPositionInWorld y < 0 ifTrue: [
		self morphPosition: (self morphPosition x @ 0)]! !
!SystemWindow methodsFor: 'change reporting' stamp: 'jmv 8/5/2012 22:56' prior: 16965752!
                          invalidateTitleArea

	"not really pretty... also invalidating the top border, regardless of it being above or below the title area
	(#titleAreaRect and #titleAreaInnerRect)"
	self invalidRect: (self morphBoundsInWorld withHeight: self labelHeight + borderWidth)! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 8/5/2012 22:52' prior: 50349274!
       layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| bl br h thickness tl tr w cornerExtent b |
	thickness _ 4.
	cornerExtent _ 20.
	b _ self morphBoundsInWorld.
	tl _ b topLeft.
	tr _ b topRight.
	bl _ b bottomLeft.
	br _ b bottomRight.
	w _ b width - cornerExtent - cornerExtent.
	h _ b height - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) morphBoundsInWorld: (tl + (cornerExtent@0) extent: w@thickness).
	(adjusters at: #bottomAdjuster) morphBoundsInWorld: (bl+ (cornerExtent @ thickness negated) extent: w@thickness).
	(adjusters at: #leftAdjuster) morphBoundsInWorld: (tl+ (0@cornerExtent) extent: thickness@h).
	(adjusters at: #rightAdjuster) morphBoundsInWorld: (tr + (thickness negated@ cornerExtent) extent: thickness@h).
	(adjusters at: #topLeftAdjuster) morphBoundsInWorld: (tl extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomLeftAdjuster) morphBoundsInWorld: (bl-(0@cornerExtent) extent: cornerExtent@cornerExtent).
	(adjusters at: #topRightAdjuster) morphBoundsInWorld: (tr+(cornerExtent negated@0) extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomRightAdjuster) morphBoundsInWorld: (br-cornerExtent extent: cornerExtent@cornerExtent).

	layoutMorph ifNotNil: [
		layoutMorph morphBoundsInWorld: self layoutBounds ]! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 8/5/2012 22:26' prior: 50345414!
                    windowBottom: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld bottom: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 8/5/2012 22:26' prior: 50345421!
                  windowBottomLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self morphBoundsInWorld: (aPoint x @ self morphBoundsInWorld top corner: self morphBoundsInWorld right @ aPoint y)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 8/5/2012 22:49' prior: 50345429!
                         windowBottomRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self morphBoundsInWorld: (self morphPositionInWorld corner: aPoint)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 8/5/2012 22:27' prior: 50345436!
       windowLeft: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld left: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 8/5/2012 22:27' prior: 50345442!
                      windowRight: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld right: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 8/5/2012 22:27' prior: 50345449!
                    windowTop: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld top: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 8/5/2012 22:27' prior: 50345455!
                        windowTopLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self morphBoundsInWorld: (aPoint corner: self morphBoundsInWorld corner)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 8/5/2012 22:45' prior: 50345462!
      windowTopRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld left @ aPoint y corner: aPoint x @ self morphBoundsInWorld bottom)! !
!Taskbar methodsFor: 'stepping' stamp: 'jmv 8/5/2012 22:28' prior: 50354429!
                              step

	"My dimensions are constrained live."
	| r |
	r _ World morphBoundsInWorld.
	r _ r left @ (r bottom -18) extent: r width@18.
	self morphBoundsInWorld = r ifFalse: [
		self morphBoundsInWorld: r]! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 8/5/2012 22:38' prior: 50355346!
                               chooseColor
	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"

	| |
	"(ColorPickerMorph new)
		choseModalityFromPreference;
		sourceHand: morph activeHand;
		target: (attribute := TextColor color: Color black);
		selector: #color:;
		originalColor: Color black;
		putUpFor: morph near: morph morphFullBoundsInWorld.
	^attribute"! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2012 22:29' prior: 50349315!
                          drawOn: aCanvas
	"
	Transcript
		showOnDisplay: true;
		bounds: bounds;
		displayOn: aCanvas form.
	"
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	Transcript
		showOnDisplay: true;
		morphBoundsInWorld: (0@0 extent: self morphExtentInWorld);
		displayOn: form;
		morphBoundsInWorld: self morphBoundsInWorld.
	aCanvas image: form at: self morphPositionInWorld! !
!WindowEdgeAdjustingMorph methodsFor: 'geometry testing' stamp: 'jmv 8/5/2012 22:51' prior: 50346481!
                            containsPoint: aPoint
	| sensitiveBorder b |
	b _ self morphBoundsInWorld.
	(b containsPoint: aPoint) ifFalse: [ ^false ].
	sensitiveBorder _ 4.
	selector caseOf: {
		[ #windowTopLeft: ] -> [ ^ aPoint x - b left < sensitiveBorder or: [ aPoint y - b top < sensitiveBorder ]].
		[ #windowTopRight: ] -> [ ^ b right - aPoint x <= sensitiveBorder or: [ aPoint y - b top < sensitiveBorder ]].
		[ #windowBottomLeft: ] -> [ ^ aPoint x - b left < sensitiveBorder or: [ b bottom - aPoint y <= sensitiveBorder ]].
		[ #windowBottomRight: ] -> [ ^ b right - aPoint x <= sensitiveBorder or: [ b bottom - aPoint y <= sensitiveBorder ]].
	}
	otherwise: [
		"all the morph is sensitive for horizontal and vertical (i.e. non corner) instances."
		^true ]! !

Transcript class removeSelector: #bounds:!

Transcript class removeSelector: #bounds:!

Morph removeSelector: #bounds!

Morph removeSelector: #bounds!

Morph removeSelector: #bounds:!

Morph removeSelector: #bounds:!

Smalltalk removeClassNamed: #ColorPickerMorph!

Smalltalk removeClassNamed: #ColorPickerMorph!

Smalltalk removeClassNamed: #SketchMorph!

Smalltalk removeClassNamed: #SketchMorph!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1356-CuisCore-JuanVuletich-2012Aug05-22h12m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1356] on 6 August 2012 at 9:39:22 am'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs color extension position extent layoutNeeded '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!FormCanvas class methodsFor: 'private' stamp: 'jmv 8/6/2012 09:15' prior: 50356158!
                   buildArrowIn: aRectangle 
	"PRIVATE - create an arrow bounded in aRectangle"
	"
	(self buildArrowOfDirection: #up size: 20) display
	"

	| arrow vertices |
	vertices _ self verticesForSimpleArrow: aRectangle.
"	arrow _ PolygonMorph 
		vertices: vertices
		color: Color darkGray
		borderWidth: 0
		borderColor: Color black."
	"arrow bounds: (arrow bounds insetBy: (aRectangle width / 6) rounded)."
	^arrow! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 09:19' prior: 50348413!
                             basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	
	
	self validateExtentAndBounds.
	extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
"	bounds _ bounds topLeft extent: aPoint."
	extent _ aPoint.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 09:35' prior: 50352994!
           morphBoundsInWorld
	"Return the bounds of this morph."
	
	"WORLD absolute bounds :("

	"remove senders and implementors"
	| answer |
	self flag: #jmvVer2.
	answer _ self morphPositionInWorld extent: self morphExtentInWorld.
	"
	bounds = answer ifFalse: [
		#morphBoundsInWorld print.
		answer print.
		bounds print.
		thisContext printStack: 10 ].
	"
	^answer
	! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 09:19' prior: 50348470!
        morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = self morphPositionInWorld ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	self validateOwnerNotNil.


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - self morphPositionInWorld.

	position _ newPositionInOwner.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 09:18' prior: 50348507!
                          morphPositionInWorld
	| answer1 |
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
"	answer2 _ bounds topLeft.
	{ answer1 . answer2 }."

	^answer1! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 09:27' prior: 50356347!
          morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		"
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
		"
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - self morphPositionInWorld.
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - self morphPositionInWorld.

	position _ newPositionInOwner.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 09:17' prior: 50349541!
                            validateExtentAndBounds
	"To be removed. Just to check consistency"
	| |
	self flag: #jmvVer2.

"	answer1 _ owner
		ifNotNil: [ owner externalizeDistanceToWorld: extent ]
		ifNil: [ extent ]."

"
	answer1 _ extent.
	answer2 _ bounds extent.

	answer1 = answer2 rounded ifFalse: [
		#validateExtentAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]
"! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 09:17' prior: 50345391!
                     validatePositionAndBounds
	"To be removed. Just to check consistency"
	| |
	self flag: #jmvVer2.
"
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.

	answer1 = answer2 ifFalse: [
		#validatePositionAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]
"! !
!Morph methodsFor: 'initialization' stamp: 'jmv 8/6/2012 09:27' prior: 50356018!
             initialize
	"initialize the state of the receiver"

	| b |
	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	b _ self defaultBounds.
	position _ b topLeft.
	extent _ b extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	color _ self defaultColor.
	layoutNeeded _ false! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/6/2012 09:34' prior: 50348683!
                 computeFullBounds
	"Private. Compute the actual full bounds of the receiver"

	"Remove when removing fullBounds"
	self flag: #jmvVer2.

	(submorphs isEmpty or: [ self clipsSubmorphs ]) ifTrue: [ ^self morphBoundsInWorld ].
	^ self morphBoundsInWorld quickMerge: self submorphBounds! !
!Morph methodsFor: 'private' stamp: 'jmv 8/6/2012 09:26' prior: 50355817!
                         privateMoveBy: delta
	"Private!! Use 'position:' instead."

	"All these will die soon!!"

	self flag: #jmvVer2.
	self validateOwnerNotNil.	"Maybe not needed"

"	bounds _ bounds translateBy: delta"! !
!Morph methodsFor: 'private' stamp: 'jmv 8/6/2012 09:26' prior: 50355825!
              privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
			
	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
"			bounds _ position extent: extent."
			layoutNeeded _ true.
			self validatePositionAndBounds.
			self validateExtentAndBounds.
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
"					bounds _ (owner externalizeToWorld: position) extent: extent."
					layoutNeeded _ true.
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]]! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 8/6/2012 09:37' prior: 50348867!
               initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
"	bounds _ 0@0 extent: CursorWithMask normal extent."
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 8/6/2012 09:28' prior: 50348940!
  initialize
	super initialize.
	
	self flag: #jmvVer2.
"	bounds _ 0@0 corner: 40@10."

	position _ 0@0.
	extent _ 40@10.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 09:38' prior: 50348971!
    morphExtent: aPoint

	self flag: #jmvVer2.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	extent = aPoint ifFalse: [
		self redrawNeeded.
"		bounds _ bounds topLeft extent: aPoint."
		extent _ aPoint.
		self validatePositionAndBounds.
		self validateExtentAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = self morphBoundsInWorld ifFalse: [
				worldState canvas: nil.
				worldState viewBox: self morphBoundsInWorld ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/6/2012 09:37' prior: 50357247!
                           viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
"	super morphPosition: newViewBox topLeft."
"	bounds _ newViewBox."
	position _ owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ].
	extent _ newViewBox extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.! !

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'owner submorphs color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'owner submorphs color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Smalltalk removeClassNamed: #CurveMorph!

Smalltalk removeClassNamed: #CurveMorph!

Smalltalk removeClassNamed: #LineMorph!

Smalltalk removeClassNamed: #LineMorph!

Smalltalk removeClassNamed: #PolygonMorph!

Smalltalk removeClassNamed: #PolygonMorph!

Smalltalk removeClassNamed: #StarMorph!

Smalltalk removeClassNamed: #StarMorph!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1357-CuisCore-JuanVuletich-2012Aug06-09h32m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1357] on 6 August 2012 at 10:17:56 am'!
!HaloMorph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 10:10'!
              morphFullBoundsInWorld
	
	"mhhhh not relly nice"
	| r |
	self flag: #jmvVer2.
	^submorphs isEmpty
		ifTrue: [ super morphFullBoundsInWorld ]
		ifFalse: [
			r _ super morphFullBoundsInWorld.
			submorphs do: [ :m |
				r _ r merge: m morphFullBoundsInWorld ].
			r]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/6/2012 10:07' prior: 50356583!
     addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPositionInOwner: 0@0 ]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/6/2012 09:41' prior: 50356683!
        basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self handleSize.
	anExtent _ ((self morphWidth + self handleSize + 8) max: minSide) @
				((self morphHeight + self handleSize + 8) max: minSide).
	aBox _ Rectangle center: self morphBoundsInWorld center extent: anExtent.
	w _ self world ifNil: [ target outermostWorldMorph ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: 8@8) ]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 8/6/2012 09:51' prior: 50357087!
         select: evt
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + (10@0)
									with: self morphBoundsInWorld topLeft)
			forHand: evt hand
			from: self.
		subMenu selectItem: nil event: evt].! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1358-CuisCore-JuanVuletich-2012Aug06-10h16m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1358] on 6 August 2012 at 4:03:10 pm'!
!Morph methodsFor: 'drawing' stamp: 'jmv 8/6/2012 15:46' prior: 16896600!
                   clippingBounds
	"Return the bounds to which any submorphs should be clipped if the property is set"
	"Maybe shouldn't exist"
	self flag: #jmvVer2.
	^self innerBounds! !
!Morph methodsFor: 'initialization' stamp: 'jmv 8/6/2012 15:46' prior: 16898298!
      defaultBounds
"answer the default bounds for the receiver"

	"Maybe shouldn't exist"
	self flag: #jmvVer2.
	^ 0 @ 0 corner: 50 @ 40! !
!ImageMorph methodsFor: 'geometry' stamp: 'jmv 8/6/2012 15:49' prior: 50347322!
         morphExtent: aPoint
	"Do nothing; my extent is determined by my image Form."

	"A clear case of a morph that shouldn't have an 'extent' ivar..."
	self flag: #jmvVer2.! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1359-CuisCore-JuanVuletich-2012Aug06-15h42m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1359] on 7 August 2012 at 7:19:50 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:17' prior: 50358135!
     basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	extent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:17' prior: 50348432!
                         morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:18' prior: 50348441!
                      morphHeight

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ extent y! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:11' prior: 50348456!
                    morphPositionInOwner
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"

	self flag: #jmvVer2.
	self validateOwnerNotNil.

	^ position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:11' prior: 50358168!
        morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = self morphPositionInWorld ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	self validateOwnerNotNil.


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - self morphPositionInWorld.

	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:13' prior: 50358206!
                           morphPositionInWorld
	| answer1 |
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	self validateOwnerNotNil.
	
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
"	answer2 _ bounds topLeft.
	{ answer1 . answer2 }."

	^answer1! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:14' prior: 50358225!
          morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		"
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
		"
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - self morphPositionInWorld.
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - self morphPositionInWorld.

	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:18' prior: 50348612!
                             morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ extent x! !
!Morph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:10' prior: 50358341!
               initialize
	"initialize the state of the receiver"

	| b |
	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	b _ self defaultBounds.
	position _ b topLeft.
	extent _ b extent.
	color _ self defaultColor.
	layoutNeeded _ false! !
!Morph methodsFor: 'private' stamp: 'jmv 8/7/2012 19:17' prior: 50358379!
                privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"

	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			layoutNeeded _ true ]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					layoutNeeded _ true ]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					]]! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 8/7/2012 19:08' prior: 50356555!
                              drawOn: aCanvas

	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: (color alpha: 0.57)
		at: self morphPositionInWorld! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 8/7/2012 19:09' prior: 50356564!
       step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target morphBoundsInWorld]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = self morphBoundsInWorld
		ifTrue: [^ self].
	newBounds extent = extent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating ifFalse: [
		submorphs size > 1
			ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self morphBoundsInWorld: newBounds! !
!HaloMorph methodsFor: 'updating' stamp: 'jmv 8/7/2012 19:08' prior: 50354982!
                               redrawNeeded
	"Quicker to invalidate handles individually if target is large (especially the world)"

	extent > (200@200)
		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [
					"Invalidate 4 outer strips first, thus subsuming separate damage."
					(self morphFullBoundsInWorld areasOutside: target morphBoundsInWorld) do:
						[ :r | self invalidRect: r ]].
				self submorphsDo: [:m | m redrawNeeded]]
		ifFalse: [ super redrawNeeded ]! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:09' prior: 50358433!
  initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 8/7/2012 19:09' prior: 50348880!
                            borderWidth: bw

	| newExtent |
	newExtent _ 2 * bw + image extent.
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ]! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:09' prior: 50348889!
      morphExtent: aPoint
	| newExtent |
	"Resist changing the extent if no wordwrap.. this should be checked."
	wrapFlag ifFalse: [ ^ self ].
	newExtent _ aPoint truncated max: self minimumExtent.
	
	"No change of wrap width"
	newExtent x = extent x ifTrue: [ ^ self ].

	super morphExtent: newExtent.
	
	self resetParagraph.
	self editor recomputeSelection.	
	self updateFromParagraph.! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 8/7/2012 19:09' prior: 50349733!
            fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent |
	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ].

	self redrawNeeded.	"Too conservative: only paragraph composition
							should cause invalidation."
	owner innerHeight: newExtent y! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:10' prior: 50358446!
                initialize
	super initialize.
	position _ 0@0.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 8/7/2012 19:17' prior: 50348951!
                      fitContents

	| newExtent |
	newExtent _ self measureContents.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 8/7/2012 19:18' prior: 50348960!
                 fitContents

	| newExtent |
	newExtent _ self measureContents.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:15' prior: 50358457!
                        morphExtent: aPoint

	self flag: #jmvVer2.
	extent = aPoint ifFalse: [
		self redrawNeeded.
		extent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = self morphBoundsInWorld ifFalse: [
				worldState canvas: nil.
				worldState viewBox: self morphBoundsInWorld ]]]! !
!PasteUpMorph methodsFor: 'misc' stamp: 'jmv 8/7/2012 19:15' prior: 50348991!
                  buildMagnifiedBackgroundImage
	| image old |
	old _ backgroundImage.
	backgroundImageData
		ifNil: [ backgroundImage _ nil ]
		ifNotNil: [ 
			image _ Form fromBinaryStream: backgroundImageData readStream.
			backgroundImage _ image magnifyTo: extent.
			self canvas ifNotNil: [ :c |
				(backgroundImage depth = 32 and: [ c depth < 32 ]) ifTrue: [
					backgroundImage _ backgroundImage orderedDither32To16 ]]
		].
	old == backgroundImage ifFalse: [
		self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/7/2012 19:15' prior: 50358479!
             viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	position _ owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ].
	extent _ newViewBox extent! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:15' prior: 50350750!
      morphExtent: newExtent

	| newExtentToUse |
	newExtent = extent ifTrue: [^ self].
	newExtentToUse _ self isHorizontal
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 8/7/2012 19:18' prior: 50349229!
                         fitContents

	| newExtent |
	newExtent _ self measureContents.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 8/7/2012 19:15' prior: 50358043!
                      drawOn: aCanvas
	"
	Transcript
		showOnDisplay: true;
		bounds: bounds;
		displayOn: aCanvas form.
	"
	Transcript
		showOnDisplay: true;
		morphBoundsInWorld: (0@0 extent: self morphExtentInWorld);
		displayOn: form;
		morphBoundsInWorld: self morphBoundsInWorld.
	aCanvas image: form at: self morphPositionInWorld! !

Morph removeSelector: #validateExtentAndBounds!

Morph removeSelector: #validateExtentAndBounds!

Morph removeSelector: #validatePositionAndBounds!

Morph removeSelector: #validatePositionAndBounds!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1360-CuisCore-JuanVuletich-2012Aug07-19h08m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1359] on 7 August 2012 at 7:24:34 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:21' prior: 50358685!
         morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = self morphPositionInWorld ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	self validateOwnerNotNil.

	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 19:22' prior: 50358738!
      morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		"
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
		"
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !

PasteUpMorph removeSelector: #privateMoveBy:!

PasteUpMorph removeSelector: #privateMoveBy:!

Morph removeSelector: #privateFullMoveBy:!

Morph removeSelector: #privateFullMoveBy:!

Morph removeSelector: #privateMoveBy:!

Morph removeSelector: #privateMoveBy:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1361-CuisCore-JuanVuletich-2012Aug07-19h19m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1361] on 7 August 2012 at 7:40:03 pm'!
!Morph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:39' prior: 50358622!
                             defaultBounds
"answer the default bounds for the receiver"

	"Maybe shouldn't exist"
	self flag: #jmvVer2.
	"Anyway, many morphs redefine #initialize asigning an extent... Unify in some style.
	Maybe #defaultExtent?"
	^ 0 @ 0 corner: 50 @ 40! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:35' prior: 50347696!
            initialize

	super initialize.
	extent _  271@121.
	responseUponCancel := ''
	! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:33' prior: 50347792!
                       initialize
	"initialize the state of the receiver"
	super initialize.
	extent _ 12 @ 12! !
!LimitedHeightTextMorph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:35' prior: 16881452!
   initialize
	super initialize.
	extent _  200 @ 120.! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:34' prior: 50347863!
               initialize
	super initialize.
	trackPointer _ true.
	magnification _ 2.
	lastPos _ self sourcePoint.
	extent _ 128@128! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:36' prior: 50346124!
             initialize
	super initialize.
	extent _ extent x @ 2! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:34' prior: 50347972!
        initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	extent _  20 @ 15! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 8/7/2012 19:37' prior: 50348113!
                     initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	extent _ 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1362-CuisCore-JuanVuletich-2012Aug07-19h33m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1362] on 7 August 2012 at 10:54:41 pm'!
!Morph methodsFor: 'change reporting' stamp: 'jmv 8/7/2012 22:53' prior: 16896335!
                           invalidRect: damageRect
	"warning. Senders are using global coordinates. Redesign!!"
	self flag: #jmvVer2.	"ok?"
	^self invalidRect: damageRect from: self! !
!Morph methodsFor: 'change reporting' stamp: 'jmv 8/7/2012 22:54' prior: 16896340!
               invalidRect: aRectangle from: aMorph
	| damageRect |
	"warning. Senders are using global coordinates. Redesign!!"
	self flag: #jmvVer2.	"ok?"
	owner ifNotNil: [
		aRectangle hasPositiveExtent ifFalse: [ ^ self ].
		damageRect _ aRectangle.
		aMorph == self ifFalse: [
			"Clip to receiver's clipping bounds if the damage came from a child"
			self clipsSubmorphs ifTrue: [
				damageRect _ aRectangle intersect: self clippingBounds ]].
		owner
			invalidRect: damageRect
			from: self ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 22:51' prior: 50345671!
           externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates.
	BUT there is no well defined World!!"
	self flag: #jmvVer2.
	^owner
		ifNotNil: [ owner externalizeToWorld: aPoint + position ]
		ifNil: [ aPoint + position ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 22:49' prior: 50358673!
                       morphPositionInOwner
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"

	self flag: #jmvVer2.
	"Maybe we don't really need an owner to answer this..."
	self validateOwnerNotNil.

	^ position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 22:49' prior: 50359099!
               morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = self morphPositionInWorld ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.


	"Maybe we don't really need an owner to run this method..."
	self validateOwnerNotNil.

	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 22:50' prior: 50358721!
        morphPositionInWorld
	| answer1 |
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	"Most likely we don't want to use global coordinates...
	In fact, we could be in many frames of reference at the same time...
	This method makes no sense at all!!"
	self validateOwnerNotNil.
	
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
"	answer2 _ bounds topLeft.
	{ answer1 . answer2 }."

	^answer1! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 22:51' prior: 50359127!
     morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	"This method MUST die"
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		"
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
		"
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/7/2012 22:48' prior: 50349556!
                       validateOwnerNotNil
	"To be removed. Just to check consistency"

	"We can activate this test. But beware. Most of the times the correct fix is NOT ensuring having an owner, but using local coordinates instead of global!!"
	self flag: #jmvVer2.
"
	owner ifNil: [
		'-----Still no owner, but this stuff kind of requires it!!-----' print.
		thisContext printStack: 10 ]
	"! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1363-CuisCore-JuanVuletich-2012Aug07-22h44m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1363] on 8 August 2012 at 11:44:53 pm'!

!classDefinition: #HandMorph category: #'Morphic-Kernel'!
Morph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!Morph methodsFor: 'fileIn/out' stamp: 'jmv 8/8/2012 23:07' prior: 16897751!
        storeDataOn: aDataStream
	"Let all Morphs be written out.  All owners are weak references.  They only go out if the owner is in the tree being written."
	| cntInstVars cntIndexedVars ti localInstVars |

	"block my owner unless he is written out by someone else"
	cntInstVars _ self class instSize.
	cntIndexedVars _ self basicSize.
	localInstVars _ Morph instVarNames.
	ti _ 1.  
	((localInstVars at: ti) = 'owner') & (Morph superclass == Object) ifFalse:
			[self error: 'this method is out of date'].
	aDataStream
		beginInstance: self class
		size: cntInstVars + cntIndexedVars.
	1 to: ti-1 do:
		[:i | aDataStream nextPut: (self instVarAt: i)].
	aDataStream nextPutWeak: owner.	"owner only written if in our tree"
	ti+1 to: cntInstVars do:
		[:i | aDataStream nextPut: (self instVarAt: i)].
	1 to: cntIndexedVars do:
		[:i | aDataStream nextPut: (self basicAt: i)]! !
!HaloMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 8/8/2012 23:39' prior: 50342804!
startDrag: evt with: dragHandle
	"Drag my target without removing it from its owner."

	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	positionOffset _ dragHandle referencePosition - target morphPosition! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/8/2012 23:39' prior: 16864079!
                            doDebug: evt with: menuHandle
	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"

	| menu |
	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self world displayWorld.
	evt shiftPressed ifTrue: [
		self delete.
		^ innerTarget inspect].

	menu _ innerTarget buildDebugMenu: evt hand.
	menu addTitle: (innerTarget printStringLimitedTo: 40).
	menu popUpInWorld: self world! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/8/2012 23:41' prior: 16864103!
doDup: evt with: dupHandle 
	"Ask hand to duplicate my target."

	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self setTarget: (target duplicateMorph: evt).
	evt hand grabMorph: target.
	self step.	"update position if necessary"! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/8/2012 23:41' prior: 16864115!
 doGrab: evt with: grabHandle
	"Ask hand to grab my target."

	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	evt hand grabMorph: target.
	self step. "update position if necessary"! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/8/2012 23:39' prior: 16864146!
                    doMenu: evt with: menuHandle
	"Ask hand to invoke the halo menu for my inner target."

	| menu |
	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self world displayWorld.
	menu _ innerTarget buildHandleMenu: evt hand.
	innerTarget addTitleForHaloMenu: menu.
	menu popUpInWorld: self world.
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/8/2012 23:39' prior: 16864246!
      mouseDownInCollapseHandle: evt with: collapseHandle
	"The mouse went down in the collapse handle; collapse the morph"

	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self setDismissColor: evt with: collapseHandle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/8/2012 23:39' prior: 50356699!
                  startGrow: evt with: growHandle
	"Initialize resizing of my target.  Launch a command representing it, to support Undo"

	| botRt |
	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self removeAllHandlesBut: growHandle.  "remove all other handles"
	botRt _ target morphPositionInWorld + target morphExtentInWorld.
	positionOffset _ (self world viewBox containsPoint: botRt)
		ifTrue: [evt eventPosition - botRt]
		ifFalse: [0@0]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/8/2012 23:39' prior: 50343073!
                             startRot: evt with: rotHandle
	"Initialize rotation of my target if it is rotatable.  Launch a command object to represent the action"

	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	growingOrRotating _ true.

	self removeAllHandlesBut: rotHandle.  "remove all other handles"
	angleOffset _ evt eventPosition - target referencePosition.
	angleOffset _ Point
			r: angleOffset r
			degrees: angleOffset degrees - target rotationDegrees

! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/8/2012 23:27' prior: 50343096!
        handleEvent: anEvent
	| evt |
	owner ifNil: [ ^ self ].
	evt _ anEvent.
	evt isMouseOver ifTrue: [ ^ self sendMouseEvent: evt ].
	
	evt isWindowEvent ifTrue: [
		self sendEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent ].

	evt isKeyboard ifTrue: [
		self sendKeyboardEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	evt isDropEvent ifTrue: [
		self sendEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	evt isMouse ifTrue: [
		lastMouseEvent _ evt.	
		lastMouseEventTime _ Time millisecondClockValue].

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: evt from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	evt isMove ifTrue: [
		self morphPosition: evt eventPosition.
		self sendMouseEvent: evt.
	] ifFalse: [
		"Issue a synthetic move event if we're not at the position of the event"
		evt eventPosition = self morphPosition ifFalse: [ self moveToEvent: evt ].
		"Drop submorphs on button events"
		self hasSubmorphs
			ifTrue: [ self dropMorphs: evt ]
			ifFalse: [ self sendMouseEvent: evt ].
	].
	self mouseOverHandler processMouseOver: lastMouseEvent! !

SystemWindow removeSelector: #handleListenEvent:!

SystemWindow removeSelector: #handleListenEvent:!

PasteUpMorph removeSelector: #unhideHiddenObjects!

PasteUpMorph removeSelector: #unhideHiddenObjects!

HandMorph removeSelector: #addEventListener:!

HandMorph removeSelector: #addEventListener:!

HandMorph removeSelector: #addKeyboardListener:!

HandMorph removeSelector: #addKeyboardListener:!

HandMorph removeSelector: #addListener:to:!

HandMorph removeSelector: #addListener:to:!

HandMorph removeSelector: #addMouseListener:!

HandMorph removeSelector: #addMouseListener:!

HandMorph removeSelector: #eventListeners!

HandMorph removeSelector: #eventListeners!

HandMorph removeSelector: #eventListeners:!

HandMorph removeSelector: #eventListeners:!

HandMorph removeSelector: #keyboardListeners!

HandMorph removeSelector: #keyboardListeners!

HandMorph removeSelector: #keyboardListeners:!

HandMorph removeSelector: #keyboardListeners:!

HandMorph removeSelector: #mouseListeners!

HandMorph removeSelector: #mouseListeners!

HandMorph removeSelector: #mouseListeners:!

HandMorph removeSelector: #mouseListeners:!

HandMorph removeSelector: #removeEventListener:!

HandMorph removeSelector: #removeEventListener:!

HandMorph removeSelector: #removeKeyboardListener:!

HandMorph removeSelector: #removeKeyboardListener:!

HandMorph removeSelector: #removeListener:from:!

HandMorph removeSelector: #removeListener:from:!

HandMorph removeSelector: #removeMouseListener:!

HandMorph removeSelector: #removeMouseListener:!

HandMorph removeSelector: #sendListenEvent:to:!

HandMorph removeSelector: #sendListenEvent:to:!

!classDefinition: #HandMorph category: #'Morphic-Kernel'!
Morph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

HaloMorph removeSelector: #handleListenEvent:!

HaloMorph removeSelector: #handleListenEvent:!

HaloMorph removeSelector: #obtainHaloForEvent:andRemoveAllHandlesBut:!

HaloMorph removeSelector: #obtainHaloForEvent:andRemoveAllHandlesBut:!

Morph removeSelector: #handleListenEvent:!

Morph removeSelector: #handleListenEvent:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1364-CuisCore-JuanVuletich-2012Aug08-23h38m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1364] on 11 August 2012 at 6:37 pm'!
!FFT methodsFor: 'testing' stamp: 'jmv 8/10/2012 23:35' prior: 50342153!
                   plot: samples in: rect
	"Throw-away code just to check out a couple of examples"
	| min max x dx pen y |
	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.
	min _ 1.0e30.  max _ -1.0e30.
	samples do: [ :v |
		min _ min min: v.
		max _ max max: v].
	pen _ Pen new.
	pen up.
	y _ (max/(max-min) * rect height + rect top).
	pen goto: rect left@ y.
	pen down.
	pen goto: rect right@ y.
	pen up.
	x _ rect left.
	dx _ rect width asFloat / samples size.
	samples do: [ :v |
		y _ (max-v) / (max-min) * rect height asFloat.
		pen goto: x asInteger @ (rect top + y asInteger).
		pen down.
		x _ x + dx].
	max printString displayOn: Display at: (x+2) @ (rect top-9).
	min printString displayOn: Display at: (x+2) @ (rect bottom - 9)! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1365-CuisCore-JuanVuletich-2012Aug11-18h33m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1364] on 11 August 2012 at 6:41:47 pm'!
!CodeFileBrowser methodsFor: 'infoView' stamp: 'jmv 8/11/2012 18:40' prior: 16811582!
annotation
	^self infoViewContents! !

CodeFileBrowser removeSelector: #annotationForClassDefinitionFor:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1366-CuisCore-JuanVuletich-2012Aug11-18h37m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1364] on 14 August 2012 at 9:23:08 am'!
!Scanner methodsFor: 'expression types' stamp: 'jmv 8/14/2012 09:11' prior: 16933329!
                         scanAllTokenPositionsInto: aBlock
	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."

	| lastMark |
	lastMark := 1.
	[currentComment ifNotNil:
		[currentComment do:
			[:cmnt| | idx |
			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.
			 (idx > 0 and: [idx < mark]) ifTrue:
				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].
		 currentComment := nil].
	mark ifNotNil:
		[(token == #- 
		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue:
			[| savedMark |
			 savedMark := mark.
			 self scanToken.
			 token := token negated.
			 mark := savedMark].
		"Compensate for the fact that the parser uses two character lookahead.  Normally we must
		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."
		 aBlock
			value: mark
			value: (source position - (aheadChar = 30 ifTrue: [hereChar = 30 asCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2]))].
	 (tokenType == #rightParenthesis
	  or: [tokenType == #doIt]) ifTrue:
		[^self].
	tokenType == #leftParenthesis
		ifTrue: 
			[self scanToken; scanAllTokenPositionsInto: aBlock]
		ifFalse: 
			[(tokenType == #word or: [tokenType == #keyword or: [tokenType == #colon]])
				ifTrue: 
					[self scanLitWord.
					 token == #true ifTrue: [token := true].
					 token == #false ifTrue: [token := false].
					 token == #nil ifTrue: [token := nil]]
				ifFalse:
					[(token == #- 
					  and: [(self typeTableAt: hereChar) == #xDigit])
						ifTrue: 
							[self scanToken.
							 token := token negated]]].
		self scanToken ] repeat! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1367-FixLastAssignmentScan-NicolasCeiller-2012Aug14-09h09m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1367] on 14 August 2012 at 5:09:45 pm'!
!Symbol methodsFor: 'accessing' stamp: 'jmv 8/14/2012 17:09' prior: 16957996!
            precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise.  The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self size = 0 ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c _ self first.
	(c isLetter not and: [ c ~= $_ ]) ifTrue: [^ 2].
	self last = $: ifTrue: [^ 3].
	^ 1! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1368-FixUnderscorePrecedence-ColinPutney-2012Aug14-17h08m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1368] on 15 August 2012 at 3:35:50 pm'!
!FFT methodsFor: 'testing' stamp: 'jmv 8/15/2012 15:35' prior: 50359802!
                              plot: samples in: rect
	"Throw-away code just to check out a couple of examples"
	| min max x dx pen y |
	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.
	min _ 1.0e30.  max _ -1.0e30.
	samples do: [ :v |
		min _ min min: v.
		max _ max max: v].
	pen _ Pen new.
	pen up.
	y _ (max/(max-min) * rect height + rect top).
	pen goto: rect left@ y.
	pen down.
	pen goto: rect right@ y.
	pen up.
	x _ rect left.
	dx _ rect width asFloat / (samples size-1).
	samples do: [ :v |
		y _ (max-v) / (max-min) * rect height asFloat.
		pen goto: x asInteger @ (rect top + y asInteger).
		pen down.
		x _ x + dx].
	max printString displayOn: Display at: (x+2) @ (rect top-9).
	min printString displayOn: Display at: (x+2) @ (rect bottom - 9)! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1369-FFTplotFix-JuanVuletich-2012Aug15-15h24m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1369] on 17 August 2012 at 8:16:24 pm'!

!classDefinition: #UserInputEvent category: #'Morphic-Events'!
MorphicEvent subclass: #UserInputEvent
	instanceVariableNames: 'type buttons position handler wasHandled'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MorphicEvent subclass: #UserInputEvent
	instanceVariableNames: 'type buttons position handler wasHandled '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseButtonEvent category: #'Morphic-Events'!
MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton eventHandler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton eventHandler '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 8/17/2012 15:31'!
                 processKeyboardSensorEvent: evt
	"process a keyboard event, updating InputSensor state"
	| charCode pressCode |
	"Never update keyboardBuffer if we have an eventQueue active"
	mouseButtons _ (mouseButtons bitAnd: 7) bitOr: ((evt at: 5) bitShift: 3).
	eventQueue ifNotNil:[^self]. 
	charCode _ evt at: 3.
	charCode ifNil: [^self]. "extra characters not handled in MVC"
	pressCode _ evt at: 4.
	pressCode = EventSensor eventKeyChar ifFalse:[^self]. "key down/up not handled in MVC"
	"mix in modifiers"
	charCode _ charCode bitOr: ((evt at: 5) bitShift: 8).
	keyboardBuffer nextPut: charCode.! !
!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 8/17/2012 15:31'!
          processMouseSensorEvent: evt
	"process a mouse event, updating InputSensor state"
	| modifiers buttons mapped |
	mousePosition _ (evt at: 3) @ (evt at: 4).
	buttons _ evt at: 5.
	modifiers _ evt at: 6.
	mapped _ self mapButtons: buttons modifiers: modifiers.
	mouseButtons _ mapped bitOr: (modifiers bitShift: 3).! !
!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 8/17/2012 15:31'!
                              processSensorEvent: evt
	"Process a single event. This method is run at high priority."
	| type |
	type _ evt at: 1.

	"Check if the event is a user interrupt"
	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [
		((evt at: 3) bitOr: ((evt at: 5) bitShift: 8)) = interruptKey]])
			 ifTrue: [
				"interrupt key is meta - not reported as event"
				^interruptSemaphore signal].

	"Store the event in the queue if there's any"
	type = EventSensor eventTypeMouse ifTrue: [
		"Only swap secondary and tertiary buttons if there is no modifier keys.
		This swap is done so a 3-button mouse  is
			left -> mouseButton1 (select)
			center -> mouseButton3 (halo)
			right -> mouseButton2 (menu).
		This is only needed on the Mac, Window VM does this mapping by default.
		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:
			left -> mouseButton1
			macOption + left -> mouseButton3
			command + left -> mouseButton2,
		but Mac users are already used to 
			macOption + left -> menu
			command + left -> halo.
		See #installMouseDecodeTable"
		(evt at: 6) = 0 ifTrue: [
			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].

	self queueEvent: evt.

	"Update state for InputSensor."
	type = EventSensor eventTypeMouse ifTrue: [
		self processMouseSensorEvent: evt ].
	type = EventSensor eventTypeKeyboard ifTrue: [
		self processKeyboardSensorEvent: evt ]! !
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 8/17/2012 19:08'!
                        flippedBy: direction centerAt: aPoint
	"Return a copy of the receiver flipped either #vertical or #horizontal."
	| newForm quad |
	newForm _ self class extent: self extent depth: depth.
	quad _ self boundingBox innerCorners.
	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])
		collect: [:i | quad at: i].
	(WarpBlt current toForm: newForm)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: newForm);
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
	newForm offset: (self offset flippedBy: direction centerAt: aPoint).
	^ newForm
"
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
			flippedBy: #vertical centerAt: 0@0) display]
"
"Consistency test...
 | f f2 p | [Sensor anyButtonPressed] whileFalse:
	[f _ Form fromDisplay: ((p _ Sensor mousePoint) extent: 31@41).
	Display fillBlack: (p extent: 31@41).
	f2 _ f flippedBy: #vertical centerAt: 0@0.
	(f2 flippedBy: #vertical centerAt: 0@0) displayAt: p]
"
! !
!ColorForm methodsFor: 'scaling, rotation' stamp: 'jmv 8/17/2012 19:08'!
    flippedBy: direction centerAt: aPoint
	| oldColors newForm |
	oldColors _ colors.
	self colors: nil.
	newForm _ super flippedBy: direction centerAt: aPoint.
	self colors: oldColors.
	newForm colors: oldColors.
	^newForm ! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/17/2012 15:57'!
                           dispatchEvent: aMorphicEvent
	"This is the central entry for dispatching events in morphic. Given some event, find the right receiver and let him handle it."

	^ (self rejectsEvent: aMorphicEvent)
		ifTrue: [ #rejected ]
		ifFalse: [ aMorphicEvent dispatchWith: self ]! !
!HaloMorph class methodsFor: 'instance protocol testing' stamp: 'jmv 8/17/2012 17:50'!
                         gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(HaloMorph)! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/17/2012 15:59'!
         dispatchWith: aMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside |
	"See if we're fully outside aMorphs bounds"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^aMorph handleEvent: self ].
	^ #rejected! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/17/2012 15:58'!
                             dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside |

	"Try to get out quickly"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: self.
	self wasHandled ifTrue:[^self].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^aMorph handleEvent: self ].
	^#rejected! !
!PasteUpMorph methodsFor: 'events-processing' stamp: 'jmv 8/17/2012 15:57'!
  dispatchEvent: anEvent
	"Reimplemented to install the receiver as the new ActiveWorld if it is one"
	| priorWorld result |
	self isWorldMorph ifFalse: [
		^super dispatchEvent: anEvent ].
	priorWorld _ ActiveWorld.
	ActiveWorld _ self.
	result _ super dispatchEvent: anEvent.
	ActiveWorld _ priorWorld.
	^result! !
!Point methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:10'!
     scaledBy: factor 
	"Answer a Point scaled by factor (an instance of Point)."

	^(factor x * x) @ (factor y * y)! !
!Point methodsFor: 'transforming' stamp: 'jmv 8/17/2012 18:46'!
             translatedBy: delta 
	"Answer a Point translated by delta (an instance of Point)."

	^(delta x + x) @ (delta y + y)! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 18:53'!
     aligned: aPoint1 with: aPoint2
	"Answer a Rectangle that is a translated by aPoint2 - aPoint1."

	^self translatedBy: aPoint2 - aPoint1! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:09'!
                 flippedBy: direction centerAt: aPoint 
	"Return a copy flipped #vertical or #horizontal, about aPoint."
	| futureOrigin futureCorner |
	direction == #horizontal
		ifTrue:
			[futureOrigin := self topRight.
			futureCorner := self bottomLeft]
		ifFalse: [direction == #vertical
			ifTrue:
				[futureOrigin := self bottomLeft.
				futureCorner := self topRight]
			ifFalse: [self error: 'unrecognizable direction']].
	^ (futureOrigin flippedBy: direction centerAt: aPoint)
		corner: (futureCorner flippedBy: direction centerAt: aPoint)! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:10'!
  scaledBy: scale 
	"Answer a Rectangle scaled by scale, a Point or a scalar."

	^Rectangle origin: origin * scale corner: corner * scale! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 18:47'!
                 translatedBy: factor 
	"Answer a Rectangle translated by factor, a Point or a scalar."

	^Rectangle origin: origin + factor corner: corner + factor! !
!UserInputEvent methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:02'!
ztranslateBy: delta
	"add delta to cursorPoint, and return the new event"
	self flag: #ya.
	position _ position + delta.! !
!UserInputEvent methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:02'!
                           ztranslatedBy: delta
	"add delta to cursorPoint, and return the new event"
	self flag: #ya.
	^self shallowCopy ztranslateBy: delta! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 8/17/2012 18:23'!
                dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| globalPt aMorphHandlesIt handledByInner lastHandler answer |

	"Only for MouseDown"
	self isMouseDown
		ifFalse: [ ^super dispatchWith: aMorph ].

	"Try to get out quickly"
	globalPt _ self eventPosition.
	(aMorph morphFullBoundsInWorld containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ eventHandler.
	aMorphHandlesIt _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isPlayfieldLike or: [ self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self)
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ aMorph containsPoint: self eventPosition event: self ])
		ifTrue:[
			"aMorph is in the top-most unlocked, visible morph in the chain."
			aMorphHandlesIt ifTrue: [ aMorph handleEvent: self ].
			answer _ self ]
		ifFalse: [
			"Mouse was not on aMorph nor any of its children"
			answer _ #rejected ].

	eventHandler _ lastHandler.
	^answer! !
!MouseButtonEvent methodsFor: 'initialize' stamp: 'jmv 8/17/2012 16:48'!
     resetHandlerFields
	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"
	self flag: #jmvVer. "All this stuff of copying events to reset this data is pretty ugly."
	super resetHandlerFields.
	eventHandler _ nil! !
!MouseMoveEvent methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:02'!
               ztranslateBy: delta
	"add delta to cursorPoint, and return the new event"
	self flag: #ya.
	super ztranslateBy: delta.
	startPoint _ startPoint + delta.! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/17/2012 15:43'!
                               dispatchWith: aMorph
	"Host window events do not have a position and are only dispatched to the World"
	aMorph isWorldMorph ifFalse: [ ^#rejected ].
	self wasHandled ifTrue: [ ^self ].
	^aMorph handleEvent: self! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48' prior: 16788193!
                      alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor mouseButton2Pressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor mouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translatedBy: delta negated.
					(newBuffRect areasOutside: buffRect) do:
						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				prevP _ p]]]! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48' prior: 16818875!
                   colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Color colorRampForDepth: Display depth extent: 256@80) display"
	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: i g: i b: i range: 255)].
	^ f
! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48' prior: 16818988!
                 showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r |
	w _ Display width // colorList size.
	r _ 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		Display fill: r fillColor: c.
		r _ r translatedBy: w@0].
! !
!Color class methodsFor: 'color from user' stamp: 'jmv 8/17/2012 18:48' prior: 16819640!
                         fromUser
	"Displays a color palette of colors, waits for a mouse click, and returns the selected color. Any pixel on the Display can be chosen, not just those in the color palette."
	"Note: Since the color chart is cached, you may need to do 'ColorChart _ nil' after changing the oldColorPaletteForDepth:extent: method."
	"Color fromUser"

	| d startPt save tr oldColor c here s |
	d _ Display depth.
	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 
		ifTrue: [ColorChart _ self oldColorPaletteForDepth: d extent: (2 * 144)@80].
	Sensor mousePoint y < Display center y 
		ifTrue: [startPt _ 0@(Display boundingBox bottom - ColorChart height)]
		ifFalse: [startPt _ 0@0].

	save _ Form fromDisplay: (startPt extent: ColorChart extent).
	ColorChart displayAt: startPt.
	tr _ ColorChart extent - (50@19) corner: ColorChart extent.
	tr _ tr translatedBy: startPt.

	oldColor _ nil.
	[Sensor anyButtonPressed] whileFalse: [
		c _ Display colorAt: (here _ Sensor mousePoint).
		(tr containsPoint: here)
			ifFalse: [Display fill: (0@61+startPt extent: 20@19) fillColor: c]
			ifTrue: [
				c _ Color transparent.
				Display fill: (0@61+startPt extent: 20@19) fillColor: Color white].
		c = oldColor ifFalse: [
			Display fillWhite: (20@61 + startPt extent: 135@19).
			c isTransparent
				ifTrue: [s _ 'transparent']
				ifFalse: [s _ c shortPrintString.
						s _ s copyFrom: 7 to: s size - 1].
			s displayAt: 20@61 + startPt.
			oldColor _ c]].
	save displayAt: startPt.
	Sensor waitNoButton.
	^ c
! !
!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 8/17/2012 15:30' prior: 16845742!
fetchMoreEvents
	"Fetch more events from the VM"
	| eventBuffer type |

	"Reset input semaphore so clients can wait for the next events after this one."
	inputSemaphore isSignaled
		ifTrue: [
			hasInputSemaphore _ true.
			inputSemaphore initSignals ].

	"Remember the last time that I checked for events."
	lastEventPoll _ Time millisecondClockValue.

	eventBuffer _ Array new: 8.
	[
		self primGetNextEvent: eventBuffer.
		type _ eventBuffer at: 1.
		type = EventSensor eventTypeNone ]
			whileFalse: [ self processSensorEvent: eventBuffer ]! !
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 8/17/2012 18:54' prior: 16859251!
        rotateBy: deg smoothing: cellSize
	"Rotate the receiver by the indicated number of degrees."
	"rot is the destination form, bit enough for any angle."
	| side rot warp r1 pts p center |
	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.
	rot _ Form extent: side@side depth: self depth.
	center _ rot extent // 2.

	"Now compute the sin and cos constants for the rotation angle." 
	warp _ (WarpBlt current toForm: rot)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: rot);
		cellSize: cellSize;  "installs a new colormap if cellSize > 1"
		combinationRule: Form over.
	r1 _ rot boundingBox aligned: center with: self boundingBox center.

	pts _ r1 innerCorners collect: [ :pt |
		p _ pt - r1 center.
		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @
		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].
	warp copyQuad: pts toRect: rot boundingBox.
	^ rot
"
 | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
		rotateBy: (a _ a+5) smoothing: 2) display].
f display
"! !
!Form methodsFor: 'transitions' stamp: 'jmv 8/17/2012 18:49' prior: 16859472!
                           pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Color black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt current toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceDisplayUpdate].

	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceDisplayUpdate.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !
!Form methodsFor: 'transitions' stamp: 'jmv 8/17/2012 18:49' prior: 16859597!
            wipeImage: otherImage at: topLeft delta: delta clippingBox: clipBox

	| wipeRect bb nSteps |
	bb _ otherImage boundingBox.
	wipeRect _ delta x = 0
		ifTrue:
		[delta y = 0 ifTrue: [nSteps _ 1. bb "allow 0@0"] ifFalse: [
		nSteps _ bb height//delta y abs + 1.  "Vertical movement"
		delta y > 0
			ifTrue: [bb topLeft extent: bb width@delta y]
			ifFalse: [bb bottomLeft+delta extent: bb width@delta y negated]]]
		ifFalse:
		[nSteps _ bb width//delta x abs + 1.  "Horizontal movement"
		delta x > 0
			ifTrue: [bb topLeft extent: delta x@bb height]
			ifFalse: [bb topRight+delta extent: delta x negated@bb height]].
	^ self wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex:
		[:i | i <= nSteps
			ifTrue: [wipeRect translatedBy: (delta* (i-1))]
			ifFalse: [nil]]! !
!FormCanvas methodsFor: 'accessing' stamp: 'jmv 8/17/2012 18:49' prior: 16860437!
                           clipRect
	"Return the currently active clipping rectangle"
	^ clipRect translatedBy: origin negated! !
!FormCanvas methodsFor: 'copying' stamp: 'jmv 8/17/2012 18:49' prior: 16860482!
         copyClipRect: aRectangle
	^ self copyOrigin: origin clipRect: (aRectangle translatedBy: origin)
! !
!FormCanvas methodsFor: 'drawing-ovals' stamp: 'jmv 8/17/2012 18:49' prior: 16860636!
      fillOval: r color: fillColor borderWidth: borderWidth borderColor: borderColor
	| rect |
	"draw the border of the oval"
	rect _ (r translatedBy: origin) truncated.
	(borderWidth = 0 or: [borderColor isTransparent]) ifFalse:[
		self setPaintColor: borderColor.
		port frameOval: rect borderWidth: borderWidth].
	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillOval: (rect insetBy: borderWidth)].
! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/17/2012 18:50' prior: 16860750!
    frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor
	| rect |
	rect _ r translatedBy: origin.
	"draw the border of the rectangle"
	borderColor isTransparent ifFalse:[
		self setPaintColor: borderColor.
		port frameRect: rect borderWidth: borderWidth ].

	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillRect: (rect insetBy: borderWidth) offset: origin ]! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/17/2012 18:50' prior: 16860767!
  frameRectangle: r borderWidth: borderWidth color: borderColor
	"
	Display getCanvas
		frameRectangle: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red
	"
	| rect |
	rect _ r translatedBy: origin.
	self setPaintColor: borderColor.
	port
		frameRect: rect
		borderWidth: borderWidth.! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 8/17/2012 18:50' prior: 16861223!
       fillRectangle: aRectangle tilingWith: aForm sourceRect: patternBox rule: aCombinationRule
	"We assume that aForm is part of an InfiniteForm"
	| additionalOffset rInPortTerms clippedPort targetTopLeft clipOffset ex 
	targetBox savedMap top left |

	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.
	something better is needed, but not now"

	ex _ patternBox extent.
	additionalOffset _ 0@0.
	rInPortTerms _ aRectangle translatedBy: origin.
	clippedPort _ port clippedBy: rInPortTerms.
	targetTopLeft _ clippedPort clipRect topLeft truncateTo: ex.
	clipOffset _ rInPortTerms topLeft - targetTopLeft.
	additionalOffset _ (clipOffset \\ ex) - ex.

	"do it iteratively"
	targetBox _ clippedPort clipRect.
	savedMap _ clippedPort colorMap.
	clippedPort sourceForm: aForm;
		fillColor: nil;
		combinationRule: aCombinationRule;
		sourceRect: patternBox;
		colorMap: (aForm colormapIfNeededFor: clippedPort destForm).
	top _ (targetBox top truncateTo: patternBox height) + additionalOffset y.
	left _  (targetBox left truncateTo: patternBox width) + additionalOffset x.

	left to: (targetBox right - 1) by: patternBox width do: [:x |
		top to: (targetBox bottom - 1) by: patternBox height do: [:y |
			clippedPort destOrigin: x@y; copyBits]].
	clippedPort colorMap: savedMap! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 8/17/2012 18:50' prior: 16861266!
                    frameRectangle: r borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor
	"
	Display getCanvas
		frameRectangle: (10@10 extent: 300@200)
		borderWidth: 20
		topLeftColor: Color green
		bottomRightColor: Color red
	Display getCanvas fillRectangle: (10@10 extent: 300@200) color: Color white
	"
	| rect w h |
	self setPaintColor: topLeftColor.
	rect _ r translatedBy: origin.

	port frameRectTopLeft: rect borderWidth: borderWidth.

	borderWidth isNumber
		ifTrue: [w _ h _ borderWidth]
		ifFalse: [w _ borderWidth x.   h _ borderWidth y].
	self setPaintColor: bottomRightColor.
	port 
		 frameRectRight: rect width: w;
		 frameRectBottom: rect height: h! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/17/2012 15:51' prior: 16897728!
                           rejectsEvent: anEvent
	"Return true to reject the given event. Rejecting an event means neither the receiver nor any of it's submorphs will be given any chance to handle it."

	^ self isLocked or: [ self visible not ]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 8/17/2012 16:21' prior: 50342652!
         transferHalo: event from: formerHaloOwner
	"Progressively transfer the halo to the next likely recipient"
	| w |

	"Never transfer halo to top-most world"
	(self isWorldMorph and:[owner isNil]) ifFalse: [
		(formerHaloOwner ~~ self) 
			ifTrue: [ ^self addHalo: event from: formerHaloOwner ]].

	event shiftPressed ifTrue: [
		"Pass it outwards"
		owner ifNotNil: [ ^owner transferHalo: event from: formerHaloOwner ].
		"We're at the top level; throw the event back in to find recipient"
		formerHaloOwner removeHalo.
		^self dispatchEvent: event copy resetHandlerFields.
	].
	self submorphsDo: [ :m |
		(m fullContainsPoint: event eventPosition) 
			ifTrue: [ ^m transferHalo: event from: formerHaloOwner ].
	].
	"We're at the bottom most level; throw the event back up to the root to find recipient"
	formerHaloOwner removeHalo.
	(w _ self world) ifNil: [ ^self ].
	^w dispatchEvent: event copy resetHandlerFields! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/17/2012 18:50' prior: 50356714!
                          savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| ownBnds fullBnds bw |
	ownBnds _ self morphBoundsInWorld.
	fullBnds _ self morphFullBoundsInWorld.
	(savedPatch isNil or: [savedPatch extent ~= fullBnds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBnds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: (fullBnds translatedBy: aCanvas origin)
		into: savedPatch.
	savedPatch offset: fullBnds topLeft.
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth.
		aStream nextPut: ownBnds.
		prevBounds ifNotNil: [ aStream nextPut: prevBounds ].
		(fullBnds areasOutside: (fullBnds insetBy: bw)) do: [ :r |
			aStream nextPut: r ].
		prevFullBounds ifNotNil: [
			(prevFullBounds areasOutside: (prevFullBounds insetBy: bw)) do: [ :r |
				aStream nextPut: r ]]]
	ifFalse: [
		prevFullBounds ifNil: [
			aStream nextPut: fullBnds ]
		ifNotNil: [
			aStream nextPut: (fullBnds merge: prevFullBounds)]].
	prevBounds _ ownBnds.
	prevFullBounds _ fullBnds! !
!HandMorph methodsFor: 'paste buffer' stamp: 'jmv 8/17/2012 18:54' prior: 50343218!
           pasteMorph

	| pastee |
	pastee _ Clipboard retrieveMorph.
	pastee ifNil: [^ self inform: 'Nothing to paste.'].
	self attachMorph: pastee.
	pastee aligned: pastee referencePosition with: self morphPosition
! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 8/17/2012 15:58' prior: 50350930!
                        sendEvent: anEvent
	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."

	^owner dispatchEvent: anEvent! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/17/2012 18:51' prior: 16868311!
             drawToggleOn: aCanvas in: aRectangle

	| aForm centeringOffset |
	complexContents hasContents ifFalse: [^self].
	aForm _ isExpanded 
		ifTrue: [container expandedForm]
		ifFalse: [container notExpandedForm].
	centeringOffset _ ((aRectangle height - aForm extent y) / 2.0) rounded.
	^aCanvas 
		image: aForm 
		at: (aRectangle topLeft translatedBy: 0 @ centeringOffset).
! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 8/17/2012 18:51' prior: 50353521!
                      debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"
	| tl |
	tl _ self morphPositionInWorld.
	self paragraph lines do: [ :line |
		aCanvas
			frameRectangle: (line rectangle translatedBy: tl)
			borderWidth: 1
			color: Color brown ]
! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43' prior: 50353545!
     clickAndHalf: evt
	self handleInteraction: [
		editor clickAndHalf: (evt ztranslatedBy: self morphPositionInWorld negated) ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43' prior: 50353553!
     doubleClickAndHalf: evt
	self handleInteraction: [
		editor doubleClickAndHalf: (evt ztranslatedBy: self morphPositionInWorld negated) ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43' prior: 50353562!
                         mouseDown: event
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].

	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"
	self hasKeyboardFocus ifFalse: [
		^event hand newKeyboardFocus: self].

	super mouseDown: event.

	self handleInteraction: [editor mouseDown: (event ztranslatedBy: self morphPositionInWorld negated)].

	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: #clickAndHalf:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:
		tripleClkSel: nil! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43' prior: 50353588!
                      mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt ztranslatedBy: self morphPositionInWorld negated)].
	(evt eventPosition y - owner morphPositionInWorld y between: 0 and: owner morphExtentInWorld y) ifFalse: [
		owner scrollSelectionIntoView ]! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43' prior: 50353602!
                         mouseUp: evt
	super mouseUp: evt.
	self pauseBlinking.
	self handleInteraction: [editor mouseUp: (evt ztranslatedBy: self morphPositionInWorld negated)].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'selection' stamp: 'jmv 8/17/2012 18:51' prior: 50353619!
              selectionRects
	"Paragraph assumes its topLeft is 0@0. We don't"
	| tl |
	tl _ self morphPositionInWorld.
	^self paragraph selectionRects collect: [ :r | r translatedBy: tl ]! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 8/17/2012 18:52' prior: 16885259!
                       sourceRectFrom: aPoint
	^ (aPoint extent: srcExtent) translatedBy: (srcExtent // -2) + 1.
! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 8/17/2012 15:58' prior: 16887758!
                    handleFocusEvent: evt
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	self dispatchEvent: evt.

	"Need to handle keyboard input if we have the focus."
	evt isKeyboard ifTrue: [^ self handleEvent: evt].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(evt isMouseOver or:[evt isMouse not]) ifTrue:[^self].
	"What remains are mouse buttons and moves"
	evt isMove ifFalse:[^self handleEvent: evt]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: evt) ifTrue:[^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: evt) ifTrue:[^self]].! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 8/17/2012 18:52' prior: 16912426!
             flashRects: rectangleList
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."
	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."

	| blt screenRect |
	blt _ (BitBlt current toForm: Display)
		sourceForm: nil;
		sourceOrigin: 0@0;
		clipRect: self viewBox;
		combinationRule: Form reverse.
	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect; forceDisplayUpdate.
		(Delay forMilliseconds: 250) wait.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect; forceDisplayUpdate].
! !
!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 8/17/2012 18:54' prior: 16923335!
           defaultAction

	| delta textFrame barFrame outerFrame result range width w1 f h textWidth textForm innerBarFrame |
	f _ StrikeFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.
	
	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
			
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ 0@0 extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + (0@2).
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal 
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [		
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		w1 _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		textForm displayAt: textFrame topLeft.
		Display fillBlack: barFrame.
		Display fillWhite: innerBarFrame.
		Display fillGray: (barFrame topLeft + (2@2) extent: w1@17) ].
	World fullRepaintNeeded.
	self resume: result! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2012 18:54' prior: 50357548!
            openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self morphBoundsInWorld: (0@0 extent: w@h).
	labelMorph fitContents.
	subLabelMorph fitContents.
	self layoutSubmorphs.
	self aligned: self morphBoundsInWorld center with: Display boundingBox center.
	aWorld startSteppingSubmorphsOf: self.! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 8/17/2012 18:55' prior: 50354227!
           strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld 
	"This method implements a staggered window placement policy that I (di) like.
	Basically it provides for up to 4 windows, staggered from each of the 4 corners.
	The windows are staggered so that there will always be a corner visible."

	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |
	allowedArea := (self maximumUsableAreaInWorld: aWorld) 
				insetBy: (self scrollBarSetback @ self screenTopSetback extent: 0 @ 0).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].
	initialFrame := 0 @ 0 extent: initialExtent.
	"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))
							min: 600@400"
	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not]) 
						collect: [:w | w morphBoundsInWorld].
	0 to: maxLevel
		do: 
			[:level | 
			1 to: 4
				do: [:ci | 
					cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft) at: ci.
					corner := allowedArea perform: cornerSel.
					"The extra grid//2 in delta helps to keep title tabs distinct"
					delta := ((maxLevel - level) * grid + (grid // 2)) @ (level * grid).
					1 to: ci - 1 do: [ :i | delta _ delta y negated @ delta x ].	"slow way"
					putativeCorner := corner + delta.
					free := true.
					otherFrames 
						do: [:w | free := free & ((w perform: cornerSel) ~= putativeCorner)].
					free 
						ifTrue: 
							[^(initialFrame aligned: (initialFrame perform: cornerSel)
								with: putativeCorner) translatedAndSquishedToBeWithin: allowedArea]]].
	"If all else fails..."
	^(self scrollBarSetback @ self screenTopSetback 
		extent: initialFrame extent) translatedAndSquishedToBeWithin: allowedArea! !
!Rectangle methodsFor: 'rectangle functions' stamp: 'jmv 8/17/2012 18:55' prior: 16927147!
 translatedToBeWithin: aRectangle
	"Answer a copy of the receiver that does not extend beyond aRectangle.  7/8/96 sw"

	^ self translatedBy: (self amountToTranslateWithin: aRectangle)! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 15:30' prior: 16927275!
                  newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor anyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor anyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ World activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent.
	^ rect! !
!Sonogram methodsFor: 'all' stamp: 'jmv 8/17/2012 18:56' prior: 50344683!
               plotColumn: dataArray

	| chm1 i normVal r |
	columnForm unhibernate.
	chm1 _ columnForm height - 1.
	0 to: chm1 do: [ :y | 
		i _ y*(dataArray size-1)//chm1 + 1.
		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).
		normVal < 0.0 ifTrue: [normVal _ 0.0].
		normVal > 1.0 ifTrue: [normVal _ 1.0].
		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].
	(lastX _ lastX + 1) > (image width - 1) ifTrue:
		[self scroll].
	image copy: (r _ (lastX@0 extent: 1@image height))
			from: (32//image depth-1)@0
			in: columnForm rule: Form over.
	"self changed."
	self invalidRect: (r translatedBy: self morphPosition)! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 8/17/2012 18:56' prior: 50354456!
                         scrollSelectionIntoView
	"Scroll my text into view if necessary and return true, else return false"

	| rectToTest |
	rectToTest _ self editor pointBlock translatedBy: self textMorph morphPositionInWorld.
	self scrollToShow: rectToTest! !
!UserInputEvent methodsFor: 'initialize' stamp: 'jmv 8/17/2012 16:48' prior: 16980692!
                          resetHandlerFields
	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"
	self flag: #jmvVer. "All this stuff of copying events to reset this data is pretty ugly."
	wasHandled _ false.! !
!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44' prior: 16878657!
                               isKeyDown
	^ type == #keyDown! !
!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44' prior: 16878661!
            isKeyUp
	^ type == #keyUp! !
!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44' prior: 16878668!
                isKeystroke
	^ type == #keystroke! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44' prior: 16901211!
           isMouseDown
	^ type == #mouseDown! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44' prior: 16901215!
           isMouseEnter
	^ type == #mouseEnter! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44' prior: 16901219!
         isMouseLeave
	^ type == #mouseLeave! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44' prior: 16901223!
         isMouseMove
	^ type == #mouseMove! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44' prior: 16901227!
           isMouseUp
	^ type == #mouseUp! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:57' prior: 16984112!
           test12   "Display restoreAfter: [WarpBlt test12]"
	"Just like test1, but comparing smooth to non-smooth warps"
	| warp pts r1 p0 p ext warp2 |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 _ Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 _ Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp _ (self toForm: Display)
		cellSize: 2;  "installs a colormap"
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	warp2 _ (self toForm: Display)
		clipRect: ((0@0 extent: r1 extent*5) translatedBy: 250@0);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor anyButtonPressed] whileFalse:
		[p _ Sensor mousePoint.
		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].
		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).
		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translatedBy: 250@0).
		]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:57' prior: 16984213!
                       test5   "Display restoreAfter: [WarpBlt test5]"
	"Demonstrates variable scale and rotate"
	| warp pts r1 p0 p |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 _ Rectangle fromUser.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 _ Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp _ (self toForm: Display)
		cellSize: 1;
		sourceForm: Display;
		cellSize: 2;  "installs a colormap"
		combinationRule: Form over.
	[Sensor anyButtonPressed] whileFalse:
		[p _ Sensor mousePoint.
		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].
		warp copyQuad: pts toRect: (r1 translatedBy: r1 width@0)]! !
!WarpBlt class methodsFor: 'form rotation' stamp: 'jmv 8/17/2012 19:11' prior: 16984241!
    rotate: srcForm degrees: angleInDegrees center: aPoint scaleBy: scalePoint smoothing: cellSize
	"Rotate the given Form the given number of degrees about the given center and scale its width and height by x and y of the given scale point. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated Form and the second is the position offset required to align the center of the rotated Form with that of the original. Note that the dimensions of the resulting Form generally differ from those of the original."

	| srcRect center radians dstOrigin dstCorner p dstRect inverseScale quad dstForm newCenter warpSrc |
	srcRect _ srcForm boundingBox.
	center _ srcRect center.
	radians _ angleInDegrees degreesToRadians.
	dstOrigin _ dstCorner _ center.
	srcRect corners do: [:corner |
		"find the limits of a rectangle that just encloses the rotated
		 original; in general, this rectangle will be larger than the
		 original (e.g., consider a square rotated by 45 degrees)"
		p _ ((corner - center) scaledBy: scalePoint) + center.
		p _ (p inverseRotateBy: radians about: center) rounded.
		dstOrigin _ dstOrigin min: p.
		dstCorner _ dstCorner max: p].

	"rotate the enclosing rectangle back to get the source quadrilateral"
	dstRect _ dstOrigin corner: dstCorner.
	inverseScale _ (1.0 / scalePoint x)@(1.0 / scalePoint y).
	quad _ dstRect innerCorners collect: [:corner |
		p _ corner inverseRotateBy: radians negated about: center.
		((p - center) scaledBy: inverseScale) + center].

	"make a Form to hold the result and do the rotation"
	warpSrc _ srcForm.
	(srcForm is: #ColorForm)
		ifTrue: [
			cellSize > 1 | true "ar 12/27/2001: Always enable - else sketches won't work"
				ifTrue: [
					warpSrc _ Form extent: srcForm extent depth: 16.
					srcForm displayOn: warpSrc.
					dstForm _ Form extent: dstRect extent depth: 16]  "use 16-bit depth to allow smoothing"
				ifFalse: [
					dstForm _ srcForm class extent: dstRect extent depth: srcForm depth]]
		ifFalse: [
			dstForm _ srcForm class extent: dstRect extent depth: srcForm depth].

	(WarpBlt toForm: dstForm)
		sourceForm: warpSrc;
		colorMap: (warpSrc colormapIfNeededFor: dstForm);
		cellSize: cellSize;  "installs a new colormap if cellSize > 1"
		combinationRule: Form paint;
		copyQuad: quad toRect: dstForm boundingBox.

	(dstForm is: #ColorForm) ifTrue: [ dstForm colors: srcForm colors copy ].
	newCenter _ (center inverseRotateBy: radians about: aPoint) truncated.
	^ Array with: dstForm with: dstRect origin + (newCenter - center)
! !

MouseMoveEvent removeSelector: #translateBy:!

MouseMoveEvent removeSelector: #translateBy:!

!classDefinition: #MouseButtonEvent category: #'Morphic-Events'!
MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton eventHandler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton eventHandler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

UserInputEvent removeSelector: #handler!

UserInputEvent removeSelector: #handler!

UserInputEvent removeSelector: #handler:!

UserInputEvent removeSelector: #handler:!

UserInputEvent removeSelector: #translateBy:!

UserInputEvent removeSelector: #translateBy:!

UserInputEvent removeSelector: #translatedBy:!

UserInputEvent removeSelector: #translatedBy:!

!classDefinition: #UserInputEvent category: #'Morphic-Events'!
MorphicEvent subclass: #UserInputEvent
	instanceVariableNames: 'type buttons position wasHandled'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MorphicEvent subclass: #UserInputEvent
	instanceVariableNames: 'type buttons position wasHandled'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

Rectangle removeSelector: #align:with:!

Rectangle removeSelector: #align:with:!

Rectangle removeSelector: #flipBy:centerAt:!

Rectangle removeSelector: #flipBy:centerAt:!

Rectangle removeSelector: #scaleBy:!

Rectangle removeSelector: #scaleBy:!

Rectangle removeSelector: #translateBy:!

Rectangle removeSelector: #translateBy:!

Point removeSelector: #scaleBy:!

Point removeSelector: #scaleBy:!

Point removeSelector: #translateBy:!

Point removeSelector: #translateBy:!

PasteUpMorph removeSelector: #processEvent:using:!

PasteUpMorph removeSelector: #processEvent:using:!

HaloMorph removeSelector: #handlerForMouseButton3Down:!

HaloMorph removeSelector: #handlerForMouseButton3Down:!

HaloMorph removeSelector: #isHandlerForMouseButton3Down:!

Morph removeSelector: #align:with:!

Morph removeSelector: #align:with:!

Morph removeSelector: #defaultEventDispatcher!

Morph removeSelector: #defaultEventDispatcher!

Morph removeSelector: #handlerForMouseButton3Down:!

Morph removeSelector: #handlerForMouseButton3Down:!

Morph removeSelector: #handlerForMouseDown:!

Morph removeSelector: #handlerForMouseDown:!

Morph removeSelector: #is:!

Morph removeSelector: #isHandlerForMouseButton3Down:!

Morph removeSelector: #mouseDownPriority!

Morph removeSelector: #mouseDownPriority!

Morph removeSelector: #processEvent:!

Morph removeSelector: #processEvent:!

Morph removeSelector: #processEvent:using:!

Morph removeSelector: #processEvent:using:!

Morph removeSelector: #wantsHaloFromClick!

Morph removeSelector: #wantsHaloFromClick!

ColorForm removeSelector: #flipBy:centerAt:!

ColorForm removeSelector: #flipBy:centerAt:!

Form removeSelector: #flipBy:centerAt:!

Form removeSelector: #flipBy:centerAt:!

EventSensor removeSelector: #processEvent:!

EventSensor removeSelector: #processEvent:!

EventSensor removeSelector: #processKeyboardEvent:!

EventSensor removeSelector: #processKeyboardEvent:!

EventSensor removeSelector: #processMouseEvent:!

EventSensor removeSelector: #processMouseEvent:!

DisplayObject class removeSelector: #writeCollection:onFileNamed:!

DisplayObject class removeSelector: #writeCollection:onFileNamed:!

DisplayObject removeSelector: #align:with:!

DisplayObject removeSelector: #align:with:!

DisplayObject removeSelector: #displayOnPort:!

DisplayObject removeSelector: #displayOnPort:!

DisplayObject removeSelector: #followCursor!

DisplayObject removeSelector: #followCursor!

DisplayObject removeSelector: #relativeRectangle!

DisplayObject removeSelector: #relativeRectangle!

DisplayObject removeSelector: #scaleBy:!

DisplayObject removeSelector: #scaleBy:!

DisplayObject removeSelector: #translateBy:!

DisplayObject removeSelector: #translateBy:!

DisplayObject removeSelector: #translatedBy:!

Smalltalk removeClassNamed: #MorphicEventDispatcher!

Smalltalk removeClassNamed: #MorphicEventDispatcher!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1370-MorphicEventsSimplification-JuanVuletich-2012Aug17-17h40m-jmv.10.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1369] on 17 August 2012 at 8:44 pm'!
!Preferences class methodsFor: 'initialization' stamp: 'jmv 8/17/2012 20:43'!
                         initialize
	"
	Preferences initialize
	"
	Preferences cuisDefaults! !
!Preferences class methodsFor: 'standard queries' stamp: 'jmv 8/17/2012 20:38' prior: 0!
 allowUnderscoreAssignments
	"Also see #allowUnderscoreSelectors.
	When true, $_ (left arrow / underscore) can be used as assignment operator.

	This preference is related with #allowUnderscoreSelectors. Combinations: If both preferences are false, underscore is illegal. If both preferences are true, underscore assignment needs the be surrounded by spaces and a single underscore cannot be used as selector."
	
"Important:
	If you set this preference to true, and the following character: _ looks like an underscore, evaluate
		StrikeFont useLeftArrow

	If you set this preference to false, be sure that #syntaxHighlightingAsYouTypeLeftArrowAssignment is also set to false.
	In addition, you'll most likely feel useful to set #syntaxHighlightingAsYouTypeAnsiAssignment to true
	Besides, if the following character: _ looks like a left arrow, you might prefer evaluating
		StrikeFont useUnderscore
	"
	^ self
		valueOfFlag: #allowUnderscoreAssignments
		ifAbsent: [ true ].

"
On 3/12/2010 8:14 PM, Andreas Raab wrote:
> Folks -
>
> Attached my take on selectors with underscores. It basically separates
> the issue of using underscores in assignment from the issue of using
> underscores in selectors, puts this into two individual preferences, and
> allows per-class scoping while providing a system-wide default.
>
> The possible combinations of preferences are:
>
> * allowUnderscoreAssignments off, allowUnderscoreSelectors: off
> The use of underscores is forbidden, i.e., the Croquet model.
>
> * allowUnderscoreAssignments on, allowUnderscoreSelectors: off
> The classic Squeak usage; all of the following are assignments:
>
> a _ b => a := b
> b_ c => b := c
> d _e => d := e
> f_g => f := g.
>
> * allowUnderscoreAssignments off, allowUnderscoreSelectors: on
> The standard usage in other dialects
>
> a _ b => ((a) _) b
> b_ c => (b_) c
> d _e => (d) _e
> f_g => (f_g)
>
> * allowUnderscoreAssignments on, allowUnderscoreSelectors: on
> The hybrid usage requiring spaces around underscore for assignment:
>
> a _ b => a := b
> b_ c => (b_) c
> d _e => (d) _e
> f_g => (f_g)
>
> This gives us a range of options to decide how to deal with it. I would
> personally say that for the core image we should go with the first
> option (disable underscores altogether) and only enable whichever option
> we like for the release.
>
> What do people think about this approach? I think it provides the most
> options and gives us ample flexibility to decide what we'd like to use
> down the road.
>
> If there is no fundamental opposition I'll push it into the trunk in a
> couple of days.
>
> Cheers,
> - Andreas
"! !
!Preferences class methodsFor: 'standard queries' stamp: 'jmv 8/17/2012 20:38' prior: 0!
            allowUnderscoreSelectors
	"Also see #allowUnderscoreAssignments
	When true, $_ (left arrow / underscore) can be used in selectors and variable names.
	
This preference is related with #allowUnderscoreAssignments. Combinations: If both preferences are false, underscore is illegal. If both preferences are true, underscore assignment needs the be surrounded by spaces and a single underscore cannot be used as selector.
	
	If you set this preference to true, most likely you'll want character this: _ (character 95) to look like an underscore and not like a left arrow.
	For this, evaluate
		StrikeFont useUnderscore
	"
	^ self
		valueOfFlag: #allowUnderscoreSelectors
		ifAbsent: [ true ].

	"At #allowUnderscoreAssignments see the bottom comment from a mail to squeak-dev by Andreas (ar)"! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 8/17/2012 20:42' prior: 50350262!
                 cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(simpleMenus false)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(allowUnderscoreAssignments false)
		(allowUnderscoreSelectors false)
		(syntaxHighlightingAsYouTypeAnsiAssignment false)
		(syntaxHighlightingAsYouTypeLeftArrowAssignment false)
	)! !
!SHParserST80 methodsFor: 'aux' stamp: 'jmv 8/17/2012 20:36' prior: 16930983!
                allowUnderscoreAssignments
	"Query class + preference.
	Please see comments in Scanner >> #allowUnderscoreAssignments"
	^(classOrMetaClass ifNotNil: [ classOrMetaClass allowUnderscoreAssignments ])
		ifNil: [ Preferences allowUnderscoreAssignments ]! !
!SHParserST80 methodsFor: 'aux' stamp: 'jmv 8/17/2012 20:36' prior: 16930993!
                     allowUnderscoreSelectors
	"Query class + preference.
	Please see comments in Scanner >> #allowUnderscoreSelectors"
	^(classOrMetaClass ifNotNil: [ classOrMetaClass allowUnderscoreSelectors ])
		ifNil: [ Preferences allowUnderscoreSelectors ]! !
!Scanner methodsFor: 'private' stamp: 'jmv 8/17/2012 20:35' prior: 16933828!
                              allowUnderscoreAssignments
	"See comment at Preferences"
	^Preferences allowUnderscoreAssignments! !
!Scanner methodsFor: 'private' stamp: 'jmv 8/17/2012 20:35' prior: 16933903!
              allowUnderscoreSelectors
	"See comment at Preferences"
	^Preferences allowUnderscoreSelectors! !
!Parser methodsFor: 'private' stamp: 'jmv 8/17/2012 20:36' prior: 16910082!
                   allowUnderscoreAssignments
	"Query class + preference"
	encoder == self ifTrue: [ ^super allowUnderscoreAssignments ].
	encoder ifNil: [ ^super allowUnderscoreAssignments ].
	^encoder classEncoding allowUnderscoreAssignments
		ifNil: [super allowUnderscoreAssignments]! !

Preferences initialize!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1371-AllowUnderscoresEverywhere-JuanVuletich-2012Aug17-20h16m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1371] on 17 August 2012 at 10:14:48 pm'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 8/17/2012 22:06' prior: 16933730!
  xIllegal
	"An illegal character was encountered"
	self notify: 'Illegal character (char code ' , hereChar asciiValue printString, ' ', hereChar asciiValue hex , ')' at: mark! !
!Parser class methodsFor: 'class initialization' stamp: 'jmv 8/17/2012 22:10' prior: 16911431!
                initialize
		
	Preferences
		addPreference: #allowBlockArgumentAssignment 
		category: #compiler 
		default: false
		balloonHelp: 'If enabled, the compiler will allow assignment into block arguments.\This provides backward compatibility with the pre-closure compiler.' withNewLines.
	Preferences
		addPreference: #allowUnderscoreAssignments 
		category: #compiler 
		default: true
		balloonHelp: 'When true, $_ (left arrow / underscore) can be used as assignment operator'.
	Preferences
		addPreference: #allowUnderscoreSelectors 
		category: #compiler 
		default: true
		balloonHelp: 'When true, $_ (left arrow / underscore) can be used in selectors and variable names'! !

Parser initialize!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Parser initialize.
Scanner initialize!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1372-AllowUnderscoresCoda-JuanVuletich-2012Aug17-22h04m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1372] on 17 August 2012 at 11:02:40 pm'!
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 8/17/2012 22:58' prior: 50352698!
   buildMorphicAnnotationsPane

	| aTextMorph |
	aTextMorph _ TextModelMorph
		textProvider: model
		textGetter: #annotation
		textSetter: nil
		selectionGetter: nil
		allowStyler: false.
	model when: #annotationChanged send: #refetch to: aTextMorph model.
	aTextMorph
		askBeforeDiscardingEdits: false;
		hideScrollBarsIndefinitely.
	^aTextMorph! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1373-FixAnnotationsUpdate-JuanVuletich-2012Aug17-23h00m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1373] on 18 August 2012 at 6:18:48 pm'!

"Change Set:		1374-CuisCore-JuanVuletich-2012Aug18-18h16m
Date:			18 August 2012
Author:			Juan Vuletich

<your descriptive text goes here>"
World eventHandler: nil.
ActiveHand eventHandler: nil!

!classDefinition: #HaloSpec category: #'Morphic-Halos'!
Object subclass: #HaloSpec
	instanceVariableNames: 'addHandleSelector horizontalPlacement verticalPlacement color iconSymbol hoverHelp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Halos'!

Object subclass: #HaloSpec
	instanceVariableNames: 'addHandleSelector horizontalPlacement verticalPlacement color iconSymbol hoverHelp '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Halos'!

!classDefinition: #HaloHandleMorph category: #'Morphic-Halos'!
Morph subclass: #HaloHandleMorph
	instanceVariableNames: 'keyStrokeSelector mouseUpSelector mouseMoveSelector mouseDownSelector'
	classVariableNames: 'CircleForm'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

Morph subclass: #HaloHandleMorph
	instanceVariableNames: 'keyStrokeSelector mouseUpSelector mouseMoveSelector mouseDownSelector '
	classVariableNames: 'CircleForm '
	poolDictionaries: ''
	category: 'Morphic-Halos'!

!classDefinition: #HaloMorph category: #'Morphic-Halos'!
Morph subclass: #HaloMorph
	instanceVariableNames: 'target innerTarget positionOffset angleOffset growingOrRotating haloBox'
	classVariableNames: 'HandleSize Icons'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

Morph subclass: #HaloMorph
	instanceVariableNames: 'target innerTarget positionOffset angleOffset growingOrRotating haloBox '
	classVariableNames: 'HandleSize Icons '
	poolDictionaries: ''
	category: 'Morphic-Halos'!
!HaloSpec methodsFor: 'accessing' stamp: 'jmv 8/18/2012 18:03'!
                      horizontalPlacement: hp verticalPlacement: vp color: col iconSymbol: is addHandleSelector: sel hoverHelp: aString
	horizontalPlacement _ hp.
	verticalPlacement _ vp.
	color _ col.
	iconSymbol _ is asSymbol.
	addHandleSelector _ sel.
	hoverHelp _ aString! !
!HaloSpec methodsFor: 'accessing' stamp: 'jmv 8/18/2012 18:04'!
                               hoverHelp
	^hoverHelp! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:22'!
                           handleMouseDown: aMorphicEvent

	super handleMouseDown: aMorphicEvent.
	self send: mouseDownSelector withEvent: aMorphicEvent! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:21'!
                   handleMouseMove: aMorphicEvent

	super handleMouseMove: aMorphicEvent.
	aMorphicEvent anyButtonPressed ifTrue: [
		self send: mouseMoveSelector withEvent: aMorphicEvent ]! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:28'!
      handleMouseUp: aMorphicEvent

	super handleMouseUp: aMorphicEvent.
	self send: mouseUpSelector withEvent: aMorphicEvent! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:08'!
                         handlesKeyboard
	"Return true if the receiver wishes to handle keyboard events"
	^super handlesKeyboard! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:27'!
         handlesMouseDown: evt
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^(super handlesMouseDown: evt) | 
		mouseDownSelector notNil | mouseMoveSelector notNil | mouseUpSelector notNil! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:08'!
                            handlesMouseOver: evt
	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?"
	^super handlesMouseOver: evt! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:09'!
                            handlesMouseStillDown: evt
	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"
	^(super handlesMouseStillDown: evt) | keyStrokeSelector notNil! !
!HaloHandleMorph methodsFor: 'accessing' stamp: 'jmv 8/18/2012 16:38'!
           keyStrokeSelector: aSymbol
	keyStrokeSelector _ aSymbol! !
!HaloHandleMorph methodsFor: 'accessing' stamp: 'jmv 8/18/2012 16:38'!
                              mouseDownSelector: aSymbol
	mouseDownSelector _ aSymbol! !
!HaloHandleMorph methodsFor: 'accessing' stamp: 'jmv 8/18/2012 16:38'!
                              mouseMoveSelector: aSymbol
	mouseMoveSelector _ aSymbol! !
!HaloHandleMorph methodsFor: 'accessing' stamp: 'jmv 8/18/2012 16:38'!
                              mouseUpSelector: aSymbol
	mouseUpSelector _ aSymbol! !
!HaloHandleMorph methodsFor: 'act' stamp: 'jmv 8/18/2012 17:19'!
        send: selector withEvent: aMorphicEvent
	| arity |
	owner ifNil: [ ^ self ].
	selector ifNil: [ ^ self ].
	arity _ selector numArgs.
	arity = 0 ifTrue: [ ^ owner perform: selector ].
	arity = 1 ifTrue: [
		^ owner
			perform: selector
			with: aMorphicEvent ].
	arity = 2 ifTrue: [
		^ owner
			perform: selector
			with: aMorphicEvent
			with: self ].
	self error: 'Event handling selectors must be Symbols and take 0-2 arguments'! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/18/2012 18:04'!
              addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPositionInOwner: 0@0 ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^handle! !
!HaloMorph methodsFor: 'forward to target' stamp: 'jmv 8/18/2012 16:33'!
                              chooseEmphasisOrAlignment
	target chooseEmphasisOrAlignment! !
!HaloMorph methodsFor: 'forward to target' stamp: 'jmv 8/18/2012 16:34'!
                        chooseFont
	target chooseFont! !
!HaloMorph methodsFor: 'forward to target' stamp: 'jmv 8/18/2012 16:25'!
                      deleteBalloon
	target deleteBalloon! !
!HaloMorph methodsFor: 'forward to target' stamp: 'jmv 8/18/2012 16:25'!
                mouseDownOnHelpHandle: anEvent
	target mouseDownOnHelpHandle: anEvent! !
!CustomMenu methodsFor: 'construction' stamp: 'jmv 8/18/2012 15:50' prior: 16830285!
  addList: listOfTuplesAndDashes
	"Add a menu item to the receiver for each tuple in the given list of the form (<what to show> <selector>). Add a line for each dash (-) in the list."

	listOfTuplesAndDashes do: [:aTuple |
		aTuple == #-
			ifTrue: [self addLine]
			ifFalse: [self add: aTuple first action: aTuple second]]

	"
	CustomMenu new addList: #(
		('apples' buyApples)
		('oranges' buyOranges)
		-
		('milk' buyMilk)); startUp
	"

! !
!FileStream class methodsFor: 'file reader services' stamp: 'jmv 8/18/2012 15:49' prior: 16852513!
  install: fullName
	"File in the entire contents of the file specified by the name provided.
	Do not affect the user change sets, store changes in separate one"

	| localName |
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: localName do: [ self fileIn: fullName ].
	('Installed ChangeSet: ', localName) print! !
!HaloSpec methodsFor: 'accessing' stamp: 'jmv 8/18/2012 18:01' prior: 16864453!
                              addHandleSelector
	^ addHandleSelector! !
!HaloSpec methodsFor: 'accessing' stamp: 'jmv 8/18/2012 18:01' prior: 16864457!
      color
	^ color! !
!HaloSpec methodsFor: 'accessing' stamp: 'jmv 8/18/2012 18:02' prior: 16864460!
                              horizontalPlacement
	^ horizontalPlacement! !
!HaloSpec methodsFor: 'accessing' stamp: 'jmv 8/18/2012 18:02' prior: 16864474!
  iconSymbol
	^ iconSymbol! !
!HaloSpec methodsFor: 'accessing' stamp: 'jmv 8/18/2012 18:02' prior: 16864478!
                    verticalPlacement
	^ verticalPlacement! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:51' prior: 16897069!
    click: evt
	"Handle a single-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:51' prior: 16897083!
       doubleClick: evt
	"Handle a double-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:51' prior: 16897122!
 handlesKeyboard
	"Return true if the receiver wishes to handle keyboard events"

	^ false
! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:52' prior: 16897130!
                handlesMouseDown: evt
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	"NOTE: The default response is false. Subclasses that implement these messages directly should override this one to return true." 

	^ false
! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:52' prior: 16897145!
                         handlesMouseOver: evt
	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?  The default response is false." 

	^ false! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:52' prior: 16897158!
         handlesMouseStillDown: evt
	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"
	^ false
! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:55' prior: 16897173!
                      keyStroke: anEvent
	"Handle a keystroke event."

	(self focusKeyboardFor: anEvent)
		ifTrue: [ ^ self ].
	(self closeWindowFor: anEvent)
		ifTrue: [ ^ self ]! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:53' prior: 16897191!
             mouseDown: evt
	"Handle a mouse down event."! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:53' prior: 16897200!
                              mouseEnter: evt
	"Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed."! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:53' prior: 16897211!
                            mouseLeave: evt
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed."! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:54' prior: 16897222!
                               mouseMove: evt
	"Handle a mouse move event."! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:54' prior: 16897231!
                              mouseStillDown: evt
	"Handle a mouse move event."! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:54' prior: 16897252!
                         mouseUp: evt
	"Handle a mouse up event."! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 8/18/2012 16:22' prior: 16898006!
                          addHandlesTo: aHaloMorph box: box
	"Add halo handles to the halo.  Apply the halo filter if appropriate"
	| wantIt |
	aHaloMorph haloBox: box.
	Preferences haloSpecifications do: [ :aSpec |
		wantIt _ Preferences selectiveHalos
			ifTrue: [
				self
					wantsHaloHandleWithSelector: aSpec addHandleSelector
					inHalo: aHaloMorph ]
			ifFalse: [ true ].
		wantIt ifTrue: [
			aHaloMorph
				perform: aSpec addHandleSelector
				with: aSpec ]].
	aHaloMorph target
		addOptionalHandlesTo: aHaloMorph
		box: box.! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 8/18/2012 16:22' prior: 16898029!
   addWorldHandlesTo: aHaloMorph box: box
	aHaloMorph haloBox: box.
	Preferences haloSpecificationsForWorld do: [ :aSpec |
		aHaloMorph
			perform: aSpec addHandleSelector
			with: aSpec ].
	aHaloMorph target
		addOptionalHandlesTo: aHaloMorph
		box: box.! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 8/18/2012 16:23' prior: 16898916!
                mouseButton3Down: anEvent
	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."
	| h doNotDrag |
	h _ anEvent hand halo.
	"Prevent wrap around halo transfers originating from throwing the event back in"
	doNotDrag _ false.
	h ifNotNil:[
		(h target == self) ifTrue: [ doNotDrag _ true].
		(h target hasOwner: self) ifTrue: [ doNotDrag _ true].
		(self hasOwner: h target) ifTrue: [ doNotDrag _ true]].

	"cmd-drag on flexed morphs works better this way"
	h _ self addHalo: anEvent.
	doNotDrag ifTrue:[^self].
	"Initiate drag transition if requested"
	anEvent hand 
		waitForClicksOrDrag: h
		event: anEvent
		clkSel: nil
		dblClkSel: nil.
	"Pass focus explicitly here"
	anEvent hand newMouseFocus: h.! !
!HaloMorph methodsFor: 'accessing' stamp: 'jmv 8/18/2012 16:23' prior: 16863611!
         setTarget: aMorph
	"Private!! Set the target without adding handles."

	target _ aMorph

! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:40' prior: 16863749!
                    addCollapseHandle: handleSpec
	"Add the collapse handle, with all of its event handlers set up, unless the target's owner is not the world or the hand."

	target owner
		ifNil: [ ^self ]	"nil happens, amazingly"
		ifNotNil: [ :to |
			(to isWorldMorph or: [ to is: #HandMorph ])
				ifFalse: [ ^self ]].
		
	(self addHandle: handleSpec)
		mouseDownSelector: #mouseDownInCollapseHandle:with:;
		mouseMoveSelector: #setDismissColor:with:;
		mouseUpSelector: #maybeCollapse:with:! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:37' prior: 16863769!
                 addDebugHandle: handleSpec

	Preferences debugHaloHandle ifTrue: [
		(self addHandle: handleSpec)
			mouseDownSelector: #doDebug:with: ]
! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:31' prior: 16863776!
    addDismissHandle: handleSpec

	(self addHandle: handleSpec)
		mouseDownSelector: #setDismissColor:with:;
		mouseMoveSelector: #setDismissColor:with:;
		mouseUpSelector: #maybeDismiss:with:! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:32' prior: 16863790!
                 addDragHandle: haloSpec

	(self addHandle: haloSpec)
		mouseDownSelector: #startDrag:with:;
		mouseMoveSelector: #doDrag:with:! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:37' prior: 16863797!
               addDupHandle: haloSpec
	(self addHandle: haloSpec) mouseDownSelector:#doDup:with:! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:39' prior: 16863803!
                            addFontEmphHandle: haloSpec

	(target is: #InnerTextMorph) ifTrue: [
		(self addHandle: haloSpec) mouseDownSelector: #chooseEmphasisOrAlignment ]! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:38' prior: 16863811!
                            addFontSizeHandle: haloSpec

	(target is: #InnerTextMorph) ifTrue: [
		(self addHandle: haloSpec) mouseDownSelector: #chooseFont]! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:36' prior: 16863819!
            addGrabHandle: haloSpec

	(self addHandle: haloSpec)
		mouseDownSelector: #doGrab:with:! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:23' prior: 16863825!
                      addGrowHandle: haloSpec

	(self addHandle: haloSpec)
		mouseDownSelector: #startGrow:with:;
		mouseMoveSelector: #doGrow:with:! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:29' prior: 16863834!
               addHelpHandle: haloSpec
	(self addHandle: haloSpec)
		mouseDownSelector: #mouseDownOnHelpHandle:;
		mouseMoveSelector: #deleteBalloon! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:36' prior: 16863843!
        addMenuHandle: haloSpec

	(self addHandle: haloSpec) mouseDownSelector: #doMenu:with:! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:35' prior: 16863849!
                        addRecolorHandle: haloSpec
	"Add a recolor handle to the receiver, if appropriate"

	(self addHandle: haloSpec) mouseUpSelector: #doRecolor:with:! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 8/18/2012 17:35' prior: 16863863!
                            addRotateHandle: haloSpec

	(self addHandle: haloSpec)
		mouseDownSelector: #startRot:with:;
		mouseMoveSelector: #doRot:with:! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/18/2012 16:21' prior: 50356637!
               addHandlesForWorldHalos
	"Add handles for world halos, like the man said"

	| box w |
	w _ self world ifNil: [target world].
	self removeAllMorphs.  "remove old handles, if any"
	self morphBoundsInWorld: target morphBoundsInWorld.
	box _ w morphBoundsInWorld insetBy: 9.
	target addWorldHandlesTo: self box: box.

	self
		addNameBeneath: (box insetBy: (0@0 corner: 0@10))
		string: (target printStringLimitedTo: 40).
	growingOrRotating _ false.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/18/2012 16:21' prior: 50359568!
                   doDebug: evt with: menuHandle
	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"

	| menu |
	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self world displayWorld.
	evt shiftPressed ifTrue: [
		self delete.
		^ target inspect].

	menu _ target buildDebugMenu: evt hand.
	menu addTitle: (target printStringLimitedTo: 40).
	menu popUpInWorld: self world! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/18/2012 16:21' prior: 50359607!
              doMenu: evt with: menuHandle
	"Ask hand to invoke the halo menu for my inner target."

	| menu |
	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self world displayWorld.
	menu _ target buildHandleMenu: evt hand.
	target addTitleForHaloMenu: menu.
	menu popUpInWorld: self world.
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/18/2012 16:21' prior: 50342977!
               doRecolor: evt with: aHandle
	"The mouse went down in the 'recolor' halo handle.  Allow the user to change the color of the innerTarget"

	evt hand obtainHalo: self.
	(aHandle containsPoint: evt eventPosition)
		ifFalse: [  "only do it if mouse still in handle on mouse up"
			self delete.
			target addHalo: evt]
		ifTrue: [
			target changeColor]! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:51' prior: 16870200!
     processKeyStroke: evt
	| action |

	(acceptOnCR and: [evt isReturnKey])
		ifTrue: [^ self acceptContents].

	self pauseBlinking.
	evt isReturnKey ifTrue: [	"Return - check for special action"
		action _ self crAction.
		action ifNotNil: [
			^action value]].
	self handleInteraction: [ editor processKeyStroke: evt ].
	self updateFromParagraph.

	self scrollSelectionIntoView! !
!MorphExtension methodsFor: 'other' stamp: 'jmv 8/18/2012 17:50' prior: 16900013!
                   isDefault
	"Return true if the receiver is a default and can be omitted"
	layoutSpec ifNotNil: [ ^ false ].
	otherProperties ifNotNil: [
		otherProperties isEmpty ifFalse: [ ^ false ]].
	^ true.! !
!MorphExtension methodsFor: 'printing' stamp: 'jmv 8/18/2012 17:50' prior: 16900023!
     printOn: aStream
	"Append to the argument, aStream, a sequence of characters that 
	identifies the receiver."
	super printOn: aStream.
	aStream nextPutAll: ' (', self identityHash printString, ')'.
	layoutSpec ifNotNil: [ aStream nextPutAll: ' [layoutSpec = ] ' , layoutSpec printString , '] ' ].
	(otherProperties isNil or: [ otherProperties isEmpty ]) ifTrue: [ ^ self ].
	aStream nextPutAll: ' [other: '.
	otherProperties keysDo: [ :aKey |
		aStream nextPutAll: ' (' , aKey , ' -> ' , (otherProperties at: aKey) printString , ')' ].
	aStream nextPut: $].! !
!MorphExtension methodsFor: 'private' stamp: 'jmv 8/18/2012 17:50' prior: 16900054!
                           sortedPropertyNames
	"answer the receiver's property names in a sorted way"
	| props |
	props _ WriteStream on: (Array new: 10).
	layoutSpec ifNotNil: [ props nextPut: #layoutSpec ].
	otherProperties ifNotNil: [
		otherProperties associationsDo: [ :a |
			props nextPut: a key ]].
	^ props contents sort: [ :s1 :s2 |
		s1 <= s2 ]! !
!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 15:58' prior: 16913652!
                  handlesMouseStillDown: evt
	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"
	"Acting when down (instead of waiting until releasing the button)
	also means that the button action is repeated if the button is kept pressed"
	^actWhen == #buttonStillDown! !
!Preferences class methodsFor: 'halos' stamp: 'jmv 8/18/2012 18:00' prior: 16919949!
              iconicHaloSpecifications
	"Answer an array that characterizes the locations, colors, icons, and selectors of the halo handles that may be used in the iconic halo scheme"

	"
	Preferences resetHaloSpecifications
	"

^ #(
	"selector						horiz				vert					color info						icon key 						balloon help
	 ---------						------				-----------			-------------------------------		---------------"
	(addCollapseHandle:		left				topCenter		(tan)							haloCollapseIcon 			'Collapse')
	(addDebugHandle:			right				topCenter		(orange)						haloDebugIcon 				'Debug')
	(addDismissHandle:			left				top				(red)							haloDismissIcon 				'Remove')
	(addRotateHandle:			left				bottom			(blue)							haloRotateIcon 				'Rotate')
	(addMenuHandle:			leftCenter		top				(blue lighter)					haloMenuIcon 				'Menu')
	(addGrabHandle:				center			top				(black)							haloGrabIcon 				'Pick up')
	(addDragHandle:				rightCenter		top				(brown)						haloDragIcon 				'Move')
	(addDupHandle:				right				top				(green)						haloDuplicateIcon 			'Duplicate')	
	(addHelpHandle:				center			bottom			(lightBlue)					haloHelpIcon 				'Help')
	(addGrowHandle:			right				bottom			(yellow)						haloScaleIcon 				'Change size')
	(addFontSizeHandle:		leftCenter		bottom			(lightGreen)					haloFontSizeIcon 			'Change font')
	(addFontEmphHandle:		rightCenter		bottom			(lightBrown darker)			haloFontEmphasisIcon 		'Emphasis & alignment')
	(addRecolorHandle:			right				bottomCenter	(magenta darker)			haloColorIcon 				'Change color')
)! !
!Preferences class methodsFor: 'halos' stamp: 'jmv 8/18/2012 18:04' prior: 16919992!
       installHaloSpecsFromArray: anArray

	| aColor |
	^ Parameters at: #HaloSpecs put: (anArray collect: [ :each |
				aColor _ Color.
				each fourth do: [ :sel | aColor _ aColor perform: sel].
				HaloSpec new 
					horizontalPlacement: each second
					verticalPlacement: each third 
					color: aColor
					iconSymbol: each fifth
					addHandleSelector: each first
					hoverHelp: each sixth])! !
!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 8/18/2012 17:53' prior: 16973831!
                         keyStroke: aKeyboardEvent
	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self closeWindowFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	self textMorph keyStroke: aKeyboardEvent! !

MorphExtension removeSelector: #eventHandler!

MorphExtension removeSelector: #eventHandler!

MorphExtension removeSelector: #eventHandler:!

MorphExtension removeSelector: #eventHandler:!

HierarchicalListMorph removeSelector: #initialize!

HierarchicalListMorph removeSelector: #initialize!

HaloMorph removeSelector: #addHandle:on:send:to:!

HaloMorph removeSelector: #addHandle:on:send:to:!

HaloMorph removeSelector: #innerTarget!

HaloMorph removeSelector: #innerTarget!

HaloMorph removeSelector: #mouseDownInDimissHandle:with:!

HaloMorph removeSelector: #mouseDownInDimissHandle:with:!

HaloMorph removeSelector: #strokeGrow:with:!

HaloMorph removeSelector: #strokeGrow:with:!

!classDefinition: #HaloMorph category: #'Morphic-Halos'!
Morph subclass: #HaloMorph
	instanceVariableNames: 'target positionOffset angleOffset growingOrRotating haloBox'
	classVariableNames: 'HandleSize Icons'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

Morph subclass: #HaloMorph
	instanceVariableNames: 'target positionOffset angleOffset growingOrRotating haloBox'
	classVariableNames: 'HandleSize Icons'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

!classDefinition: #HaloHandleMorph category: #'Morphic-Halos'!
Morph subclass: #HaloHandleMorph
	instanceVariableNames: 'mouseDownSelector mouseUpSelector mouseMoveSelector keyStrokeSelector'
	classVariableNames: 'CircleForm'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

Morph subclass: #HaloHandleMorph
	instanceVariableNames: 'mouseDownSelector mouseUpSelector mouseMoveSelector keyStrokeSelector'
	classVariableNames: 'CircleForm'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

Morph removeSelector: #balloonHelpTextForHandle:!

Morph removeSelector: #balloonHelpTextForHandle:!

Morph removeSelector: #eventHandler!

Morph removeSelector: #eventHandler!

Morph removeSelector: #eventHandler:!

Morph removeSelector: #eventHandler:!

Morph removeSelector: #on:send:to:!

Morph removeSelector: #on:send:to:!

Morph removeSelector: #on:send:to:withValue:!

Morph removeSelector: #on:send:to:withValue:!

HaloSpec removeSelector: #horizontalPlacement:verticalPlacement:color:iconSymbol:addHandleSelector:!

HaloSpec removeSelector: #horizontalPlacement:verticalPlacement:color:iconSymbol:addHandleSelector:!

!classDefinition: #HaloSpec category: #'Morphic-Halos'!
Object subclass: #HaloSpec
	instanceVariableNames: 'addHandleSelector horizontalPlacement verticalPlacement color iconSymbol hoverHelp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Halos'!

Object subclass: #HaloSpec
	instanceVariableNames: 'addHandleSelector horizontalPlacement verticalPlacement color iconSymbol hoverHelp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Halos'!

Smalltalk removeClassNamed: #EventHandler!

Smalltalk removeClassNamed: #EventHandler!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences resetHaloSpecifications!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1374-KillEventHandler-JuanVuletich-2012Aug18-18h16m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1374] on 19 August 2012 at 11:34:39 am'!

!classDefinition: #MouseMoveEvent category: #'Morphic-Events'!
MouseEvent subclass: #MouseMoveEvent
	instanceVariableNames: 'startPoint trail'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MouseEvent subclass: #MouseMoveEvent
	instanceVariableNames: 'startPoint trail '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!MouseEvent methodsFor: 'accessing' stamp: 'jmv 8/19/2012 11:13'!
                     eventType
	^type! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/19/2012 11:12'!
            isMouseOver
	^type == #mouseOver! !
!MouseMoveEvent methodsFor: 'private' stamp: 'jmv 8/19/2012 10:45'!
                        setType: evtType position: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	type _ evtType.
	position _ evtEnd.
	buttons _ evtButtons.
	source _ evtHand.
	wasHandled _ false.
	timeStamp _ stamp! !
!WindowEvent methodsFor: 'accessing' stamp: 'jmv 8/19/2012 10:58'!
                 windowAction: aValue

	action _ aValue! !
!WindowEvent methodsFor: 'accessing' stamp: 'jmv 8/19/2012 11:09'!
                   windowEventType
	"This should match the definitions in sq.h"
	^#(
		windowMetricChange
		windowClose
		windowIconise
		windowActivated
		windowPaint
	) at: action ifAbsent: [#windowEventUnknown]! !
!AutoCompleter methodsFor: 'keyboard' stamp: 'jmv 8/19/2012 11:29' prior: 16783276!
      autoCompletionAround: aBlock keyStroke: aKeyboardEvent

	(self handleKeystrokeBefore: aKeyboardEvent)
		ifTrue: [^ self].
	aBlock value.
	"Narrow the completion with any of the keys"
	self handleKeystrokeAfter: aKeyboardEvent! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 8/19/2012 11:02' prior: 50339932!
      selectEquivalentMethods
	"Selects all method definitions for which there is already an equivalent method in the current image, 
	(meaning that the difference is cosmetic and not in behavior)"
	Cursor wait showWhile: [
		1 to: changeList size do: [ :i | 
			| change class |
			change _ changeList at: i.
			listSelections at: i put:
				((change type == #method and: [
					(class _ change methodClass) notNil]) and: [
						(class includesSelector: change methodSelector) and: [
							| cmWithNode |
							cmWithNode _ [class basicCompile: change string notifying: nil trailer: class defaultMethodTrailer ifFail: nil] 
								on: SyntaxErrorNotification do: [ :ex | ex return ].
							(cmWithNode notNil and: [
								| current inChange |
								current _ (class compiledMethodAt: change methodSelector) copyWithTrailerBytes: #(0).
								inChange _ cmWithNode method copyWithTrailerBytes: #(0).
								current = inChange or: [
									| currentCmWithNode |
									currentCmWithNode _ [class basicCompile: (class decompilerClass new decompile: change methodSelector in: class) decompileString
											notifying: nil trailer: class defaultMethodTrailer ifFail: nil] on: SyntaxErrorNotification do: [ :ex | ex return ].
									(currentCmWithNode notNil and: [
										current _ currentCmWithNode method copyWithTrailerBytes: #(0).
										current = inChange])
								]
							])
						]]
				)]].
	self changed: #allSelections.
	self changed: #annotation! !
!Morph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:32' prior: 50362243!
        handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	"NOTE: The default response is false. Subclasses that implement these messages directly should override this one to return true." 

	^ false
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 11:29' prior: 16897492!
        handleKeystroke: aKeyboardEvent
	"System level event handling."

	aKeyboardEvent wasHandled ifTrue:[^self].
	self handlesKeyboard ifFalse:[^self].
	aKeyboardEvent wasHandled: true.
	^self keyStroke: aKeyboardEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 11:26' prior: 50342560!
                  handleMouseOver: aMorphicEvent
	"System level event handling."
	aMorphicEvent hand mouseFocus == self ifTrue:[
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: aMorphicEvent eventPosition event: aMorphicEvent) ifFalse:[
			^self]].
	aMorphicEvent hand noticeMouseOver: self event: aMorphicEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 11:27' prior: 50342573!
                      rejectDropEvent: aMorphicEvent
	"This hook allows the receiver to repel a drop operation currently executed. The method is called prior to checking children so the receiver must validate that the event was really designated for it.
	Note that the ordering of the tests below is designed to avoid a (possibly expensive) #fullContainsPoint: test. If the receiver doesn't want to repel the morph anyways we don't need to check after all."
	(self repelsMorph: aMorphicEvent contents event: aMorphicEvent) ifFalse:[^self]. "not repelled"
	(self fullContainsPoint: aMorphicEvent eventPosition) ifFalse:[^self]. "not for me"
	"Throw it away"
	aMorphicEvent wasHandled: true.
	aMorphicEvent contents rejectDropMorphEvent: aMorphicEvent! !
!AutoCompleterMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:31' prior: 16783703!
      handlesMouseDown: aMouseButtonEvent

	^ true! !
!FillInTheBlankMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:31' prior: 16852797!
                handlesMouseDown: aMouseButtonEvent
	^true! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:31' prior: 50362051!
                      handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^(super handlesMouseDown: aMouseButtonEvent) | 
		mouseDownSelector notNil | mouseMoveSelector notNil | mouseUpSelector notNil! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 8/19/2012 11:25' prior: 50346794!
                              popUpFor: aMorph event: aMorphicEvent
	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."

	| hand anEvent |
	self flag: #workAround.	"We should really have some event/hand here..."
	anEvent _ aMorphicEvent
				ifNil: [
					hand _ aMorph world activeHand.
					hand ifNil: [ hand _ aMorph world firstHand ]. 
					hand lastEvent ]
				ifNotNil: [
					hand _ aMorphicEvent hand.
					aMorphicEvent ].
	hand halo: self.
	hand world addMorphFront: self.
	self target: aMorph.
	positionOffset _ anEvent eventPosition - aMorph morphPosition.
	self startStepping! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 11:25' prior: 50354970!
     containsPoint: aPoint event: aMorphicEvent
	"mouseButton3 events are handled by the halo"

	(aMorphicEvent isMouse and: [
		aMorphicEvent isMouseDown and: [ aMorphicEvent mouseButton3Pressed ]])
	ifTrue: [
		^ self morphFullBoundsInWorld containsPoint: aMorphicEvent eventPosition ].

	^ super containsPoint: aPoint event: aMorphicEvent! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 8/19/2012 10:45' prior: 50349780!
                      generateMouseEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| pos buttons modifiers type trail stamp oldButtons |
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].
	pos := evtBuf third @ evtBuf fourth.
	buttons := evtBuf fifth.
	modifiers := evtBuf sixth.
	type := buttons = 0 
		ifTrue: [
			lastEventBuffer fifth = 0 ifTrue: [#mouseMove] ifFalse: [#mouseUp]]
		ifFalse: [
			lastEventBuffer fifth = 0 
						ifTrue: [#mouseDown]
						ifFalse: [#mouseMove]].
	buttons := buttons bitOr: (modifiers bitShift: 3).
	oldButtons := lastEventBuffer fifth 
				bitOr: (lastEventBuffer sixth bitShift: 3).
	lastEventBuffer := evtBuf.
	type == #mouseMove 
		ifTrue: [
			trail := self mouseTrailFrom: evtBuf.
			^MouseMoveEvent new 
				setType: type
				position: trail last
				buttons: buttons
				hand: self
				stamp: stamp].
	^MouseButtonEvent new 
		setType: type
		position: pos
		which: (oldButtons bitXor: buttons)
		buttons: buttons
		hand: self
		stamp: stamp! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 8/19/2012 10:58' prior: 16865598!
                       generateWindowEvent: evtBuf 
	"Generate the appropriate window event for the given raw event buffer"

	| evt |
	evt := WindowEvent new.
	evt setTimeStamp: evtBuf second.
	evt timeStamp = 0 ifTrue: [evt setTimeStamp: Time millisecondClockValue].
	evt windowAction: evtBuf third.
	evt rectangle: (Rectangle origin: evtBuf fourth @ evtBuf fifth corner: evtBuf sixth @ evtBuf seventh ).
	
	^evt! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 8/19/2012 11:26' prior: 50343294!
moveToEvent: aMorphicEvent
	"Issue a mouse move event to make the receiver appear at the given position"

	self handleEvent: (MouseMoveEvent new
		setType: #mouseMove
		position: aMorphicEvent eventPosition
		buttons: aMorphicEvent buttons
		hand: self
		stamp: aMorphicEvent timeStamp)! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:31' prior: 16870102!
   handlesMouseDown: aMouseButtonEvent
	^ true! !
!InnerTextMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 11:28' prior: 16870218!
                   handleKeystroke: aKeyboardEvent
	"System level event handling."

	aKeyboardEvent wasHandled ifTrue:[^self].
	self handlesKeyboard ifFalse:	[^ self].
	aKeyboardEvent wasHandled: true.
	self keyStroke: aKeyboardEvent! !
!LayoutAdjustingMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:31' prior: 16879721!
     handlesMouseDown: aMouseButtonEvent

	^ true! !
!MagnifierMorph methodsFor: 'events' stamp: 'jmv 8/19/2012 11:32' prior: 16885124!
                             handlesMouseDown: aMouseButtonEvent
	^aMouseButtonEvent mouseButton2Pressed
		or: [super handlesMouseDown: aMouseButtonEvent]! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 8/19/2012 11:32' prior: 16886950!
             handlesMouseDown: aMouseButtonEvent

	^ true
! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 8/19/2012 11:32' prior: 16887793!
 handlesMouseDown: aMouseButtonEvent
	^true! !
!MorphicEvent methodsFor: 'comparing' stamp: 'jmv 8/19/2012 11:07' prior: 16900162!
                              = aMorphicEvent
	^self class = aMorphicEvent class! !
!MorphicEvent methodsFor: 'comparing' stamp: 'jmv 8/19/2012 11:07' prior: 16900167!
                      hash
	^super hash! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 11:21' prior: 16900170!
                     sentTo: aMorph
	"Dispatch the receiver into aMorph"
	^aMorph handleUnknownEvent: self! !
!MorphicEvent methodsFor: 'testing' stamp: 'jmv 8/19/2012 11:12' prior: 16900210!
                     isMouseOver
	^false! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 11:20' prior: 16841175!
                      sentTo: aMorph
	"Dispatch the receiver into aMorph"
	^aMorph handleDropMorph: self! !
!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:32' prior: 16906437!
           handlesMouseDown: aMouseButtonEvent
	^ true! !
!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:32' prior: 16911694!
                        handlesMouseDown: aMouseButtonEvent
	^true! !
!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:09' prior: 16911735!
                         windowEvent: aMorphicEvent
	self windowEventHandler
		ifNotNil: [^self windowEventHandler windowEvent: aMorphicEvent].

	aMorphicEvent windowEventType == #windowClose
		ifTrue: [
			^TheWorldMenu basicNew quitSession]
! !
!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:32' prior: 16913639!
 handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !
!PluggableScrollPane methodsFor: 'pane events' stamp: 'jmv 8/19/2012 11:32' prior: 16915397!
        handlesMouseDown: aMouseButtonEvent
	^ true! !
!ScrollBar methodsFor: 'event handling' stamp: 'jmv 8/19/2012 11:33' prior: 16935115!
                           handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !
!TranscriptMorph methodsFor: 'menus' stamp: 'jmv 8/19/2012 11:33' prior: 16978443!
                  handlesMouseDown: aMouseButtonEvent
	^ true! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 11:21' prior: 16878598!
                          sentTo: aMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue:[^aMorph handleKeystroke: self].
	type == #keyDown ifTrue:[^aMorph handleKeyDown: self].
	type == #keyUp ifTrue:[^aMorph handleKeyUp: self].
	^super sentTo: aMorph! !
!MouseEvent methodsFor: 'comparing' stamp: 'jmv 8/19/2012 11:13' prior: 50344936!
                      = aMorphicEvent
	super = aMorphicEvent ifFalse:[^false].
	type = aMorphicEvent eventType ifFalse: [ ^false ].
	position = aMorphicEvent eventPosition ifFalse: [^ false].
	buttons = aMorphicEvent buttons ifFalse: [^ false].
	^ true
! !
!MouseEvent methodsFor: 'comparing' stamp: 'jmv 8/19/2012 11:14' prior: 16901128!
   hash
	^ type hash + position hash + buttons hash! !
!MouseEvent methodsFor: 'converting' stamp: 'jmv 8/19/2012 10:46' prior: 16901140!
                         asMouseMove: deltaTime
	"Convert the receiver into a mouse move. adjust timestamp by the provided delta"

	^ MouseMoveEvent new
		setType: #mouseMove
		position: position
		buttons: buttons
		hand: source
		stamp: timeStamp + deltaTime! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 11:22' prior: 16901158!
                             sentTo: aMorph
	"Dispatch the receiver into aMorph"
	type == #mouseOver ifTrue:[^aMorph handleMouseOver: self].
	type == #mouseEnter ifTrue:[^aMorph handleMouseEnter: self].
	type == #mouseLeave ifTrue:[^aMorph handleMouseLeave: self].
	^super sentTo: aMorph! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 11:22' prior: 16900809!
sentTo: aMorph
	"Dispatch the receiver into anObject"
	type == #mouseDown ifTrue:[^aMorph handleMouseDown: self].
	type == #mouseUp ifTrue:[^aMorph handleMouseUp: self].
	^super sentTo: aMorph! !
!MouseMoveEvent methodsFor: 'comparing' stamp: 'jmv 8/19/2012 10:42' prior: 50344957!
      = aMorphicEvent
	super = aMorphicEvent ifFalse:[^false].
	position = aMorphicEvent eventPosition ifFalse: [^ false].
	buttons = aMorphicEvent buttons ifFalse: [^ false].
	^ true
! !
!MouseMoveEvent methodsFor: 'comparing' stamp: 'jmv 8/19/2012 10:44' prior: 16901280!
                    hash
	^ position hash + buttons hash! !
!MouseMoveEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 11:22' prior: 16901285!
sentTo: aMorph
	"Dispatch the receiver into anObject"
	type == #mouseMove ifTrue:[^aMorph handleMouseMove: self].
	^super sentTo: aMorph! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 11:22' prior: 16986046!
                               sentTo: aMorph
	"Dispatch the receiver into anObject"
	^aMorph handleWindowEvent: self! !

WindowEvent removeSelector: #action!

WindowEvent removeSelector: #action!

WindowEvent removeSelector: #action:!

WindowEvent removeSelector: #action:!

WindowEvent removeSelector: #eventType!

WindowEvent removeSelector: #type!

WindowEvent removeSelector: #type!

MouseMoveEvent removeSelector: #endPoint!

MouseMoveEvent removeSelector: #endPoint!

MouseMoveEvent removeSelector: #printOn:!

MouseMoveEvent removeSelector: #printOn:!

MouseMoveEvent removeSelector: #setType:startPoint:endPoint:buttons:hand:stamp:!

MouseMoveEvent removeSelector: #setType:startPoint:endPoint:trail:buttons:hand:stamp:!

MouseMoveEvent removeSelector: #setType:startPoint:endPoint:trail:buttons:hand:stamp:!

MouseMoveEvent removeSelector: #startPoint!

MouseMoveEvent removeSelector: #startPoint!

MouseMoveEvent removeSelector: #storeOn:!

MouseMoveEvent removeSelector: #storeOn:!

MouseMoveEvent removeSelector: #trail!

MouseMoveEvent removeSelector: #trail!

MouseMoveEvent removeSelector: #type:readFrom:!

MouseMoveEvent removeSelector: #type:readFrom:!

MouseMoveEvent removeSelector: #ztranslateBy:!

MouseMoveEvent removeSelector: #ztranslateBy:!

!classDefinition: #MouseMoveEvent category: #'Morphic-Events'!
MouseEvent subclass: #MouseMoveEvent
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MouseEvent subclass: #MouseMoveEvent
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MouseButtonEvent removeSelector: #storeOn:!

MouseButtonEvent removeSelector: #storeOn:!

MouseButtonEvent removeSelector: #type:readFrom:!

MouseButtonEvent removeSelector: #type:readFrom:!

MouseEvent removeSelector: #printOn:!

MouseEvent removeSelector: #printOn:!

MouseEvent removeSelector: #storeOn:!

MouseEvent removeSelector: #storeOn:!

MouseEvent removeSelector: #type:readFrom:!

MouseEvent removeSelector: #type:readFrom:!

KeyboardEvent removeSelector: #printOn:!

KeyboardEvent removeSelector: #printOn:!

KeyboardEvent removeSelector: #storeOn:!

KeyboardEvent removeSelector: #storeOn:!

KeyboardEvent removeSelector: #type:readFrom:!

KeyboardEvent removeSelector: #type:readFrom:!

UserInputEvent removeSelector: #buttonString!

UserInputEvent removeSelector: #buttonString!

UserInputEvent removeSelector: #eventType!

UserInputEvent removeSelector: #modifierString!

UserInputEvent removeSelector: #modifierString!

UserInputEvent removeSelector: #type!

UserInputEvent removeSelector: #type!

MorphicEvent class removeSelector: #readFrom:!

MorphicEvent class removeSelector: #readFrom:!

MorphicEvent class removeSelector: #type:readFrom:!

MorphicEvent class removeSelector: #type:readFrom:!

DropEvent removeSelector: #eventType!

DropEvent removeSelector: #printOn:!

DropEvent removeSelector: #printOn:!

DropEvent removeSelector: #type!

DropEvent removeSelector: #type!

MorphicEvent removeSelector: #eventType!

MorphicEvent removeSelector: #printOn:!

MorphicEvent removeSelector: #storeOn:!

MorphicEvent removeSelector: #type!

MorphicEvent removeSelector: #type!

MorphicEvent removeSelector: #type:readFrom:!

MorphicEvent removeSelector: #type:readFrom:!

Morph removeSelector: #click!

Morph removeSelector: #click!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1375-MorphicEventSimplification-JuanVuletich-2012Aug19-10h16m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1374] on 19 August 2012 at 4:32:20 pm'!
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 16:18'!
                       handHandleEvent: aMorphicEvent

	owner ifNil: [ ^ self ].
	aMorphicEvent isMouseOver ifTrue: [ ^ self sendMouseEvent: aMorphicEvent ].
	
	aMorphicEvent isWindowEvent ifTrue: [
		owner dispatchEvent: aMorphicEvent.
		^ self mouseOverHandler processMouseOver: lastMouseEvent ].

	aMorphicEvent isKeyboard ifTrue: [
		self sendKeyboardEvent: aMorphicEvent.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	aMorphicEvent isDropEvent ifTrue: [
		owner dispatchEvent: aMorphicEvent.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	aMorphicEvent isMouse ifTrue: [
		lastMouseEvent _ aMorphicEvent.	
		lastMouseEventTime _ Time millisecondClockValue].

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMorphicEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	aMorphicEvent isMove ifTrue: [
		self morphPosition: aMorphicEvent eventPosition.
		self sendMouseEvent: aMorphicEvent.
	] ifFalse: [
		"Issue a synthetic move event if we're not at the position of the event"
		aMorphicEvent eventPosition = self morphPosition ifFalse: [ self moveToEvent: aMorphicEvent ].
		"Drop submorphs on button events"
		self hasSubmorphs
			ifTrue: [ self dropMorphs: aMorphicEvent ]
			ifFalse: [ self sendMouseEvent: aMorphicEvent ].
	].
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 16:28' prior: 16897467!
                   handleFocusEvent: aMorphicEvent
	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."
	^aMorphicEvent sentTo: self! !
!HandMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 16:18' prior: 50350892!
                       processEvents
	"Process user input events from the local input devices."

	| evt evtBuf type hadAny |

	hadAny := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		evt := nil.	"for unknown event types"
		type := evtBuf first.
		type = EventSensor eventTypeMouse
			ifTrue: [ evt := self generateMouseEvent: evtBuf ].
		type = EventSensor eventTypeKeyboard 
			ifTrue: [ evt := self generateKeyboardEvent: evtBuf ].
		type = EventSensor eventTypeWindow
			ifTrue: [ evt _ self generateWindowEvent: evtBuf ].
		"All other events are ignored"
		evt
			ifNil: [
				^hadAny]
			ifNotNil: [
				"Finally, handle it"
				self handHandleEvent: evt.
				hadAny := true.
				"For better user feedback, return immediately after a mouse event has been processed."
				evt isMouse ifTrue: [ ^hadAny ]]].
	"note: if we come here we didn't have any mouse events"
	mouseClickState 
		ifNotNil: [ 
			"No mouse events during this cycle. Make sure click states time out accordingly"
			mouseClickState
				handleEvent: (lastMouseEvent asMouseMove: (Time millisecondClockValue - lastMouseEventTime max: 0))
				from: self ].
	^hadAny! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 8/19/2012 16:05' prior: 50348288!
                           dropMorph: aMorph event: aMouseEvent
	"Drop the given morph which was carried by the hand"
	| dropEvent |
	(aMouseEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue: [ ^self ].
	dropEvent _ DropEvent new setPosition: self morphPosition contents: aMorph hand: self.
	owner dispatchEvent: dropEvent.
	dropEvent wasHandled ifFalse: [ aMorph rejectDropMorphEvent: dropEvent ].
	self mouseOverHandler processMouseOver: aMouseEvent! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 8/19/2012 16:22' prior: 50363071!
                   moveToEvent: aMorphicEvent
	"Issue a mouse move event to make the receiver appear at the given position"

	self handHandleEvent: (MouseMoveEvent new
		setType: #mouseMove
		position: aMorphicEvent eventPosition
		buttons: aMorphicEvent buttons
		hand: self
		stamp: aMorphicEvent timeStamp)! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 8/19/2012 16:08' prior: 16865705!
    sendMouseEvent: aMouseEvent
	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."

	| w |
	mouseFocus ifNotNil: [
		(w _ mouseFocus world) ifNil: [
			mouseFocus _ nil.
			^self ].
		^self sendFocusEvent: aMouseEvent to: mouseFocus in: w].

	^owner dispatchEvent: aMouseEvent! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 8/19/2012 16:28' prior: 50361078!
                handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	self dispatchEvent: aMorphicEvent.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [^ aMorphicEvent sentTo: self ].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue:[^self].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [^ aMorphicEvent sentTo: self ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue:[^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue:[^self]].! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 16:29' prior: 50360138!
              dispatchWith: aMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside |
	"See if we're fully outside aMorphs bounds"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^ self sentTo: aMorph ].
	^ #rejected! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 16:25' prior: 50360164!
                 dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside |

	"Try to get out quickly"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: self.
	self wasHandled ifTrue:[^self].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^ self sentTo: aMorph ].
	^#rejected! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 16:29' prior: 50360272!
                        dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| globalPt aMorphHandlesIt handledByInner lastHandler answer |

	"Only for MouseDown"
	self isMouseDown
		ifFalse: [ ^super dispatchWith: aMorph ].

	"Try to get out quickly"
	globalPt _ self eventPosition.
	(aMorph morphFullBoundsInWorld containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ eventHandler.
	aMorphHandlesIt _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isPlayfieldLike or: [ self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self)
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ aMorph containsPoint: self eventPosition event: self ])
		ifTrue:[
			"aMorph is in the top-most unlocked, visible morph in the chain."
			aMorphHandlesIt ifTrue: [ self sentTo: aMorph ].
			answer _ self ]
		ifFalse: [
			"Mouse was not on aMorph nor any of its children"
			answer _ #rejected ].

	eventHandler _ lastHandler.
	^answer! !
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 8/19/2012 16:30' prior: 16901366!
                      processMouseOver: aMouseEvent 
	"Re-establish the z-order for all morphs wrt the given event"

	| hand focus evt |
	hand := aMouseEvent hand.
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	"Now go looking for eventual mouse overs"
	hand handHandleEvent: aMouseEvent asMouseOver.
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [^leftMorphs := enteredMorphs := overMorphs := nil].
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m | 
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sentTo: m ]
				ifFalse: [overMorphs nextPut: m]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
			"inform: was called in handleEvent:"
			^leftMorphs := enteredMorphs := overMorphs := nil].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m | 
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sentTo: m ]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			^leftMorphs := enteredMorphs := overMorphs := nil].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 16:29' prior: 50360362!
               dispatchWith: aMorph
	"Host window events do not have a position and are only dispatched to the World"
	aMorph isWorldMorph ifFalse: [ ^#rejected ].
	self wasHandled ifTrue: [ ^self ].
	^ self sentTo: aMorph! !

HandMorph removeSelector: #handleEvent:!

HandMorph removeSelector: #handleEvent:!

HandMorph removeSelector: #sendEvent:!

HandMorph removeSelector: #sendEvent:!

Morph removeSelector: #handleEvent:!

Morph removeSelector: #handleEvent:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1376-MorphicEventSimplification-JuanVuletich-2012Aug19-15h36m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1374] on 19 August 2012 at 4:43:11 pm'!
!HandMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 16:38'!
                              processEventQueue
	"Process user input events from the local input devices."

	| evt evtBuf type hadAny |

	hadAny := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		evt := nil.	"for unknown event types"
		type := evtBuf first.
		type = EventSensor eventTypeMouse
			ifTrue: [ evt := self generateMouseEvent: evtBuf ].
		type = EventSensor eventTypeKeyboard 
			ifTrue: [ evt := self generateKeyboardEvent: evtBuf ].
		type = EventSensor eventTypeWindow
			ifTrue: [ evt _ self generateWindowEvent: evtBuf ].
		"All other events are ignored"
		evt
			ifNil: [
				^hadAny]
			ifNotNil: [
				"Finally, handle it"
				self startEventDispatch: evt.
				hadAny := true.
				"For better user feedback, return immediately after a mouse event has been processed."
				evt isMouse ifTrue: [ ^hadAny ]]].
	"note: if we come here we didn't have any mouse events"
	mouseClickState 
		ifNotNil: [ 
			"No mouse events during this cycle. Make sure click states time out accordingly"
			mouseClickState
				handleEvent: (lastMouseEvent asMouseMove: (Time millisecondClockValue - lastMouseEventTime max: 0))
				from: self ].
	^hadAny! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 16:38'!
    startEventDispatch: aMorphicEvent

	owner ifNil: [ ^ self ].
	aMorphicEvent isMouseOver ifTrue: [ ^ self sendMouseEvent: aMorphicEvent ].
	
	aMorphicEvent isWindowEvent ifTrue: [
		owner dispatchEvent: aMorphicEvent.
		^ self mouseOverHandler processMouseOver: lastMouseEvent ].

	aMorphicEvent isKeyboard ifTrue: [
		self sendKeyboardEvent: aMorphicEvent.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	aMorphicEvent isDropEvent ifTrue: [
		owner dispatchEvent: aMorphicEvent.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	aMorphicEvent isMouse ifTrue: [
		lastMouseEvent _ aMorphicEvent.	
		lastMouseEventTime _ Time millisecondClockValue].

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMorphicEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	aMorphicEvent isMove ifTrue: [
		self morphPosition: aMorphicEvent eventPosition.
		self sendMouseEvent: aMorphicEvent.
	] ifFalse: [
		"Issue a synthetic move event if we're not at the position of the event"
		aMorphicEvent eventPosition = self morphPosition ifFalse: [
			"Issue a mouse move event to make the receiver appear at the given position"
			self startEventDispatch: (MouseMoveEvent new
				setType: #mouseMove
				position: aMorphicEvent eventPosition
				buttons: aMorphicEvent buttons
				hand: self
				stamp: aMorphicEvent timeStamp) ].
		"Drop submorphs on button events"
		self hasSubmorphs
			ifTrue: [ self dropMorphs: aMorphicEvent ]
			ifFalse: [ self sendMouseEvent: aMorphicEvent ].
	].
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 8/19/2012 16:38' prior: 50363690!
                processMouseOver: aMouseEvent 
	"Re-establish the z-order for all morphs wrt the given event"

	| hand focus evt |
	hand := aMouseEvent hand.
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	"Now go looking for eventual mouse overs"
	hand startEventDispatch: aMouseEvent asMouseOver.
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [^leftMorphs := enteredMorphs := overMorphs := nil].
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m | 
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sentTo: m ]
				ifFalse: [overMorphs nextPut: m]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
			"inform: was called in handleEvent:"
			^leftMorphs := enteredMorphs := overMorphs := nil].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m | 
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sentTo: m ]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			^leftMorphs := enteredMorphs := overMorphs := nil].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 8/19/2012 16:34' prior: 16986794!
            doOneCycleNowFor: aWorld
	"Immediately do one cycle of the interaction loop.
	This should not be called directly, but only via doOneCycleFor:"

	| hadAnyEvent |
	DisplayScreen checkForNewScreenSize.

	"process user input events"
	self handsDo: [ :h |
		ActiveHand _ h.
		hadAnyEvent _ h processEventQueue.
		ActiveHand _ nil
	].

	"the default is the primary hand"
	ActiveHand _ self hands first.

	aWorld runStepMethods.		"there are currently some variations here"
	self displayWorldSafely: aWorld.

	^hadAnyEvent! !

HandMorph removeSelector: #handHandleEvent:!

HandMorph removeSelector: #handHandleEvent:!

HandMorph removeSelector: #moveToEvent:!

HandMorph removeSelector: #moveToEvent:!

HandMorph removeSelector: #processEvents!

HandMorph removeSelector: #processEvents!

HandMorph removeSelector: #waitForClicksOrDrag:event:!

HandMorph removeSelector: #waitForClicksOrDrag:event:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1377-MorphicEventSimplification-JuanVuletich-2012Aug19-16h32m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1377] on 19 August 2012 at 9:32:33 pm'!
!MorphicEvent commentStamp: '<historical>' prior: 16900124!
               This class represents the base for all Morphic events.

Instance variables:
	stamp	<Integer>	The millisecond clock time stamp (based on Time millisecondClock)
	source	<Hand | nil>	If non-nil the hand that generated the event.!
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:44' prior: 16897444!
        handleDropMorph: anEvent
	"Handle a dropping morph."
	| aMorph localPt |
	aMorph _ anEvent contents.
	"Do a symmetric check if both morphs like each other"
	((self wantsDroppedMorph: aMorph event: anEvent)	"I want her"
		and: [aMorph wantsToBeDroppedInto: self])		"she wants me"
			ifFalse: [
				^ self].
	anEvent wasHandled: true.
	localPt _ aMorph referencePosition.
	aMorph referencePosition: localPt.
	self acceptDroppingMorph: aMorph event: anEvent.
	aMorph justDroppedInto: self event: anEvent.
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:44' prior: 50363431!
                 handleFocusEvent: aMorphicEvent
	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."

	^aMorphicEvent sentTo: self! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:44' prior: 16897476!
                       handleKeyDown: anEvent
	"System level event handling."

	anEvent wasHandled ifTrue: [^self].
	self handlesKeyboard ifFalse: [^self].
	anEvent wasHandled: true.
	^self keyDown: anEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:45' prior: 16897484!
                handleKeyUp: anEvent
	"System level event handling."

	anEvent wasHandled ifTrue: [^self].
	self handlesKeyboard ifFalse: [^self].
	anEvent wasHandled: true.
	^self keyUp: anEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:45' prior: 50362912!
                    handleKeystroke: aKeyboardEvent
	"System level event handling."

	aKeyboardEvent wasHandled ifTrue: [^self].
	self handlesKeyboard ifFalse: [^self].
	aKeyboardEvent wasHandled: true.
	^self keyStroke: aKeyboardEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:45' prior: 16897097!
                handleMouseDown: anEvent
	"System level event handling."
	anEvent wasHandled ifTrue: [ ^self ]. "not interested"
	anEvent hand removePendingBalloonFor: self.
	anEvent wasHandled: true.
	self activateWindow.

	"Make me modal during mouse transitions"
	anEvent hand newMouseFocus: self event: anEvent.
	anEvent mouseButton3Changed ifTrue: [^self mouseButton3Down: anEvent].

	self mouseDown: anEvent.
	anEvent hand removeHaloFromClick: anEvent on: self.

	(self handlesMouseStillDown: anEvent) ifTrue:[
		self startStepping: #handleMouseStillDown: 
			at: Time millisecondClockValue + self mouseStillDownThreshold
			arguments: {anEvent copy resetHandlerFields}
			stepTime: self mouseStillDownStepRate ].
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:45' prior: 16897509!
       handleMouseEnter: anEvent
	"System level event handling."
	anEvent isDraggingEvent ifTrue: [
		^self].
	self wantsBalloon ifTrue: [
		anEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: anEvent) ifTrue: [
		anEvent wasHandled: true.
		self mouseEnter: anEvent ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:46' prior: 16897532!
                     handleMouseMove: anEvent
	"System level event handling."
	anEvent wasHandled ifTrue: [^self]. "not interested"
	"Rules say that by default a morph gets #mouseMove iff
		* the hand is not dragging anything,
			+ and some button is down,
			+ and the receiver is the current mouse focus."
	(anEvent hand hasSubmorphs) ifTrue: [^self].
	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse: [^self].
	anEvent wasHandled: true.
	self mouseMove: anEvent.
	(self handlesMouseStillDown: anEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #handleMouseStillDown: 
			at: Time millisecondClockValue
			arguments: {anEvent copy resetHandlerFields}
			stepTime: 1].
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:46' prior: 50362922!
                  handleMouseOver: aMorphicEvent
	"System level event handling."
	aMorphicEvent hand mouseFocus == self ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: aMorphicEvent eventPosition event: aMorphicEvent) ifFalse: [
			^self ]].
	aMorphicEvent hand noticeMouseOver: self event: aMorphicEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:46' prior: 16897568!
                   handleMouseStillDown: anEvent
	"Called from the stepping mechanism for morphs wanting continuously repeated 'yes the mouse is still down, yes it is still down, yes it has not changed yet, no the mouse is still not up, yes the button is down' etc messages"
	(anEvent hand mouseFocus == self) 
		ifFalse: [ ^self stopSteppingSelector: #handleMouseStillDown: ].
	self mouseStillDown: anEvent.
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:47' prior: 16897583!
 handleMouseUp: anEvent
	"System level event handling."
	anEvent wasHandled ifTrue: [^self]. "not interested"
	anEvent hand mouseFocus == self ifFalse: [^self]. "Not interested in other parties"
	anEvent hand releaseMouseFocus: self.
	anEvent wasHandled: true.
	anEvent mouseButton3Changed
		ifTrue: [ self mouseButton3Up: anEvent ]
		ifFalse: [ self mouseUp: anEvent.
				self stopSteppingSelector: #handleMouseStillDown: ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:47' prior: 16897599!
handleUnknownEvent: anEvent
	"An event of an unknown type was sent to the receiver. What shall we do?!!"

	Beeper beep. 
	anEvent printString displayAt: 0@0.
	anEvent wasHandled: true! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 19:47' prior: 16897607!
                handleWindowEvent: anEvent
	"Handle an event concerning our host window"

	anEvent wasHandled ifTrue: [^self]. "not interested"
	(self wantsWindowEvent: anEvent) ifFalse: [^self].
	anEvent wasHandled: true.
	self windowEvent: anEvent.
! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1378-MorphicEventTweaks-JuanVuletich-2012Aug19-19h26m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1378] on 19 August 2012 at 10:20:44 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 22:07'!
                          dispatchEvent: aMorphicEvent localPosition: localPosition
	"This is the central entry for dispatching events in morphic. Given some event, find the right receiver and let him handle it.
	localPosition is in our coordinates."

	^ (self rejectsEvent: aMorphicEvent)
		ifTrue: [ #rejected ]
		ifFalse: [ aMorphicEvent dispatchWith: self localPosition: localPosition ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/19/2012 21:46'!
                    externalize: aPoint
	"aPoint is in own coordinates. Answer is in owner's coordinates."
	"Must include scale and rotation!!"
	self flag: #jmvVer2.
	^ aPoint + position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/19/2012 21:45'!
                          internalize: aPoint
	"aPoint is in owner's coordinates. Answer is in own coordinates."
	"Must include scale and rotation!!"
	self flag: #jmvVer2.
	^ aPoint - position! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 22:04'!
                dispatchWith: aMorph localPosition: positionInAMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside |
	"See if we're fully outside aMorphs bounds"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild dispatchEvent: self localPosition: nil) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^ self sentTo: aMorph localPosition: nil ].
	^ #rejected! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 21:50'!
                        sentTo: aMorph localPosition: localPosition
	"Dispatch the receiver into aMorph"

	^ aMorph handleUnknownEvent: self! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 22:03'!
     dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside |

	"Try to get out quickly"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: self.
	self wasHandled ifTrue:[^self].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild dispatchEvent: self localPosition: nil) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^ self sentTo: aMorph localPosition: nil].
	^#rejected! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 21:48'!
          sentTo: aMorph localPosition: localPosition
	"Dispatch the receiver into aMorph"
	^aMorph handleDropMorph: self! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 21:49'!
      sentTo: aMorph localPosition: localPosition
	"Dispatch the receiver into anObject"

	type == #keystroke ifTrue: [ ^aMorph handleKeystroke: self ].
	type == #keyDown ifTrue: [ ^aMorph handleKeyDown: self ].
	type == #keyUp ifTrue: [ ^aMorph handleKeyUp: self ].
	^ super sentTo: aMorph localPosition: localPosition! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 21:53'!
                               sentTo: aMorph localPosition: localPosition
	"Dispatch the receiver into aMorph"
	type == #mouseOver ifTrue: [ ^aMorph handleMouseOver: self ].
	type == #mouseEnter ifTrue: [ ^aMorph handleMouseEnter: self ].
	type == #mouseLeave ifTrue: [ ^aMorph handleMouseLeave: self ].
	^ super sentTo: aMorph localPosition: localPosition! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 22:05'!
            dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| globalPt aMorphHandlesIt handledByInner lastHandler answer |

	"Only for MouseDown"
	self isMouseDown
		ifFalse: [ ^super dispatchWith: aMorph localPosition: nil ].

	"Try to get out quickly"
	globalPt _ self eventPosition.
	(aMorph morphFullBoundsInWorld containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ eventHandler.
	aMorphHandlesIt _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isPlayfieldLike or: [ self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self)
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self localPosition: nil) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ aMorph containsPoint: self eventPosition event: self ])
		ifTrue:[
			"aMorph is in the top-most unlocked, visible morph in the chain."
			aMorphHandlesIt ifTrue: [ self sentTo: aMorph localPosition: nil ].
			answer _ self ]
		ifFalse: [
			"Mouse was not on aMorph nor any of its children"
			answer _ #rejected ].

	eventHandler _ lastHandler.
	^answer! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 21:50'!
                sentTo: aMorph localPosition: localPosition
	"Dispatch the receiver into anObject"
	type == #mouseDown ifTrue: [ ^aMorph handleMouseDown: self ].
	type == #mouseUp ifTrue: [ ^aMorph handleMouseUp: self ].
	^super sentTo: aMorph localPosition: localPosition! !
!MouseMoveEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 21:51'!
                    sentTo: aMorph localPosition: localPosition
	"Dispatch the receiver into anObject"

	type == #mouseMove ifTrue: [ ^aMorph handleMouseMove: self ].
	^ super sentTo: aMorph localPosition: localPosition! !
!PasteUpMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 22:07'!
         dispatchEvent: anEvent localPosition: localPosition
	"Reimplemented to install the receiver as the new ActiveWorld if it is one.
	localPosition is in our coordinates."
	| priorWorld result |
	self isWorldMorph ifFalse: [
		^super dispatchEvent: anEvent localPosition: localPosition ].
	priorWorld _ ActiveWorld.
	ActiveWorld _ self.
	result _ super dispatchEvent: anEvent localPosition: localPosition.
	ActiveWorld _ priorWorld.
	^result! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 22:00'!
  dispatchWith: aMorph localPosition: positionInAMorph
	"Host window events do not have a position and are only dispatched to the World"

	aMorph isWorldMorph ifFalse: [ ^#rejected ].
	self wasHandled ifTrue: [ ^self ].
	^ self sentTo: aMorph localPosition: nil! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 21:51'!
                    sentTo: aMorph localPosition: localPosition
	"Dispatch the receiver into anObject"

	^ aMorph handleWindowEvent: self! !
!WindowEvent methodsFor: 'accessing' stamp: 'jmv 8/19/2012 22:15'!
    eventPosition
	"Answer something..."
	^rectangle topLeft! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 21:53' prior: 50363990!
               handleFocusEvent: aMorphicEvent
	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."

	^aMorphicEvent sentTo: self localPosition: nil! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 8/19/2012 22:04' prior: 50360879!
                               transferHalo: event from: formerHaloOwner
	"Progressively transfer the halo to the next likely recipient"
	| w |

	"Never transfer halo to top-most world"
	(self isWorldMorph and:[owner isNil]) ifFalse: [
		(formerHaloOwner ~~ self) 
			ifTrue: [ ^self addHalo: event from: formerHaloOwner ]].

	event shiftPressed ifTrue: [
		"Pass it outwards"
		owner ifNotNil: [ ^owner transferHalo: event from: formerHaloOwner ].
		"We're at the top level; throw the event back in to find recipient"
		formerHaloOwner removeHalo.
		^self dispatchEvent: event copy resetHandlerFields localPosition: nil.
	].
	self submorphsDo: [ :m |
		(m fullContainsPoint: event eventPosition) 
			ifTrue: [ ^m transferHalo: event from: formerHaloOwner ].
	].
	"We're at the bottom most level; throw the event back up to the root to find recipient"
	formerHaloOwner removeHalo.
	(w _ self world) ifNil: [ ^self ].
	^w dispatchEvent: event copy resetHandlerFields localPosition: nil! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 22:03' prior: 50363809!
          startEventDispatch: aMorphicEvent

	owner ifNil: [ ^ self ].
	aMorphicEvent isMouseOver ifTrue: [ ^ self sendMouseEvent: aMorphicEvent ].
	
	aMorphicEvent isWindowEvent ifTrue: [
		owner dispatchEvent: aMorphicEvent localPosition: nil.
		^ self mouseOverHandler processMouseOver: lastMouseEvent ].

	aMorphicEvent isKeyboard ifTrue: [
		self sendKeyboardEvent: aMorphicEvent.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	aMorphicEvent isDropEvent ifTrue: [
		owner dispatchEvent: aMorphicEvent localPosition: nil.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	aMorphicEvent isMouse ifTrue: [
		lastMouseEvent _ aMorphicEvent.	
		lastMouseEventTime _ Time millisecondClockValue].

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMorphicEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	aMorphicEvent isMove ifTrue: [
		self morphPosition: aMorphicEvent eventPosition.
		self sendMouseEvent: aMorphicEvent.
	] ifFalse: [
		"Issue a synthetic move event if we're not at the position of the event"
		aMorphicEvent eventPosition = self morphPosition ifFalse: [
			"Issue a mouse move event to make the receiver appear at the given position"
			self startEventDispatch: (MouseMoveEvent new
				setType: #mouseMove
				position: aMorphicEvent eventPosition
				buttons: aMorphicEvent buttons
				hand: self
				stamp: aMorphicEvent timeStamp) ].
		"Drop submorphs on button events"
		self hasSubmorphs
			ifTrue: [ self dropMorphs: aMorphicEvent ]
			ifFalse: [ self sendMouseEvent: aMorphicEvent ].
	].
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 8/19/2012 22:18' prior: 50363480!
              dropMorph: aMorph event: aMouseEvent
	"Drop the given morph which was carried by the hand"
	| dropEvent |
	(aMouseEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue: [ ^self ].
	dropEvent _ DropEvent new setPosition: self morphPosition contents: aMorph hand: self.
	owner dispatchEvent: dropEvent localPosition: dropEvent eventPosition.
	dropEvent wasHandled ifFalse: [ aMorph rejectDropMorphEvent: dropEvent ].
	self mouseOverHandler processMouseOver: aMouseEvent! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 8/19/2012 22:03' prior: 50363509!
            sendMouseEvent: aMouseEvent
	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."

	| w |
	mouseFocus ifNotNil: [
		(w _ mouseFocus world) ifNil: [
			mouseFocus _ nil.
			^self ].
		^self sendFocusEvent: aMouseEvent to: mouseFocus in: w].

	^owner dispatchEvent: aMouseEvent localPosition: nil! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 8/19/2012 22:04' prior: 50363522!
                             handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	self dispatchEvent: aMorphicEvent localPosition: nil.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: nil].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue:[^self].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: nil ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue:[^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue:[^self]].! !
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 8/19/2012 21:54' prior: 50363867!
             processMouseOver: aMouseEvent 
	"Re-establish the z-order for all morphs wrt the given event"

	| hand focus evt |
	hand := aMouseEvent hand.
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	"Now go looking for eventual mouse overs"
	hand startEventDispatch: aMouseEvent asMouseOver.
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [^leftMorphs := enteredMorphs := overMorphs := nil].
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m | 
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sentTo: m localPosition: nil ]
				ifFalse: [overMorphs nextPut: m]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
			"inform: was called in handleEvent:"
			^leftMorphs := enteredMorphs := overMorphs := nil].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m | 
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sentTo: m localPosition: nil ]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			^leftMorphs := enteredMorphs := overMorphs := nil].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil! !

WindowEvent removeSelector: #dispatchWith:!

WindowEvent removeSelector: #dispatchWith:!

WindowEvent removeSelector: #sentTo:!

WindowEvent removeSelector: #sentTo:!

PasteUpMorph removeSelector: #dispatchEvent:!

PasteUpMorph removeSelector: #dispatchEvent:!

MouseMoveEvent removeSelector: #sentTo:!

MouseMoveEvent removeSelector: #sentTo:!

MouseButtonEvent removeSelector: #dispatchWith:!

MouseButtonEvent removeSelector: #dispatchWith:!

MouseButtonEvent removeSelector: #sentTo:!

MouseButtonEvent removeSelector: #sentTo:!

MouseEvent removeSelector: #sentTo:!

MouseEvent removeSelector: #sentTo:!

KeyboardEvent removeSelector: #sentTo:!

KeyboardEvent removeSelector: #sentTo:!

DropEvent removeSelector: #dispatchWith:!

DropEvent removeSelector: #dispatchWith:!

DropEvent removeSelector: #sentTo:!

DropEvent removeSelector: #sentTo:!

MorphicEvent removeSelector: #dispatchWith:!

MorphicEvent removeSelector: #dispatchWith:!

MorphicEvent removeSelector: #sentTo:!

MorphicEvent removeSelector: #sentTo:!

Morph removeSelector: #dispatchEvent:!

Morph removeSelector: #dispatchEvent:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1379-LocalPositionInEvents-JuanVuletich-2012Aug19-22h13m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1379] on 19 August 2012 at 11:13:23 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 22:52'!
                 handleDropMorph: anEvent localPosition: localEventPosition
	"Handle a dropping morph."
	| aMorph posInWorld |
	aMorph _ anEvent contents.
	"Do a symmetric check if both morphs like each other"
	((self wantsDroppedMorph: aMorph event: anEvent)	"I want her"
		and: [aMorph wantsToBeDroppedInto: self])		"she wants me"
			ifFalse: [
				^ self].
	anEvent wasHandled: true.
	posInWorld _ aMorph referencePosition.
	aMorph referencePosition: posInWorld.
	self acceptDroppingMorph: aMorph event: anEvent.
	aMorph justDroppedInto: self event: anEvent.
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 22:55'!
                      handleKeyDown: anEvent localPosition: localEventPosition
	"System level event handling."

	anEvent wasHandled ifTrue: [^self].
	self handlesKeyboard ifFalse: [^self].
	anEvent wasHandled: true.
	^self keyDown: anEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 22:58'!
                              handleKeyUp: anEvent localPosition: localEventPosition
	"System level event handling."

	anEvent wasHandled ifTrue: [^self].
	self handlesKeyboard ifFalse: [^self].
	anEvent wasHandled: true.
	^self keyUp: anEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:09'!
  handleKeystroke: aKeyboardEvent localPosition: localEventPosition
	"System level event handling."

	aKeyboardEvent wasHandled ifTrue: [^self].
	self handlesKeyboard ifFalse: [^self].
	aKeyboardEvent wasHandled: true.
	^self keyStroke: aKeyboardEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:07'!
                              handleMouseDown: anEvent localPosition: localEventPosition
	"System level event handling."
	anEvent wasHandled ifTrue: [ ^self ]. "not interested"
	anEvent hand removePendingBalloonFor: self.
	anEvent wasHandled: true.
	self activateWindow.

	"Make me modal during mouse transitions"
	anEvent hand newMouseFocus: self event: anEvent.
	anEvent mouseButton3Changed ifTrue: [^self mouseButton3Down: anEvent].

	self mouseDown: anEvent.
	anEvent hand removeHaloFromClick: anEvent on: self.

	(self handlesMouseStillDown: anEvent) ifTrue:[
		self startStepping: #handleMouseStillDown:localPosition:
			at: Time millisecondClockValue + self mouseStillDownThreshold
			arguments: {anEvent copy resetHandlerFields . localEventPosition}
			stepTime: self mouseStillDownStepRate ].
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:01'!
                   handleMouseEnter: anEvent localPosition: localEventPosition
	"System level event handling."
	anEvent isDraggingEvent ifTrue: [
		^self].
	self wantsBalloon ifTrue: [
		anEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: anEvent) ifTrue: [
		anEvent wasHandled: true.
		self mouseEnter: anEvent ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:02'!
   handleMouseLeave: anEvent localPosition: localEventPosition
	"System level event handling."
	anEvent hand removePendingBalloonFor: self.
	anEvent isDraggingEvent ifTrue: [
		^self].
	(self handlesMouseOver: anEvent) ifTrue: [
		anEvent wasHandled: true.
		self mouseLeave: anEvent ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:07'!
                             handleMouseMove: anEvent localPosition: localEventPosition
	"System level event handling."
	anEvent wasHandled ifTrue: [^self]. "not interested"
	"Rules say that by default a morph gets #mouseMove iff
		* the hand is not dragging anything,
			+ and some button is down,
			+ and the receiver is the current mouse focus."
	(anEvent hand hasSubmorphs) ifTrue: [^self].
	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse: [^self].
	anEvent wasHandled: true.
	self mouseMove: anEvent.
	(self handlesMouseStillDown: anEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #handleMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {anEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:04'!
                              handleMouseOver: aMorphicEvent localPosition: localEventPosition
	"System level event handling."
	aMorphicEvent hand mouseFocus == self ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: aMorphicEvent eventPosition event: aMorphicEvent) ifFalse: [
			^self ]].
	aMorphicEvent hand noticeMouseOver: self event: aMorphicEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:07'!
 handleMouseStillDown: anEvent localPosition: localEventPosition
	"Called from the stepping mechanism for morphs wanting continuously repeated 'yes the mouse is still down, yes it is still down, yes it has not changed yet, no the mouse is still not up, yes the button is down' etc messages"
	(anEvent hand mouseFocus == self) 
		ifFalse: [
			^self stopSteppingSelector: #handleMouseStillDown:localPosition: ].
	self mouseStillDown: anEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:10'!
handleMouseUp: anEvent localPosition: localEventPosition
	"System level event handling."
	anEvent wasHandled ifTrue: [^self]. "not interested"
	anEvent hand mouseFocus == self ifFalse: [^self]. "Not interested in other parties"
	anEvent hand releaseMouseFocus: self.
	anEvent wasHandled: true.
	anEvent mouseButton3Changed
		ifTrue: [ self mouseButton3Up: anEvent ]
		ifFalse: [
			self mouseUp: anEvent.
			self stopSteppingSelector: #handleMouseStillDown:localPosition: ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:11'!
                              handleUnknownEvent: anEvent localPosition: localEventPosition
	"An event of an unknown type was sent to the receiver. What shall we do?!!"

	Beeper beep. 
	anEvent printString displayAt: 0@0.
	anEvent wasHandled: true! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:11'!
                              handleWindowEvent: anEvent localPosition: localEventPosition
	"Handle an event concerning our host window"

	anEvent wasHandled ifTrue: [^self]. "not interested"
	(self wantsWindowEvent: anEvent) ifFalse: [^self].
	anEvent wasHandled: true.
	self windowEvent: anEvent.
! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 23:00'!
   handleMouseDown: aMorphicEvent localPosition: localEventPosition

	super handleMouseDown: aMorphicEvent localPosition: localEventPosition.
	self send: mouseDownSelector withEvent: aMorphicEvent! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 23:04'!
               handleMouseMove: aMorphicEvent localPosition: localEventPosition

	super handleMouseMove: aMorphicEvent localPosition: localEventPosition.
	aMorphicEvent anyButtonPressed ifTrue: [
		self send: mouseMoveSelector withEvent: aMorphicEvent ]! !
!HaloHandleMorph methodsFor: 'event handling' stamp: 'jmv 8/19/2012 23:10'!
  handleMouseUp: aMorphicEvent localPosition: localEventPosition

	super handleMouseUp: aMorphicEvent localPosition: localEventPosition.
	self send: mouseUpSelector withEvent: aMorphicEvent! !
!HierarchicalListMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:06'!
            handleMouseMove: anEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"
	anEvent wasHandled ifTrue:[^self]. "not interested"
	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].
	anEvent wasHandled: true.
	self mouseMove: anEvent.
	(self handlesMouseStillDown: anEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #handleMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {anEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!InnerTextMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 22:59'!
    handleKeystroke: aKeyboardEvent localPosition: localEventPosition
	"System level event handling."

	aKeyboardEvent wasHandled ifTrue:[^self].
	self handlesKeyboard ifFalse:	[^ self].
	aKeyboardEvent wasHandled: true.
	self keyStroke: aKeyboardEvent! !
!InnerTextMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:07'!
                      handleMouseMove: anEvent localPosition: localEventPosition
	"Re-implemented to allow for mouse-up move events"
	anEvent wasHandled ifTrue:[^self]. "not interested"
	(anEvent hand hasSubmorphs) ifTrue:[^self].
	anEvent wasHandled: true.
	self mouseMove: anEvent.
	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].
	(self handlesMouseStillDown: anEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #handleMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {anEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 8/19/2012 23:10'!
 handleMouseUp: anEvent localPosition: localEventPosition
	"The handling of control between menu item requires them to act on mouse up even if not the current focus. This is different from the default behavior which really only wants to handle mouse ups when they got mouse downs before"
	anEvent wasHandled ifTrue:[^self]. "not interested"
	anEvent hand releaseMouseFocus: self.
	anEvent wasHandled: true.
	anEvent mouseButton3Changed
		ifTrue: [ self mouseButton3Up: anEvent ]
		ifFalse: [ self mouseUp: anEvent ]! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:02'!
             handleMouseEnter: anEvent localPosition: localEventPosition
	"System level event handling."
	"Do #mouseEnter: even if button down (others, like LayoutAdjustingMorph need the default behavior)"
	self wantsBalloon ifTrue: [
		anEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: anEvent) ifTrue:[
		anEvent wasHandled: true.
		self mouseEnter: anEvent ]! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:02'!
    handleMouseLeave: anEvent localPosition: localEventPosition
	"System level event handling."
	"Do #mouseLeave: even if button down (others, like LayoutAdjustingMorph need the default behavior)"
	anEvent hand removePendingBalloonFor: self.
	(self handlesMouseOver: anEvent) ifTrue: [
		anEvent wasHandled: true.
		self mouseLeave: anEvent ]! !
!PluggableListMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 23:08'!
                        handleMouseMove: anEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"
	anEvent wasHandled ifTrue:[^self]. "not interested"
	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].
	anEvent wasHandled: true.
	self mouseMove: anEvent.
	(self handlesMouseStillDown: anEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #handleMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {anEvent copy resetHandlerFields . localEventPosition }
			stepTime: 1].
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 22:37' prior: 50364423!
                            handleFocusEvent: aMorphicEvent
	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."

	^aMorphicEvent sentTo: self localPosition: (self internalizeFromWorld: aMorphicEvent eventPosition)! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/19/2012 22:26' prior: 50364185!
                        internalize: aPoint
	"aPoint is in owner's coordinates. Answer is in own coordinates."
	"Must include scale and rotation!!"
	self flag: #jmvVer2.
	aPoint ifNil: [ ^nil ].	"sacar esto!!"
	^ aPoint - position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/19/2012 22:36' prior: 50345708!
  internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	self flag: #jmvVer2.
	aPoint ifNil: [ ^nil ].	"sacar esto!!"
	^(owner
		ifNotNil: [ owner internalizeFromWorld: aPoint ]
		ifNil: [ aPoint ])
			- position! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 8/19/2012 22:42' prior: 50364434!
        transferHalo: event from: formerHaloOwner
	"Progressively transfer the halo to the next likely recipient"
	| w p |

	"Never transfer halo to top-most world"
	(self isWorldMorph and:[owner isNil]) ifFalse: [
		(formerHaloOwner ~~ self) 
			ifTrue: [ ^self addHalo: event from: formerHaloOwner ]].

	event shiftPressed ifTrue: [
		"Pass it outwards"
		owner ifNotNil: [ ^owner transferHalo: event from: formerHaloOwner ].
		"We're at the top level; throw the event back in to find recipient"
		formerHaloOwner removeHalo.
		p _ self internalizeFromWorld: event eventPosition.
		^self dispatchEvent: event copy resetHandlerFields localPosition: p.
	].
	self submorphsDo: [ :m |
		(m fullContainsPoint: event eventPosition) 
			ifTrue: [ ^m transferHalo: event from: formerHaloOwner ].
	].
	"We're at the bottom most level; throw the event back up to the root to find recipient"
	formerHaloOwner removeHalo.
	(w _ self world) ifNil: [ ^self ].
	^w dispatchEvent: event copy resetHandlerFields localPosition: event eventPosition! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/19/2012 22:29' prior: 50364467!
    startEventDispatch: aMorphicEvent

	owner ifNil: [ ^ self ].
	aMorphicEvent isMouseOver ifTrue: [ ^ self sendMouseEvent: aMorphicEvent ].
	
	aMorphicEvent isWindowEvent ifTrue: [
		owner dispatchEvent: aMorphicEvent localPosition: aMorphicEvent eventPosition.
		^ self mouseOverHandler processMouseOver: lastMouseEvent ].

	aMorphicEvent isKeyboard ifTrue: [
		self sendKeyboardEvent: aMorphicEvent.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	aMorphicEvent isDropEvent ifTrue: [
		owner dispatchEvent: aMorphicEvent localPosition: aMorphicEvent eventPosition.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	aMorphicEvent isMouse ifTrue: [
		lastMouseEvent _ aMorphicEvent.	
		lastMouseEventTime _ Time millisecondClockValue].

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMorphicEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	aMorphicEvent isMove ifTrue: [
		self morphPosition: aMorphicEvent eventPosition.
		self sendMouseEvent: aMorphicEvent.
	] ifFalse: [
		"Issue a synthetic move event if we're not at the position of the event"
		aMorphicEvent eventPosition = self morphPosition ifFalse: [
			"Issue a mouse move event to make the receiver appear at the given position"
			self startEventDispatch: (MouseMoveEvent new
				setType: #mouseMove
				position: aMorphicEvent eventPosition
				buttons: aMorphicEvent buttons
				hand: self
				stamp: aMorphicEvent timeStamp) ].
		"Drop submorphs on button events"
		self hasSubmorphs
			ifTrue: [ self dropMorphs: aMorphicEvent ]
			ifFalse: [ self sendMouseEvent: aMorphicEvent ].
	].
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 8/19/2012 22:31' prior: 50364544!
 sendMouseEvent: aMouseEvent
	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."

	| w |
	mouseFocus ifNotNil: [
		(w _ mouseFocus world) ifNil: [
			mouseFocus _ nil.
			^self ].
		^self sendFocusEvent: aMouseEvent to: mouseFocus in: w].

	^owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 8/19/2012 22:39' prior: 50364558!
       handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	| eventPositionInOurCoordinates |
	eventPositionInOurCoordinates _ self internalizeFromWorld: aMorphicEvent eventPosition.

	self dispatchEvent: aMorphicEvent localPosition: eventPositionInOurCoordinates.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 22:23' prior: 50364193!
    dispatchWith: aMorph localPosition: positionInAMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside eventPositionInChild |
	"See if we're fully outside aMorphs bounds"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^ self sentTo: aMorph localPosition: positionInAMorph ].
	^ #rejected! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 23:11' prior: 50364221!
                  sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into aMorph"

	^ aMorph handleUnknownEvent: self localPosition: positionInAMorph! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 22:22' prior: 50364227!
                  dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside eventPositionInChild |

	"Try to get out quickly"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: self.
	self wasHandled ifTrue:[^self].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^ self sentTo: aMorph localPosition: positionInAMorph].
	^#rejected! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 22:54' prior: 50364259!
    sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into aMorph"

	^aMorph handleDropMorph: self localPosition: positionInAMorph! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 23:00' prior: 50364265!
                  sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [ ^ aMorph
			handleKeystroke: self
			localPosition: positionInAMorph ].
	type == #keyDown ifTrue: [ ^ aMorph
			handleKeyDown: self
			localPosition: positionInAMorph ].
	type == #keyUp ifTrue: [ ^ aMorph
			handleKeyUp: self
			localPosition: positionInAMorph ].
	^ super
		sentTo: aMorph
		localPosition: positionInAMorph! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 23:05' prior: 50364278!
                 sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into aMorph"

	type == #mouseOver ifTrue: [
		^aMorph handleMouseOver: self localPosition: positionInAMorph ].
	type == #mouseEnter ifTrue: [
		^ aMorph handleMouseEnter: self localPosition: positionInAMorph ].
	type == #mouseLeave ifTrue: [
		^aMorph handleMouseLeave: self localPosition: positionInAMorph ].
	^ super sentTo: aMorph localPosition: positionInAMorph! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 22:32' prior: 50364291!
              dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| globalPt aMorphHandlesIt handledByInner lastHandler answer eventPositionInChild |

	"Only for MouseDown"
	self isMouseDown
		ifFalse: [ ^super dispatchWith: aMorph localPosition: positionInAMorph ].

	"Try to get out quickly"
	globalPt _ self eventPosition.
	(aMorph morphFullBoundsInWorld containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ eventHandler.
	aMorphHandlesIt _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isPlayfieldLike or: [ self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self)
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ aMorph containsPoint: self eventPosition event: self ])
		ifTrue:[
			"aMorph is in the top-most unlocked, visible morph in the chain."
			aMorphHandlesIt ifTrue: [ self sentTo: aMorph localPosition: positionInAMorph ].
			answer _ self ]
		ifFalse: [
			"Mouse was not on aMorph nor any of its children"
			answer _ #rejected ].

	eventHandler _ lastHandler.
	^answer! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 23:10' prior: 50364365!
                             sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"

	type == #mouseDown ifTrue: [
		^aMorph handleMouseDown: self localPosition: positionInAMorph ].
	type == #mouseUp ifTrue: [
		^aMorph handleMouseUp: self localPosition: positionInAMorph ].
	^super sentTo: aMorph localPosition: positionInAMorph! !
!MouseMoveEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 23:04' prior: 50364376!
                         sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"

	type == #mouseMove ifTrue: [
		^aMorph handleMouseMove: self localPosition: positionInAMorph ].
	^ super sentTo: aMorph localPosition: positionInAMorph! !
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 8/19/2012 22:40' prior: 50364599!
                processMouseOver: aMouseEvent 
	"Re-establish the z-order for all morphs wrt the given event"

	| hand focus evt p |
	hand := aMouseEvent hand.
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	"Now go looking for eventual mouse overs"
	hand startEventDispatch: aMouseEvent asMouseOver.
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [^leftMorphs := enteredMorphs := overMorphs := nil].
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m | 
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					p _ m internalizeFromWorld: evt eventPosition.
					evt sentTo: m localPosition: p ]
				ifFalse: [overMorphs nextPut: m]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
			"inform: was called in handleEvent:"
			^leftMorphs := enteredMorphs := overMorphs := nil].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m | 
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					p _ m internalizeFromWorld: evt eventPosition.
					evt sentTo: m localPosition: p ]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			^leftMorphs := enteredMorphs := overMorphs := nil].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 22:31' prior: 50364401!
dispatchWith: aMorph localPosition: positionInAMorph
	"Host window events do not have a position and are only dispatched to the World"

	aMorph isWorldMorph ifFalse: [ ^#rejected ].
	self wasHandled ifTrue: [ ^self ].
	^ self sentTo: aMorph localPosition: positionInAMorph! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/19/2012 23:12' prior: 50364412!
                       sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"

	^ aMorph handleWindowEvent: self localPosition: positionInAMorph! !

PluggableListMorph removeSelector: #handleMouseMove:!

PluggableListMorph removeSelector: #handleMouseMove:!

MenuItemMorph removeSelector: #handleMouseEnter:!

MenuItemMorph removeSelector: #handleMouseEnter:!

MenuItemMorph removeSelector: #handleMouseLeave:!

MenuItemMorph removeSelector: #handleMouseLeave:!

MenuItemMorph removeSelector: #handleMouseUp:!

MenuItemMorph removeSelector: #handleMouseUp:!

InnerTextMorph removeSelector: #handleKeystroke:!

InnerTextMorph removeSelector: #handleKeystroke:!

InnerTextMorph removeSelector: #handleMouseMove:!

InnerTextMorph removeSelector: #handleMouseMove:!

HierarchicalListMorph removeSelector: #handleMouseMove:!

HierarchicalListMorph removeSelector: #handleMouseMove:!

HaloHandleMorph removeSelector: #handleMouseDown:!

HaloHandleMorph removeSelector: #handleMouseDown:!

HaloHandleMorph removeSelector: #handleMouseMove:!

HaloHandleMorph removeSelector: #handleMouseMove:!

HaloHandleMorph removeSelector: #handleMouseUp:!

HaloHandleMorph removeSelector: #handleMouseUp:!

Morph removeSelector: #handleDropMorph:!

Morph removeSelector: #handleDropMorph:!

Morph removeSelector: #handleKeyDown:!

Morph removeSelector: #handleKeyDown:!

Morph removeSelector: #handleKeyUp:!

Morph removeSelector: #handleKeyUp:!

Morph removeSelector: #handleKeystroke:!

Morph removeSelector: #handleKeystroke:!

Morph removeSelector: #handleMouseDown:!

Morph removeSelector: #handleMouseDown:!

Morph removeSelector: #handleMouseEnter:!

Morph removeSelector: #handleMouseEnter:!

Morph removeSelector: #handleMouseLeave:!

Morph removeSelector: #handleMouseLeave:!

Morph removeSelector: #handleMouseMove:!

Morph removeSelector: #handleMouseMove:!

Morph removeSelector: #handleMouseOver:!

Morph removeSelector: #handleMouseOver:!

Morph removeSelector: #handleMouseStillDown:!

Morph removeSelector: #handleMouseStillDown:!

Morph removeSelector: #handleMouseUp:!

Morph removeSelector: #handleMouseUp:!

Morph removeSelector: #handleUnknownEvent:!

Morph removeSelector: #handleUnknownEvent:!

Morph removeSelector: #handleWindowEvent:!

Morph removeSelector: #handleWindowEvent:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1380-LocalPositionInEvents-JuanVuletich-2012Aug19-22h26m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1380] on 20 August 2012 at 7:37:42 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:19'!
                 processDropMorph: aDropEvent localPosition: localEventPosition
	"Handle a dropping morph."
	| aMorph posInWorld |
	aMorph _ aDropEvent contents.
	"Do a symmetric check if both morphs like each other"
	((self wantsDroppedMorph: aMorph event: aDropEvent)	"I want her"
		and: [aMorph wantsToBeDroppedInto: self])		"she wants me"
			ifFalse: [
				^ self].
	aDropEvent wasHandled: true.
	posInWorld _ aMorph referencePosition.
	aMorph referencePosition: posInWorld.
	self acceptDroppingMorph: aMorph event: aDropEvent.
	aMorph justDroppedInto: self event: aDropEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:19'!
     processKeyDown: aKeyboardEvent localPosition: localEventPosition
	"System level event handling."

	aKeyboardEvent wasHandled ifTrue: [^self].
	self handlesKeyboard ifFalse: [^self].
	aKeyboardEvent wasHandled: true.
	^self keyDown: aKeyboardEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:20'!
 processKeyUp: aKeyboardEvent localPosition: localEventPosition
	"System level event handling."

	aKeyboardEvent wasHandled ifTrue: [^self].
	self handlesKeyboard ifFalse: [^self].
	aKeyboardEvent wasHandled: true.
	^self keyUp: aKeyboardEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:02'!
     processKeystroke: aKeyboardEvent localPosition: localEventPosition
	"System level event handling."

	aKeyboardEvent wasHandled ifTrue: [^self].
	self handlesKeyboard ifFalse: [^self].
	aKeyboardEvent wasHandled: true.
	^self keyStroke: aKeyboardEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:11'!
                             processMouseDown: anEvent localPosition: localEventPosition
	"System level event handling."
	anEvent wasHandled ifTrue: [ ^self ]. "not interested"
	anEvent hand removePendingBalloonFor: self.
	anEvent wasHandled: true.
	self activateWindow.

	"Make me modal during mouse transitions"
	anEvent hand newMouseFocus: self event: anEvent.
	anEvent mouseButton3Changed ifTrue: [^self mouseButton3Down: anEvent].

	self mouseDown: anEvent.
	anEvent hand removeHaloFromClick: anEvent on: self.

	(self handlesMouseStillDown: anEvent) ifTrue:[
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue + self mouseStillDownThreshold
			arguments: {anEvent copy resetHandlerFields . localEventPosition}
			stepTime: self mouseStillDownStepRate ].
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:22'!
                 processMouseEnter: aMouseEvent localPosition: localEventPosition
	"System level event handling."
	aMouseEvent isDraggingEvent ifTrue: [
		^self].
	self wantsBalloon ifTrue: [
		aMouseEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: aMouseEvent) ifTrue: [
		aMouseEvent wasHandled: true.
		self mouseEnter: aMouseEvent ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:03'!
          processMouseLeave: anEvent localPosition: localEventPosition
	"System level event handling."
	anEvent hand removePendingBalloonFor: self.
	anEvent isDraggingEvent ifTrue: [
		^self].
	(self handlesMouseOver: anEvent) ifTrue: [
		anEvent wasHandled: true.
		self mouseLeave: anEvent ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:25'!
                            processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"System level event handling."

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	"Rules say that by default a morph gets #mouseMove iff
		* the hand is not dragging anything,
			+ and some button is down,
			+ and the receiver is the current mouse focus."
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	(aMouseMoveEvent anyButtonPressed and: [ aMouseMoveEvent hand mouseFocus == self ]) ifFalse: [^self].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {aMouseMoveEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:21'!
              processMouseOver: aMouseEvent localPosition: localEventPosition
	"System level event handling."
	aMouseEvent hand mouseFocus == self ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: aMouseEvent eventPosition event: aMouseEvent) ifFalse: [
			^self ]].
	aMouseEvent hand noticeMouseOver: self event: aMouseEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:11'!
            processMouseStillDown: anEvent localPosition: localEventPosition
	"Called from the stepping mechanism for morphs wanting continuously repeated 'yes the mouse is still down, yes it is still down, yes it has not changed yet, no the mouse is still not up, yes the button is down' etc messages"
	(anEvent hand mouseFocus == self) 
		ifFalse: [
			^self stopSteppingSelector: #processMouseStillDown:localPosition: ].
	self mouseStillDown: anEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:21'!
                              processMouseUp: aMouseButtonEvent localPosition: localEventPosition
	"System level event handling."

	aMouseButtonEvent wasHandled ifTrue: [^self]. "not interested"
	aMouseButtonEvent hand mouseFocus == self ifFalse: [^self]. "Not interested in other parties"
	aMouseButtonEvent hand releaseMouseFocus: self.
	aMouseButtonEvent wasHandled: true.
	aMouseButtonEvent mouseButton3Changed
		ifTrue: [ self mouseButton3Up: aMouseButtonEvent ]
		ifFalse: [
			self mouseUp: aMouseButtonEvent.
			self stopSteppingSelector: #processMouseStillDown:localPosition: ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:20'!
           processUnknownEvent: aMorphicEvent localPosition: localEventPosition
	"An event of an unknown type was sent to the receiver. What shall we do?!!"

	Beeper beep. 
	aMorphicEvent printString displayAt: 0@0.
	aMorphicEvent wasHandled: true! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:26'!
           processWindowEvent: aWindowEvent localPosition: localEventPosition
	"Handle an event concerning our host window"

	aWindowEvent wasHandled ifTrue: [^self]. "not interested"
	(self wantsWindowEvent: aWindowEvent) ifFalse: [^self].
	aWindowEvent wasHandled: true.
	self windowEvent: aWindowEvent.
! !
!HaloHandleMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:20'!
      processMouseDown: aMouseButtonEvent localPosition: localEventPosition

	super processMouseDown: aMouseButtonEvent localPosition: localEventPosition.
	self send: mouseDownSelector withEvent: aMouseButtonEvent! !
!HaloHandleMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:23'!
                              processMouseMove: aMouseMoveEvent localPosition: localEventPosition

	super processMouseMove: aMouseMoveEvent localPosition: localEventPosition.
	aMouseMoveEvent anyButtonPressed ifTrue: [
		self send: mouseMoveSelector withEvent: aMouseMoveEvent ]! !
!HaloHandleMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:21'!
                     processMouseUp: aMouseButtonEvent localPosition: localEventPosition

	super processMouseUp: aMouseButtonEvent localPosition: localEventPosition.
	self send: mouseUpSelector withEvent: aMouseButtonEvent! !
!InnerTextMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:02'!
     processKeystroke: aKeyboardEvent localPosition: localEventPosition
	"System level event handling."

	aKeyboardEvent wasHandled ifTrue:[^self].
	self handlesKeyboard ifFalse:	[^ self].
	aKeyboardEvent wasHandled: true.
	self keyStroke: aKeyboardEvent! !
!InnerTextMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:25'!
                     processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Re-implemented to allow for mouse-up move events"

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent.
	(aMouseMoveEvent anyButtonPressed and: [ aMouseMoveEvent hand mouseFocus == self ]) ifFalse: [ ^self ].
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {aMouseMoveEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:22'!
 processMouseEnter: aMouseEvent localPosition: localEventPosition
	"System level event handling."
	"Do #mouseEnter: even if button down (others, like LayoutAdjustingMorph need the default behavior)"
	self wantsBalloon ifTrue: [
		aMouseEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: aMouseEvent) ifTrue:[
		aMouseEvent wasHandled: true.
		self mouseEnter: aMouseEvent ]! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:22'!
               processMouseLeave: aMouseEvent localPosition: localEventPosition
	"System level event handling."

	"Do #mouseLeave: even if button down (others, like LayoutAdjustingMorph need the default behavior)"
	aMouseEvent hand removePendingBalloonFor: self.
	(self handlesMouseOver: aMouseEvent) ifTrue: [
		aMouseEvent wasHandled: true.
		self mouseLeave: aMouseEvent ]! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:21'!
       processMouseUp: aMouseButtonEvent localPosition: localEventPosition
	"The handling of control between menu item requires them to act on mouse up even if not the current focus. This is different from the default behavior which really only wants to handle mouse ups when they got mouse downs before"

	aMouseButtonEvent wasHandled ifTrue:[^self]. "not interested"
	aMouseButtonEvent hand releaseMouseFocus: self.
	aMouseButtonEvent wasHandled: true.
	aMouseButtonEvent mouseButton3Changed
		ifTrue: [ self mouseButton3Up: aMouseButtonEvent ]
		ifFalse: [ self mouseUp: aMouseButtonEvent ]! !
!HierarchicalListMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:23'!
                             processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	(aMouseMoveEvent anyButtonPressed and: [ aMouseMoveEvent hand mouseFocus == self]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {aMouseMoveEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!PluggableListMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 19:25'!
                     processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	(aMouseMoveEvent anyButtonPressed and: [ aMouseMoveEvent hand mouseFocus == self ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {aMouseMoveEvent copy resetHandlerFields . localEventPosition }
			stepTime: 1].
! !
!MessageNames methodsFor: 'selector list' stamp: 'jmv 8/20/2012 19:08' prior: 16888589!
             messageList
	"Answer the receiver's message list, computing it if necessary. The way 
	to force a recomputation is to set the messageList to nil"
	messageList
		ifNil: [
			messageList _ selectedSelector
				ifNil: [#()]
				ifNotNil: [
					Smalltalk allImplementorsOf: selectedSelector].
			self initializeMessageList: messageList.
			self messageListIndex: (messageList size > 0
				ifTrue: [1]
				ifFalse: [0])
			].
	^ messageList! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:40' prior: 50362217!
                              click: aMorphicEvent
	"Handle a single-click event. This message is only sent to clients that request it by sending one of the #waitForClicksOrDrag:... messages to the initiating hand in their mouseDown: method. This default implementation does nothing."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:41' prior: 50362227!
                    doubleClick: aMorphicEvent
	"Handle a double-click event. This message is only sent to clients that request it by sending one of the #waitForClicksOrDrag:... messages to the initiating hand in their mouseDown: method. This default implementation does nothing."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:43' prior: 16897168!
              keyDown: aMorphicEvent
	"Handle a key down event. The default response is to do nothing."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:46' prior: 50362270!
                         keyStroke: aKeyboardEvent
	"Handle a keystroke event."

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self closeWindowFor: aKeyboardEvent)
		ifTrue: [ ^ self ]! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:58' prior: 16897186!
keyUp: anEvent
	"Handle a key up event. The default response is to do nothing."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:02' prior: 50362278!
   mouseDown: evt
	"Handle a mouse down event."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:03' prior: 50362283!
      mouseEnter: evt
	"Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:03' prior: 50362290!
    mouseLeave: evt
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:03' prior: 50362297!
       mouseMove: evt
	"Handle a mouse move event."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:03' prior: 50362302!
      mouseStillDown: evt
	"Handle a mouse move event."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:03' prior: 50362307!
 mouseUp: evt
	"Handle a mouse up event."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:03' prior: 16897290!
          windowEvent: anEvent
	"Host window event"! !
!Morph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:49' prior: 50362237!
                         handlesKeyboard
	"Return true if the receiver wishes to handle keyboard events"

	^ false
! !
!Morph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:49' prior: 50362901!
        handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	"NOTE: The default response is false. Subclasses that implement these messages directly should override this one to return true." 

	^ false
! !
!Morph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:49' prior: 50362254!
   handlesMouseOver: aMorphicEvent
	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?  The default response is false." 

	^ false! !
!Morph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:49' prior: 50362262!
                       handlesMouseStillDown: evt
	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"
	^ false! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:15' prior: 50353258!
                  mouseUp: evt
	(self containsPoint: evt eventPosition)
		ifTrue: [
			self selected: 
				((evt eventPosition y - self morphPositionInWorld y // self class itemHeight) + 
					self firstVisible).
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!AutoCompleterMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:54' prior: 50362962!
    handlesMouseDown: aMouseButtonEvent

	^ true! !
!FillInTheBlankMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:02' prior: 50342762!
                        mouseDown: evt
	(self containsPoint: evt eventPosition) ifFalse:[^ Beeper beep]. "sent in response to outside modal click"
	evt hand grabMorph: self. "allow repositioning"! !
!FillInTheBlankMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:54' prior: 50362967!
         handlesMouseDown: aMouseButtonEvent
	^true! !
!HaloHandleMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:50' prior: 50362972!
              handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^(super handlesMouseDown: aMouseButtonEvent) | 
		mouseDownSelector notNil | mouseMoveSelector notNil | mouseUpSelector notNil! !
!HaloHandleMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:51' prior: 50362069!
        handlesMouseStillDown: evt
	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"
	^(super handlesMouseStillDown: evt) | keyStrokeSelector notNil! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:12' prior: 50342814!
    mouseMove: evt
	"Drag our target around"
	| thePoint |
	thePoint _ evt eventPosition - positionOffset.
	target morphPosition: thePoint! !
!HaloMorph methodsFor: 'event handling' stamp: 'jmv 8/20/2012 18:13' prior: 50362983!
popUpFor: aMorph event: aMorphicEvent
	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."

	| hand anEvent |
	self flag: #workAround.	"We should really have some event/hand here..."
	anEvent _ aMorphicEvent
				ifNil: [
					hand _ aMorph world activeHand.
					hand ifNil: [ hand _ aMorph world firstHand ]. 
					hand lastEvent ]
				ifNotNil: [
					hand _ aMorphicEvent hand.
					aMorphicEvent ].
	hand halo: self.
	hand world addMorphFront: self.
	self target: aMorph.
	positionOffset _ anEvent eventPosition - aMorph morphPosition.
	self startStepping! !
!HaloMorph methodsFor: 'event handling' stamp: 'jmv 8/20/2012 18:13' prior: 16863675!
        staysUpWhenMouseIsDownIn: aMorph
	^ ((aMorph == target) or: [aMorph hasOwner: self])! !
!HaloMorph methodsFor: 'event handling' stamp: 'jmv 8/20/2012 18:13' prior: 16863680!
                  transferHalo: event
	"Transfer the halo to the next likely recipient"
	target ifNil: [ ^self delete ].
	target transferHalo: event from: target.! !
!HandleMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:45' prior: 50343309!
                            keyStroke: aKeyboardEvent
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ aKeyboardEvent keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - (1@0) ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + (1@0) ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - (0@1) ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + (0@1) ].
	"Special case for return"
	aKeyboardEvent isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:00' prior: 50360997!
      clickAndHalf: evt
	self handleInteraction: [
		editor clickAndHalf: (evt ztranslatedBy: self morphPositionInWorld negated) ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:57' prior: 16870106!
             keyStroke: aKeyboardEvent

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self closeWindowFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
		
	"Maybe disable? Precludes the use of up and down arrows with control,
	that are standard keystrokes in Windows to control the cursor.
	Problem: At least Mac and Win VM generate ctrl-up and ctrl-down for
	mouse wheel events.
	I guess most people would prefer the mouse wheel to work properly..."
	(owner scrollByKeyboard: aKeyboardEvent)
		ifTrue: [ ^self ].

	autoCompleter 
		ifNil: [ self processKeyStroke: aKeyboardEvent ]
		ifNotNil: [
			autoCompleter
				autoCompletionAround: [ self processKeyStroke: aKeyboardEvent ]
				keyStroke: aKeyboardEvent ]! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:59' prior: 50361014!
  mouseDown: event
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].

	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"
	self hasKeyboardFocus ifFalse: [
		^event hand newKeyboardFocus: self].

	super mouseDown: event.

	self handleInteraction: [editor mouseDown: (event ztranslatedBy: self morphPositionInWorld negated)].

	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: #clickAndHalf:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:
		tripleClkSel: nil! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:00' prior: 50361040!
                              mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt ztranslatedBy: self morphPositionInWorld negated)].
	(evt eventPosition y - owner morphPositionInWorld y between: 0 and: owner morphExtentInWorld y) ifFalse: [
		owner scrollSelectionIntoView ]! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:00' prior: 50361054!
 mouseUp: evt
	super mouseUp: evt.
	self pauseBlinking.
	self handleInteraction: [editor mouseUp: (evt ztranslatedBy: self morphPositionInWorld negated)].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:51' prior: 16870098!
 handlesKeyboard

	^self visible! !
!InnerTextMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:52' prior: 50363083!
                          handlesMouseDown: aMouseButtonEvent
	^ true! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:01' prior: 50356802!
                        mouseDown: anEvent
	super mouseDown: anEvent.
	self cursor show.
	hand _ anEvent hand.
	self startStepping.
	Preferences fastDragWindowForMorphic ifTrue: [
		indicator _ RectangleIndicatorMorph new.
		indicator morphBoundsInWorld: self initialIndicatorBounds.
		indicator openInWorld ]! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:01' prior: 16879741!
      mouseEnter: anEvent
	super mouseEnter: anEvent.
	self cursor show.
	hand _ anEvent hand.
	self startStepping! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:01' prior: 16879748!
                       mouseLeave: anEvent
	super mouseLeave: anEvent.
	hand _ nil! !
!LayoutAdjustingMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:55' prior: 50363098!
                        handlesMouseDown: aMouseButtonEvent

	^ true! !
!LayoutAdjustingMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:55' prior: 16879725!
       handlesMouseOver: evt

	^ true! !
!MagnifierMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:55' prior: 50363103!
                           handlesMouseDown: aMouseButtonEvent
	^aMouseButtonEvent mouseButton2Pressed
		or: [super handlesMouseDown: aMouseButtonEvent]! !
!MenuItemMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:55' prior: 50363110!
                             handlesMouseDown: aMouseButtonEvent

	^ true! !
!MenuItemMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:55' prior: 16886954!
              handlesMouseOver: anEvent
	^true! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:48' prior: 16887894!
              keyStroke: aKeyboardEvent 
	| matchString char asc selectable help |
	help _ HoverHelpMorph contents: 'Enter text to\narrow selection down\to matching items ' withNewLines.
	help popUpForHand: self activeHand.
	char := aKeyboardEvent keyCharacter.
	asc := char asciiValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: 
					[selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: 
							["self delete."

							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: 
			["escape key"

			self valueOfProperty: #matchString
				ifPresentDo: 
					[:str | 
					str isEmpty 
						ifFalse: 
							["If filtered, first ESC removes filter"

							self setProperty: #matchString toValue: String new.
							self selectItem: nil event: aKeyboardEvent.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			popUpOwner ifNil: [^self delete].
			"If a sub-menu, then deselect, and return focus to outer menu"
			self selectItem: nil event: aKeyboardEvent.
			aKeyboardEvent hand newMouseFocus: popUpOwner owner.
			^aKeyboardEvent hand newKeyboardFocus: popUpOwner owner].
	(asc = 28 or: [asc = 29]) 
		ifTrue: 
			["left or right arrow key"

			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: 
					[aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].
	matchString := char = Character backspace 
				ifTrue: 
					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent.
	help _ HoverHelpMorph contents: 'Enter text to\narrow selection down\to matching items ' withNewLines.
	help popUpForHand: self activeHand.
! !
!MenuMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:52' prior: 16887888!
                           handlesKeyboard
	"Answer whether the receiver handle keyboard events"

	^self visible! !
!MenuMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:56' prior: 50363114!
         handlesMouseDown: aMouseButtonEvent
	^true! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 17:50' prior: 50365188!
                         handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	| eventPositionInOurCoordinates |
	eventPositionInOurCoordinates _ self internalizeFromWorld: aMorphicEvent eventPosition.

	self dispatchEvent: aMorphicEvent localPosition: eventPositionInOurCoordinates.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !
!MenuMorph methodsFor: 'misc' stamp: 'jmv 8/20/2012 17:49' prior: 16887752!
              activate: evt
	"Receiver should be activated; e.g., so that control passes correctly."
	evt hand newMouseFocus: self.! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 19:12' prior: 50365267!
                 sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into aMorph"

	^ aMorph processUnknownEvent: self localPosition: positionInAMorph! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 19:01' prior: 50365311!
                 sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into aMorph"

	^aMorph processDropMorph: self localPosition: positionInAMorph! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 19:04' prior: 50365319!
                 sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [
		^ aMorph
			processKeystroke: self
			localPosition: positionInAMorph ].
	type == #keyDown ifTrue: [
		^ aMorph
			processKeyDown: self
			localPosition: positionInAMorph ].
	type == #keyUp ifTrue: [ 
		^ aMorph
			processKeyUp: self
			localPosition: positionInAMorph ].
	^ super
		sentTo: aMorph
		localPosition: positionInAMorph.! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 19:10' prior: 50365336!
      sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into aMorph"

	type == #mouseOver ifTrue: [
		^aMorph processMouseOver: self localPosition: positionInAMorph ].
	type == #mouseEnter ifTrue: [
		^ aMorph processMouseEnter: self localPosition: positionInAMorph ].
	type == #mouseLeave ifTrue: [
		^aMorph processMouseLeave: self localPosition: positionInAMorph ].
	^ super sentTo: aMorph localPosition: positionInAMorph! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 19:12' prior: 50365432!
           sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"

	type == #mouseDown ifTrue: [
		^aMorph processMouseDown: self localPosition: positionInAMorph ].
	type == #mouseUp ifTrue: [
		^aMorph processMouseUp: self localPosition: positionInAMorph ].
	^super sentTo: aMorph localPosition: positionInAMorph! !
!MouseMoveEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 19:09' prior: 50365446!
                       sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"

	type == #mouseMove ifTrue: [
		^aMorph processMouseMove: self localPosition: positionInAMorph ].
	^ super sentTo: aMorph localPosition: positionInAMorph! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:00' prior: 16906427!
                     clickAndHalf: evt
	self handleInteraction: [ self editor clickAndHalf: evt ]! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:57' prior: 16906446!
                         keyStroke: aKeyboardEvent
	"Handle a keystroke event."

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self closeWindowFor: aKeyboardEvent)
		ifTrue: [ ^ self ].

	"Return - check for special action
	Note: Code below assumes that this was some
	input field reacting on Return. Break the keyboard
	focus so that the receiver can be safely deleted.
	jmv - Currently not implemented"
	"
	evt isReturnKey ifTrue: [
		action _ self crAction.
		action ifNotNil: [
			evt hand newKeyboardFocus: nil.
			^action value ] ].
	"
	self pauseBlinking.
	self handleInteraction: [ self editor processKeyStroke: aKeyboardEvent ].
	self updateFromContents.
	super keyStroke: aKeyboardEvent  "sends to keyStroke event handler, if any"! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:07' prior: 50343973!
       mouseDown: event
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	event hand newKeyboardFocus: self.

	self handleInteraction: [
		self editor mouseDown: event index: (self characterIndexAtPoint: event eventPosition) ].

	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: #clickAndHalf:
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:07' prior: 16906490!
                 mouseEnter: event
	super mouseEnter: event.
	Preferences focusFollowsMouse
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:07' prior: 50343991!
           mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self].
	self handleInteraction: [
		self editor mouseMove: evt index: (self characterIndexAtPoint: evt eventPosition) ]! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:07' prior: 16906505!
                          mouseUp: evt
	super mouseUp: evt.
	self pauseBlinking
! !
!OneLineEditorMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:52' prior: 16906433!
                               handlesKeyboard

	^self visible! !
!OneLineEditorMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:52' prior: 50363144!
                      handlesMouseDown: aMouseButtonEvent
	^ true! !
!OneLineEditorMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:52' prior: 16906441!
          handlesMouseOver: evt
	"implements #mouseEnter: and/or #mouseLeave:"
	^true! !
!PasteUpMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:40' prior: 16911690!
click: aMorphicEvent
	^self mouseButton2Activity! !
!PasteUpMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:04' prior: 16911712!
                           mouseDown: event
	"Handle a mouse down event."

	| grabbedMorph |
	grabbedMorph _ self morphToGrab: event.
	grabbedMorph ifNotNil:[
		grabbedMorph isSticky ifTrue:[^self].
		^event hand grabMorph: grabbedMorph].

	event mouseButton2Pressed ifTrue: [^self mouseButton2Activity].

	super mouseDown: event.

	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: event
		clkSel: #click:
		clkNHalf: nil
		dblClkSel: #doubleClick:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PasteUpMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:04' prior: 50363154!
     windowEvent: aMorphicEvent
	self windowEventHandler
		ifNotNil: [^self windowEventHandler windowEvent: aMorphicEvent].

	aMorphicEvent windowEventType == #windowClose
		ifTrue: [
			^TheWorldMenu basicNew quitSession]
! !
!PasteUpMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:56' prior: 50363149!
 handlesMouseDown: aMouseButtonEvent
	^true! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:05' prior: 16913665!
                         mouseDown: event
	event mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].
	isPressed _ true.
	self redrawNeeded.
	(actWhen == #buttonDown or: [ actWhen == #buttonStillDown ])
		ifTrue: [
			self performAction ]
		ifFalse: [
			"Don't make multi-click slower if we act on button down, just do multiple actions"
			event hand
				waitForClicksOrDragOrSimulatedMouseButton2: self
				event: event
				clkSel: nil
				clkNHalf: nil
				dblClkSel: #doubleClick:
				dblClkNHalfSel: nil
				tripleClkSel: nil ]! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:05' prior: 16913684!
mouseEnter: event
	"The mouse entered the receiver"
	mouseIsOver _ true.
	self redrawNeeded.
	^super mouseEnter: event! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:05' prior: 16913691!
             mouseLeave: event
	"The mouse has left the area of the receiver"
	mouseIsOver _ false.
	self redrawNeeded.
	^super mouseLeave: event! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:05' prior: 16913698!
                               mouseStillDown: evt
	"Acting when down (instead of waiting until releasing the button)
	also means that the button actin is repeated if the button is kept pressed.
	See #handlesMouseStillDown:"
	self performAction! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:05' prior: 50344110!
              mouseUp: evt
	isPressed _ false.
	mouseIsOver _ false.
	(actWhen == #buttonUp and: [self containsPoint: evt eventPosition])
		ifTrue: [ self performAction ].
	self redrawNeeded! !
!PluggableButtonMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:57' prior: 50363164!
   handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !
!PluggableButtonMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:57' prior: 16913645!
                            handlesMouseOver: evt
	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?" 
	^true! !
!PluggableButtonMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:57' prior: 50362602!
                     handlesMouseStillDown: evt
	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"
	"Acting when down (instead of waiting until releasing the button)
	also means that the button action is repeated if the button is kept pressed"
	^actWhen == #buttonStillDown! !
!DraggeableButtonMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:58' prior: 16841127!
         mouseDown: aMouseEvent
	"Inform the model that this button has been released. "
	super mouseDown: aMouseEvent.
	grabSelector ifNotNil: [
		model perform: grabSelector ]! !
!DraggeableButtonMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:59' prior: 16841135!
                          mouseMove: aMouseEvent
	dragSelector ifNotNil: [
		model perform: dragSelector with: aMouseEvent targetPoint ]! !
!DraggeableButtonMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:59' prior: 16841142!
                    mouseUp: aMouseEvent
	isPressed _ false.
	mouseIsOver _ false.
	actWhen == #buttonUp
		ifTrue: [ self performAction ].
	self redrawNeeded! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/20/2012 17:53' prior: 16914932!
                           doubleClickAndHalf: evt
	"Some subclasses might do something"! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/20/2012 17:53' prior: 16914943!
       keyStroke: aKeyboardEvent

	( self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self closeWindowFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	super keyStroke: aKeyboardEvent.
	(self scrollByKeyboard: aKeyboardEvent)
		ifTrue: [ ^self ].
	scroller keyStroke: aKeyboardEvent! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/20/2012 17:53' prior: 16914955!
         mouseDown: event

	event mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [^ self mouseButton2Activity].
	scroller mouseDown: event.
	event hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:
		dblClkNHalfSel: #doubleClickAndHalf:
		tripleClkSel: nil! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/20/2012 18:14' prior: 16915401!
         mouseMove: evt
	scroller  mouseMove: evt! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/20/2012 17:53' prior: 16914969!
                            mouseUp: evt
	super mouseUp: evt.
	scroller mouseUp: evt! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/20/2012 17:54' prior: 16914974!
            scrollByKeyboard: event
	"If event is ctrl+up/down then scroll and answer true"
	event controlKeyPressed ifFalse: [ ^ false ].
	event keyValue = 30 ifTrue: [
		scrollBar scrollUp: 3.
		^ true ].
	event keyValue = 31 ifTrue: [
		scrollBar scrollDown: 3.
		^ true ].
	^ false.! !
!PluggableScrollPane methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:57' prior: 50363171!
  handlesMouseDown: aMouseButtonEvent
	^ true! !
!PluggableScrollPane methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:57' prior: 16914937!
         handlesMouseOver: evt
	"subclasses implement #mouseEnter: and/or #mouseLeave:"
	^true! !
!HierarchicalListMorph methodsFor: 'commands' stamp: 'jmv 8/20/2012 17:55' prior: 16866522!
           expandAll
	(selectedMorph isNil
		or: [selectedMorph isExpanded])
		ifTrue: [^self].
	self expandAll: selectedMorph.
	scroller adjustExtent.
	self setScrollDeltas! !
!HierarchicalListMorph methodsFor: 'commands' stamp: 'jmv 8/20/2012 17:55' prior: 16866530!
                              expandAll: aMorph
	| allChildren |
	aMorph toggleExpandedState.
	allChildren _ OrderedCollection new: 10.
	aMorph recursiveAddTo: allChildren.
	allChildren do: [:each | 
		(each canExpand and: [each isExpanded not])
			ifTrue: [self expandAll: each]].
! !
!HierarchicalListMorph methodsFor: 'commands' stamp: 'jmv 8/20/2012 17:55' prior: 16866541!
    toggleExpandedState: aMorph event: event
	| oldState |
	"self setSelectedMorph: aMorph."
	event mouseButton2Pressed ifTrue: [
		oldState _ aMorph isExpanded.
		scroller submorphs copy do: [ :each |
			(each canExpand and: [each isExpanded = oldState]) ifTrue: [
				each toggleExpandedState.
			].
		].
	] ifFalse: [
		aMorph toggleExpandedState.
	].
	scroller adjustExtent.
	self setScrollDeltas! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:56' prior: 16866435!
                      keyStroke: aKeyboardEvent 
	"Process potential command keys"

	| args aCharacter |
	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self closeWindowFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self scrollByKeyboard: aKeyboardEvent)
		ifTrue: [ ^self ].
	aCharacter _ aKeyboardEvent keyCharacter.
	(self arrowKey: aCharacter)
		ifTrue: [ ^self ].
	keystrokeActionSelector ifNil: [^self].
	(args _ keystrokeActionSelector numArgs) = 1 
		ifTrue: [^mainView perform: keystrokeActionSelector with: aCharacter].
	args = 2 
		ifTrue: [
			^mainView 
				perform: keystrokeActionSelector
				with: aCharacter
				with: self].
	^self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:55' prior: 50344138!
                           mouseDown: evt

	| aMorph |
	evt hand newKeyboardFocus: self.
	aMorph _ self itemFromPoint: evt eventPosition.
	(aMorph notNil and: [ aMorph inToggleArea: evt eventPosition ])
		ifTrue: [ ^self toggleExpandedState: aMorph event: evt ]. 
	evt mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [ ^ self mouseButton2Activity ].
	aMorph ifNil: [ ^super mouseDown: evt ].
	aMorph highlightForMouseDown.
	evt hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: evt 
		clkSel: #click:
		clkNHalf: nil
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:10' prior: 16866497!
                        mouseEnter: event
	super mouseEnter: event.
	Preferences focusFollowsMouse
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:11' prior: 50344160!
        mouseUp: event 
	| aMorph |
	aMorph := self itemFromPoint: event eventPosition.
	aMorph ifNil: [^self].
	aMorph highlightedForMouseDown ifFalse: [^self].
	aMorph highlightForMouseDown: false.
	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	((autoDeselect isNil or: [autoDeselect]) and: [aMorph == selectedMorph]) 
		ifTrue: [self setSelectedMorph: nil]
		ifFalse: [self setSelectedMorph: aMorph].
	Cursor normal show! !
!HierarchicalListMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:51' prior: 16866407!
          handlesKeyboard

	^self visible! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:41' prior: 50344179!
      doubleClick: aMorphicEvent
	| index |
	doubleClickSelector ifNil: [^super doubleClick: aMorphicEvent].
	index _ self rowAtLocation: aMorphicEvent eventPosition.
	index = 0 ifTrue: [ ^super doubleClick: aMorphicEvent ].
	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."
	^ self model perform: doubleClickSelector! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:56' prior: 16914013!
       keyStroke: aKeyboardEvent 
	"Process keys"
	
	| aCharacter |
	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self closeWindowFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self scrollByKeyboard: aKeyboardEvent) 
		ifTrue: [ ^self ].
	aCharacter _ aKeyboardEvent keyCharacter.
	(self arrowKey: aCharacter)
		ifTrue: [ ^self ].
	aCharacter asciiValue = 27 ifTrue: [	" escape key"
		^ self mouseButton2Activity].
	aKeyboardEvent anyModifierKeyPressed
		ifTrue: [
			(self keystrokeAction: aCharacter)
				ifTrue: [ ^self ]].
	^ self keyboardSearch: aCharacter! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:11' prior: 16914050!
          mouseEnter: event
	super mouseEnter: event.
	Preferences focusFollowsMouse
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!PluggableListMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:53' prior: 16914009!
                           handlesKeyboard

	^self visible! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 8/20/2012 18:06' prior: 50344236!
mouseDown: event

	| oldIndex oldVal row w |
	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].

	self hasKeyboardFocus ifFalse: [
		event hand newKeyboardFocus: self ].

	row _ self rowAtLocation: event eventPosition.

	row = 0 ifTrue: [^super mouseDown: event].

	w _ self ownerThatIsA: SystemWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Set or clear new primary selection (listIndex)"
		dragOnOrOff
			ifTrue: [self changeModelSelection: row]
			ifFalse: [self changeModelSelection: 0].

		"Need to restore the old one, due to how model works, and set new one."
		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
		self listSelectionAt: row put: dragOnOrOff.
		"event hand releaseMouseFocus: aMorph."
		"aMorph changed"
	].
	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 8/20/2012 18:06' prior: 50357415!
  mouseMove: event 
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row b |
	b _ self morphBoundsInWorld.
	row _ (event eventPosition y < b top and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: b topLeft) + 2 ]
		ifFalse: [
			(event eventPosition y > b bottom and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: b bottomLeft) - 3 ]
				ifFalse: [ self rowAtLocation: event eventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 8/20/2012 18:06' prior: 16914729!
                          mouseUp: event

	dragOnOrOff _ nil.  "So improperly started drags will have not effect"
	dragStartRow _ nil! !
!ScrollBar methodsFor: 'events' stamp: 'jmv 8/20/2012 18:07' prior: 16935128!
   mouseDown: aMouseEvent
	"Update visual feedback"
	super mouseDown: aMouseEvent.
	self setNextDirectionFromEvent: aMouseEvent.
	self scrollByPage! !
!ScrollBar methodsFor: 'events' stamp: 'jmv 8/20/2012 18:07' prior: 16935135!
                              mouseStillDown: evt
	self scrollByPage! !
!ScrollBar methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:57' prior: 50363176!
                        handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	^true! !
!ScrollBar methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:57' prior: 16935121!
       handlesMouseStillDown: evt
	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"
	^true! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:42' prior: 16973807!
                        doubleClick: aMorphicEvent
	self textMorph doubleClick: aMorphicEvent! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:12' prior: 16973812!
    doubleClickAndHalf: event
	self textMorph doubleClickAndHalf: event! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 17:57' prior: 50362681!
      keyStroke: aKeyboardEvent
	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self closeWindowFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	self textMorph keyStroke: aKeyboardEvent! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:11' prior: 16973853!
                              mouseEnter: event
	super mouseEnter: event.
	Preferences focusFollowsMouse
		ifTrue: [ event hand newKeyboardFocus: self textMorph ]! !
!TranscriptMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:58' prior: 50363183!
                    handlesMouseDown: aMouseButtonEvent
	^ true! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 19:12' prior: 50365529!
                            sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"

	^ aMorph processWindowEvent: self localPosition: positionInAMorph! !

TextModelMorph removeSelector: #handlesKeyboard!

TextModelMorph removeSelector: #handlesKeyboard!

PluggableListMorph removeSelector: #handleMouseMove:localPosition:!

PluggableListMorph removeSelector: #handleMouseMove:localPosition:!

HierarchicalListMorph removeSelector: #handleMouseMove:localPosition:!

HierarchicalListMorph removeSelector: #handleMouseMove:localPosition:!

MenuItemMorph removeSelector: #handleMouseEnter:localPosition:!

MenuItemMorph removeSelector: #handleMouseEnter:localPosition:!

MenuItemMorph removeSelector: #handleMouseLeave:localPosition:!

MenuItemMorph removeSelector: #handleMouseLeave:localPosition:!

MenuItemMorph removeSelector: #handleMouseUp:localPosition:!

MenuItemMorph removeSelector: #handleMouseUp:localPosition:!

InnerTextMorph removeSelector: #handleKeystroke:localPosition:!

InnerTextMorph removeSelector: #handleKeystroke:localPosition:!

InnerTextMorph removeSelector: #handleMouseMove:localPosition:!

InnerTextMorph removeSelector: #handleMouseMove:localPosition:!

HaloHandleMorph removeSelector: #handleMouseDown:localPosition:!

HaloHandleMorph removeSelector: #handleMouseDown:localPosition:!

HaloHandleMorph removeSelector: #handleMouseMove:localPosition:!

HaloHandleMorph removeSelector: #handleMouseMove:localPosition:!

HaloHandleMorph removeSelector: #handleMouseUp:localPosition:!

HaloHandleMorph removeSelector: #handleMouseUp:localPosition:!

HaloHandleMorph removeSelector: #handlesKeyboard!

HaloHandleMorph removeSelector: #handlesKeyboard!

HaloHandleMorph removeSelector: #handlesMouseOver:!

HaloHandleMorph removeSelector: #handlesMouseOver:!

Morph removeSelector: #handleDropMorph:localPosition:!

Morph removeSelector: #handleDropMorph:localPosition:!

Morph removeSelector: #handleKeyDown:localPosition:!

Morph removeSelector: #handleKeyDown:localPosition:!

Morph removeSelector: #handleKeyUp:localPosition:!

Morph removeSelector: #handleKeyUp:localPosition:!

Morph removeSelector: #handleKeystroke:localPosition:!

Morph removeSelector: #handleKeystroke:localPosition:!

Morph removeSelector: #handleMouseDown:localPosition:!

Morph removeSelector: #handleMouseDown:localPosition:!

Morph removeSelector: #handleMouseEnter:localPosition:!

Morph removeSelector: #handleMouseEnter:localPosition:!

Morph removeSelector: #handleMouseLeave:localPosition:!

Morph removeSelector: #handleMouseLeave:localPosition:!

Morph removeSelector: #handleMouseMove:localPosition:!

Morph removeSelector: #handleMouseMove:localPosition:!

Morph removeSelector: #handleMouseOver:localPosition:!

Morph removeSelector: #handleMouseOver:localPosition:!

Morph removeSelector: #handleMouseStillDown:localPosition:!

Morph removeSelector: #handleMouseStillDown:localPosition:!

Morph removeSelector: #handleMouseUp:localPosition:!

Morph removeSelector: #handleMouseUp:localPosition:!

Morph removeSelector: #handleUnknownEvent:localPosition:!

Morph removeSelector: #handleUnknownEvent:localPosition:!

Morph removeSelector: #handleWindowEvent:localPosition:!

Morph removeSelector: #handleWindowEvent:localPosition:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1381-LocalPositionInEvents-JuanVuletich-2012Aug20-18h45m-jmv.5.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1380] on 20 August 2012 at 8:28:59 pm'!
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 20:07'!
                    startDropEventDispatch: aDropEvent

	owner dispatchEvent: aDropEvent localPosition: aDropEvent eventPosition.
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 20:24'!
              startKeyboardDispatch: aKeyboardEvent

	self keyboardFocus ifNotNil: [
		keyboardFocus handleFocusEvent: aKeyboardEvent ].
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 20:28'!
 startMouseDispatch: aMouseEvent

	aMouseEvent isMouseOver ifTrue: [
		^self mouseFocus
			ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
			ifNil: [ owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition ]].

	"any mouse event but mouseOver"
	lastMouseEvent _ aMouseEvent.	
	lastMouseEventTime _ Time millisecondClockValue.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	aMouseEvent isMove
		ifTrue: [
			self morphPosition: aMouseEvent eventPosition.
			self mouseFocus
				ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
				ifNil: [ owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition ]
		] ifFalse: [
			"Issue a synthetic move event if we're not at the position of the event"
			aMouseEvent eventPosition = self morphPosition ifFalse: [
				"Issue a mouse move event to make the receiver appear at the given position"
				self startMouseDispatch: (MouseMoveEvent new
					setType: #mouseMove
					position: aMouseEvent eventPosition
					buttons: aMouseEvent buttons
					hand: self
					stamp: aMouseEvent timeStamp) ].
			"Drop submorphs on button events"
			self hasSubmorphs
				ifTrue: [ self dropMorphs: aMouseEvent ]
				ifFalse: [
					self mouseFocus
						ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
						ifNil: [ owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition ]]].
		self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 20:08'!
startWindowEventDispatch: aWindowEvent

	owner dispatchEvent: aWindowEvent localPosition: aWindowEvent eventPosition.
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 20:10'!
         startDispatchFrom: aHand
	"double dispatch the event dispatch"
	"An event of an unknown type was sent. What shall we do?!!"

	Beeper beep. 
	self printString displayAt: 0@0.
	self wasHandled: true! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 20:10'!
                     startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startDropEventDispatch: self! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 20:09'!
                  startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startKeyboardDispatch: self! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 20:28'!
                      startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startMouseDispatch: self! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/20/2012 20:09'!
                        startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startWindowEventDispatch: self! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 20:10' prior: 50365114!
                              startEventDispatch: aMorphicEvent

	owner ifNil: [ ^ self ].
	aMorphicEvent startDispatchFrom: self! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 8/20/2012 20:23' prior: 16865072!
   keyboardFocus

	keyboardFocus ifNotNil: [
		keyboardFocus world
			ifNil: [ keyboardFocus _ nil ]].
	^ keyboardFocus! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 8/20/2012 20:24' prior: 16865090!
                  mouseFocus

	mouseFocus ifNotNil: [
		mouseFocus world
			ifNil: [ mouseFocus _ nil ]].
	^mouseFocus! !

PasteUpMorph removeSelector: #becomeActiveDuring:!

PasteUpMorph removeSelector: #becomeActiveDuring:!

HandMorph removeSelector: #sendFocusEvent:to:in:!

HandMorph removeSelector: #sendFocusEvent:to:in:!

HandMorph removeSelector: #sendKeyboardEvent:!

HandMorph removeSelector: #sendKeyboardEvent:!

HandMorph removeSelector: #sendMouseEvent:!

HandMorph removeSelector: #sendMouseEvent:!

HandMorph removeSelector: #startMouseOverDispatch:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1382-EventDispatchRefactor-JuanVuletich-2012Aug20-19h37m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1382] on 21 August 2012 at 8:40:11 am'!
!Morph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:10'!
             click: aMouseButtonEvent localPosition: localEventPosition
	"Handle a single-click event. This message is only sent to clients that request it by sending one of the #waitForClicksOrDrag:... messages to the initiating hand in their mouseDown: method. This default implementation does nothing."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:07'!
                              doubleClick: aMouseButtonEvent localPosition: localEventPosition
	"Handle a double-click event. This message is only sent to clients that request it by sending one of the #waitForClicksOrDrag:... messages to the initiating hand in their mouseDown: method. This default implementation does nothing."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:25'!
                        mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition
	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."
	| h doNotDrag |
	h _ aMouseButtonEvent hand halo.
	"Prevent wrap around halo transfers originating from throwing the event back in"
	doNotDrag _ false.
	h ifNotNil:[
		(h target == self) ifTrue: [ doNotDrag _ true].
		(h target hasOwner: self) ifTrue: [ doNotDrag _ true].
		(self hasOwner: h target) ifTrue: [ doNotDrag _ true]].

	"cmd-drag on flexed morphs works better this way"
	h _ self addHalo: aMouseButtonEvent.
	doNotDrag ifTrue: [ ^self ].
	"Initiate drag transition if requested"
	aMouseButtonEvent hand 
		waitForClicksOrDrag: h
		event: aMouseButtonEvent
		clkSel: nil
		dblClkSel: nil.
	"Pass focus explicitly here"
	aMouseButtonEvent hand newMouseFocus: h.! !
!Morph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:25'!
                               mouseButton3Up: aMouseButtonEvent localPosition: localEventPosition
	"Ignored. Theoretically we should never get here since control is transferred to the halo on #mouseButton3Down: but subclasses may implement this differently."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/21/2012 07:56'!
                              mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse down event."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:14'!
      mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Handle a mouse move event."! !
!Morph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:19'!
        mouseUp: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event."! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:17'!
                             mouseUp: aMouseButtonEvent localPosition: localEventPosition
	(self containsPoint: aMouseButtonEvent eventPosition)
		ifTrue: [
			self selected: 
				((aMouseButtonEvent eventPosition y - self morphPositionInWorld y // self class itemHeight) + 
					self firstVisible).
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!FillInTheBlankMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 07:55'!
                       mouseDown: aMouseButtonEvent localPosition: localEventPosition

	(self containsPoint: aMouseButtonEvent eventPosition) ifFalse: [
		^ Beeper beep]. "sent in response to outside modal click"
	aMouseButtonEvent hand grabMorph: self. "allow repositioning"! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:25'!
  mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition
	"Transfer the halo to the next likely recipient"
	target ifNil:[^self delete].
	aMouseButtonEvent hand obtainHalo: self.
	positionOffset _ aMouseButtonEvent eventPosition - target morphPosition.
	"wait for drags or transfer"
	aMouseButtonEvent hand 
		waitForClicksOrDrag: self 
		event: aMouseButtonEvent
		clkSel: #transferHalo:
		dblClkSel: nil! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:13'!
                            mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Drag our target around"
	| thePoint |
	thePoint _ aMouseMoveEvent eventPosition - positionOffset.
	target morphPosition: thePoint! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:01'!
                         clickAndHalf: aMouseButtonEvent localPosition: localEventPosition
	self handleInteraction: [
		editor clickAndHalf: (aMouseButtonEvent ztranslatedBy: self morphPositionInWorld negated) localPosition: localEventPosition ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:05'!
                             doubleClickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	self handleInteraction: [
		editor doubleClickAndHalf: (aMouseButtonEvent ztranslatedBy: self morphPositionInWorld negated) localPosition: localEventPosition ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:06'!
                mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	aMouseButtonEvent mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].

	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"
	self hasKeyboardFocus ifFalse: [
		^aMouseButtonEvent hand newKeyboardFocus: self].

	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.

	self handleInteraction: [ editor mouseDown: (aMouseButtonEvent ztranslatedBy: self morphPositionInWorld negated) localPosition: localEventPosition ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:localPosition:
		tripleClkSel: nil! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:16'!
                      mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent mouseButton1Pressed ifFalse: [ ^ self enterClickableRegion: aMouseMoveEvent ].
	self handleInteraction: [ editor mouseMove: (aMouseMoveEvent ztranslatedBy: self morphPositionInWorld negated) localPosition: localEventPosition].
	(aMouseMoveEvent eventPosition y - owner morphPositionInWorld y between: 0 and: owner morphExtentInWorld y) ifFalse: [
		owner scrollSelectionIntoView ]! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:18'!
              mouseUp: aMouseButtonEvent localPosition: localEventPosition

	super mouseUp: aMouseButtonEvent localPosition: localEventPosition.
	self pauseBlinking.
	self handleInteraction: [editor mouseUp: (aMouseButtonEvent ztranslatedBy: self morphPositionInWorld negated) localPosition: localEventPosition].
	owner scrollSelectionIntoView! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 07:55'!
          mouseDown: aMouseButtonEvent localPosition: localEventPosition

	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	self cursor show.
	hand _ aMouseButtonEvent hand.
	self startStepping.
	Preferences fastDragWindowForMorphic ifTrue: [
		indicator _ RectangleIndicatorMorph new.
		indicator morphBoundsInWorld: self initialIndicatorBounds.
		indicator openInWorld ]! !
!MagnifierMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 07:55'!
                         mouseDown: aMouseButtonEvent localPosition: localEventPosition

	aMouseButtonEvent mouseButton2Pressed
		ifTrue: [ self chooseMagnification: aMouseButtonEvent ]
		ifFalse: [ super mouseDown: aMouseButtonEvent localPosition: localEventPosition ]! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 07:56'!
      mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse down event. Menu items get activated when the mouse is over them."

	aMouseButtonEvent shiftPressed ifTrue: [ ^ super mouseDown: aMouseButtonEvent localPosition: localEventPosition ].  "enable label editing" 
	aMouseButtonEvent hand newMouseFocus: owner. "Redirect to menu for valid transitions"
	owner selectItem: self event: aMouseButtonEvent! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:18'!
                  mouseUp: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event. Menu items get activated when the mouse is over them. Do nothing if we're not in a 'valid menu transition', meaning that the current hand focus must be aimed at the owning menu."
	aMouseButtonEvent hand mouseFocus == owner ifFalse: [ ^self ].
	"This will happen if the menu has toggles in it. (for instance, the 'show...' button)
	Update the look, refresh the world and wait a bit,
	to give the user some visual feedback"
	self contentString ifNotNil: [
		self contents: self contentString withMarkers: true inverse: true.
		self refreshWorld.
		(Delay forMilliseconds: 200) wait].
	self deselect: aMouseButtonEvent.
	self invokeWithEvent: aMouseButtonEvent! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 07:56'!
                     mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse down event."
	(stayUp or: [ self fullContainsPoint: aMouseButtonEvent eventPosition ]) 
		ifFalse: [ ^self deleteIfPopUp: aMouseButtonEvent ]. "click outside"
	self isSticky ifTrue: [ ^self ].
	"Grab the menu and drag it to some other place"
	aMouseButtonEvent hand grabMorph: self! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:19'!
                     mouseUp: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event.
	Note: This might be sent from a modal shell."
	(self fullContainsPoint: aMouseButtonEvent eventPosition) ifFalse:[
		"Mouse up outside. Release eventual focus and delete if pop up."
		aMouseButtonEvent hand releaseMouseFocus: self.
		^ self deleteIfPopUp: aMouseButtonEvent ].
	stayUp ifFalse:[
		"Still in pop-up transition; keep focus"
		aMouseButtonEvent hand newMouseFocus: self ]! !
!MouseClickState methodsFor: 'private' stamp: 'jmv 8/21/2012 08:35'!
                              lastClickLocalPosition

	^clickClient internalizeFromWorld: lastClickDown eventPosition! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:02'!
                              clickAndHalf: aMouseButtonEvent localPosition: localEventPosition
	self handleInteraction: [ self editor clickAndHalf: aMouseButtonEvent localPosition: localEventPosition ]! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:03'!
         mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	aMouseButtonEvent hand newKeyboardFocus: self.

	self handleInteraction: [
		self editor mouseDown: aMouseButtonEvent index: (self characterIndexAtPoint: aMouseButtonEvent eventPosition) ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:15'!
         mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent mouseButton1Pressed ifFalse: [ ^ self ].
	self handleInteraction: [
		self editor mouseMove: aMouseMoveEvent index: (self characterIndexAtPoint: aMouseMoveEvent eventPosition) ]! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:19'!
                     mouseUp: aMouseButtonEvent localPosition: localEventPosition

	super mouseUp: aMouseButtonEvent localPosition: localEventPosition.
	self pauseBlinking
! !
!PasteUpMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:10'!
    click: aMouseButtonEvent localPosition: localEventPosition

	^self mouseButton2Activity! !
!PasteUpMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:10'!
    mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse down event."

	| grabbedMorph |
	grabbedMorph _ self morphToGrab: aMouseButtonEvent.
	grabbedMorph ifNotNil: [
		grabbedMorph isSticky ifTrue: [ ^self ].
		^aMouseButtonEvent hand grabMorph: grabbedMorph].

	aMouseButtonEvent mouseButton2Pressed ifTrue: [ ^self mouseButton2Activity ].

	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:08'!
                   mouseDown: aMouseButtonEvent localPosition: localEventPosition

	aMouseButtonEvent mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].
	isPressed _ true.
	self redrawNeeded.
	(actWhen == #buttonDown or: [ actWhen == #buttonStillDown ])
		ifTrue: [
			self performAction ]
		ifFalse: [
			"Don't make multi-click slower if we act on button down, just do multiple actions"
			aMouseButtonEvent hand
				waitForClicksOrDragOrSimulatedMouseButton2: self
				event: aMouseButtonEvent
				clkSel: nil
				clkNHalf: nil
				dblClkSel: #doubleClick:localPosition:
				dblClkNHalfSel: nil
				tripleClkSel: nil ]! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:19'!
               mouseUp: aMouseButtonEvent localPosition: localEventPosition

	isPressed _ false.
	mouseIsOver _ false.
	(actWhen == #buttonUp and: [self containsPoint: aMouseButtonEvent eventPosition])
		ifTrue: [ self performAction ].
	self redrawNeeded! !
!DraggeableButtonMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 07:55'!
   mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Inform the model that this button has been released. "
	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	grabSelector ifNotNil: [
		model perform: grabSelector ]! !
!DraggeableButtonMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:13'!
                          mouseMove: aMouseMoveEvent localPosition: localEventPosition

	dragSelector ifNotNil: [
		model perform: dragSelector with: aMouseMoveEvent targetPoint ]! !
!DraggeableButtonMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:17'!
                         mouseUp: aMouseButtonEvent localPosition: localEventPosition
	isPressed _ false.
	mouseIsOver _ false.
	actWhen == #buttonUp
		ifTrue: [ self performAction ].
	self redrawNeeded! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/21/2012 08:05'!
   doubleClickAndHalf: aMouseButtonEvent localPosition: localEventPosition
	"Some subclasses might do something"! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/21/2012 08:09'!
       mouseDown: aMouseButtonEvent localPosition: localEventPosition

	aMouseButtonEvent mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [^ self mouseButton2Activity].
	scroller mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: #doubleClickAndHalf:localPosition:
		tripleClkSel: nil! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/21/2012 08:16'!
                             mouseMove: aMouseMoveEvent localPosition: localEventPosition

	scroller  mouseMove: aMouseMoveEvent localPosition: localEventPosition! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 8/21/2012 08:21'!
               mouseUp: aMouseButtonEvent localPosition: localEventPosition

	super mouseUp: aMouseButtonEvent localPosition: localEventPosition.
	scroller mouseUp: aMouseButtonEvent localPosition: localEventPosition! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:10'!
         mouseDown: aMouseButtonEvent localPosition: localEventPosition

	| aMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	aMorph _ self itemFromPoint: aMouseButtonEvent eventPosition.
	(aMorph notNil and: [ aMorph inToggleArea: aMouseButtonEvent eventPosition ])
		ifTrue: [ ^self toggleExpandedState: aMorph event: aMouseButtonEvent ]. 
	aMouseButtonEvent mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [ ^ self mouseButton2Activity ].
	aMorph ifNil: [ ^super mouseDown: aMouseButtonEvent localPosition: localEventPosition ].
	aMorph highlightForMouseDown.
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:17'!
                        mouseUp: aMouseButtonEvent localPosition: localEventPosition
	| aMorph |
	aMorph _ self itemFromPoint: aMouseButtonEvent eventPosition.
	aMorph ifNil: [^self].
	aMorph highlightedForMouseDown ifFalse: [^self].
	aMorph highlightForMouseDown: false.
	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	((autoDeselect isNil or: [autoDeselect]) and: [aMorph == selectedMorph]) 
		ifTrue: [self setSelectedMorph: nil]
		ifFalse: [self setSelectedMorph: aMorph].
	Cursor normal show! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:08'!
                     doubleClick: aMouseButtonEvent localPosition: localEventPosition
	| index |
	doubleClickSelector ifNil: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	index _ self rowAtLocation: aMouseButtonEvent eventPosition.
	index = 0 ifTrue: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."
	^ self model perform: doubleClickSelector! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:10'!
                               mouseDown: aMouseButtonEvent localPosition: localEventPosition

	| row |
	aMouseButtonEvent mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [ ^ self mouseButton2Activity ].
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self.
		"If we are focusing, deselect, so that later selection doesn't result in deselect."
		self listMorph noSelection].
	row _ self rowAtLocation: aMouseButtonEvent eventPosition.
	row = 0  ifTrue: [ ^super mouseDown: aMouseButtonEvent localPosition: localEventPosition ].
	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:20'!
         mouseUp: aMouseButtonEvent localPosition: localEventPosition
	"The mouse came up within the list; take appropriate action"

	| row |
	row _ self rowAtLocation: aMouseButtonEvent eventPosition.
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	(autoDeselect == false and: [row = 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"
	"No change if model is locked"
	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])
		ifTrue: [self changeModelSelection: 0]
		ifFalse: [self changeModelSelection: row].
	Cursor normal show.
! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 8/21/2012 08:08'!
mouseDown: aMouseButtonEvent localPosition: localEventPosition

	| oldIndex oldVal row w |
	aMouseButtonEvent mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].

	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self ].

	row _ self rowAtLocation: aMouseButtonEvent eventPosition.

	row = 0 ifTrue: [ ^super mouseDown: aMouseButtonEvent localPosition: localEventPosition ].

	w _ self ownerThatIsA: SystemWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Set or clear new primary selection (listIndex)"
		dragOnOrOff
			ifTrue: [self changeModelSelection: row]
			ifFalse: [self changeModelSelection: 0].

		"Need to restore the old one, due to how model works, and set new one."
		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
		self listSelectionAt: row put: dragOnOrOff.
		"event hand releaseMouseFocus: aMorph."
		"aMorph changed"
	].
	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 8/21/2012 08:15'!
        mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row b |
	b _ self morphBoundsInWorld.
	row _ (aMouseMoveEvent eventPosition y < b top and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: b topLeft) + 2 ]
		ifFalse: [
			(aMouseMoveEvent eventPosition y > b bottom and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: b bottomLeft) - 3 ]
				ifFalse: [ self rowAtLocation: aMouseMoveEvent eventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 8/21/2012 08:20'!
 mouseUp: aMouseButtonEvent localPosition: localEventPosition

	dragOnOrOff _ nil.  "So improperly started drags will have not effect"
	dragStartRow _ nil! !
!ScrollBar methodsFor: 'events' stamp: 'jmv 8/21/2012 07:59'!
     mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Update visual feedback"

	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	self setNextDirectionFromEvent: aMouseButtonEvent.
	self scrollByPage! !
!SimpleEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:01'!
                    clickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	| here |
	here _ self pointIndex.
	(here between: 2 and: string size)
		ifTrue: [ self selectWord ]
		ifFalse: [
			"if at beginning or end, select entire string"
			self selectAll ].! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:01'!
  clickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	self selectWord.

	doWordSelection _ true.
	doParagraphSelection _ false.
	initialSelectionStart _ self startBlock.
	initialSelectionStop _ self stopBlock! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:05'!
                               doubleClickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	| here b interval |
	b _ paragraph characterBlockAtPoint: aMouseButtonEvent eventPosition.
	here _ b stringIndex.
	interval _ self privateCurrentString encompassParagraph: (here to: here).
	self selectFrom: interval first to: interval last.

	doWordSelection _ false.
	doParagraphSelection _ true.
	initialSelectionStart _ self startBlock.
	initialSelectionStop _ self stopBlock! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:00'!
                         mouseDown: aMouseButtonEvent localPosition: localEventPosition
	| clickPoint b |

	initialSelectionStart _ nil.
	initialSelectionStop _ nil.
	doWordSelection _ false.
	doParagraphSelection _ false.

	"Multiple selection of text.
	Windows uses Control, Mac uses Command (i.e. commandAlt)
	On the Mac, command-button1 is translated to command-button3 by the VM. do:
		Preferences disable: #commandClickOpensHalo
	to disable this behavior and make command-button1 work for multiple selection. "
	(aMouseButtonEvent controlKeyPressed or: [ aMouseButtonEvent commandAltKeyPressed ]) ifTrue: [
		self selectionInterval size > 0 ifTrue: [
			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.
			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]
	ifFalse: [
		selectionStartBlocks _ #().
		selectionStopBlocks _ #() ].

	clickPoint _ aMouseButtonEvent eventPosition.
	b _ paragraph characterBlockAtPoint: clickPoint.

	(paragraph clickAt: clickPoint) ifTrue: [
		markBlock _ b.
		pointBlock _ b.
		aMouseButtonEvent hand releaseKeyboardFocus: self.
		^ self ].
	
	aMouseButtonEvent shiftPressed
		ifFalse: [
			(self markIndex = b stringIndex and: [ self pointIndex = b stringIndex ])
				ifTrue: [
					markBlock _ b.
					pointBlock _ b ]
				ifFalse: [
					markBlock _ b.
					pointBlock _ b.	
					self setEmphasisHereFromText ]]! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:15'!
      mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Change the selection in response to mouse-down drag"

	| b interval i1 i2 |

	doWordSelection ifTrue: [
		pointBlock _ (paragraph characterBlockAtPoint: (aMouseMoveEvent eventPosition)).
		self selectWordLeftDelimiters: '' rightDelimiters: ''.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	doParagraphSelection ifTrue: [
		b _ paragraph characterBlockAtPoint: aMouseMoveEvent eventPosition.
		i1 _ b stringIndex min: initialSelectionStart stringIndex.
		i2 _ b stringIndex max: initialSelectionStop stringIndex-1.
		interval _ self privateCurrentString encompassParagraph: (i1 to: i2).
		self selectFrom: interval first to: interval last.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	pointBlock _ (paragraph characterBlockAtPoint: (aMouseMoveEvent eventPosition)).
	self storeSelectionInParagraph! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:20'!
                         mouseUp: aMouseButtonEvent localPosition: localEventPosition
	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |

	aMouseButtonEvent shiftPressed
		ifTrue: [
			"Squeak classic behavior for click, move, shift-click sequence "
			"pointBlock _(paragraph characterBlockAtPoint: (evt eventPosition))."

			"Mac behavior"
			cursorBlock _ paragraph characterBlockAtPoint: aMouseButtonEvent eventPosition.
			cursorIndex _ cursorBlock stringIndex.
			startBlock _ self startBlock min: cursorBlock.
			startIndex _ startBlock stringIndex.
			stopBlock _ self stopBlock max: cursorBlock.
			stopIndex _ stopBlock stringIndex.
			(stopIndex - cursorIndex) < (cursorIndex - startIndex)
				ifTrue: [
					markBlock _ startBlock.
					pointBlock _ cursorBlock ]
				ifFalse: [
					markBlock _ stopBlock.
					pointBlock _ cursorBlock ]].
	self storeSelectionInParagraph! !
!SmalltalkEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:03'!
         clickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	| here |
	here _ self pointIndex.
	(here between: 2 and: model textSize)
		ifTrue: [
			super clickAndHalf: aMouseButtonEvent localPosition: localEventPosition ]
		ifFalse: [
			"if at beginning or end, select entire string"
			self selectAll ]! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:09'!
 doubleClick: aMouseButtonEvent localPosition: localEventPosition

	self textMorph doubleClick: aMouseButtonEvent localPosition: localEventPosition! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:06'!
       doubleClickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	self textMorph doubleClickAndHalf: aMouseButtonEvent localPosition: localEventPosition! !
!TranscriptMorph methodsFor: 'menus' stamp: 'jmv 8/21/2012 08:00'!
                         mouseDown: aMouseButtonEvent localPosition: localEventPosition

	"Invoke the menu"
	aMouseButtonEvent mouseButton2Pressed ifTrue: [
		self getMenu ifNotNil: [ :menu |
			menu invokeModal ].
		^self ].

	super mouseDown: aMouseButtonEvent localPosition: localEventPosition! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/21/2012 08:25' prior: 50365662!
                        processMouseDown: aMouseButtonEvent localPosition: localEventPosition
	"System level event handling."
	aMouseButtonEvent wasHandled ifTrue: [ ^self ]. "not interested"
	aMouseButtonEvent hand removePendingBalloonFor: self.
	aMouseButtonEvent wasHandled: true.
	self activateWindow.

	"Make me modal during mouse transitions"
	aMouseButtonEvent hand newMouseFocus: self event: aMouseButtonEvent.
	aMouseButtonEvent mouseButton3Changed ifTrue: [ ^self mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition ].

	self mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.

	(self handlesMouseStillDown: aMouseButtonEvent) ifTrue:[
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue + self mouseStillDownThreshold
			arguments: {aMouseButtonEvent copy resetHandlerFields . localEventPosition}
			stepTime: self mouseStillDownStepRate ].
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/21/2012 08:16' prior: 50365715!
                         processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"System level event handling."

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	"Rules say that by default a morph gets #mouseMove iff
		* the hand is not dragging anything,
			+ and some button is down,
			+ and the receiver is the current mouse focus."
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	(aMouseMoveEvent anyButtonPressed and: [ aMouseMoveEvent hand mouseFocus == self ]) ifFalse: [^self].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {aMouseMoveEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/21/2012 08:26' prior: 50365775!
                            processMouseUp: aMouseButtonEvent localPosition: localEventPosition
	"System level event handling."

	aMouseButtonEvent wasHandled ifTrue: [^self]. "not interested"
	aMouseButtonEvent hand mouseFocus == self ifFalse: [^self]. "Not interested in other parties"
	aMouseButtonEvent hand releaseMouseFocus: self.
	aMouseButtonEvent wasHandled: true.
	aMouseButtonEvent mouseButton3Changed
		ifTrue: [ self mouseButton3Up: aMouseButtonEvent localPosition: localEventPosition ]
		ifFalse: [
			self mouseUp: aMouseButtonEvent localPosition: localEventPosition.
			self stopSteppingSelector: #processMouseStillDown:localPosition: ]! !
!InnerTextMorph methodsFor: 'events-processing' stamp: 'jmv 8/21/2012 08:16' prior: 50365858!
              processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Re-implemented to allow for mouse-up move events"

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(aMouseMoveEvent anyButtonPressed and: [ aMouseMoveEvent hand mouseFocus == self ]) ifFalse: [ ^self ].
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {aMouseMoveEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 8/21/2012 08:26' prior: 50365912!
               processMouseUp: aMouseButtonEvent localPosition: localEventPosition
	"The handling of control between menu item requires them to act on mouse up even if not the current focus. This is different from the default behavior which really only wants to handle mouse ups when they got mouse downs before"

	aMouseButtonEvent wasHandled ifTrue:[^self]. "not interested"
	aMouseButtonEvent hand releaseMouseFocus: self.
	aMouseButtonEvent wasHandled: true.
	aMouseButtonEvent mouseButton3Changed
		ifTrue: [ self mouseButton3Up: aMouseButtonEvent localPosition: localEventPosition ]
		ifFalse: [ self mouseUp: aMouseButtonEvent localPosition: localEventPosition ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 8/21/2012 08:36' prior: 16887720!
                               selectItem: aMenuItem event: anEvent
	selectedItem ifNotNil: [ selectedItem deselect: anEvent ].
	selectedItem _ aMenuItem.
	selectedItem ifNotNil: [ selectedItem select: anEvent ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:35' prior: 16900908!
                   click

	clickDone ifFalse: [
		clickSelector ifNotNil: [
			clickClient perform: clickSelector with: lastClickDown with: self lastClickLocalPosition ].
		clickDone _ true ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:35' prior: 16900915!
                           clickAndAHalf

	clickAndHalfDone ifFalse: [
		clickAndHalfSelector ifNotNil: [
			"Focus was lost at buttonUp. Set it again."
			lastClickDown hand newMouseFocus: clickClient event: lastClickDown.
			clickClient perform: clickAndHalfSelector with: lastClickDown with: self lastClickLocalPosition ].
		clickAndHalfDone _ true ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:35' prior: 16900927!
 doubleClick

	doubleClickDone ifFalse: [
		dblClickSelector ifNotNil: [
			clickClient perform: dblClickSelector with: lastClickDown with: self lastClickLocalPosition ].
		doubleClickDone _ true ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:35' prior: 16900935!
   doubleClickAndHalf

	doubleClickAndHalfDone ifFalse: [
		dblClickAndHalfSelector ifNotNil: [
			"Focus was lost at buttonUp. Set it again."
			lastClickDown hand newMouseFocus: clickClient event: lastClickDown.
			clickClient perform: dblClickAndHalfSelector with: lastClickDown with: self lastClickLocalPosition ].
		doubleClickAndHalfDone _ true ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:29' prior: 50343902!
          handleEvent: aMouseEvent from: aHand
	"Process the given mouse event to detect a click, double-click, or drag.
	Return true if the event should be processed by the sender, false if it shouldn't.
	NOTE: This method heavily relies on getting *all* mouse button events."

	| timedOut distance |
	timedOut _ (aMouseEvent timeStamp - lastClickDown timeStamp) > DoubleClickTimeout.
	distance _ (aMouseEvent eventPosition - lastClickDown eventPosition) r.
	"Real action dispatch might be done after the triggering event, for example, because of waiting for timeout.
	So, count the button downs and ups(clicks), to be processed, maybe later, maybe in a mouseMove..."
	aMouseEvent isMouseDown ifTrue: [
		lastClickDown _ aMouseEvent.
		buttonDownCount _ buttonDownCount + 1 ].
	aMouseEvent isMouseUp ifTrue: [
		buttonUpCount _ buttonUpCount + 1 ].

	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."
	(buttonDownCount = 1 and: [ buttonUpCount = 0]) ifTrue: [
		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [
			aHand dontWaitForMoreClicks.
			clickClient mouseButton2Activity.
			^ false ].
		"If we have already moved, then it won't be a double or triple click... why wait?"
		distance > 0 ifTrue: [
			aHand dontWaitForMoreClicks.
			self click.
			^ false ]].

	"If we're over triple click, or timed out, or mouse moved, don't allow more clicks."
	(buttonDownCount = 4 or: [ timedOut or: [ distance > 0 ]]) ifTrue: [
		aHand dontWaitForMoreClicks.
		^ false ].

	"Simple click."
	(buttonDownCount = 1 and: [ buttonUpCount = 1 ]) ifTrue: [
		self click ].

	"Click & hold"
	(buttonDownCount = 2 and: [ buttonUpCount = 1]) ifTrue: [
		self clickAndAHalf ].

	"Double click."
	(buttonDownCount = 2 and: [ buttonUpCount = 2]) ifTrue: [
		self doubleClick ].

	"Double click & hold."
	(buttonDownCount = 3 and: [ buttonUpCount = 2]) ifTrue: [
		self doubleClickAndHalf ].

	"Triple click"
	(buttonDownCount = 3 and: [ buttonUpCount = 3]) ifTrue: [
		self tripleClick ].

	"This means: if a mouseDown, then don't further process this event (so we can turn it into a double or triple click on next buttonUp)"
	^ aMouseEvent isMouseDown! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:35' prior: 16901018!
  tripleClick

	tripleClickSelector ifNotNil: [
		clickClient perform: tripleClickSelector with: lastClickDown with: self lastClickLocalPosition]! !
!HierarchicalListMorph methodsFor: 'events-processing' stamp: 'jmv 8/21/2012 08:16' prior: 50365934!
        processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	(aMouseMoveEvent anyButtonPressed and: [ aMouseMoveEvent hand mouseFocus == self]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {aMouseMoveEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!PluggableListMorph methodsFor: 'events-processing' stamp: 'jmv 8/21/2012 08:16' prior: 50365958!
   processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	(aMouseMoveEvent anyButtonPressed and: [ aMouseMoveEvent hand mouseFocus == self ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {aMouseMoveEvent copy resetHandlerFields . localEventPosition }
			stepTime: 1].
! !

TranscriptMorph removeSelector: #mouseDown:!

TranscriptMorph removeSelector: #mouseDown:!

TextModelMorph removeSelector: #doubleClick:!

TextModelMorph removeSelector: #doubleClick:!

TextModelMorph removeSelector: #doubleClickAndHalf:!

TextModelMorph removeSelector: #doubleClickAndHalf:!

SmalltalkEditor removeSelector: #clickAndHalf:!

SmalltalkEditor removeSelector: #clickAndHalf:!

TextEditor removeSelector: #clickAndHalf:!

TextEditor removeSelector: #clickAndHalf:!

TextEditor removeSelector: #doubleClickAndHalf:!

TextEditor removeSelector: #doubleClickAndHalf:!

TextEditor removeSelector: #mouseDown:!

TextEditor removeSelector: #mouseDown:!

TextEditor removeSelector: #mouseMove:!

TextEditor removeSelector: #mouseMove:!

TextEditor removeSelector: #mouseUp:!

TextEditor removeSelector: #mouseUp:!

SimpleEditor removeSelector: #clickAndHalf:!

SimpleEditor removeSelector: #clickAndHalf:!

ScrollBar removeSelector: #mouseDown:!

ScrollBar removeSelector: #mouseDown:!

PluggableListMorphOfMany removeSelector: #mouseDown:!

PluggableListMorphOfMany removeSelector: #mouseDown:!

PluggableListMorphOfMany removeSelector: #mouseMove:!

PluggableListMorphOfMany removeSelector: #mouseMove:!

PluggableListMorphOfMany removeSelector: #mouseUp:!

PluggableListMorphOfMany removeSelector: #mouseUp:!

PluggableListMorph removeSelector: #doubleClick:!

PluggableListMorph removeSelector: #doubleClick:!

PluggableListMorph removeSelector: #mouseDown:!

PluggableListMorph removeSelector: #mouseDown:!

PluggableListMorph removeSelector: #mouseUp:!

PluggableListMorph removeSelector: #mouseUp:!

HierarchicalListMorph removeSelector: #mouseDown:!

HierarchicalListMorph removeSelector: #mouseDown:!

HierarchicalListMorph removeSelector: #mouseUp:!

HierarchicalListMorph removeSelector: #mouseUp:!

PluggableScrollPane removeSelector: #doubleClickAndHalf:!

PluggableScrollPane removeSelector: #doubleClickAndHalf:!

PluggableScrollPane removeSelector: #mouseDown:!

PluggableScrollPane removeSelector: #mouseDown:!

PluggableScrollPane removeSelector: #mouseMove:!

PluggableScrollPane removeSelector: #mouseMove:!

PluggableScrollPane removeSelector: #mouseUp:!

PluggableScrollPane removeSelector: #mouseUp:!

DraggeableButtonMorph removeSelector: #mouseDown:!

DraggeableButtonMorph removeSelector: #mouseDown:!

DraggeableButtonMorph removeSelector: #mouseMove:!

DraggeableButtonMorph removeSelector: #mouseMove:!

DraggeableButtonMorph removeSelector: #mouseUp:!

DraggeableButtonMorph removeSelector: #mouseUp:!

PluggableButtonMorph removeSelector: #mouseDown:!

PluggableButtonMorph removeSelector: #mouseDown:!

PluggableButtonMorph removeSelector: #mouseUp:!

PluggableButtonMorph removeSelector: #mouseUp:!

PasteUpMorph removeSelector: #click:!

PasteUpMorph removeSelector: #click:!

PasteUpMorph removeSelector: #mouseDown:!

PasteUpMorph removeSelector: #mouseDown:!

OneLineEditorMorph removeSelector: #clickAndHalf:!

OneLineEditorMorph removeSelector: #clickAndHalf:!

OneLineEditorMorph removeSelector: #mouseDown:!

OneLineEditorMorph removeSelector: #mouseDown:!

OneLineEditorMorph removeSelector: #mouseMove:!

OneLineEditorMorph removeSelector: #mouseMove:!

OneLineEditorMorph removeSelector: #mouseUp:!

OneLineEditorMorph removeSelector: #mouseUp:!

MenuMorph removeSelector: #mouseDown:!

MenuMorph removeSelector: #mouseDown:!

MenuMorph removeSelector: #mouseUp:!

MenuMorph removeSelector: #mouseUp:!

MenuItemMorph removeSelector: #mouseDown:!

MenuItemMorph removeSelector: #mouseDown:!

MenuItemMorph removeSelector: #mouseUp:!

MenuItemMorph removeSelector: #mouseUp:!

MagnifierMorph removeSelector: #mouseDown:!

MagnifierMorph removeSelector: #mouseDown:!

LayoutAdjustingMorph removeSelector: #mouseDown:!

LayoutAdjustingMorph removeSelector: #mouseDown:!

InnerTextMorph removeSelector: #clickAndHalf:!

InnerTextMorph removeSelector: #clickAndHalf:!

InnerTextMorph removeSelector: #doubleClickAndHalf:!

InnerTextMorph removeSelector: #doubleClickAndHalf:!

InnerTextMorph removeSelector: #mouseDown:!

InnerTextMorph removeSelector: #mouseDown:!

InnerTextMorph removeSelector: #mouseMove:!

InnerTextMorph removeSelector: #mouseMove:!

InnerTextMorph removeSelector: #mouseUp:!

InnerTextMorph removeSelector: #mouseUp:!

HaloMorph removeSelector: #mouseButton3Down:!

HaloMorph removeSelector: #mouseButton3Down:!

HaloMorph removeSelector: #mouseMove:!

HaloMorph removeSelector: #mouseMove:!

FillInTheBlankMorph removeSelector: #mouseDown:!

FillInTheBlankMorph removeSelector: #mouseDown:!

AutoCompleterMorph removeSelector: #mouseUp:!

AutoCompleterMorph removeSelector: #mouseUp:!

Morph removeSelector: #click:!

Morph removeSelector: #click:!

Morph removeSelector: #doubleClick:!

Morph removeSelector: #doubleClick:!

Morph removeSelector: #mouseButton3Down:!

Morph removeSelector: #mouseButton3Down:!

Morph removeSelector: #mouseButton3Up:!

Morph removeSelector: #mouseButton3Up:!

Morph removeSelector: #mouseDown:!

Morph removeSelector: #mouseDown:!

Morph removeSelector: #mouseMove:!

Morph removeSelector: #mouseMove:!

Morph removeSelector: #mouseUp:!

Morph removeSelector: #mouseUp:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1383-LocalPositionInEvents-JuanVuletich-2012Aug21-07h44m-jmv.10.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1382] on 21 August 2012 at 9:17:21 am'!
!Morph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 09:01'!
                          morphExtentInOwner
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ extent! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:47'!
                     didClick

	clickDone ifFalse: [
		clickSelector ifNotNil: [
			clickClient perform: clickSelector with: lastClickDown with: self lastClickLocalPosition ].
		clickDone _ true ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:48'!
        didClickAndHalf

	clickAndHalfDone ifFalse: [
		clickAndHalfSelector ifNotNil: [
			"Focus was lost at buttonUp. Set it again."
			lastClickDown hand newMouseFocus: clickClient event: lastClickDown.
			clickClient perform: clickAndHalfSelector with: lastClickDown with: self lastClickLocalPosition ].
		clickAndHalfDone _ true ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:48'!
               didCoubleClick

	doubleClickDone ifFalse: [
		dblClickSelector ifNotNil: [
			clickClient perform: dblClickSelector with: lastClickDown with: self lastClickLocalPosition ].
		doubleClickDone _ true ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:48'!
                didCoubleClickAndHalf

	doubleClickAndHalfDone ifFalse: [
		dblClickAndHalfSelector ifNotNil: [
			"Focus was lost at buttonUp. Set it again."
			lastClickDown hand newMouseFocus: clickClient event: lastClickDown.
			clickClient perform: dblClickAndHalfSelector with: lastClickDown with: self lastClickLocalPosition ].
		doubleClickAndHalfDone _ true ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:48'!
                       didCripleClick

	tripleClickSelector ifNotNil: [
		clickClient perform: tripleClickSelector with: lastClickDown with: self lastClickLocalPosition]! !
!SimpleEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:42'!
         clickAndHalf

	| here |
	here _ self pointIndex.
	(here between: 2 and: string size)
		ifTrue: [ self selectWord ]
		ifFalse: [
			"if at beginning or end, select entire string"
			self selectAll ].! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:42'!
                       clickAndHalf

	self selectWord.

	doWordSelection _ true.
	doParagraphSelection _ false.
	initialSelectionStart _ self startBlock.
	initialSelectionStop _ self stopBlock! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:46'!
                    doubleClickAndHalf

	| here interval |
	here _ self pointIndex.
	interval _ self privateCurrentString encompassParagraph: (here to: here).
	self selectFrom: interval first to: interval last.

	doWordSelection _ false.
	doParagraphSelection _ true.
	initialSelectionStart _ self startBlock.
	initialSelectionStop _ self stopBlock! !
!SmalltalkEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:43'!
                clickAndHalf

	| here |
	here _ self pointIndex.
	(here between: 2 and: model textSize)
		ifTrue: [
			super clickAndHalf ]
		ifFalse: [
			"if at beginning or end, select entire string"
			self selectAll ]! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/21/2012 09:16' prior: 50365275!
                           dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside eventPositionInChild |

	"Try to get out quickly"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: self.
	self wasHandled ifTrue: [^self ].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^ self sentTo: aMorph localPosition: positionInAMorph].
	^#rejected! !
!HierarchicalListMorph methodsFor: 'events-processing' stamp: 'jmv 8/21/2012 09:05' prior: 50368679!
                processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	(aMouseMoveEvent anyButtonPressed and: [ aMouseMoveEvent hand mouseFocus == self]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue
			arguments: {aMouseMoveEvent copy resetHandlerFields . localEventPosition}
			stepTime: 1].
! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 09:14' prior: 50367615!
                 clickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	self handleInteraction: [
		editor clickAndHalf ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:47' prior: 50367626!
                    doubleClickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	self handleInteraction: [
		editor doubleClickAndHalf ]
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 09:13' prior: 50367637!
         mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	aMouseButtonEvent mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].

	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"
	self hasKeyboardFocus ifFalse: [
		^aMouseButtonEvent hand newKeyboardFocus: self].

	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.

	self handleInteraction: [ editor mouseDown: aMouseButtonEvent localPosition: localEventPosition ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:localPosition:
		tripleClkSel: nil! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 09:16' prior: 50367669!
                       mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent mouseButton1Pressed ifFalse: [ ^ self enterClickableRegion: aMouseMoveEvent ].
	self handleInteraction: [ editor mouseMove: aMouseMoveEvent localPosition: localEventPosition].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 09:13' prior: 50367686!
            mouseUp: aMouseButtonEvent localPosition: localEventPosition

	super mouseUp: aMouseButtonEvent localPosition: localEventPosition.
	self pauseBlinking.
	self handleInteraction: [ editor mouseUp: aMouseButtonEvent  localPosition: localEventPosition ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 09:01' prior: 50353611!
               extentForComposing
	self flag: #jmvVer2.	"like #extent ..."
	^wrapFlag
		ifTrue: [ self morphExtentInOwner x @ 9999999 ]
		ifFalse: [ 9999999@9999999 ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/21/2012 08:49' prior: 50368599!
                handleEvent: aMouseEvent from: aHand
	"Process the given mouse event to detect a click, double-click, or drag.
	Return true if the event should be processed by the sender, false if it shouldn't.
	NOTE: This method heavily relies on getting *all* mouse button events."

	| timedOut distance |
	timedOut _ (aMouseEvent timeStamp - lastClickDown timeStamp) > DoubleClickTimeout.
	distance _ (aMouseEvent eventPosition - lastClickDown eventPosition) r.
	"Real action dispatch might be done after the triggering event, for example, because of waiting for timeout.
	So, count the button downs and ups(clicks), to be processed, maybe later, maybe in a mouseMove..."
	aMouseEvent isMouseDown ifTrue: [
		lastClickDown _ aMouseEvent.
		buttonDownCount _ buttonDownCount + 1 ].
	aMouseEvent isMouseUp ifTrue: [
		buttonUpCount _ buttonUpCount + 1 ].

	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."
	(buttonDownCount = 1 and: [ buttonUpCount = 0]) ifTrue: [
		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [
			aHand dontWaitForMoreClicks.
			clickClient mouseButton2Activity.
			^ false ].
		"If we have already moved, then it won't be a double or triple click... why wait?"
		distance > 0 ifTrue: [
			aHand dontWaitForMoreClicks.
			self didClick.
			^ false ]].

	"If we're over triple click, or timed out, or mouse moved, don't allow more clicks."
	(buttonDownCount = 4 or: [ timedOut or: [ distance > 0 ]]) ifTrue: [
		aHand dontWaitForMoreClicks.
		^ false ].

	"Simple click."
	(buttonDownCount = 1 and: [ buttonUpCount = 1 ]) ifTrue: [
		self didClick ].

	"Click & hold"
	(buttonDownCount = 2 and: [ buttonUpCount = 1]) ifTrue: [
		self didClickAndHalf ].

	"Double click."
	(buttonDownCount = 2 and: [ buttonUpCount = 2]) ifTrue: [
		self didCoubleClick ].

	"Double click & hold."
	(buttonDownCount = 3 and: [ buttonUpCount = 2]) ifTrue: [
		self didCoubleClickAndHalf ].

	"Triple click"
	(buttonDownCount = 3 and: [ buttonUpCount = 3]) ifTrue: [
		self didCripleClick ].

	"This means: if a mouseDown, then don't further process this event (so we can turn it into a double or triple click on next buttonUp)"
	^ aMouseEvent isMouseDown! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:43' prior: 50367804!
               clickAndHalf: aMouseButtonEvent localPosition: localEventPosition
	self handleInteraction: [ self editor clickAndHalf ]! !
!Paragraph methodsFor: 'editing' stamp: 'jmv 8/21/2012 09:02' prior: 50353855!
                      clickAt: clickPoint
	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."
	| startBlock action target range boxes box t |
	action _ false.
	startBlock _ self characterBlockAtPoint: clickPoint.
	t _ model actualContents.
	(t attributesAt: startBlock stringIndex) do: [ :att | 
		att mayActOnClick ifTrue:
				[(target _ model) ifNil: [ target _ editor morph].
				range _ t rangeOf: att startingAt: startBlock stringIndex.
				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 
							to: (self characterBlockForIndex: range last+1).
				box _ boxes detect: [ :each | each containsPoint: clickPoint] ifNone: nil.
				box ifNotNil: [
					box _ editor morph morphBoundsInWorld.
					editor morph allOwnersDo: [ :m | box _ box intersect: (m morphBoundsInWorld) ].
					Utilities
						awaitMouseUpIn: box
						repeating: nil
						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action _ true]].
					Cursor currentCursor == Cursor webLink ifTrue:[Cursor normal show].
				]]].
	^ action! !
!Paragraph methodsFor: 'private' stamp: 'jmv 8/21/2012 08:59' prior: 16909189!
                    lineIndexForPoint: aPoint
	"Answer the index of the line in which to select the character nearest to aPoint."
	| i py |
	py _ aPoint y truncated.

	"Find the first line at this y-value"
	i _ (self fastFindFirstLineSuchThat: [ :line | line bottom > py]) min: lines size.

	"Now find the first line at this x-value"
	[ i < lines size and: [ (lines at: i+1) top = (lines at: i) top
				and: [ aPoint x >= (lines at: i+1) left ]]]
		whileTrue: [ i _ i + 1 ].
	^ i! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 09:07' prior: 50368256!
  mouseDown: aMouseButtonEvent localPosition: localEventPosition
	| b |

	initialSelectionStart _ nil.
	initialSelectionStop _ nil.
	doWordSelection _ false.
	doParagraphSelection _ false.

	"Multiple selection of text.
	Windows uses Control, Mac uses Command (i.e. commandAlt)
	On the Mac, command-button1 is translated to command-button3 by the VM. do:
		Preferences disable: #commandClickOpensHalo
	to disable this behavior and make command-button1 work for multiple selection. "
	(aMouseButtonEvent controlKeyPressed or: [ aMouseButtonEvent commandAltKeyPressed ]) ifTrue: [
		self selectionInterval size > 0 ifTrue: [
			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.
			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]
	ifFalse: [
		selectionStartBlocks _ #().
		selectionStopBlocks _ #() ].

	b _ paragraph characterBlockAtPoint: localEventPosition.

	(paragraph clickAt: localEventPosition) ifTrue: [
		markBlock _ b.
		pointBlock _ b.
		aMouseButtonEvent hand releaseKeyboardFocus: self.
		^ self ].
	
	aMouseButtonEvent shiftPressed
		ifFalse: [
			(self markIndex = b stringIndex and: [ self pointIndex = b stringIndex ])
				ifTrue: [
					markBlock _ b.
					pointBlock _ b ]
				ifFalse: [
					markBlock _ b.
					pointBlock _ b.	
					self setEmphasisHereFromText ]]! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 09:10' prior: 50368301!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Change the selection in response to mouse-down drag"

	| b interval i1 i2 |
	doWordSelection ifTrue: [
		pointBlock _ (paragraph characterBlockAtPoint: localEventPosition).
		self selectWordLeftDelimiters: '' rightDelimiters: ''.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	doParagraphSelection ifTrue: [
		b _ paragraph characterBlockAtPoint: localEventPosition.
		i1 _ b stringIndex min: initialSelectionStart stringIndex.
		i2 _ b stringIndex max: initialSelectionStop stringIndex-1.
		interval _ self privateCurrentString encompassParagraph: (i1 to: i2).
		self selectFrom: interval first to: interval last.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	pointBlock _ (paragraph characterBlockAtPoint: localEventPosition).
	self storeSelectionInParagraph! !
!TextEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 09:13' prior: 50368338!
               mouseUp: aMouseButtonEvent localPosition: localEventPosition
	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |

	aMouseButtonEvent shiftPressed
		ifTrue: [
			"Squeak classic behavior for click, move, shift-click sequence "
			"pointBlock _(paragraph characterBlockAtPoint: (evt eventPosition))."

			"Mac behavior"
			cursorBlock _ paragraph characterBlockAtPoint: localEventPosition.
			cursorIndex _ cursorBlock stringIndex.
			startBlock _ self startBlock min: cursorBlock.
			startIndex _ startBlock stringIndex.
			stopBlock _ self stopBlock max: cursorBlock.
			stopIndex _ stopBlock stringIndex.
			(stopIndex - cursorIndex) < (cursorIndex - startIndex)
				ifTrue: [
					markBlock _ startBlock.
					pointBlock _ cursorBlock ]
				ifFalse: [
					markBlock _ stopBlock.
					pointBlock _ cursorBlock ]].
	self storeSelectionInParagraph! !

UserInputEvent removeSelector: #ztranslateBy:!

UserInputEvent removeSelector: #ztranslateBy:!

UserInputEvent removeSelector: #ztranslatedBy:!

UserInputEvent removeSelector: #ztranslatedBy:!

SmalltalkEditor removeSelector: #clickAndHalf:localPosition:!

SmalltalkEditor removeSelector: #clickAndHalf:localPosition:!

TextEditor removeSelector: #clickAndHalf:localPosition:!

TextEditor removeSelector: #clickAndHalf:localPosition:!

TextEditor removeSelector: #doubleClickAndHalf:localPosition:!

TextEditor removeSelector: #doubleClickAndHalf:localPosition:!

SimpleEditor removeSelector: #clickAndHalf:localPosition:!

SimpleEditor removeSelector: #clickAndHalf:localPosition:!

MouseClickState removeSelector: #click!

MouseClickState removeSelector: #click!

MouseClickState removeSelector: #clickAndAHalf!

MouseClickState removeSelector: #clickAndAHalf!

MouseClickState removeSelector: #doubleClick!

MouseClickState removeSelector: #doubleClick!

MouseClickState removeSelector: #doubleClickAndHalf!

MouseClickState removeSelector: #doubleClickAndHalf!

MouseClickState removeSelector: #tripleClick!

MouseClickState removeSelector: #tripleClick!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1384-LocalPositionInEvents-JuanVuletich-2012Aug21-08h40m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1384] on 21 August 2012 at 10:37:28 am'!
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 8/21/2012 10:03'!
                 zdrawBoundsForRow: row
	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"
	| topLeft |
	self flag: #jmvVer2. "y drawBoundsForRow: tambien"
	topLeft _ self morphPositionInWorld + (0 @ (row - 1 * font height)).
	^ topLeft extent: self morphExtentInWorld x @ font height! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/21/2012 09:25'!
 focusIndicatorExtent
	| e |
	e _ self morphExtentInWorld - borderWidth - borderWidth.
	self vIsScrollbarShowing ifTrue: [
		e _ e x - self scrollBarClass scrollbarThickness @ e y ].
	self hIsScrollbarShowing ifTrue: [
		e _ e x @ (e y - self scrollBarClass scrollbarThickness) ].
	^e! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/21/2012 09:25'!
                       viewableExtent

	^self focusIndicatorExtent - (self xtraBorder * 2)! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 8/21/2012 10:04' prior: 50353441!
                             drawBoundsForRow: row
	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"
	| topLeft |
	self flag: #jmvVer2. "y drawBoundsForRow: tambien"
	"revisar, limpiar?"
	topLeft _ self externalize: (0 @ (row - 1 * font height)).
	^ topLeft extent: self morphExtentInOwner x @ font height! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 10:02' prior: 50353462!
             draw: item atRow: row on: canvas
	"display the given item at row row"
	| drawBounds f |
	drawBounds _ self zdrawBoundsForRow: row.
	drawBounds _ drawBounds intersect: self morphBoundsInWorld.
	f _ (item is: #Text) ifTrue: [ font emphasized: (item emphasisAt: 1) ] ifFalse: [ font ].
	canvas drawString: item in: drawBounds font: f color: (self colorForRow: row)! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 10:02' prior: 50353476!
                               drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"

	selectionDrawBounds _ self zdrawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: self morphBoundsInWorld.
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas fillRectangle: selectionDrawBounds colorOrInfiniteForm: c! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 10:02' prior: 50353496!
                          drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self zdrawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: self morphBoundsInWorld.
	aCanvas
		fillRectangle: selectionDrawBounds
		colorOrInfiniteForm: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 10:03' prior: 50369067!
        doubleClickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	self handleInteraction: [
		editor doubleClickAndHalf ].
	owner scrollSelectionIntoView! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 09:36' prior: 50347846!
      adjustExtent
	"This is just a suggestion. If we do wordwrap, the width will be honored.
	But the height is whatever is appropriate for the contents!!"
	self morphExtent: owner viewableExtent! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 8/21/2012 10:31' prior: 16888096!
         invokeModalAt: aPoint in: aWorld allowKeyboard: aBoolean
	"Invoke this menu and don't return until the user has chosen a value.
	See senders of this method for finding out how to use modal menu morphs."
	| w oldFocus actHand |
	actHand _ aWorld activeHand.
	oldFocus _ actHand keyboardFocus.
	w _ aWorld outermostWorldMorph. "containing hand"
	w doOneSubCycle.
	self	
		popUpAt: aPoint
		forHand: actHand 
		in: aWorld 
		allowKeyboard: aBoolean.
	self isModalInvokationDone: false.
	[self isInWorld & self isModalInvokationDone not] whileTrue: [w doOneSubCycle].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 8/21/2012 10:32' prior: 16884767!
                     invokeAt: aPoint in: aWorld allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	|actHand w oldFocus |
	self flag: #bob.		"is <aPoint> global or local?"
	self flag: #arNote.	"<aPoint> is local to aWorld"
	actHand _ aWorld activeHand.
	oldFocus _ actHand keyboardFocus.
	w _ aWorld outermostWorldMorph. "containing hand"
	w doOneSubCycle.
	self
		popUpAt: aPoint
		forHand: actHand
		in: aWorld 
		allowKeyboard: aBoolean.
	done _ false.
	[self isInWorld & done not] whileTrue: [w doOneSubCycle].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ mvcSelection ! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/21/2012 09:22' prior: 50353941!
              focusIndicatorRectangle

	| topLeft bottomRight |
	self flag: #jmvVer. "Prefer #focusIndicatorExtent"
	topLeft _ self morphPositionInWorld.
	bottomRight _ topLeft + self morphExtentInWorld.
	topLeft _ topLeft + borderWidth.
	bottomRight _ bottomRight - borderWidth.
	self vIsScrollbarShowing ifTrue: [
		bottomRight _ scrollBar morphPositionInWorld x -1@ bottomRight y].
	self hIsScrollbarShowing ifTrue: [
		bottomRight _ bottomRight x @ 
			(bottomRight y - self scrollBarClass scrollbarThickness)].
	^topLeft corner: bottomRight! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/21/2012 09:44' prior: 50344125!
               scrollerOffset
	^(scroller morphPositionInOwner negated + borderWidth + self xtraBorder)! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/21/2012 09:36' prior: 16915192!
          viewableHeight
	"Viewable height.
	Leave room for horizontal scrollbar if present"

	^self viewableExtent y! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/21/2012 09:36' prior: 16915198!
                       viewableWidth
	"Viewable width.
	Leave room for vertical scrollbar if present"

	^self viewableExtent x! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 8/21/2012 09:33' prior: 16915347!
                          scrollToShow: aRectangle
	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space.
	This means that 0@0 is scrolling all the way top and all the way left"
	| delta |
	(aRectangle top >= 0 and: [
		aRectangle bottom <= self viewableHeight ])
		ifTrue: [
			"already visible"
			^self ].

	"Scroll end of selection into view if necessary"
	delta _ aRectangle amountToTranslateWithin: (0@0 extent: self viewableExtent).
	delta y ~= 0 ifTrue: [
		self scrollBy: 0@delta y ]! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 8/21/2012 09:59' prior: 50354023!
                          scrollSelectionIntoView

	selectedMorph ifNotNil: [
		self flag: #jmvVer2.	"traducir mejor el rectangulo..."
		self scrollToShow: ((scroller externalize: selectedMorph morphPositionInOwner) extent: selectedMorph morphExtentInOwner) ]! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 10:37' prior: 50368045!
                            mouseDown: aMouseButtonEvent localPosition: localEventPosition

	| row |
	"First check for option (menu) click"
	aMouseButtonEvent mouseButton2Pressed ifTrue: [
		^ self mouseButton2Activity ].
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self.
		"If we are focusing, deselect, so that later selection doesn't result in deselect."
		self listMorph noSelection].
	row _ self rowAtLocation: aMouseButtonEvent eventPosition.
	row = 0  ifTrue: [ ^super mouseDown: aMouseButtonEvent localPosition: localEventPosition ].
	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 8/21/2012 10:05' prior: 16914380!
                      scrollSelectionIntoView
	"make sure that the current selection is visible"
	| row |
	row _ self getCurrentSelectionIndex.
	row = 0 ifTrue: [
		^ scrollBar setValue: scrollBar value ].
	self scrollToShow: (self listMorph drawBoundsForRow: row)! !
!SystemWindow methodsFor: 'top window' stamp: 'jmv 8/21/2012 10:36' prior: 16965703!
                     activateAndSendTopToBack: aBoolean
	"Bring me to the front and make me able to respond to mouse and keyboard"

	| oldTop |
	self owner 
		ifNil: [^self	"avoid spurious activate when drop in trash"].
	oldTop _ TopWindow.
	TopWindow _ self.

	oldTop ifNotNil: [
		oldTop passivate.
		aBoolean ifTrue: [
			oldTop owner addMorphBack: oldTop ]].

	self owner firstSubmorph == self 
		ifFalse: [
			"Bring me to the top if not already"
			self owner addMorphFront: self].
	self redrawNeeded.

	"Set keyboard focus"
	self submorphToFocusKeyboard ifNotNil: [ :m |
		self world ifNotNil: [ :w | w activeHand newKeyboardFocus: m ]]! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 8/21/2012 09:32' prior: 50361345!
                    scrollSelectionIntoView
	"Scroll my text into view if necessary and return true, else return false"

	self scrollToShow: (self editor pointBlock translatedBy: self textMorph morphPositionInOwner)! !

PluggableScrollPane removeSelector: #viewableBounds!

PluggableScrollPane removeSelector: #viewableBounds!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1385-LocalCoordinatesInMorphs-JuanVuletich-2012Aug21-10h35m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1385] on 21 August 2012 at 1:29:09 pm'!
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 8/21/2012 12:38'!
                  enterClickableRegion: aMorphicEvent localPosition: localEventPosition
	| index isLink |
	aMorphicEvent hand hasSubmorphs ifTrue: [ ^self ].
	paragraph ifNotNil:[
		index _ (paragraph characterBlockAtPoint: localEventPosition) stringIndex.
		isLink _ (model actualContents attributesAt: index) 
					anySatisfy: [ :attr | attr mayActOnClick ].
		isLink ifTrue: [ Cursor webLink show ] ifFalse: [ Cursor normal show ]]! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 8/21/2012 13:04' prior: 16899265!
     findSubmorphBinary: aBlock
	"Use binary search for finding a specific submorph of the receiver. Caller must be certain that the ordering holds for the submorphs."
	^submorphs findBinary: aBlock do: [ :found | found ] ifNone: [ :a :b | ]! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 13:23' prior: 50367566!
                         mouseUp: aMouseButtonEvent localPosition: localEventPosition
	(self containsPoint: aMouseButtonEvent eventPosition)
		ifTrue: [
			self selected: (localEventPosition y // self class itemHeight) +  self firstVisible.
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 13:10' prior: 50367980!
                            mouseDown: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	itemMorph _ self itemFromPoint: localEventPosition.
	(itemMorph notNil and: [
		itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)) ])
		ifTrue: [ ^self toggleExpandedState: itemMorph event: aMouseButtonEvent ]. 
	aMouseButtonEvent mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [ ^ self mouseButton2Activity ].
	itemMorph ifNil: [ ^super mouseDown: aMouseButtonEvent localPosition: localEventPosition ].
	itemMorph highlightForMouseDown.
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 13:10' prior: 50368008!
                          mouseUp: aMouseButtonEvent localPosition: localEventPosition
	| itemMorph |
	itemMorph _ self itemFromPoint: localEventPosition.
	itemMorph ifNil: [^self].
	itemMorph highlightedForMouseDown ifFalse: [^self].
	itemMorph highlightForMouseDown: false.
	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	((autoDeselect isNil or: [autoDeselect]) and: [itemMorph == selectedMorph]) 
		ifTrue: [self setSelectedMorph: nil]
		ifFalse: [self setSelectedMorph: itemMorph].
	Cursor normal show! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 8/21/2012 13:08' prior: 50355073!
                  itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last internalPoint |
	internalPoint _ scroller internalize: aPoint.
	scroller hasSubmorphs ifFalse: [ ^nil ].
	(internalPoint > (0@0) and: [ internalPoint < scroller morphExtentInOwner ]) ifFalse: [ ^nil ].
	ptY _ internalPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	scroller firstSubmorph morphPositionInOwner y > ptY ifTrue: [ ^nil ].
	last _ scroller lastSubmorph.
	last morphPositionInOwner y + last morphExtentInOwner y < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^scroller 
		findSubmorphBinary: [ :m |
			(m morphPositionInOwner y <= ptY and: [ m morphPositionInOwner y + m morphExtentInOwner y >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPositionInOwner y + (m morphExtentInOwner y // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 13:13' prior: 16868197!
                            drawLineToggleToTextOn: aCanvas lineColor: lineColor hasToggle: hasToggle
	"If I am not the only item in my container, draw the line between:
		- my toggle (if any) or my left edge (if no toggle)
		- and my text left edge"

	| myBounds myCenter hLineY hLineLeft |
	self isSoleItem ifTrue: [ ^self ].
	myBounds := self toggleRectangle translatedBy: self morphPositionInWorld.
	myCenter := myBounds center.
	hLineY := myCenter y.
	hasToggle
		ifTrue: [hLineLeft := myBounds right - 3]
		ifFalse: [hLineLeft := myCenter x - 1].
	"Draw line from toggle to text"
	aCanvas
		line: hLineLeft @ hLineY
		to: myBounds right + 0 @ hLineY
		width: 1
		color: lineColor! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 13:13' prior: 50354372!
               drawLinesToFirstChildOn: aCanvas lineColor: lineColor 
	"Draw line from me to next sibling"

	| vLineX vLineTop vLineBottom childBounds childCenter |
	childBounds := self firstChild toggleRectangle translatedBy: self firstChild morphPositionInWorld.
	childCenter := childBounds center.
	vLineX := childCenter x - 1.
	vLineTop := self morphPositionInWorld y + self morphExtentInWorld y.
	self firstChild hasToggle
		ifTrue: [vLineBottom := childCenter y - 7]
		ifFalse: [vLineBottom := childCenter y].
	aCanvas
		line: vLineX @ vLineTop
		to: vLineX @ vLineBottom
		width: 1
		color: lineColor! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 13:14' prior: 16868258!
                drawLinesToNextSiblingOn: aCanvas lineColor: lineColor hasToggle: hasToggle
	| myBounds nextSibBounds vLineX myCenter vLineTop vLineBottom |
	myBounds := self toggleRectangle translatedBy: self morphPositionInWorld.
	nextSibBounds := self nextSibling toggleRectangle translatedBy: self nextSibling morphPositionInWorld.
	myCenter := myBounds center.
	vLineX := myCenter x - 1.
	hasToggle
		ifTrue: [vLineTop := myCenter y + 5]
		ifFalse: [vLineTop := myCenter y].
	self nextSibling hasToggle
		ifTrue: [vLineBottom := nextSibBounds top + 2 ]
		ifFalse: [vLineBottom :=  nextSibBounds center y ].
	"Draw line from me to next sibling"
	aCanvas
		line: vLineX @ vLineTop
		to: vLineX @ vLineBottom
		width: 1
		color: lineColor! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 13:15' prior: 50354392!
            drawOn: aCanvas

	| tRect sRect columnRect columnScanner columnData columnLeft colorToUse |

	tRect := self toggleRectangle translatedBy: self morphPositionInWorld.
	sRect := self morphBoundsInWorld withLeft: tRect right + 4.
	self drawToggleOn: aCanvas in: tRect.
	colorToUse _ complexContents preferredColor ifNil: [color].
	(container columns isNil or: [(contents asString indexOf: Character tab) = 0]) ifTrue: [
		aCanvas drawString: contents asString in: sRect font: self fontToUse color: colorToUse.
	] ifFalse: [
		columnLeft _ sRect left.
		columnScanner _ ReadStream on: contents asString.
		container columns do: [ :width |
			columnRect _ columnLeft @ sRect top extent: width @ sRect height.
			columnData _ columnScanner upTo: Character tab.
			columnData isEmpty ifFalse: [
				aCanvas drawString: columnData in: columnRect font: self fontToUse color: colorToUse.
			].
			columnLeft _ columnRect right + 5.
		].
	]
! !
!IndentingListItemMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 12:47' prior: 50354423!
                               toggleRectangle

	^(12*indentLevel @ 0) extent: 12@extent y! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 12:38' prior: 50369106!
              mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent mouseButton1Pressed ifFalse: [
		^ self enterClickableRegion: aMouseMoveEvent localPosition: localEventPosition ].
	self handleInteraction: [
		editor mouseMove: aMouseMoveEvent localPosition: localEventPosition].
	owner scrollSelectionIntoView! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 13:18' prior: 50357107!
 characterIndexAtPoint: aPoint

	| line block f |
	f _ self fontToUse.
	
	line _ TextLine 
		start: 1
		stop: contents size
		internalSpaces: 0
		paddingWidth: 0.
	line
		rectangle: (0@0 extent: extent);
		lineHeight: f height baseline: f ascent.
		
	block _ (CharacterBlockScanner new text: 
			(contents asText font: font))
		characterBlockAtPoint: aPoint index: nil
		in: line.

	^ block stringIndex! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 13:20' prior: 50367812!
                    mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	aMouseButtonEvent hand newKeyboardFocus: self.

	self handleInteraction: [
		self editor mouseDown: aMouseButtonEvent index: (self characterIndexAtPoint: localEventPosition) ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 13:20' prior: 50367833!
      mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent mouseButton1Pressed ifFalse: [ ^ self ].
	self handleInteraction: [
		self editor mouseMove: aMouseMoveEvent index: (self characterIndexAtPoint: localEventPosition) ]! !
!TextDoIt class methodsFor: 'as yet unclassified' stamp: 'jmv 8/21/2012 12:36' prior: 16971079!
       evalString: str
	"
	('Some text. ',
	(Text string: '<click here>' attribute: (TextDoIt evalString: 'TranscriptWindow openTranscript')), 
	' more regular text') edit
	"
	^ self new evalString: str! !

InnerTextMorph removeSelector: #enterClickableRegion:!

InnerTextMorph removeSelector: #enterClickableRegion:!

IndentingListItemMorph removeSelector: #toggleBounds!

IndentingListItemMorph removeSelector: #toggleBounds!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1386-LocalCoordinatesInMorphs-JuanVuletich-2012Aug21-13h28m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1386] on 21 August 2012 at 8:34:35 pm'!
!FillInTheBlankMorph commentStamp: '<historical>' prior: 0!
        A simple dialog with an entry field and accept / cancel buttons.!
!MenuLineMorph commentStamp: '<historical>' prior: 0!
        Just a line for separating items in menus.!

!classDefinition: #RectangleLikeMorph category: #'Morphic-Kernel'!
Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!RectangleLikeMorph commentStamp: '<historical>' prior: 0!
                      Hierarchy  for morph that are rectangle like. Including rectangles with rounded corners and such. The idea is that the 'xtent' ivar is all that's needed to establish our extent and shape. Subclasses can add things like 'roundedCornerRadious' or such.!

!classDefinition: #BorderedRectMorph category: #'Morphic-Kernel'!
RectangleLikeMorph subclass: #BorderedRectMorph
	instanceVariableNames: 'borderWidth borderColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

RectangleLikeMorph subclass: #BorderedRectMorph
	instanceVariableNames: 'borderWidth borderColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!BorderedRectMorph commentStamp: '<historical>' prior: 0!
            BorderedMorph introduce borders to morph. Borders have the instanceVariables borderWidth and borderColor.
 
BorderedMorph new borderColor: Color red; borderWidth: 10; openInWorld.

BorderedMorph also have a varaity of border styles: simple, inset, raised, complexAltFramed, complexAltInset, complexAltRaised, complexFramed, complexInset, complexRaised.
These styles are set using the classes BorderStyle, SimpleBorder, RaisedBorder, InsetBorder and ComplexBorder.

BorderedMorph new borderColor: Color white; openInWorld.
BorderedMorph new borderColor: #inset; borderWidth: 2; openInWorld!
!BorderedRectMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 16:12'!
         borderColor
	^ borderColor! !
!BorderedRectMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 16:12'!
                         borderColor: aColor
	borderColor = aColor ifFalse: [
		borderColor _ aColor.
		self redrawNeeded]! !
!BorderedRectMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 16:12'!
                  borderWidth: anInteger
	borderWidth = anInteger ifFalse: [
		borderColor ifNil: [ borderColor _ Color black ].
		borderWidth _ anInteger max: 0.
		self redrawNeeded ]! !
!BorderedRectMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 16:12'!
               drawOn: aCanvas

	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor! !
!BorderedRectMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:23'!
     innerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

	^ self morphBoundsInWorld insetBy: (borderWidth ifNil: [0])! !
!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 16:12'!
      defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Color black! !
!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 16:12'!
              defaultBorderWidth
	"answer the default border width for the receiver"
	^ 2! !
!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 16:29'!
   initialize
	self flag: #jmvVer2.  "many users would be just happy with a RectangleLikeMorph... Check them!!"
	"initialize the state of the receiver"
	super initialize.
	"initialize the receiver state related to border"
	borderColor _ self defaultBorderColor.
	borderWidth _ self defaultBorderWidth! !
!BorderedRectMorph methodsFor: 'testing' stamp: 'jmv 8/21/2012 16:12'!
            isOpaqueMorph
	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)
	but is not an opaque rectangle covering bounds MUST answer false to this message"
	color mightBeTranslucent ifTrue: [
		^false ].
	borderWidth > 0 ifTrue: [
		borderColor mightBeTranslucent ifTrue: [
			^false ]].
	^true! !
!BorderedRectMorph class methodsFor: 'instance protocol testing' stamp: 'jmv 8/21/2012 16:12'!
                       gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(BorderedMorph)! !
!BorderedMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:34' prior: 50356491!
                       innerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

	^ self morphBoundsInWorld insetBy: (borderWidth ifNil: [0])! !
!BorderedMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 16:12' prior: 50332726!
                          initialize
	"initialize the state of the receiver"
	super initialize.
	"initialize the receiver state related to border"
	borderColor _ self defaultBorderColor.
	borderWidth _ self defaultBorderWidth! !
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 8/21/2012 16:23' prior: 50356117!
                    buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ BorderedRectMorph new.
	outerBox
		morphExtent: finalSizeInteger asPoint * resizeFactor;
		borderWidth: 0;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox morphBoundsInWorld.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPositionInOwner: 12@8.	"not a clue why these numbers work..."
	
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 16:23' prior: 50356656!
           addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ BorderedRectMorph new
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph morphExtent y + 5).
	nameBackground morphBoundsInWorld: (nameMorph morphBoundsInWorld outsetBy: 2).
	^nameMorph! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/21/2012 16:23' prior: 16880327!
       example1
"
	self example1
"
| pane row |
pane _ LayoutMorph newColumn separation: 5.
pane color: Color red.

row _ LayoutMorph newRow.
row
	color: Color red;
	addMorph: (RectangleMorph new color: (Color h: 60 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (RectangleMorph new color: (Color blue))
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (RectangleMorph new color: (Color h: 60 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue))
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/21/2012 16:23' prior: 16880386!
                          example11
"
	self example11
"
| pane row |
pane _ LayoutMorph newColumn separation: 5.
pane color: Color red.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (RectangleMorph new color: (Color h: 60 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 10);
	addAdjusterMorph; 
	addMorph: (RectangleMorph new color: (Color blue))
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (RectangleMorph new color: (Color h: 60 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue))
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/21/2012 16:24' prior: 16880448!
                           example13
	"
	self example13
	"
	| pane row innerRow |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	innerRow _ (LayoutMorph newRow separation: 5) color: Color red.
	innerRow
		addMorph: BorderedRectMorph new layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: BorderedRectMorph new layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: BorderedRectMorph new layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 minorDirectionPadding: #center);
addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 minorDirectionPadding: #top);
addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/21/2012 16:24' prior: 16880489!
                     example2
	"
	self example2
	"
	| pane row |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/21/2012 16:24' prior: 16880516!
          example3
	"
	self example3
	"
	| pane row innerRow |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	innerRow _ (LayoutMorph newRow separation: 5) color: Color red.
	innerRow
		addMorph: BorderedRectMorph new layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: BorderedRectMorph new layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: BorderedRectMorph new layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 minorDirectionPadding: #center);
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/21/2012 16:24' prior: 50356923!
               example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane color: Color lightGreen; morphBoundsInWorld: (120 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '1').

rect1 := RectangleMorph new color: (Color lightOrange); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect1.
rect2 := RectangleMorph new color: (Color cyan); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect2.
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "2"
pane color: Color lightGreen; morphBoundsInWorld: (320 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '2').

rect1 := RectangleMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane color: Color lightGreen; morphBoundsInWorld: (520 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '3').

rect1 := BorderedRectMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := BorderedRectMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane openInWorld.! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 8/21/2012 16:28' prior: 50351250!
                testLayout1
	"
	self new testLayout1
	"
	| pane row1 row2 row3 r1c1 r1c2 r1c3 r1c4 r1c5 r2c1 r2c2 r2c3 r3c1 r3c2 r3c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row1 _ LayoutMorph newRow separation: 5.
	row1 color: Color red;
		addMorph: (r1c1 _ BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 10);
		addMorph: (r1c2 _ BorderedRectMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r1c3 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r1c4 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.15);
		addMorph: (r1c5 _ BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
	pane addMorph: row1 layoutSpec: LayoutSpec useAll.
	row2 _ LayoutMorph newRow separation: 5.
	row2 color: Color red;
		addMorph: (r2c1 _ BorderedRectMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r2c2 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r2c3 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.2).
	pane addMorph: row2 layoutSpec: LayoutSpec useAll.
	row3 _ LayoutMorph newRow separation: 5.
	row3 color: Color red;
		addMorph: (r3c1 _ BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
		addMorph: (r3c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40);
		addMorph: (r3c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row3 layoutSpec: (LayoutSpec fixedHeight: 60).
	pane openInWorld; morphExtent: 408@300.
	World doOneCycleNow.

	self assert: row1 morphWidth = (pane morphWidth - 10).
	self assert: r1c1 morphWidth class == SmallInteger.
	self assert: r1c1 morphHeight class == SmallInteger.
	self assert: r1c1 morphWidth = 10.
	self assert: r1c1 morphHeight = (row1 morphHeight - 10).
	self assert: r1c2 morphWidth = 200.
	self assert: r1c2 morphHeight = (row1 morphHeight - 10).
	self assert: r1c3 morphWidth = (r1c2 morphWidth / 0.8 * 0.4) rounded.
	self assert: r1c3 morphHeight = (row1 morphHeight - 10).
	self assert: r1c4 morphWidth = (r1c2 morphWidth / 0.8 * 0.15) rounded.
	self assert: r1c4 morphHeight = (row1 morphHeight - 10).
	self assert: r1c5 morphWidth = 20.
	self assert: r1c5 morphHeight = 20.

	self assert: row2 morphWidth = (pane morphWidth - 10).
	self assert: r2c1 morphWidth = 216.
	self assert: r2c1 morphHeight = (row2 morphHeight - 10).
	self assert: r2c2 morphWidth = (r2c1 morphWidth / 0.8 * 0.4) rounded.
	self assert: r2c2 morphHeight = (row2 morphHeight - 10).
	self assert: r2c3 morphWidth = (r2c1 morphWidth / 0.8 * 0.2) rounded.
	self assert: r2c3 morphHeight = (row2 morphHeight - 10).

	self assert: row3 morphWidth = (pane morphWidth - 10).
	self assert: row3 morphHeight = 60.
	self assert: r3c1 morphWidth = 20.
	self assert: r3c1 morphHeight = (row3 morphHeight - 10 * 0.8) rounded.
	self assert: r3c2 morphWidth = (row3 morphWidth - 10 - 20 - 10 - 30 * 0.5) rounded.
	self assert: r3c2 morphHeight = 40.
	self assert: r3c3 morphWidth = 30.
	self assert: r3c3 morphHeight = (row3 morphHeight - 10).

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 8/21/2012 16:25' prior: 50356174!
   testLayout2
	"
	self new testLayout2
	"
	| pane row c1 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (c1 _ BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane openInWorld; morphExtent: 400@300.
	World doOneCycleNow.

	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = (pane morphHeight - 10 * 0.9) rounded.
	self assert: c1 morphBoundsInWorld bottom = (row morphBoundsInWorld bottom - 5) description: 'Should be at bottom'.
	self assert: c1 morphWidth = 20.
	self assert: c1 morphHeight = (row morphHeight - 10 * 0.8) rounded.
	self assert: c2 morphBoundsInWorld top = (row morphBoundsInWorld top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = 256.
	self assert: c2 morphHeight = 40.
	self assert: ((c3 morphBoundsInWorld top - row morphBoundsInWorld top) - (row morphBoundsInWorld bottom - c3 morphBoundsInWorld bottom)) abs < 2 description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (c1 morphHeight / 0.8 * 0.7) rounded.

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 8/21/2012 16:25' prior: 50356230!
         testLayout3
	"
	self new testLayout3
	"
	| pane row innerRow i1 i2 i3 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	innerRow _ LayoutMorph newRow color: Color red;  separation: 5.
	innerRow
		addMorph: (i1 _ BorderedRectMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i2 _ BorderedRectMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i3 _ BorderedRectMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 minorDirectionPadding: #center);
		addMorph: (c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 200).
	pane openInWorld; morphExtent: 400@300.
	World doOneCycleNow.

	self assert: row morphBoundsInWorld left = (pane morphBoundsInWorld left + 5).
	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = 200.
	self assert: innerRow morphBoundsInWorld left = (row morphBoundsInWorld left + 5).
	self assert: (innerRow morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - innerRow morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: innerRow morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: innerRow morphHeight = 30.

	self assert: i1 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 5).
	self assert: (i1 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i1 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i1 morphWidth = 10.
	self assert: i1 morphHeight = 10.
	self assert: i2 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 20).
	self assert: (i2 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i2 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i2 morphWidth = 10.
	self assert: i2 morphHeight = 10.
	self assert: i3 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 35).
	self assert: (i3 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i3 morphWidth = (innerRow morphWidth - 40).
	self assert: i3 morphHeight = 10.

	self assert: c2 morphBoundsInWorld top = (row morphBoundsInWorld top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: c2 morphHeight = 40.
	self assert: (c3 morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - c3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (row morphHeight - 10).

	pane delete! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 8/21/2012 16:26' prior: 50346129!
           addStayUpIcons
	| closeBox pinBox w |
	
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 42.
	self addMorphFront: 
		(LayoutMorph newRow
			morphHeight: (titleMorph morphHeight max: 19);
			morphWidth: w;	"Make room for buttons"
			color: Color transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (BorderedRectMorph new borderWidth: 0; color: Color transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (BorderedRectMorph new borderWidth: 0; color: Color transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 8/21/2012 16:26' prior: 50346170!
               addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ BorderedRectMorph new.
	self setTitleParametersFor: titleMorph.
	pp _ 8@2.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s.
		s morphPositionInOwner: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphHeight: pp y; morphWidth: w + 8.
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 8/21/2012 16:28' prior: 50350783!
                         initializeSlider
	"initialize the receiver's slider"

	sliderShadow _ BorderedRectMorph new.
	sliderShadow borderWidth: 0.
	self addMorph: sliderShadow.
	sliderShadow hide.
		
	slider _ self sliderClass new.
	slider model: self.
	slider grabSelector: #sliderGrabbed.
	slider dragSelector: #scrollAbsolute:.
	slider action: #sliderReleased.
	self addMorph: slider.

	self computeSlider! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1387-RectangleLikeMorph-JuanVuletich-2012Aug21-20h33m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1387] on 21 August 2012 at 6:36:04 pm'!

"Change Set:		1388-CuisCore-JuanVuletich-2012Aug21-18h32m
Date:			21 August 2012
Author:			Juan Vuletich

<your descriptive text goes here>"
TranscriptWindow allInstancesDo: [ :a | a delete ].
ProgressMorph allInstancesDo: [ :a | a delete ]!

!classDefinition: #EllipseMorph category: #'Morphic-Basic'!
BorderedRectMorph subclass: #EllipseMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

BorderedRectMorph subclass: #EllipseMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!classDefinition: #FillInTheBlankMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #FillInTheBlankMorph
	instanceVariableNames: 'response done textPane responseUponCancel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #FillInTheBlankMorph
	instanceVariableNames: 'response done textPane responseUponCancel '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #FrameRateMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #FrameRateMorph
	instanceVariableNames: 'lastStepStamp lastStepDelta meanStepDelta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #FrameRateMorph
	instanceVariableNames: 'lastStepStamp lastStepDelta meanStepDelta '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #HoverHelpMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #HoverHelpMorph
	instanceVariableNames: 'contents paragraph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #HoverHelpMorph
	instanceVariableNames: 'contents paragraph '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #ImageMorph category: #'Morphic-Basic'!
RectangleLikeMorph subclass: #ImageMorph
	instanceVariableNames: 'image'
	classVariableNames: 'DefaultForm'
	poolDictionaries: ''
	category: 'Morphic-Basic'!

RectangleLikeMorph subclass: #ImageMorph
	instanceVariableNames: 'image '
	classVariableNames: 'DefaultForm '
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!classDefinition: #InnerPluggableMorph category: #'Morphic-Views for Models'!
RectangleLikeMorph subclass: #InnerPluggableMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

RectangleLikeMorph subclass: #InnerPluggableMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

!classDefinition: #LayoutAdjustingMorph category: #'Morphic-Layouts'!
RectangleLikeMorph subclass: #LayoutAdjustingMorph
	instanceVariableNames: 'hand indicator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

RectangleLikeMorph subclass: #LayoutAdjustingMorph
	instanceVariableNames: 'hand indicator '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #MenuLineMorph category: #'Morphic-Menus'!
RectangleLikeMorph subclass: #MenuLineMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

RectangleLikeMorph subclass: #MenuLineMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MinimalStringMorph category: #'Morphic-Basic'!
RectangleLikeMorph subclass: #MinimalStringMorph
	instanceVariableNames: 'font emphasis contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

RectangleLikeMorph subclass: #MinimalStringMorph
	instanceVariableNames: 'font emphasis contents '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!classDefinition: #OneLineEditorMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #OneLineEditorMorph
	instanceVariableNames: 'font emphasis contents editor showCaret pauseBlinking caretRect keyboardFocusWatcher'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #OneLineEditorMorph
	instanceVariableNames: 'font emphasis contents editor showCaret pauseBlinking caretRect keyboardFocusWatcher '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PasteUpMorph category: #'Morphic-Worlds'!
BorderedRectMorph subclass: #PasteUpMorph
	instanceVariableNames: 'worldState backgroundImage backgroundImageData'
	classVariableNames: 'DisableDeferredUpdates WindowEventHandler'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

BorderedRectMorph subclass: #PasteUpMorph
	instanceVariableNames: 'worldState backgroundImage backgroundImageData '
	classVariableNames: 'DisableDeferredUpdates WindowEventHandler '
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

!classDefinition: #ProgressBarMorph category: #'Morphic-Widgets'!
BorderedRectMorph subclass: #ProgressBarMorph
	instanceVariableNames: 'value progressColor lastValue'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

BorderedRectMorph subclass: #ProgressBarMorph
	instanceVariableNames: 'value progressColor lastValue '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #RectangleIndicatorMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #RectangleIndicatorMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #RectangleIndicatorMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #StringMorph category: #'Morphic-Basic'!
RectangleLikeMorph subclass: #StringMorph
	instanceVariableNames: 'font emphasis contents hasFocus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

RectangleLikeMorph subclass: #StringMorph
	instanceVariableNames: 'font emphasis contents hasFocus '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!classDefinition: #TranscriptMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #TranscriptMorph
	instanceVariableNames: 'form'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #TranscriptMorph
	instanceVariableNames: 'form '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 16:46' prior: 50348001!
                           initialize
	super initialize.
	self separation: 0.
	labelMorph _ StringMorph contents: '' font: AbstractFont default.
	subLabelMorph _ StringMorph contents: '' font: AbstractFont default.
	progress _ ProgressBarMorph new.
	progress morphExtent: 200 @ 15.
	self addMorph: labelMorph.
	self addMorph: subLabelMorph.
	self addMorph: progress fixedHeight: 15.! !

!classDefinition: #TranscriptMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #TranscriptMorph
	instanceVariableNames: 'form'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #TranscriptMorph
	instanceVariableNames: 'form'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #StringMorph category: #'Morphic-Basic'!
RectangleLikeMorph subclass: #StringMorph
	instanceVariableNames: 'font emphasis contents hasFocus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

RectangleLikeMorph subclass: #StringMorph
	instanceVariableNames: 'font emphasis contents hasFocus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!classDefinition: #ProgressBarMorph category: #'Morphic-Widgets'!
BorderedRectMorph subclass: #ProgressBarMorph
	instanceVariableNames: 'value progressColor lastValue'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

BorderedRectMorph subclass: #ProgressBarMorph
	instanceVariableNames: 'value progressColor lastValue'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PasteUpMorph category: #'Morphic-Worlds'!
BorderedRectMorph subclass: #PasteUpMorph
	instanceVariableNames: 'worldState backgroundImage backgroundImageData'
	classVariableNames: 'DisableDeferredUpdates WindowEventHandler'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

BorderedRectMorph subclass: #PasteUpMorph
	instanceVariableNames: 'worldState backgroundImage backgroundImageData'
	classVariableNames: 'DisableDeferredUpdates WindowEventHandler'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

!classDefinition: #OneLineEditorMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #OneLineEditorMorph
	instanceVariableNames: 'font emphasis contents editor showCaret pauseBlinking caretRect keyboardFocusWatcher'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #OneLineEditorMorph
	instanceVariableNames: 'font emphasis contents editor showCaret pauseBlinking caretRect keyboardFocusWatcher'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #MinimalStringMorph category: #'Morphic-Basic'!
RectangleLikeMorph subclass: #MinimalStringMorph
	instanceVariableNames: 'font emphasis contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

RectangleLikeMorph subclass: #MinimalStringMorph
	instanceVariableNames: 'font emphasis contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #LayoutAdjustingMorph category: #'Morphic-Layouts'!
RectangleLikeMorph subclass: #LayoutAdjustingMorph
	instanceVariableNames: 'hand indicator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

RectangleLikeMorph subclass: #LayoutAdjustingMorph
	instanceVariableNames: 'hand indicator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #ImageMorph category: #'Morphic-Basic'!
RectangleLikeMorph subclass: #ImageMorph
	instanceVariableNames: 'image'
	classVariableNames: 'DefaultForm'
	poolDictionaries: ''
	category: 'Morphic-Basic'!

RectangleLikeMorph subclass: #ImageMorph
	instanceVariableNames: 'image'
	classVariableNames: 'DefaultForm'
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!classDefinition: #HoverHelpMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #HoverHelpMorph
	instanceVariableNames: 'contents paragraph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #HoverHelpMorph
	instanceVariableNames: 'contents paragraph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #FrameRateMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #FrameRateMorph
	instanceVariableNames: 'lastStepStamp lastStepDelta meanStepDelta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #FrameRateMorph
	instanceVariableNames: 'lastStepStamp lastStepDelta meanStepDelta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #FillInTheBlankMorph category: #'Morphic-Widgets'!
RectangleLikeMorph subclass: #FillInTheBlankMorph
	instanceVariableNames: 'response done textPane responseUponCancel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

RectangleLikeMorph subclass: #FillInTheBlankMorph
	instanceVariableNames: 'response done textPane responseUponCancel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1388-RectangleLikeMorph-JuanVuletich-2012Aug21-18h32m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1386] on 21 August 2012 at 4:49:26 pm'!
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/21/2012 16:25' prior: 50370299!
                 example1
"
	self example1
"
| pane row |
pane _ LayoutMorph newColumn separation: 5.
pane color: Color red.

row _ LayoutMorph newRow.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (BorderedRectMorph new color: (Color blue))
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue))
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/21/2012 16:26' prior: 50370359!
           example11
"
	self example11
"
| pane row |
pane _ LayoutMorph newColumn separation: 5.
pane color: Color red.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 10);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color blue))
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue))
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ LayoutMorph newRow separation: 5.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 8/21/2012 16:26' prior: 50370529!
            example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane color: Color lightGreen; morphBoundsInWorld: (120 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '1').

rect1 := BorderedRectMorph new color: (Color lightOrange); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect2.
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "2"
pane color: Color lightGreen; morphBoundsInWorld: (320 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '2').

rect1 := BorderedRectMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane color: Color lightGreen; morphBoundsInWorld: (520 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '3').

rect1 := BorderedRectMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := BorderedRectMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane openInWorld.! !

Smalltalk removeClassNamed: #RectangleMorph!

Smalltalk removeClassNamed: #RectangleMorph!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1389-KillRectangleMorph-JuanVuletich-2012Aug21-16h46m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1386] on 21 August 2012 at 4:51:25 pm'!

!classDefinition: #PluggableMorph category: #'Morphic-Views for Models'!
BorderedRectMorph subclass: #PluggableMorph
	instanceVariableNames: 'model'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

BorderedRectMorph subclass: #PluggableMorph
	instanceVariableNames: 'model '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 8/21/2012 16:51' prior: 50332808!
   createPackage

	| pkName |
	pkName _ FillInTheBlank request: 'Name for new package?'.
	CodePackage
		named: pkName
		createIfAbsent: true
		registerIfNew: true! !
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 8/21/2012 16:50' prior: 50332816!
       browseFullProtocol
	"Create and schedule a new protocol browser on the currently selected class or meta."

	| aPBrowser label |
	model selectedClassOrMetaClass ifNotNil: [ :classOrMetaclass |
		aPBrowser _ ProtocolBrowser new on: classOrMetaclass.
		label _ 'Entire protocol of: ', classOrMetaclass name.
		MessageSetWindow open: aPBrowser label: label ]! !
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 8/21/2012 16:50' prior: 50332830!
    browseProtocol
	"Create and schedule a new protocol browser on the currently selected class or meta."
	| aPBrowser label |
	model selectedClassOrMetaClass ifNotNil: [ :classOrMetaclass |
		aPBrowser _ ProtocolBrowser new onSubProtocolOf: classOrMetaclass.
		label _'Sub-protocol of: ', classOrMetaclass name.
		MessageSetWindow open: aPBrowser label: label ]! !

!classDefinition: #PluggableMorph category: #'Morphic-Views for Models'!
BorderedRectMorph subclass: #PluggableMorph
	instanceVariableNames: 'model'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

BorderedRectMorph subclass: #PluggableMorph
	instanceVariableNames: 'model'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1390-BorderedRectMorph-JuanVuletich-2012Aug21-16h49m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1386] on 21 August 2012 at 4:54:10 pm'!

!classDefinition: #AutoCompleterMorph category: #UCompletion!
BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'UCompletion'!

BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'UCompletion'!

!classDefinition: #MagnifierMorph category: #'Morphic-Widgets'!
BorderedRectMorph subclass: #MagnifierMorph
	instanceVariableNames: 'magnification trackPointer lastPos srcExtent auxCanvas magnifiedForm'
	classVariableNames: 'RecursionLock'
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

BorderedRectMorph subclass: #MagnifierMorph
	instanceVariableNames: 'magnification trackPointer lastPos srcExtent auxCanvas magnifiedForm '
	classVariableNames: 'RecursionLock '
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 8/21/2012 16:53' prior: 16807478!
                       allInstVarNamesEverywhere
	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"

	| aList |
	aList _ OrderedCollection new.
	(self allSuperclasses , self withAllSubclasses asOrderedCollection) do:
		[:cls | aList addAll: cls instVarNames].
	^ aList asSet

	"BorderedRectMorph allInstVarNamesEverywhere"! !
!BorderedRectMorph class methodsFor: 'instance protocol testing' stamp: 'jmv 8/21/2012 16:52' prior: 50370204!
                      gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(BorderedRectMorph)! !

!classDefinition: #MagnifierMorph category: #'Morphic-Widgets'!
BorderedRectMorph subclass: #MagnifierMorph
	instanceVariableNames: 'magnification trackPointer lastPos srcExtent auxCanvas magnifiedForm'
	classVariableNames: 'RecursionLock'
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

BorderedRectMorph subclass: #MagnifierMorph
	instanceVariableNames: 'magnification trackPointer lastPos srcExtent auxCanvas magnifiedForm'
	classVariableNames: 'RecursionLock'
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #AutoCompleterMorph category: #UCompletion!
BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'UCompletion'!

BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'UCompletion'!

Smalltalk removeClassNamed: #BorderedMorph!

Smalltalk removeClassNamed: #BorderedMorph!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1391-BorderedRectMorph-JuanVuletich-2012Aug21-16h51m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1386] on 21 August 2012 at 4:56:42 pm'!

!classDefinition: #HaloHandleMorph category: #'Morphic-Halos'!
RectangleLikeMorph subclass: #HaloHandleMorph
	instanceVariableNames: 'mouseDownSelector mouseUpSelector mouseMoveSelector keyStrokeSelector'
	classVariableNames: 'CircleForm'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

RectangleLikeMorph subclass: #HaloHandleMorph
	instanceVariableNames: 'mouseDownSelector mouseUpSelector mouseMoveSelector keyStrokeSelector '
	classVariableNames: 'CircleForm '
	poolDictionaries: ''
	category: 'Morphic-Halos'!

!classDefinition: #HaloMorph category: #'Morphic-Halos'!
RectangleLikeMorph subclass: #HaloMorph
	instanceVariableNames: 'target positionOffset angleOffset growingOrRotating haloBox'
	classVariableNames: 'HandleSize Icons'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

RectangleLikeMorph subclass: #HaloMorph
	instanceVariableNames: 'target positionOffset angleOffset growingOrRotating haloBox '
	classVariableNames: 'HandleSize Icons '
	poolDictionaries: ''
	category: 'Morphic-Halos'!

!classDefinition: #HandMorph category: #'Morphic-Kernel'!
RectangleLikeMorph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

RectangleLikeMorph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!classDefinition: #HandMorph category: #'Morphic-Kernel'!
RectangleLikeMorph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

RectangleLikeMorph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!classDefinition: #HaloMorph category: #'Morphic-Halos'!
RectangleLikeMorph subclass: #HaloMorph
	instanceVariableNames: 'target positionOffset angleOffset growingOrRotating haloBox'
	classVariableNames: 'HandleSize Icons'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

RectangleLikeMorph subclass: #HaloMorph
	instanceVariableNames: 'target positionOffset angleOffset growingOrRotating haloBox'
	classVariableNames: 'HandleSize Icons'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

!classDefinition: #HaloHandleMorph category: #'Morphic-Halos'!
RectangleLikeMorph subclass: #HaloHandleMorph
	instanceVariableNames: 'mouseDownSelector mouseUpSelector mouseMoveSelector keyStrokeSelector'
	classVariableNames: 'CircleForm'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

RectangleLikeMorph subclass: #HaloHandleMorph
	instanceVariableNames: 'mouseDownSelector mouseUpSelector mouseMoveSelector keyStrokeSelector'
	classVariableNames: 'CircleForm'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1392-Handles-JuanVuletich-2012Aug21-16h54m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1386] on 21 August 2012 at 5:04:21 pm'!
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 8/21/2012 17:01' prior: 50352221!
               buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.47;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 8/21/2012 16:58' prior: 50352322!
buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton backColor labelBackground |
	backColor _ self textBackgroundColor.	
	labelBackground _ Theme current background.
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.5;
		addAdjusterAndMorph: summary proportionalHeight: 0.18;
		addAdjusterAndMorph: description proportionalHeight: 0.22;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.1.
	self setLabel: 'Installed Packages'! !
!ReferenceStreamTest methodsFor: 'testing' stamp: 'jmv 8/21/2012 17:02' prior: 16928243!
                               testWeakDumps
	"Test that if we serialize a model with weak references to views, only the model is serialized and not the views.
	
	Note: The bug became apparent only when dumping a model to a SmartRefStream, that calls #references, and the serialized stream
	was later materialized in an image where the view classes had been deleted. In such rare cases, materialization would fail when trying to reference these
	absent classes. If serializing to a ReferenceStream, the bug didn't become apparent (views were never serialized). If serializing to a SmartRefStream, but
	view classes still existed, the bug didn't really become apparent (because views were not actually deserialized), the only effect was a larger file.
	
	ReferenceStreamTest new testWeakDumps
	"
	| oldInstance window refStream |
	oldInstance _ TextModel withText: 'This is a text'.
	window _ SystemWindow editText: oldInstance label: 'old instance' wrap: true.
	refStream _ ReferenceStream on: (DummyStream on: nil).
	refStream nextPut: oldInstance.
	self deny: (refStream references keys anySatisfy: [ :dumpedObject | dumpedObject isKindOf: Morph ]).
	window delete! !
!SmartRefStreamTest methodsFor: 'testing' stamp: 'jmv 8/21/2012 17:00' prior: 16944049!
                     testWeakDumps
	"Test that if we serialize a model with weak references to views, only the model is serialized and not the views.
	
	Note: The bug became apparent only when dumping a model to a SmartRefStream, that calls #references, and the serialized stream
	was later materialized in an image where the view classes had been deleted. In such rare cases, materialization would fail when trying to reference these
	absent classes. If serializing to a ReferenceStream, the bug didn't become apparent (views were never serialized). If serializing to a SmartRefStream, but
	view classes still existed, the bug didn't really become apparent (because views were not actually deserialized), the only effect was a larger file.
	
	SmartRefStreamTest new testWeakDumps
	"
	| oldInstance window refStream |
	oldInstance _ TextModel withText: 'This is a text'.
	window _ SystemWindow editText: oldInstance label: 'old instance' wrap: true.
	refStream _ SmartRefStream on: (DummyStream on: nil).
	refStream nextPut: oldInstance.
	self deny: (refStream references keys anySatisfy: [ :dumpedObject | dumpedObject isKindOf: Morph ]).
	window delete! !
!TaskbarTaskTest methodsFor: 'as yet unclassified' stamp: 'cbr 4/19/2011 18:18' prior: 16967355!
              setUp

	morph _ Morph new.
	task _ TaskbarTask new minimize: morph! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1393-MorphNotSizeable-JuanVuletich-2012Aug21-16h56m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1393] on 21 August 2012 at 6:51:51 pm'!

!classDefinition: #RectangleLikeMorph category: #'Morphic-Kernel'!
Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent ccolor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent ccolor '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!RectangleLikeMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 18:46'!
               color: aColor
	"Set the receiver's color. "
	ccolor = aColor ifFalse: [
		color _ aColor.
		ccolor _ aColor.
		self redrawNeeded ]! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:46'!
           defaultColor
	^ Color orange! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:49'!
                 initialize
	super initialize.
	xtent _ self defaultBounds extent.
	ccolor _ self defaultColor! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 18:48'!
                      basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	xtent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	extent _ aPoint.
	xtent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!HaloMorph methodsFor: 'event handling' stamp: 'jmv 8/21/2012 18:42'!
              transferHalo: event  localPosition: localEventPosition
	"Transfer the halo to the next likely recipient"
	target ifNil: [ ^self delete ].
	target transferHalo: event from: target.! !
!Morph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 18:47' prior: 16896111!
                            color: aColor

"borrarlo!!"

	"Set the receiver's color. "
	color = aColor ifFalse: [
		color _ aColor.
		self redrawNeeded ]! !
!Morph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:49' prior: 50359212!
             defaultBounds
"answer the default bounds for the receiver"

	"Maybe shouldn't exist... INDEED!!"
	self flag: #jmvVer2.
	"Anyway, many morphs redefine #initialize asigning an extent... Unify in some style.
	Maybe #defaultExtent?"
	^ 0 @ 0 corner: 50 @ 40! !
!Morph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:47' prior: 50358829!
             initialize
	"initialize the state of the receiver"

	| b |
	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	b _ self defaultBounds.
	position _ b topLeft.
	extent _ b extent.
	color _ self defaultColor.		"borrar este!!"
	layoutNeeded _ false! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:51' prior: 50359223!
         initialize

	super initialize.
	extent _  271@121.
	xtent _  271@121.
	responseUponCancel _ ''
	! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 18:42' prior: 50367590!
              mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition
	"Transfer the halo to the next likely recipient"
	target ifNil:[^self delete].
	aMouseButtonEvent hand obtainHalo: self.
	positionOffset _ aMouseButtonEvent eventPosition - target morphPosition.
	"wait for drags or transfer"
	aMouseButtonEvent hand 
		waitForClicksOrDrag: self 
		event: aMouseButtonEvent
		clkSel: #transferHalo:localPosition:
		dblClkSel: nil! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:51' prior: 50358928!
                      initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	xtent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:49' prior: 50359229!
              initialize
	"initialize the state of the receiver"
	super initialize.
	extent _ 12 @ 12.
	xtent _ 12@12! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 18:47' prior: 16869903!
                               textColor: aColor

	ccolor = aColor ifTrue: [^ self].
	color _ aColor.
	ccolor _ aColor.
	self redrawNeeded! !
!LimitedHeightTextMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:50' prior: 50359235!
              initialize
	super initialize.
	extent _  200 @ 120.
	xtent _  200 @ 120! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:50' prior: 50359240!
                          initialize
	super initialize.
	trackPointer _ true.
	magnification _ 2.
	lastPos _ self sourcePoint.
	extent _ 128@128.
	xtent _ 128@128! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:51' prior: 50359247!
                          initialize
	super initialize.
	extent _ extent x @ 2.
	xtent _ xtent x @ 2! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:49' prior: 50358977!
                            initialize
	super initialize.
	position _ 0@0.
	extent _ 40@10.
	xtent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 18:50' prior: 50359001!
            morphExtent: aPoint

	self flag: #jmvVer2.
	xtent = aPoint ifFalse: [
		self redrawNeeded.
		extent _ aPoint.
		xtent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = self morphBoundsInWorld ifFalse: [
				worldState canvas: nil.
				worldState viewBox: self morphBoundsInWorld ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/21/2012 18:50' prior: 50359035!
                       viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	position _ owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ].
	extent _ newViewBox extent.
	xtent _ newViewBox extent! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:50' prior: 50359252!
                        initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	extent _  20 @ 15.
	xtent _  20 @ 15! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:50' prior: 50359266!
 initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	extent _ 300 @ 200.
	xtent _ 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !

HaloMorph removeSelector: #transferHalo:!

HaloMorph removeSelector: #transferHalo:!

!classDefinition: #RectangleLikeMorph category: #'Morphic-Kernel'!
Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent ccolor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent ccolor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1394-MorphNotSizeable-JuanVuletich-2012Aug21-18h38m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1394] on 21 August 2012 at 8:29:11 pm'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts'!
BorderedRectMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction separation padding'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

BorderedRectMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction separation padding'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
RectangleLikeMorph allSubInstancesDo: [ :m |
	(m instVarNamed: 'xtent') ifNil: [ m instVarNamed: 'xtent' put: (m instVarNamed: 'extent') ].
	(m instVarNamed: 'ccolor') ifNil: [ m instVarNamed: 'ccolor' put: (m instVarNamed: 'color') ]].
BorderedRectMorph allSubInstancesDo: [ :m |
	(m instVarNamed: 'borderWidth') ifNil: [ m instVarNamed: 'borderWidth' put: (m instVarNamed: '0') ].
	(m instVarNamed: 'borderColor') ifNil: [ m instVarNamed: 'borderColor' put: (m instVarNamed: 'color') ]].!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1395-LayoutMorph-JuanVuletich-2012Aug21-20h25m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1393] on 21 August 2012 at 7:04:28 pm'!

"Change Set:		1396-CuisCore-JuanVuletich-2012Aug21-18h54m
Date:			21 August 2012
Author:			Juan Vuletich

<your descriptive text goes here>"
Taskbar reset.
"Taskbar show."
!
!RectangleLikeMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 18:54'!
               color

	^ ccolor! !
!BorderedRectMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:55' prior: 50370149!
                     drawOn: aCanvas

	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: ccolor borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor! !
!BorderedRectMorph methodsFor: 'testing' stamp: 'jmv 8/21/2012 18:55' prior: 50370190!
                     isOpaqueMorph
	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)
	but is not an opaque rectangle covering bounds MUST answer false to this message"
	ccolor mightBeTranslucent ifTrue: [
		^false ].
	borderWidth > 0 ifTrue: [
		borderColor mightBeTranslucent ifTrue: [
			^false ]].
	^true! !
!EllipseMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:55' prior: 50353270!
   drawOn: aCanvas 

	| r |
	r _ self morphBoundsInWorld.
	aCanvas isShadowDrawing
		ifTrue: [^ aCanvas fillOval: r color:  ccolor borderWidth: 0 borderColor: nil].
	aCanvas fillOval: r color: ccolor borderWidth: borderWidth borderColor: borderColor.
! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:56' prior: 50353300!
           drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				roundRect: self morphBoundsInWorld
				color: ccolor
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		fillRectangle: textPane morphBoundsInWorld
		colorOrInfiniteForm: (Theme current paneBackgroundFrom: ccolor)! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:59' prior: 50358886!
        drawOn: aCanvas

	aCanvas
		image: (self class circleForm: xtent)
		multipliedBy: (ccolor alpha: 0.57)
		at: self morphPositionInWorld! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 8/21/2012 18:59' prior: 50358893!
      step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target morphBoundsInWorld]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = self morphBoundsInWorld
		ifTrue: [^ self].
	newBounds extent = xtent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating ifFalse: [
		submorphs size > 1
			ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self morphBoundsInWorld: newBounds! !
!HaloMorph methodsFor: 'updating' stamp: 'jmv 8/21/2012 18:59' prior: 50358911!
                               redrawNeeded
	"Quicker to invalidate handles individually if target is large (especially the world)"

	xtent > (200@200)
		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [
					"Invalidate 4 outer strips first, thus subsuming separate damage."
					(self morphFullBoundsInWorld areasOutside: target morphBoundsInWorld) do:
						[ :r | self invalidRect: r ]].
				self submorphsDo: [:m | m redrawNeeded]]
		ifFalse: [ super redrawNeeded ]! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 18:59' prior: 50358938!
      borderWidth: bw

	| newExtent |
	newExtent _ 2 * bw + image extent.
	xtent = newExtent ifFalse: [
		self basicExtent: newExtent ]! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 18:56' prior: 16869900!
     textColor

	^ ccolor! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:56' prior: 50353532!
                    drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		paragraph: self paragraph
		bounds: self morphBoundsInWorld
		color: ccolor
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 18:59' prior: 50358945!
                        morphExtent: aPoint
	| newExtent |
	"Resist changing the extent if no wordwrap.. this should be checked."
	wrapFlag ifFalse: [ ^ self ].
	newExtent _ aPoint truncated max: self minimumExtent.
	
	"No change of wrap width"
	newExtent x = xtent x ifTrue: [ ^ self ].

	super morphExtent: newExtent.
	
	self resetParagraph.
	self editor recomputeSelection.	
	self updateFromParagraph.! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 18:59' prior: 50358960!
            fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent |
	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).
	xtent = newExtent ifFalse: [
		self basicExtent: newExtent ].

	self redrawNeeded.	"Too conservative: only paragraph composition
							should cause invalidation."
	owner innerHeight: newExtent y! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:56' prior: 50353639!
            drawOn: aCanvas
	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: ccolor borderWidth: 2 borderStyleSymbol: #raised! !
!LayoutAdjustingMorph methodsFor: 'testing' stamp: 'jmv 8/21/2012 18:56' prior: 50349626!
                             isOpaqueMorph
	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)
	but is not an opaque rectangle covering bounds MUST answer false to this message"
	ccolor mightBeTranslucent ifTrue: [
		^false ].
	^true! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 8/21/2012 18:58' prior: 50348925!
                        chooseMagnification
	| result |
	result _ (SelectionMenu selections: #(1.5 2 4 8))
		startUpWithCaption: 'Choose magnification
(currently ', magnification printString, ')'.
	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].
	magnification _ result.
	self morphExtent: xtent. "round to new magnification"
	self redrawNeeded. "redraw even if extent wasn't changed"! !
!MenuMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:55' prior: 50353804!
                  drawOn: aCanvas
	
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas roundRect: self morphBoundsInWorld color: ccolor radius: Theme current roundedWindowRadius ]
		ifFalse: [
			aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: ccolor borderWidth: borderWidth borderStyleSymbol: #raised baseColorForBorder: ccolor ]! !
!MinimalStringMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:56' prior: 50353819!
 drawOn: aCanvas

	aCanvas drawString: contents in: self morphBoundsInWorld font: self fontToUse color: ccolor! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 18:59' prior: 50358985!
                     fitContents

	| newExtent |
	newExtent _ self measureContents.
	xtent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 18:59' prior: 50358993!
                 fitContents

	| newExtent |
	newExtent _ self measureContents.
	xtent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:59' prior: 50369997!
                   characterIndexAtPoint: aPoint

	| line block f |
	f _ self fontToUse.
	
	line _ TextLine 
		start: 1
		stop: contents size
		internalSpaces: 0
		paddingWidth: 0.
	line
		rectangle: (0@0 extent: xtent);
		lineHeight: f height baseline: f ascent.
		
	block _ (CharacterBlockScanner new text: 
			(contents asText font: font))
		characterBlockAtPoint: aPoint index: nil
		in: line.

	^ block stringIndex! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:56' prior: 50353826!
                    drawOn: aCanvas
	self hasSelection ifTrue: [
		self drawSelectionOn: aCanvas ].
	self hasVisibleCaret ifTrue: [
		self drawCaretOn: aCanvas].
	aCanvas drawString: contents in: self morphBoundsInWorld font: self fontToUse color: ccolor! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:57' prior: 50357182!
drawOn: aCanvas

	"draw background image."
	| b |
	b _ self morphBoundsInWorld.
	backgroundImage
		ifNotNil: [
			"self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"
			self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage at: b topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage at: b topLeft ]]

		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [ccolor class == TranslucentColor])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt current toForm: Display)
						clipRect: aCanvas clipRect;
						copy: b
						from: 0@0 in: nil
						fillColor: ccolor rule: Form over]
				ifFalse: [ super drawOn: aCanvas ]]! !
!PasteUpMorph methodsFor: 'misc' stamp: 'jmv 8/21/2012 18:58' prior: 50359017!
   buildMagnifiedBackgroundImage
	| image old |
	old _ backgroundImage.
	backgroundImageData
		ifNil: [ backgroundImage _ nil ]
		ifNotNil: [ 
			image _ Form fromBinaryStream: backgroundImageData readStream.
			backgroundImage _ image magnifyTo: xtent.
			self canvas ifNotNil: [ :c |
				(backgroundImage depth = 32 and: [ c depth < 32 ]) ifTrue: [
					backgroundImage _ backgroundImage orderedDither32To16 ]]
		].
	old == backgroundImage ifFalse: [
		self redrawNeeded ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:57' prior: 50357292!
           draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ ccolor.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: self morphBoundsInWorld
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:58' prior: 50357307!
                          drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y b |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		b _ self morphBoundsInWorld.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ b center.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ b width-labelMargin-labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ b left + labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawStringEmbossed: l
			in: (x@y extent: xtent - (labelMargin*2-2@4))
			font: f
			color: colorForLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:58' prior: 50357344!
               drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin b |

	f _ self fontToUse.
	b _ self morphBoundsInWorld.
	center _ b center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ b width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ b left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: xtent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:57' prior: 50353901!
    drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	rect _ self morphBoundsInWorld insetBy: 1@3.
	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: ccolor hue s: ccolor saturation * 1.3 v: ccolor brightness * 0.9 ]
				ifFalse: [
					colorForButton _ ccolor ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ ccolor adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 18:58' prior: 50349110!
             magnifiedIcon
	| b |
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		self isRoundButton
			ifFalse: [ ^ magnifiedIcon ].
		b _ xtent x max: xtent y.
		b < icon extent x ifTrue: [
			magnifiedIcon _ icon magnifyTo: b@b ].
		b /  icon extent x > 1.7
			ifTrue: [	
				b _ b * 3 // 4.
				magnifiedIcon _ icon magnifyTo: b @ b]].
	^magnifiedIcon! !
!ScrollBar methodsFor: 'access' stamp: 'jmv 8/21/2012 18:55' prior: 16934861!
                      color: aColor
	"Change the color of the scrollbar to go with aColor."
	| buttonColor |
	super color: aColor.
	buttonColor _ ccolor alphaMixed: 0.7 with: (Color gray: 0.95).
	upButton color: buttonColor.
	downButton color: buttonColor.
	slider color: buttonColor slightlyLighter.
	sliderShadow color: (ccolor alphaMixed: 0.45 with: Color white)! !
!ScrollBar methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:55' prior: 50354302!
                      drawOn: aCanvas

	aCanvas
		fillRectangle: self morphBoundsInWorld
		colorOrInfiniteForm: (ccolor alphaMixed: 0.3 with: Color white)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 8/21/2012 18:58' prior: 50359049!
              morphExtent: newExtent

	| newExtentToUse |
	newExtent = xtent ifTrue: [^ self].
	newExtentToUse _ self isHorizontal
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = xtent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 8/21/2012 18:56' prior: 16935013!
                           recreateSubmorphs
	self removeAllMorphs.
	self
		initializeUpButton;
		initializeDownButton;
		initializeSlider.
	"Set color for submorphs"
	self color: ccolor.! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 18:59' prior: 50359065!
         fitContents

	| newExtent |
	newExtent _ self measureContents.
	xtent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!StringMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:56' prior: 50354365!
                          drawOn: aCanvas

	aCanvas drawString: contents in: self morphBoundsInWorld font: self fontToUse color: ccolor.! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:56' prior: 50369946!
                  drawOn: aCanvas

	| tRect sRect columnRect columnScanner columnData columnLeft colorToUse |

	tRect := self toggleRectangle translatedBy: self morphPositionInWorld.
	sRect := self morphBoundsInWorld withLeft: tRect right + 4.
	self drawToggleOn: aCanvas in: tRect.
	colorToUse _ complexContents preferredColor ifNil: [ccolor].
	(container columns isNil or: [(contents asString indexOf: Character tab) = 0]) ifTrue: [
		aCanvas drawString: contents asString in: sRect font: self fontToUse color: colorToUse.
	] ifFalse: [
		columnLeft _ sRect left.
		columnScanner _ ReadStream on: contents asString.
		container columns do: [ :width |
			columnRect _ columnLeft @ sRect top extent: width @ sRect height.
			columnData _ columnScanner upTo: Character tab.
			columnData isEmpty ifFalse: [
				aCanvas drawString: columnData in: columnRect font: self fontToUse color: colorToUse.
			].
			columnLeft _ columnRect right + 5.
		].
	]
! !
!IndentingListItemMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 18:59' prior: 50369979!
                              toggleRectangle

	^(12*indentLevel @ 0) extent: 12@xtent y! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:57' prior: 50357025!
               drawOn: aCanvas 
	| stringColor stringBounds leftEdge b |

	b _ self morphBoundsInWorld.
	stringColor _ ccolor.
	isSelected & isEnabled
		ifTrue: [
			aCanvas fillRectangle: b colorOrInfiniteForm: Theme current menuHighlight].
	leftEdge := 0.
	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ].
			aCanvas image: iconForm at: b left+1 @ (b top + (b height - iconForm height // 2)).
			leftEdge _ iconForm width + self iconSeparation].

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + self submorphBounds width + 8 ].

	stringBounds _ b left + leftEdge @ (b top + 1) corner: b corner.

	aCanvas
		drawString: contents
		in: stringBounds
		font: self fontToUse
		color: stringColor.
	subMenu
		ifNotNil: [ aCanvas image: SubMenuMarker at: b right - 8 @ (b top + b bottom - SubMenuMarker height // 2) ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:56' prior: 50357684!
    addPossiblyUncoveredAreasIn: aRectangle to: aCollection
	"Answer an array of rectangles encompassing those areas in aRectangle not completely
	covered by self. These are the areas that might require further drawing (of morphs below us)
	All areas that might possibly be uncovered must be included."
	 | r |
	ccolor mightBeTranslucent ifTrue: [
		aCollection add: aRectangle.
		^self ].

	"Solid rectangle.
	This will be the fastest in many cases. So, please disable rounded corners if on slow hardware!!"
	Theme current roundWindowCorners ifFalse: [
		aRectangle areasOutside: self morphBoundsInWorld do: [ :rr |  aCollection add: rr ].
		^self ].

	"The solid rectangle does not include the corners.
	Report a couple of rows (top and bottom) or columns (left and right) as uncovered areas.
	We could also try to be more careful and answer each rounded corner...
	Right now, report top and bottom rows as uncovered areas"
	r _ Theme current roundedWindowRadius.
	aRectangle areasOutside: (self morphBoundsInWorld insetBy: 0@r) do: [ :rr |  aCollection add: rr ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:55' prior: 50357720!
     drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: ccolor borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	aCanvas fillRectangle: self titleAreaInnerRect colorOrInfiniteForm: titleColor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:56' prior: 50357735!
                      drawRoundedFrameOn: aCanvas color: widgetsColor
	"Title area is not inside window borders"
	| bottomFactor topFactor |
	Theme current useWindowTitleGradient
		ifTrue: [
			topFactor _ Theme current titleGradientTopFactor.
			bottomFactor _ Theme current titleGradientBottomFactor ]
		ifFalse: [
			topFactor _ 1.
			bottomFactor _ 1 ].
	aCanvas
		windowFrame: self morphBoundsInWorld 
		color: widgetsColor * Theme current titleGradientExtraLightness
		radius: Theme current roundedWindowRadius
		border: borderWidth
		labelHeight: self labelHeight + borderWidth
		gradientTop: topFactor
		gradientBottom: bottomFactor
		insideColor: ccolor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/21/2012 18:58' prior: 50350402!
          makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: xtent world: self world) topLeft! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 8/21/2012 18:58' prior: 50350428!
                     morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = xtent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent]! !
!SystemWindow methodsFor: 'testing' stamp: 'jmv 8/21/2012 18:56' prior: 16965677!
                             isOpaqueMorph
	"Not really used, as we also reimplement #addPossiblyUncoveredAreasIn:to:"
	^(Theme current roundWindowCorners or: [ ccolor mightBeTranslucent ]) not! !

RectangleLikeMorph removeSelector: #morphExtent!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1396-RemoveMorphIvars1-JuanVuletich-2012Aug21-18h54m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1396] on 21 August 2012 at 8:38:41 pm'!
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:37'!
             morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ xtent! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:37'!
                         morphExtentInOwner
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ xtent! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:38'!
                  morphHeight

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ xtent y! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:37'!
                       morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ xtent x! !
!BorderedRectMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:36' prior: 50370157!
         innerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

	^ self morphBoundsInWorld insetBy: borderWidth! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1397-RemoveMorphIvars2-JuanVuletich-2012Aug21-20h36m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1396] on 21 August 2012 at 8:43:07 pm'!
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:42'!
        morphExtent: aPoint
"assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self basicExtent: aPoint! !
!Morph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 20:40' prior: 16896108!
                             color

	^ Color blue! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:41' prior: 50358659!
                            morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ 50 @ 40! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:41' prior: 50368898!
                    morphExtentInOwner
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ 50 @ 40! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:41' prior: 50358667!
             morphHeight

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ 40! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:41' prior: 50358823!
                         morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ 50! !
!Morph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:42' prior: 50372192!
                    initialize
	"initialize the state of the receiver"

	| b |
	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	b _ self defaultBounds.
	position _ b topLeft.
	layoutNeeded _ false! !
!RectangleLikeMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 20:39' prior: 50372133!
                color: aColor
	"Set the receiver's color. "
	ccolor = aColor ifFalse: [
		ccolor _ aColor.
		self redrawNeeded ]! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:38' prior: 50372150!
                   basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	xtent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	xtent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:39' prior: 50372208!
      initialize

	super initialize.
	xtent _  271@121.
	responseUponCancel _ ''
	! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:39' prior: 50372231!
                          initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	position _ 0@0.
	xtent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:39' prior: 50372242!
                      initialize
	"initialize the state of the receiver"
	super initialize.
	xtent _ 12@12! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 20:40' prior: 50372249!
                  textColor: aColor

	ccolor = aColor ifTrue: [^ self].
	ccolor _ aColor.
	self redrawNeeded! !
!LimitedHeightTextMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:39' prior: 50372256!
                               initialize
	super initialize.
	xtent _  200 @ 120! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:39' prior: 50372262!
                initialize
	super initialize.
	trackPointer _ true.
	magnification _ 2.
	lastPos _ self sourcePoint.
	xtent _ 128@128! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:39' prior: 50372270!
             initialize
	super initialize.
	xtent _ xtent x @ 2! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:39' prior: 50372276!
                    initialize
	super initialize.
	position _ 0@0.
	xtent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 20:39' prior: 50372284!
                             morphExtent: aPoint

	self flag: #jmvVer2.
	xtent = aPoint ifFalse: [
		self redrawNeeded.
		xtent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = self morphBoundsInWorld ifFalse: [
				worldState canvas: nil.
				worldState viewBox: self morphBoundsInWorld ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/21/2012 20:39' prior: 50372301!
          viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	position _ owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ].
	xtent _ newViewBox extent! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:39' prior: 50372317!
                     initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	xtent _  20 @ 15! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 8/21/2012 20:39' prior: 50372331!
                     initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	xtent _ 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !

Morph removeSelector: #basicExtent:!

Morph removeSelector: #basicExtent:!

Morph removeSelector: #color:!

Morph removeSelector: #color:!

Morph removeSelector: #defaultColor!

Morph removeSelector: #defaultColor!

Morph removeSelector: #morphExtent:!

Morph removeSelector: #morphExtent:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1398-RemoveMorphIvars3-JuanVuletich-2012Aug21-20h38m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1396] on 21 August 2012 at 8:43:27 pm'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'owner submorphs color extension position extent layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'owner submorphs color extension position extent layoutNeeded '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension position layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension position layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1399-RemoveMorphIvars4-JuanVuletich-2012Aug21-20h43m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1399] on 21 August 2012 at 9:46:20 pm'!

!classDefinition: #RectangleLikeMorph category: #'Morphic-Kernel'!
Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent ccolor color extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent ccolor color extent '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!classDefinition: #RectangleLikeMorph category: #'Morphic-Kernel'!
Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent ccolor extent color'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'xtent ccolor extent color'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
RectangleLikeMorph allSubInstancesDo: [ :m |
	m instVarNamed: 'color' put: (m instVarNamed: 'ccolor').
	m instVarNamed: 'extent' put: (m instVarNamed: 'xtent') ]!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1400-RemoveMorphIvars5-JuanVuletich-2012Aug21-21h43m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1400] on 21 August 2012 at 9:51:59 pm'!
!RectangleLikeMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 21:51' prior: 50373222!
                        color: aColor
	"Set the receiver's color. "
	color = aColor ifFalse: [
		ccolor _ aColor.
		color _ aColor.
		self redrawNeeded ]! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:49' prior: 50372144!
                            initialize
	super initialize.
	xtent _ self defaultBounds extent.
	extent _ self defaultBounds extent.
	ccolor _ self defaultColor.
	color _ self defaultColor! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:49' prior: 50373229!
     basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	xtent _ aPoint.
	extent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:50' prior: 50373244!
                   initialize

	super initialize.
	xtent _  271@121.
	extent _  271@121.
	responseUponCancel _ ''
	! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:51' prior: 50373250!
      initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	position _ 0@0.
	xtent _ CursorWithMask normal extent.
	extent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:49' prior: 50373260!
              initialize
	"initialize the state of the receiver"
	super initialize.
	xtent _ 12@12.
	extent _ 12@12! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 21:51' prior: 50373266!
 textColor: aColor

	color = aColor ifTrue: [^ self].
	ccolor _ aColor.
	color _ aColor.
	self redrawNeeded! !
!LimitedHeightTextMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:50' prior: 50373273!
               initialize
	super initialize.
	xtent _  200 @ 120.
	extent _  200 @ 120! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:50' prior: 50373278!
                          initialize
	super initialize.
	trackPointer _ true.
	magnification _ 2.
	lastPos _ self sourcePoint.
	xtent _ 128@128.
	extent _ 128@128! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:50' prior: 50373285!
                          initialize
	super initialize.
	xtent _ xtent x @ 2.
	extent _ xtent x @ 2! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:49' prior: 50373290!
                             initialize
	super initialize.
	position _ 0@0.
	xtent _ 40@10.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:50' prior: 50373298!
            morphExtent: aPoint

	self flag: #jmvVer2.
	extent = aPoint ifFalse: [
		self redrawNeeded.
		xtent _ aPoint.
		extent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = self morphBoundsInWorld ifFalse: [
				worldState canvas: nil.
				worldState viewBox: self morphBoundsInWorld ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/21/2012 21:50' prior: 50373314!
                      viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	position _ owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ].
	xtent _ newViewBox extent.
	extent _ newViewBox extent! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:50' prior: 50373329!
                        initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	xtent _  20 @ 15.
	extent _  20 @ 15! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:50' prior: 50373343!
 initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	xtent _ 300 @ 200.
	extent _ 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
RectangleLikeMorph allSubInstancesDo: [ :m |
	m instVarNamed: 'color' put: (m instVarNamed: 'ccolor').
	m instVarNamed: 'extent' put: (m instVarNamed: 'xtent') ]!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1401-RemoveMorphIvars6-JuanVuletich-2012Aug21-21h48m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1400] on 21 August 2012 at 9:58:21 pm'!
!RectangleLikeMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 21:54' prior: 50372436!
                             color

	^ color! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:52' prior: 50373124!
                    morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ extent! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:52' prior: 50373132!
        morphExtentInOwner
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ extent! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:52' prior: 50373140!
 morphHeight

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ extent y! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:52' prior: 50373146!
      morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ extent x! !
!BorderedRectMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:54' prior: 50372440!
         drawOn: aCanvas
	aCanvas
		fillRectangle: self morphBoundsInWorld
		colorOrInfiniteForm: color
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!BorderedRectMorph methodsFor: 'testing' stamp: 'jmv 8/21/2012 21:54' prior: 50372449!
             isOpaqueMorph
	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)
	but is not an opaque rectangle covering bounds MUST answer false to this message"
	color mightBeTranslucent ifTrue: [
		^false ].
	borderWidth > 0 ifTrue: [
		borderColor mightBeTranslucent ifTrue: [
			^false ]].
	^true! !
!EllipseMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:55' prior: 50372462!
    drawOn: aCanvas 

	| r |
	r _ self morphBoundsInWorld.
	aCanvas isShadowDrawing
		ifTrue: [^ aCanvas fillOval: r color:  color borderWidth: 0 borderColor: nil].
	aCanvas fillOval: r color: color borderWidth: borderWidth borderColor: borderColor.
! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:56' prior: 50372473!
             drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				roundRect: self morphBoundsInWorld
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		fillRectangle: textPane morphBoundsInWorld
		colorOrInfiniteForm: (Theme current paneBackgroundFrom: color)! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:57' prior: 50372488!
          drawOn: aCanvas

	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: (color alpha: 0.57)
		at: self morphPositionInWorld! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 8/21/2012 21:54' prior: 50372495!
      step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target morphBoundsInWorld]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = self morphBoundsInWorld
		ifTrue: [^ self].
	newBounds extent = extent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating ifFalse: [
		submorphs size > 1
			ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self morphBoundsInWorld: newBounds! !
!HaloMorph methodsFor: 'updating' stamp: 'jmv 8/21/2012 21:54' prior: 50372513!
                              redrawNeeded
	"Quicker to invalidate handles individually if target is large (especially the world)"

	extent > (200@200)
		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [
					"Invalidate 4 outer strips first, thus subsuming separate damage."
					(self morphFullBoundsInWorld areasOutside: target morphBoundsInWorld) do:
						[ :r | self invalidRect: r ]].
				self submorphsDo: [:m | m redrawNeeded]]
		ifFalse: [ super redrawNeeded ]! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 21:53' prior: 50372530!
     borderWidth: bw

	| newExtent |
	newExtent _ 2 * bw + image extent.
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ]! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 21:56' prior: 50372537!
    textColor

	^ color! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:56' prior: 50372541!
                     drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		paragraph: self paragraph
		bounds: self morphBoundsInWorld
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:53' prior: 50372554!
                         morphExtent: aPoint
	| newExtent |
	"Resist changing the extent if no wordwrap.. this should be checked."
	wrapFlag ifFalse: [ ^ self ].
	newExtent _ aPoint truncated max: self minimumExtent.
	
	"No change of wrap width"
	newExtent x = extent x ifTrue: [ ^ self ].

	super morphExtent: newExtent.
	
	self resetParagraph.
	self editor recomputeSelection.	
	self updateFromParagraph.! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 21:53' prior: 50372569!
           fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent |
	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ].

	self redrawNeeded.	"Too conservative: only paragraph composition
							should cause invalidation."
	owner innerHeight: newExtent y! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:56' prior: 50372586!
           drawOn: aCanvas
	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: color borderWidth: 2 borderStyleSymbol: #raised! !
!LayoutAdjustingMorph methodsFor: 'testing' stamp: 'jmv 8/21/2012 21:56' prior: 50372594!
                              isOpaqueMorph
	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)
	but is not an opaque rectangle covering bounds MUST answer false to this message"
	color mightBeTranslucent ifTrue: [
		^false ].
	^true! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 8/21/2012 21:53' prior: 50372605!
                         chooseMagnification
	| result |
	result _ (SelectionMenu selections: #(1.5 2 4 8))
		startUpWithCaption: 'Choose magnification
(currently ', magnification printString, ')'.
	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].
	magnification _ result.
	self morphExtent: extent. "round to new magnification"
	self redrawNeeded. "redraw even if extent wasn't changed"! !
!MenuMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:57' prior: 50372620!
                 drawOn: aCanvas
	
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas roundRect: self morphBoundsInWorld color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #raised baseColorForBorder: color ]! !
!MinimalStringMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:56' prior: 50372635!
    drawOn: aCanvas

	aCanvas drawString: contents in: self morphBoundsInWorld font: self fontToUse color: color! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 21:53' prior: 50372642!
                      fitContents

	| newExtent |
	newExtent _ self measureContents.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 21:54' prior: 50372650!
                fitContents

	| newExtent |
	newExtent _ self measureContents.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:54' prior: 50372658!
                  characterIndexAtPoint: aPoint

	| line block f |
	f _ self fontToUse.
	
	line _ TextLine 
		start: 1
		stop: contents size
		internalSpaces: 0
		paddingWidth: 0.
	line
		rectangle: (0@0 extent: extent);
		lineHeight: f height baseline: f ascent.
		
	block _ (CharacterBlockScanner new text: 
			(contents asText font: font))
		characterBlockAtPoint: aPoint index: nil
		in: line.

	^ block stringIndex! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:56' prior: 50372674!
                   drawOn: aCanvas
	self hasSelection ifTrue: [ self drawSelectionOn: aCanvas ].
	self hasVisibleCaret ifTrue: [ self drawCaretOn: aCanvas ].
	aCanvas
		drawString: contents
		in: self morphBoundsInWorld
		font: self fontToUse
		color: color! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:55' prior: 50372684!
                            drawOn: aCanvas

	"draw background image."
	| b |
	b _ self morphBoundsInWorld.
	backgroundImage
		ifNotNil: [
			"self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"
			self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage at: b topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage at: b topLeft ]]

		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [color class == TranslucentColor])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt current toForm: Display)
						clipRect: aCanvas clipRect;
						copy: b
						from: 0@0 in: nil
						fillColor: color rule: Form over]
				ifFalse: [ super drawOn: aCanvas ]]! !
!PasteUpMorph methodsFor: 'misc' stamp: 'jmv 8/21/2012 21:52' prior: 50372723!
     buildMagnifiedBackgroundImage
	| image old |
	old _ backgroundImage.
	backgroundImageData
		ifNil: [ backgroundImage _ nil ]
		ifNotNil: [ 
			image _ Form fromBinaryStream: backgroundImageData readStream.
			backgroundImage _ image magnifyTo: extent.
			self canvas ifNotNil: [ :c |
				(backgroundImage depth = 32 and: [ c depth < 32 ]) ifTrue: [
					backgroundImage _ backgroundImage orderedDither32To16 ]]
		].
	old == backgroundImage ifFalse: [
		self redrawNeeded ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:55' prior: 50372741!
          draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: self morphBoundsInWorld
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:53' prior: 50372756!
                           drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y b |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		b _ self morphBoundsInWorld.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ b center.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ b width-labelMargin-labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ b left + labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawStringEmbossed: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: colorForLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:53' prior: 50372793!
              drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin b |

	f _ self fontToUse.
	b _ self morphBoundsInWorld.
	center _ b center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ b width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ b left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:55' prior: 50372817!
   drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	rect _ self morphBoundsInWorld insetBy: 1@3.
	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 21:53' prior: 50372857!
                  magnifiedIcon
	| b |
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		self isRoundButton
			ifFalse: [ ^ magnifiedIcon ].
		b _ extent x max: extent y.
		b < icon extent x ifTrue: [
			magnifiedIcon _ icon magnifyTo: b@b ].
		b /  icon extent x > 1.7
			ifTrue: [	
				b _ b * 3 // 4.
				magnifiedIcon _ icon magnifyTo: b @ b]].
	^magnifiedIcon! !
!ScrollBar methodsFor: 'access' stamp: 'jmv 8/21/2012 21:55' prior: 50372871!
                    color: aColor
	"Change the color of the scrollbar to go with aColor."
	| buttonColor |
	super color: aColor.
	buttonColor _ color alphaMixed: 0.7 with: (Color gray: 0.95).
	upButton color: buttonColor.
	downButton color: buttonColor.
	slider color: buttonColor slightlyLighter.
	sliderShadow color: (color alphaMixed: 0.45 with: Color white)! !
!ScrollBar methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:55' prior: 50372885!
                        drawOn: aCanvas

	aCanvas
		fillRectangle: self morphBoundsInWorld
		colorOrInfiniteForm: (color alphaMixed: 0.3 with: Color white)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:53' prior: 50372895!
               morphExtent: newExtent

	| newExtentToUse |
	newExtent = extent ifTrue: [^ self].
	newExtentToUse _ self isHorizontal
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 8/21/2012 21:55' prior: 50372911!
                         recreateSubmorphs
	self removeAllMorphs.
	self
		initializeUpButton;
		initializeDownButton;
		initializeSlider.
	"Set color for submorphs"
	self color: color.! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 21:54' prior: 50372919!
          fitContents

	| newExtent |
	newExtent _ self measureContents.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!StringMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:56' prior: 50372927!
                         drawOn: aCanvas
	aCanvas
		drawString: contents
		in: self morphBoundsInWorld
		font: self fontToUse
		color: color! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:56' prior: 50372934!
             drawOn: aCanvas

	| tRect sRect columnRect columnScanner columnData columnLeft colorToUse |

	tRect := self toggleRectangle translatedBy: self morphPositionInWorld.
	sRect := self morphBoundsInWorld withLeft: tRect right + 4.
	self drawToggleOn: aCanvas in: tRect.
	colorToUse _ complexContents preferredColor ifNil: [color].
	(container columns isNil or: [(contents asString indexOf: Character tab) = 0]) ifTrue: [
		aCanvas drawString: contents asString in: sRect font: self fontToUse color: colorToUse.
	] ifFalse: [
		columnLeft _ sRect left.
		columnScanner _ ReadStream on: contents asString.
		container columns do: [ :width |
			columnRect _ columnLeft @ sRect top extent: width @ sRect height.
			columnData _ columnScanner upTo: Character tab.
			columnData isEmpty ifFalse: [
				aCanvas drawString: columnData in: columnRect font: self fontToUse color: colorToUse.
			].
			columnLeft _ columnRect right + 5.
		].
	]
! !
!IndentingListItemMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 21:54' prior: 50372967!
                               toggleRectangle

	^(12*indentLevel @ 0) extent: 12@extent y! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:57' prior: 50372972!
              drawOn: aCanvas 
	| stringColor stringBounds leftEdge b |

	b _ self morphBoundsInWorld.
	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas fillRectangle: b colorOrInfiniteForm: Theme current menuHighlight].
	leftEdge := 0.
	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ].
			aCanvas image: iconForm at: b left+1 @ (b top + (b height - iconForm height // 2)).
			leftEdge _ iconForm width + self iconSeparation].

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + self submorphBounds width + 8 ].

	stringBounds _ b left + leftEdge @ (b top + 1) corner: b corner.

	aCanvas
		drawString: contents
		in: stringBounds
		font: self fontToUse
		color: stringColor.
	subMenu
		ifNotNil: [ aCanvas image: SubMenuMarker at: b right - 8 @ (b top + b bottom - SubMenuMarker height // 2) ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:55' prior: 50373002!
     addPossiblyUncoveredAreasIn: aRectangle to: aCollection
	"Answer an array of rectangles encompassing those areas in aRectangle not completely
	covered by self. These are the areas that might require further drawing (of morphs below us)
	All areas that might possibly be uncovered must be included."
	 | r |
	color mightBeTranslucent ifTrue: [
		aCollection add: aRectangle.
		^self ].

	"Solid rectangle.
	This will be the fastest in many cases. So, please disable rounded corners if on slow hardware!!"
	Theme current roundWindowCorners ifFalse: [
		aRectangle areasOutside: self morphBoundsInWorld do: [ :rr |  aCollection add: rr ].
		^self ].

	"The solid rectangle does not include the corners.
	Report a couple of rows (top and bottom) or columns (left and right) as uncovered areas.
	We could also try to be more careful and answer each rounded corner...
	Right now, report top and bottom rows as uncovered areas"
	r _ Theme current roundedWindowRadius.
	aRectangle areasOutside: (self morphBoundsInWorld insetBy: 0@r) do: [ :rr |  aCollection add: rr ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:55' prior: 50373038!
      drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	aCanvas fillRectangle: self titleAreaInnerRect colorOrInfiniteForm: titleColor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:56' prior: 50373053!
                       drawRoundedFrameOn: aCanvas color: widgetsColor
	"Title area is not inside window borders"
	| bottomFactor topFactor |
	Theme current useWindowTitleGradient
		ifTrue: [
			topFactor _ Theme current titleGradientTopFactor.
			bottomFactor _ Theme current titleGradientBottomFactor ]
		ifFalse: [
			topFactor _ 1.
			bottomFactor _ 1 ].
	aCanvas
		windowFrame: self morphBoundsInWorld 
		color: widgetsColor * Theme current titleGradientExtraLightness
		radius: Theme current roundedWindowRadius
		border: borderWidth
		labelHeight: self labelHeight + borderWidth
		gradientTop: topFactor
		gradientBottom: bottomFactor
		insideColor: color! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/21/2012 21:53' prior: 50373076!
           makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:53' prior: 50373092!
                    morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent]! !
!SystemWindow methodsFor: 'testing' stamp: 'jmv 8/21/2012 21:55' prior: 50373107!
                            isOpaqueMorph
	"Not really used, as we also reimplement #addPossiblyUncoveredAreasIn:to:"
	^(Theme current roundWindowCorners or: [ color mightBeTranslucent ]) not! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1402-RemoveMorphIvars7-JuanVuletich-2012Aug21-21h51m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1400] on 21 August 2012 at 10:01:21 pm'!
!RectangleLikeMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 21:59' prior: 50373473!
              color: aColor
	"Set the receiver's color. "
	color = aColor ifFalse: [
		color _ aColor.
		self redrawNeeded ]! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 22:00' prior: 50373481!
               initialize
	super initialize.
	extent _ self defaultBounds extent.
	color _ self defaultColor! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:58' prior: 50373489!
      basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	extent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 22:01' prior: 50373670!
           morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ extent! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:59' prior: 50373505!
 initialize

	super initialize.
	extent _  271@121.
	responseUponCancel _ ''
	! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:59' prior: 50373511!
                         initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:59' prior: 50373522!
                     initialize
	"initialize the state of the receiver"
	super initialize.
	extent _ 12@12! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 22:00' prior: 50373528!
                 textColor: aColor

	color = aColor ifTrue: [^ self].
	color _ aColor.
	self redrawNeeded! !
!LimitedHeightTextMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:59' prior: 50373535!
 initialize
	super initialize.
	extent _  200 @ 120! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:59' prior: 50373541!
               initialize
	super initialize.
	trackPointer _ true.
	magnification _ 2.
	lastPos _ self sourcePoint.
	extent _ 128@128! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:58' prior: 50373549!
            initialize
	super initialize.
	extent _ extent x @ 2! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:59' prior: 50373555!
                  initialize
	super initialize.
	position _ 0@0.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 8/21/2012 21:59' prior: 50373563!
                            morphExtent: aPoint

	self flag: #jmvVer2.
	extent = aPoint ifFalse: [
		self redrawNeeded.
		extent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = self morphBoundsInWorld ifFalse: [
				worldState canvas: nil.
				worldState viewBox: self morphBoundsInWorld ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/21/2012 21:59' prior: 50373580!
        viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	position _ owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ].
	extent _ newViewBox extent! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:59' prior: 50373596!
                    initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	extent _  20 @ 15! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:59' prior: 50373610!
                    initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	extent _ 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1403-RemoveMorphIvars8-JuanVuletich-2012Aug21-21h58m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1403] on 21 August 2012 at 10:45:35 pm'!
!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 22:45' prior: 50370178!
      initialize
	"initialize the state of the receiver"
	super initialize.
	"initialize the receiver state related to border"
	borderColor _ self defaultBorderColor.
	borderWidth _ self defaultBorderWidth! !
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 8/21/2012 22:38' prior: 50370231!
                    buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ RectangleLikeMorph new.
	outerBox
		morphExtent: finalSizeInteger asPoint * resizeFactor;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox morphBoundsInWorld.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPositionInOwner: 12@8.	"not a clue why these numbers work..."
	
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/21/2012 22:38' prior: 50370272!
                            addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleLikeMorph new
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph morphExtent y + 5).
	nameBackground morphBoundsInWorld: (nameMorph morphBoundsInWorld outsetBy: 2).
	^nameMorph! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 8/21/2012 22:39' prior: 50370754!
                             testLayout3
	"
	self new testLayout3
	"
	| pane row innerRow i1 i2 i3 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	innerRow _ LayoutMorph newRow color: Color red;  separation: 5.
	innerRow
		addMorph: (i1 _ RectangleLikeMorph new)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i2 _ RectangleLikeMorph new)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i3 _ RectangleLikeMorph new)
			layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 minorDirectionPadding: #center);
		addMorph: (c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 200).
	pane openInWorld; morphExtent: 400@300.
	World doOneCycleNow.

	self assert: row morphBoundsInWorld left = (pane morphBoundsInWorld left + 5).
	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = 200.
	self assert: innerRow morphBoundsInWorld left = (row morphBoundsInWorld left + 5).
	self assert: (innerRow morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - innerRow morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: innerRow morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: innerRow morphHeight = 30.

	self assert: i1 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 5).
	self assert: (i1 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i1 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i1 morphWidth = 10.
	self assert: i1 morphHeight = 10.
	self assert: i2 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 20).
	self assert: (i2 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i2 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i2 morphWidth = 10.
	self assert: i2 morphHeight = 10.
	self assert: i3 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 35).
	self assert: (i3 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i3 morphWidth = (innerRow morphWidth - 40).
	self assert: i3 morphHeight = 10.

	self assert: c2 morphBoundsInWorld top = (row morphBoundsInWorld top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: c2 morphHeight = 40.
	self assert: (c3 morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - c3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (row morphHeight - 10).

	pane delete! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 8/21/2012 22:41' prior: 50370861!
                        addStayUpIcons
	| closeBox pinBox w |
	
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 42.
	self addMorphFront: 
		(LayoutMorph newRow
			morphHeight: (titleMorph morphHeight max: 19);
			morphWidth: w;	"Make room for buttons"
			color: Color transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleLikeMorph new color: Color transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleLikeMorph new color: Color transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 8/21/2012 22:40' prior: 50370902!
             addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ RectangleLikeMorph new.
	titleMorph color: Theme current menuTitleBar.
	pp _ 8@2.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s.
		s morphPositionInOwner: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphHeight: pp y; morphWidth: w + 8.
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 8/21/2012 22:41' prior: 50370930!
                  initializeSlider
	"initialize the receiver's slider"

	sliderShadow _ RectangleLikeMorph new.
	self addMorph: sliderShadow.
	sliderShadow hide.
		
	slider _ self sliderClass new.
	slider model: self.
	slider grabSelector: #sliderGrabbed.
	slider dragSelector: #scrollAbsolute:.
	slider action: #sliderReleased.
	self addMorph: slider.

	self computeSlider! !

MenuMorph removeSelector: #setTitleParametersFor:!

MenuMorph removeSelector: #setTitleParametersFor:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1404-UseRectangleLikeMorph-JuanVuletich-2012Aug21-22h33m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1404] on 21 August 2012 at 11:01:12 pm'!
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 23:00' prior: 50361193!
  openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self morphBoundsInWorld: (Display boundingBox center - (w@h//2) extent: w@h).
	labelMorph fitContents.
	subLabelMorph fitContents.
	self layoutSubmorphs.
	aWorld startSteppingSubmorphsOf: self.! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1405-ProgressMorphTweak-JuanVuletich-2012Aug21-22h59m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1405] on 23 August 2012 at 2:24:54 pm'!

!classDefinition: #RectangleLikeMorph category: #'Morphic-Kernel'!
Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'extent color'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'extent color'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1406-CuisCore-JuanVuletich-2012Aug23-14h23m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1406] on 24 August 2012 at 8:25:58 am'!

!classDefinition: #WeakIdentitySet category: #'Collections-Weak'!
WeakSet subclass: #WeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

WeakSet subclass: #WeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakIdentitySetTest category: #CollectionTests!
TestCase subclass: #WeakIdentitySetTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CollectionTests'!

TestCase subclass: #WeakIdentitySetTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CollectionTests'!
!WeakIdentitySet methodsFor: 'private' stamp: 'jmv 8/24/2012 08:02'!
                     scanFor: anObject
	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements"

	| element hash start finish |
	finish _ array size.
	finish > 4096
		ifTrue: [ hash _ anObject identityHash * (finish // 4096) ]
		ifFalse: [ hash _ anObject identityHash ].
	start _ (hash \\ array size) + 1.

	"Search from (hash mod size) to the end."
	start to: finish do:
		[:index | ((element _ array at: index) == flag or: [element == anObject])
			ifTrue: [^ index ]].

	"Search from 1 to where we started."
	1 to: start-1 do:
		[:index | ((element _ array at: index) == flag or: [element == anObject])
			ifTrue: [^ index ]].

	^ 0  "No match AND no empty slot"! !
!WeakIdentitySetTest methodsFor: 'testing' stamp: 'jmv 8/24/2012 08:24'!
                            test
	"
	(also tests WeakSet a bit)
	WeakIdentitySetTest new test
	"
	| ary1 ary2 count w wi |
	ary1 _ { 3@4 . 4@5 }.
	ary2 _ { 13@4 . 14@5 }.
	w _ WeakSet new.
	w addAll: ary1.
	wi _ WeakIdentitySet new.
	wi addAll: ary2.
	
	self assert: w size = 2.
	count _ 0.
	w do: [ :each |
		count _ count + 1.
		self assert: each class == Point ].
	self assert: count = 2.
	self assert: (w includes: ary1 first).
	self assert: (w includes: ary1 second).
	self assert: (w includes: 3@4).
	self assert: (w includes: 4@5).

	self assert: wi size = 2.
	count _ 0.
	wi do: [ :each |
		count _ count + 1.
		self assert: each class == Point ].
	self assert: count = 2.
	self assert: (wi includes: ary2 first).
	self assert: (wi includes: ary2 second).
	self deny: (wi includes: 13@4).
	self deny: (wi includes: 14@5).

	"Now make one element in each disappear"
	ary1 at: 1 put: 9.
	ary2 at: 1 put: 99.
	Smalltalk garbageCollect.

	"A little weird, but yes, elements that disappeared are still counted, but NOT iterated!!"
	self assert: w size = 2.
	count _ 0.
	w do: [ :each |
		count _ count + 1 ].
	self assert: count = 1.
	self deny: (w includes: ary1 first).
	self assert: (w includes: ary1 second).

	self assert: wi size = 2. 	"A little weird, but yes, elements that disappeared are still counted"
	count _ 0.
	wi do: [ :each |
		count _ count + 1 ].
	self assert: count = 1.
	self deny: (wi includes: ary2 first).
	self assert: (wi includes: ary2 second).! !
!WorldState methodsFor: 'initialization' stamp: 'jmv 8/24/2012 08:24' prior: 50339299!
                               initialize

	hands _ #().
	damageRecorder _ DamageRecorder new.
	stepList _ Heap sortBlock: self stepListSortBlock.
	lastStepTime _ 0.
	lastAlarmTime _ 0.
	drawingFailingMorphs _ WeakIdentitySet new.
	pause _ 20.
	lastCycleTime _ Time millisecondClockValue.
	lastCycleHadAnyEvent _ false! !
!WorldState methodsFor: 'errors on draw' stamp: 'jmv 8/24/2012 08:25' prior: 16986886!
      removeAllKnownFailing
	drawingFailingMorphs _ WeakIdentitySet new.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
World removeAllKnownFailing!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1407-CuisCore-JuanVuletich-2012Aug24-07h52m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1407] on 25 August 2012 at 2:26:30 pm'!
!Morph methodsFor: 'layout' stamp: 'jmv 8/25/2012 13:50'!
     layoutSubmorphsIfNeeded
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.

	layoutNeeded ifNil: [ layoutNeeded _ true ].
	layoutNeeded ifTrue: [
		self layoutSubmorphs.
		layoutNeeded _ false ]! !
!Morph methodsFor: 'change reporting' stamp: 'jmv 8/25/2012 13:50' prior: 50348357!
          privateInvalidateMorph: aMorph
	"Private. Invalidate the given morph after adding or removing.
	This method is private because a) we're invalidating the morph 'remotely'
	and b) it forces a fullBounds computation which should not be necessary
	for a general morph c) the morph may or may not actually invalidate
	anything (if it's not in the world nothing will happen) and d) the entire
	mechanism should be rewritten."

	"Is this needed at all?"
	self flag: #jmvVer2.
	aMorph layoutSubmorphsIfNeeded.

	aMorph redrawNeeded! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/25/2012 14:24' prior: 16896585!
      clipSubmorphs: aBoolean
	"Drawing specific. If this property is set, clip the receiver's submorphs to the receiver's clipping bounds."
	self redrawNeeded.
	aBoolean
		ifTrue: [ self setProperty: #clipSubmorphs toValue: true ]
		ifFalse: [ self removeProperty: #clipSubmorphs ].
	self redrawNeeded! !
!Morph methodsFor: 'fileIn/out' stamp: 'jmv 8/25/2012 14:07' prior: 50355774!
      prepareToBeSaved
	"Prepare this morph to be saved to disk. Subclasses should nil out any instance variables that holds state that should not be saved, such as cached Forms. Note that this operation may take more drastic measures than releaseCachedState; for example, it might discard the transcript of an interactive chat session."

	self releaseCachedState! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/25/2012 13:50' prior: 50354618!
           morphFullBoundsInWorld
	"Morphs should know nothing about absolute coordinates..."
	"Should implement in some reasonable way... including submorphs?"
	self flag: #jmvVer2.
	self layoutSubmorphsIfNeeded.

	self flag: #jmvVer2.
	^self morphBoundsInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/25/2012 13:50' prior: 50359358!
                     morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = self morphPositionInWorld ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsIfNeeded; redrawNeeded.


	"Maybe we don't really need an owner to run this method..."
	self validateOwnerNotNil.

	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/25/2012 13:50' prior: 50359410!
                   morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	"This method MUST die"
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		"
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
		"
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsIfNeeded; redrawNeeded.

	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/25/2012 14:20' prior: 50356052!
    someSubmorphPositionOrExtentChanged
	"Our extent, or some submorph changed. Must layout submorphs again."

	layoutNeeded _ true! !
!Morph methodsFor: 'layout-properties' stamp: 'jmv 8/25/2012 14:25' prior: 16898502!
        layoutSpec: aLayoutSpec
	"Layout specific. Set the layout spec describing where the receiver should appear in a proportional layout"
	self layoutSpec == aLayoutSpec ifTrue:[^self].
	aLayoutSpec morph: self.
	self assureExtension layoutSpec: aLayoutSpec.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].! !
!Morph methodsFor: 'updating' stamp: 'jmv 8/25/2012 14:01' prior: 50356062!
                   redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Just ours, or include submorphs if we don't clip.
	Think about it. We don't to know about a specific rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"
	
	"This method is the only real use of ivar fullBounds, other than senders of #fullBounds"

	self layoutSubmorphsIfNeeded.
	self invalidRect: self morphFullBoundsInWorld! !
!Morph methodsFor: 'private' stamp: 'jmv 8/25/2012 14:08' prior: 50358844!
           privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |

	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					]]! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 8/25/2012 14:22' prior: 50374395!
                      basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	extent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	self redrawNeeded! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/25/2012 13:43' prior: 50356622!
                     addHandles
	| box |
	target isWorldMorph ifTrue: [ ^ self addHandlesForWorldHalos ].

	self removeAllMorphs.  "remove old handles, if any"
	self morphBoundsInWorld: target worldBoundsForHalo.  "update my size"
	box _ self basicBox.

	target addHandlesTo: self box: box.

	self addName.
	growingOrRotating _ false.
	self redrawNeeded! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/25/2012 13:43' prior: 50362479!
 addHandlesForWorldHalos
	"Add handles for world halos, like the man said"

	| box w |
	w _ self world ifNil: [target world].
	self removeAllMorphs.  "remove old handles, if any"
	self morphBoundsInWorld: target morphBoundsInWorld.
	box _ w morphBoundsInWorld insetBy: 9.
	target addWorldHandlesTo: self box: box.

	self
		addNameBeneath: (box insetBy: (0@0 corner: 0@10))
		string: (target printStringLimitedTo: 40).
	growingOrRotating _ false.
	self redrawNeeded! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/25/2012 13:43' prior: 50353357!
                              doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target morphPositionInWorld.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target morphExtent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle morphExtent // 2)! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 8/25/2012 13:43' prior: 50347750!
                              doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle morphExtent // 2)! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 8/25/2012 14:03' prior: 50349606!
updateFromParagraph
	"A change has taken place in my paragraph, as a result of editing and I must be updated. "

	paragraph ifNotNil: [
		editor storeSelectionInParagraph.
		self fit ].

	owner
		updateScrollBarsBounds;
		setScrollDeltas! !
!LayoutAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 8/25/2012 01:01' prior: 50343410!
                   adjustIndicatorAt: aPoint
	owner direction = #vertical
		ifTrue: [
			indicator morphPosition: indicator morphPosition x @ (aPoint y-(indicator morphBoundsInWorld height//2)) ]
		ifFalse: [
			indicator morphPosition: (aPoint x-(indicator morphBoundsInWorld width//2)) @ indicator morphPosition y ]! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 8/25/2012 11:14' prior: 16879900!
                               padding: aSymbolOrNumber
	"This sets how extra space is used when doing layout. For example, a column might have extra , unneded vertical space. #top means widgets are set close to the top, and extra space is at bottom. Conversely, #bottom means widgets are set close to the bottom, and extra space is at top. Valid values include #left and #right (for rows) and #center. Alternatively, any number between 0.0 and 1.0 might be used.
	self new padding: #center
	self new padding: 0.9
	"
	padding _ aSymbolOrNumber
		caseOf: {
			[ #top ] -> [ 0.0 ].
			[ #left ] -> [ 0.0 ].
			[ #center ] -> [ 0.5 ].
			[ #right ] -> [ 1.0 ].
			[ #bottom ] -> [ 1.0 ]
		}
		otherwise: [ aSymbolOrNumber ]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 8/25/2012 14:11' prior: 50355879!
                           layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		layoutNeeded _ false.
		^self].

	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self layoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self layoutBounds ].

	layoutNeeded _ false! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 8/25/2012 11:13' prior: 50356814!
                layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight r t b |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableWidth _ boundsForLayout width - ((submorphs size + 1) * xSep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth _ usableWidth - sumOfFixed.
	normalizationFactor _ self proportionalWidthNormalizationFactor.
	availableForPropWidth _ availableForPropWidth * normalizationFactor.
	widths _ submorphs collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + xSep max: 0) +  boundsForLayout left.
	usableHeight _ boundsForLayout height - (2*ySep) max: 0.
	boundsTop _ boundsForLayout top.	
	boundsRight _ boundsForLayout right.
	submorphs size to: 1 by: -1 do: [ :index | | m w h ls |
		m _ submorphs at: index.
		w _ widths at: index.
		"major direction"
		r _ l + w min: boundsRight.
		"minor direction"
		ls _ m layoutSpec.
		h _ (ls heightFor: usableHeight) min: usableHeight.
		t _ (usableHeight - h) * ls minorDirectionPadding + ySep + boundsTop.
		b _ t + h.
		"Set bounds and adjust major direction for next step"
		m morphBoundsInWorld: (l rounded @ t rounded corner: r rounded @ b rounded).
		w > 0 ifTrue: [
			l _ r + xSep min: boundsRight ]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 8/25/2012 11:14' prior: 50356868!
        layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom b l r |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableHeight _ boundsForLayout height - ((submorphs size + 1) * ySep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight _ usableHeight - sumOfFixed.
	normalizationFactor _ self proportionalHeightNormalizationFactor.
	availableForPropHeight _ availableForPropHeight * normalizationFactor.
	heights _ submorphs collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + ySep max: 0) +  boundsForLayout top.
	usableWidth _ boundsForLayout width - (2*xSep) max: 0.
	boundsLeft _ boundsForLayout left.	
	boundsBottom _ boundsForLayout bottom.
	submorphs size to: 1 by: -1 do: [ :index | | m h w ls |
		m _ submorphs at: index.
		h _ heights at: index.
		"major direction"
		b _ t + h min: boundsBottom.
		"minor direction"
		ls _ m layoutSpec.
		w _ (ls widthFor: usableWidth) min: usableWidth.
		l _ (usableWidth - w) * ls minorDirectionPadding + xSep + boundsLeft.
		r _ l + w.
		"Set bounds and adjust major direction for next step"
		m morphBoundsInWorld: (l rounded @ t rounded corner: r rounded @ b rounded).
		h > 0 ifTrue: [
			t _ b + ySep min: boundsBottom ]]! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 8/25/2012 14:14' prior: 50355892!
                        adjustHorizontallyBy: aLayoutAdjustMorph at: aPoint
	| delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |
	doNotResizeBelow _ self minPaneWidthForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	l _ self submorphs at: i +1.
	ls _ l layoutSpec.
	lCurrentWidth _ l morphWidth max: 1.	"avoid division by zero"
	r _ self submorphs at: i - 1.
	rs _ r layoutSpec.
	rCurrentWidth _ r morphWidth max: 1.	"avoid division by zero"
	delta _ aPoint x - aLayoutAdjustMorph referencePosition x.
	delta _ delta max: doNotResizeBelow - lCurrentWidth.
	delta _ delta min: rCurrentWidth - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	rNewWidth _ rCurrentWidth - delta.
	lNewWidth _ lCurrentWidth + delta.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [	"If both proportional, update them"
			ls setProportionalWidth: (1.0 * lNewWidth / lCurrentWidth * ls proportionalWidth).
			rs setProportionalWidth: (1.0 * rNewWidth / rCurrentWidth * rs proportionalWidth) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 8/25/2012 14:11' prior: 50355935!
              adjustVerticallyBy: aLayoutAdjustMorph at: aPoint
	| delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |
	doNotResizeBelow _ self minPaneHeightForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	t _ self submorphs at: i +1.
	ts _ t layoutSpec.
	tCurrentHeight _ t morphHeight max: 1.	"avoid division by zero"
	b _ self submorphs at: i - 1.
	bs _ b layoutSpec.
	bCurrentHeight _ b morphHeight max: 1.	"avoid division by zero"
	delta _ aPoint y - aLayoutAdjustMorph referencePosition y.
	delta _ delta max: doNotResizeBelow - tCurrentHeight.
	delta _ delta min: bCurrentHeight - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	tNewHeight _ tCurrentHeight + delta.
	bNewHeight _ bCurrentHeight - delta.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [	"If both proportional, update them"
			ts setProportionalHeight: (1.0 * tNewHeight / tCurrentHeight * ts proportionalHeight).
			bs setProportionalHeight: (1.0 * bNewHeight / bCurrentHeight * bs proportionalHeight) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	self layoutSubmorphs! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 8/25/2012 14:20' prior: 50374471!
               morphExtent: aPoint

	self flag: #jmvVer2.
	extent = aPoint ifFalse: [
		self redrawNeeded.
		extent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = self morphBoundsInWorld ifFalse: [
				worldState canvas: nil.
				worldState viewBox: self morphBoundsInWorld ]]]! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/25/2012 14:20' prior: 16915124!
                  someSubmorphPositionOrExtentChanged
	"Our extent, or some submorph changed. Must layout submorphs again."

	super someSubmorphPositionOrExtentChanged.
	self updateScrollBarsBounds! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 8/25/2012 14:12' prior: 50374834!
               openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self morphBoundsInWorld: (Display boundingBox center - (w@h//2) extent: w@h).
	labelMorph fitContents.
	subLabelMorph fitContents.
	layoutNeeded _ true.
	aWorld startSteppingSubmorphsOf: self.! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 8/25/2012 14:23' prior: 16965553!
       collapseOrExpand
	"Collapse or expand the window, depending on existing state"

	isCollapsed
		ifTrue: [ self expand ]
		ifFalse: [ self collapse]! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 8/25/2012 13:51' prior: 16986912!
                          displayWorld: aWorld submorphs: submorphs
	"Update this world's display."

	| deferredUpdateMode worldDamageRects handsToDraw allDamage |
	submorphs do: [ :m | m layoutSubmorphsIfNeeded].  "force re-layout if needed"
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.
	deferredUpdateMode ifFalse: [ self assuredNonDisplayCanvas ].

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.

	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"draw hands onto world canvas"
	handsToDraw reverseDo: [ :h | self drawHand: h ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ aWorld flashRects: allDamage ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateMode
		ifTrue: [ self forceDamageToScreen: allDamage ]
		ifFalse: [ canvas showAt: aWorld viewBox origin invalidRects: allDamage ].
	"restore world canvas under hands"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].
	Display deferUpdates: false; forceDisplayUpdate! !

PluggableScrollPane removeSelector: #mustLayout!

LayoutMorph class removeSelector: #example4!

LayoutMorph class removeSelector: #example4!

LayoutMorph class removeSelector: #example5!

LayoutMorph class removeSelector: #example5!

Morph removeSelector: #computeFullBounds!

Morph removeSelector: #computeFullBounds!

Morph removeSelector: #layoutSubmorphsAndComputeFullBounds!

Morph removeSelector: #layoutSubmorphsAndComputeFullBounds!

Morph removeSelector: #mustLayout!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1408-LayoutSimplification-JuanVuletich-2012Aug25-13h40m-jmv.7.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1408] on 25 August 2012 at 3:41:40 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 8/25/2012 15:41' prior: 50375074!
 morphFullBoundsInWorld
	"Morphs should know nothing about absolute coordinates..."
	"Should implement in some reasonable way... including submorphs?"

	self flag: #jmvVer2.
	"IF I remove this, then layout of buttons in FileList breaks when selecting / deselecting code files. Besides, ProgressMorph example breaks too"
	self layoutSubmorphsIfNeeded.

	self flag: #jmvVer2.
	^self morphBoundsInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/25/2012 15:09' prior: 50375085!
  morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = self morphPositionInWorld ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	self redrawNeeded.

	"Maybe we don't really need an owner to run this method..."
	self validateOwnerNotNil.

	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/25/2012 15:09' prior: 50375115!
                morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	"This method MUST die"
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].

	position = newPositionInOwner ifTrue: [
		^ self ].		"Null change".

	self redrawNeeded.
	position _ newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/25/2012 15:19' prior: 16898450!
           layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	"Only specific subclasses do layout."
	layoutNeeded _ false! !
!Morph methodsFor: 'layout' stamp: 'jmv 8/25/2012 15:40' prior: 50375014!
                              layoutSubmorphsIfNeeded
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.

	layoutNeeded ifTrue: [
		self layoutSubmorphs ].! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 8/25/2012 15:16' prior: 16899551!
           removeMorph: aMorph
	"Remove the given morph from my submorphs"
	| aWorld |
	aMorph owner == self ifFalse:[^self].
	aWorld := self world.
	aWorld ifNotNil: [
		aMorph redrawNeeded ].
	self privateRemove: aMorph.
	aMorph privateOwner: nil.
	self removedMorph: aMorph.
	self someSubmorphPositionOrExtentChanged.! !
!Morph methodsFor: 'updating' stamp: 'jmv 8/25/2012 15:40' prior: 50375204!
                           redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Just ours, or include submorphs if we don't clip.
	Think about it. We don't to know about a specific rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"

	
	self layoutSubmorphsIfNeeded.
	self invalidRect: self morphFullBoundsInWorld! !
!Morph methodsFor: 'private' stamp: 'jmv 8/25/2012 15:15' prior: 16899702!
     privateAddAllMorphs: aCollection atIndex: index
	"Private. Add aCollection of morphs to the receiver"
	| myWorld itsWorld otherSubmorphs |
	myWorld _ self world.
	otherSubmorphs _ submorphs copyWithoutAll: aCollection.
	(index between: 0 and: otherSubmorphs size)
		ifFalse: [^ self error: 'index out of range'].
	index = 0
		ifTrue:[	submorphs _ aCollection asArray, otherSubmorphs]
		ifFalse:[	index = otherSubmorphs size
			ifTrue:[	submorphs _ otherSubmorphs, aCollection]
			ifFalse:[	submorphs _ otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ]].
	aCollection do: [:m | | itsOwner |
		itsOwner _ m owner.
		itsOwner ifNotNil: [
			itsWorld _ m world.
			(itsWorld == myWorld) ifFalse: [
				itsWorld ifNotNil: [m redrawNeeded]].
			(itsOwner ~~ self) ifTrue: [
				m owner privateRemove: m.
				m owner removedMorph: m ]].
		m privateOwner: self.
		myWorld ifNotNil: [m redrawNeeded].
		(myWorld == itsWorld) ifFalse: [m intoWorld: myWorld].
		itsOwner == self ifFalse: [
			self addedMorph: m.
			m noteNewOwner: self ].
	].
	self someSubmorphPositionOrExtentChanged! !
!Morph methodsFor: 'private' stamp: 'jmv 8/25/2012 15:16' prior: 16899740!
         privateAddMorph: aMorph atIndex: index

	| oldIndex myWorld itsWorld oldOwner |
	((index >= 1) and: [index <= (submorphs size + 1)])
		ifFalse: [^ self error: 'index out of range'].
	myWorld _ self world.
	oldOwner _ aMorph owner.
	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue:[
		"aMorph's position changes within in the submorph chain"
		oldIndex < index ifTrue:[
			"moving aMorph to back"
			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.
			submorphs at: index-1 put: aMorph.
		] ifFalse:[
			"moving aMorph to front"
			oldIndex-1 to: index by: -1 do:[:i|
				submorphs at: i+1 put: (submorphs at: i)].
			submorphs at: index put: aMorph.
		].
	] ifFalse:[
		"adding a new morph"
		oldOwner ifNotNil:[
			itsWorld _ aMorph world.
			itsWorld ifNotNil: [aMorph redrawNeeded].
			oldOwner privateRemove: aMorph.
			oldOwner removedMorph: aMorph.
		].
		aMorph privateOwner: self.
		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).
		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].
	].
	myWorld ifNotNil:[aMorph redrawNeeded].
	self someSubmorphPositionOrExtentChanged.
	oldOwner == self ifFalse: [
		self addedMorph: aMorph.
		aMorph noteNewOwner: self ].
! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 8/25/2012 15:19' prior: 50357906!
               layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| bl br h thickness tl tr w cornerExtent b |
	thickness _ 4.
	cornerExtent _ 20.
	b _ self morphBoundsInWorld.
	tl _ b topLeft.
	tr _ b topRight.
	bl _ b bottomLeft.
	br _ b bottomRight.
	w _ b width - cornerExtent - cornerExtent.
	h _ b height - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) morphBoundsInWorld: (tl + (cornerExtent@0) extent: w@thickness).
	(adjusters at: #bottomAdjuster) morphBoundsInWorld: (bl+ (cornerExtent @ thickness negated) extent: w@thickness).
	(adjusters at: #leftAdjuster) morphBoundsInWorld: (tl+ (0@cornerExtent) extent: thickness@h).
	(adjusters at: #rightAdjuster) morphBoundsInWorld: (tr + (thickness negated@ cornerExtent) extent: thickness@h).
	(adjusters at: #topLeftAdjuster) morphBoundsInWorld: (tl extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomLeftAdjuster) morphBoundsInWorld: (bl-(0@cornerExtent) extent: cornerExtent@cornerExtent).
	(adjusters at: #topRightAdjuster) morphBoundsInWorld: (tr+(cornerExtent negated@0) extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomRightAdjuster) morphBoundsInWorld: (br-cornerExtent extent: cornerExtent@cornerExtent).

	layoutMorph ifNotNil: [
		layoutMorph morphBoundsInWorld: self layoutBounds ].
	
	layoutNeeded _ false! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 8/25/2012 15:07' prior: 50375644!
                             displayWorld: aWorld submorphs: submorphs
	"Update this world's display."

	| deferredUpdateMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.
	deferredUpdateMode ifFalse: [ self assuredNonDisplayCanvas ].

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.

	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"draw hands onto world canvas"
	handsToDraw reverseDo: [ :h | self drawHand: h ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ aWorld flashRects: allDamage ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateMode
		ifTrue: [ self forceDamageToScreen: allDamage ]
		ifFalse: [ canvas showAt: aWorld viewBox origin invalidRects: allDamage ].
	"restore world canvas under hands"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].
	Display deferUpdates: false; forceDisplayUpdate! !

Morph removeSelector: #privateInvalidateMorph:!

Morph removeSelector: #privateInvalidateMorph:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1409-LayoutSimplification-JuanVuletich-2012Aug25-15h37m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1409] on 25 August 2012 at 5:09:04 pm'!
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 8/25/2012 17:09' prior: 50369456!
                            drawBoundsForRow: row
	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"

	self flag: #jmvVer2.
	"revisar senders"
	^ 0 @ (row - 1 * font height) extent: self morphExtentInOwner x @ font height! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/25/2012 17:07' prior: 50369469!
 draw: item atRow: row on: canvas
	"display the given item at row row"
	| drawBounds f |
	drawBounds _ self drawBoundsForRow: row.
	drawBounds _ drawBounds intersect: (0@0 extent: extent).
	drawBounds _ (self externalizeToWorld: drawBounds origin) extent: drawBounds extent.
	f _ (item is: #Text) ifTrue: [ font emphasized: (item emphasisAt: 1) ] ifFalse: [ font ].
	canvas drawString: item in: drawBounds font: f color: (self colorForRow: row)! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/25/2012 17:07' prior: 50369484!
             drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"
	selectionDrawBounds _ self drawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: (0@0 extent: extent).
	selectionDrawBounds _ (self externalizeToWorld: selectionDrawBounds origin) extent: selectionDrawBounds extent.
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas fillRectangle: selectionDrawBounds colorOrInfiniteForm: c! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/25/2012 17:08' prior: 50369504!
              drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (0@0 extent: extent).
	selectionDrawBounds _ (self externalizeToWorld: selectionDrawBounds origin) extent: selectionDrawBounds extent.
	aCanvas
		fillRectangle: selectionDrawBounds
		colorOrInfiniteForm: (Theme current listHighlightFocused: owner hasKeyboardFocus).! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 8/25/2012 16:56' prior: 50369697!
                   scrollSelectionIntoView
	"make sure that the current selection is visible"
	| row r |
	row _ self getCurrentSelectionIndex.
	row = 0 ifTrue: [
		^ scrollBar setValue: scrollBar value ].
	self flag: #jmvVer2.
	r _ self listMorph drawBoundsForRow: row.
	r _ ((self listMorph externalize: r origin) extent: r extent).
	self scrollToShow: r! !

InnerListMorph removeSelector: #ydrawBoundsForRow:!

InnerListMorph removeSelector: #zdrawBoundsForRow:!

InnerListMorph removeSelector: #zdrawBoundsForRow:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1410-InnerListMorphTweaks-JuanVuletich-2012Aug25-16h36m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1410] on 26 August 2012 at 11:08:22 pm'!
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/26/2012 22:57' prior: 16860674!
                              fillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: bw borderStyleSymbol: aSymbol
	"
	Display getCanvas
		fillRectangle: (10@10 extent: 300@200)
		colorOrInfiniteForm: (InfiniteForm verticalGradient: 24 topColor: Color green bottomColor:Color red)
		borderWidth: 5
		borderStyleSymbol: #raised
	"

	"Nicer. does frame with translucent black or white. Downside: requires proper color.
	Some buttons are actually transparent (should be fixed!!), and there is a trick to grab some
	opaque owner's color. And this is needed because (for instance) SystemWindow does NOT paint the inside with its color, but that color is needed to paint separators and button area. Something better is needed!!!!!!!!!!"
	"
	self fillRectangle: r color: .aColorOrInfiniteForm
	self frameRectangle: r borderWidth: bw borderStyleSymbol: aSymbol
	"

	self fillRectangle: (aRectangle insetBy: bw) colorOrInfiniteForm: aColorOrInfiniteForm.
	self frameRectangle: aRectangle color: aColorOrInfiniteForm asColor borderWidth: bw borderStyleSymbol: aSymbol! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/26/2012 23:00' prior: 16860710!
    fillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: bw borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder

	"
	| if |
	if _ InfiniteForm verticalGradient: 24 topColor: Color green bottomColor:Color red.
	Display getCanvas
		fillRectangle: (10@10 extent: 300@200)
		colorOrInfiniteForm: if
		borderWidth: 5
		borderStyleSymbol: #raised
		baseColorForBorder: if asColor
	"

	"
Pretty ugly.
#fillRectangle:color::borderWidth:borderStyleSymbol:  is much better but has trouble with silly transparent morphs
	"
	
	self fillRectangle: (aRectangle insetBy: bw) colorOrInfiniteForm: aColorOrInfiniteForm.
	self frameRectangle: aRectangle color: baseColorForBorder borderWidth: bw borderStyleSymbol: aSymbol! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 8/26/2012 22:33' prior: 16860942!
                    windowFrame: aRectangle color: aColor radius: r border: borderWidth labelHeight: h gradientTop: topFactor gradientBottom: bottomFactor insideColor: insideColor
	"
	Display getCanvas windowFrame: (10@10 extent: 200@100) color: Color red radius: 10  border: 5 labelHeight: 25 gradientTop: 1.0 gradientBottom: 0.5 insideColor: Color green
	"
	"top stripe"
	| bottomColor he tl tr |
	self
		image: (FormCanvas topLeftCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		image: (FormCanvas topRightCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self
		fillRectangle: ((aRectangle withHeight: h) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.

	"left and right borders"
	tl _ aRectangle topLeft + (0@h).
	tr _ aRectangle topRight + (borderWidth negated@h).
	he _ borderWidth@(aRectangle height - h - r).
	self fillRectangle: (tl extent: he) colorOrInfiniteForm: bottomColor.
	self fillRectangle: (tr extent: he) colorOrInfiniteForm: bottomColor.
	
	"bottom stripe"
	self
		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: aRectangle bottomLeft - (0@r).
	self
		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: aRectangle bottomRight - (r@r) .
	self fillRectangle: ((aRectangle bottomLeft + (r@borderWidth negated)) extent: (aRectangle width - r - r@borderWidth)) colorOrInfiniteForm: bottomColor.

	"inside"
	self fillRectangle: (aRectangle insetBy: (borderWidth@h corner: borderWidth@borderWidth)) colorOrInfiniteForm: insideColor! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/26/2012 22:39' prior: 50353379!
          drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"It looks like this method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: self morphPositionInWorld
		color: Color black! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/26/2012 22:46' prior: 16864782!
         needsToBeDrawn
	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."
	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."
	
	"Note. We draw the hand as a regular morph (using #drawOn:), disabling the hardware cursor, when we carry submorphs. The reason is to lock the mouse pointer and the carried morph together. Otherwhise the carried morph would lag behind the mouse pointer.
	This method answers whether the regular #drawOn: drawing mechanism is used for us.
	
	Check senders. Hand drawing is handled explicitly by the world, because the Hand is not a submorph of the world!!"

	(savedPatch notNil
		or: [ submorphs anySatisfy: [ :ea | ea visible ] ] )
		ifTrue: [
			"using the software cursor; hide the hardware one"
			Sensor currentCursor == Cursor blank ifFalse: [Cursor blank show].
			^ true].

	^ false! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 8/26/2012 22:59' prior: 50373844!
      drawOn: aCanvas
	aCanvas fillRectangle: self morphBoundsInWorld colorOrInfiniteForm: color borderWidth: 2 borderStyleSymbol: #raised baseColorForBorder: color! !
!MorphicScanner methodsFor: 'stop conditions' stamp: 'jmv 8/26/2012 22:26' prior: 16900674!
  doNewLine
	"When a newLine is encountered, simply increment the pointer 
	into the paragraph."

	lastIndex _ lastIndex + 1.
	^false! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 8/26/2012 22:59' prior: 50374000!
                               draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: self morphBoundsInWorld
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !

FormCanvas removeSelector: #line:to:brushForm:!

FormCanvas removeSelector: #line:to:brushForm:!

FormCanvas removeSelector: #line:to:width:color:dashLength:secondColor:secondDashLength:startingOffset:!

FormCanvas removeSelector: #line:to:width:color:dashLength:secondColor:secondDashLength:startingOffset:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1411-MinorTweaks-JuanVuletich-2012Aug26-23h07m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1411] on 28 August 2012 at 8:29:09 am'!

!classDefinition: #MatrixTransform2x3 category: #'Morphic-Kernel'!
Object variableWordSubclass: #MatrixTransform2x3
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object variableWordSubclass: #MatrixTransform2x3
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!MatrixTransform2x3 commentStamp: '<historical>' prior: 0!
               This class represents a transformation for points, that is a combination of scale, offset, and rotation. It is implemented as a 2x3 matrix containing the transformation from the local coordinate system in the external coordinate system. Thus, transforming points from internal to external coordinates is fast and cheap whereas transformations from external to local coordinate systems are relatively expensive.

Implementation Note: In the original version, from Squeak, it is assumed that the transformation deals with Integer points. All transformations will return Integer coordinates (even though float points may be passed in here). In this version, point transformations are for Float points. The plugin needs fixing, so the plugin primitives that round to integer points are commented. Rectangle transformations were removed (they were are for Display rectangles, and are done in integer coordinates by the plugin).!
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 4/28/2011 08:59'!
             externalizeDistance: aPoint
	"Externalize a distance vector. A distance is not a position. It is a magnitude with a direction.
	It is usually used as a delta to be added to a position to obtain some other position."

	| x y |
	x _ (aPoint x * self a11) + (aPoint y * self a12).
	y _ (aPoint x * self a21) + (aPoint y * self a22).
	^x @ y! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 4/28/2011 09:00'!
                    externalizePosition: aPoint
	"Answer coordinates for aPoint in the space we are in.
	 aPoint is expressed in us."

	"Warning: The plugin rounds result to integers. We want Float points."
	"<primitive: 'primitiveTransformPoint' module: 'Matrix2x3Plugin'>"

	| x y |
	x _ (aPoint x * self a11) + (aPoint y * self a12) + self a13.
	y _ (aPoint x * self a21) + (aPoint y * self a22) + self a23.
	^x @ y! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 4/28/2011 09:00'!
                       externalizePositions: inArray
	"Transform all the points of inArray from local into global coordinates"

	^inArray collect: [ :pt | self externalizePosition: pt ]! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 4/28/2011 08:34'!
   externalizeScalar: aNumber
	"Externalize a distance (without a direction).
	 Only valid if we preserve aspect ratio (meaning that the scale factor is the same in all directions)."

	^aNumber * self scalarScaleFactor! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 4/28/2011 09:00'!
              internalizeDistance: aPoint
	"Internalize a distance vector. A distance is not a position. It is a magnitude with a direction.
	It is usually used as a delta to be added to a position to obtain some other position."

	| x y det a11 a12 a21 a22 detX detY |
	x _ aPoint x asFloat.
	y _ aPoint y asFloat.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^0@0 ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 4/28/2011 08:58'!
 internalizePosition: aPoint
	"Answer our coordinates for aPoint.
	 aPoint is expressed in the space we are in."

	"Warning: The plugin rounds result to integers. We want Float points."
	"<primitive: 'primitiveInvertPoint' module: 'Matrix2x3Plugin'>"

	| x y det a11 a12 a21 a22 detX detY |
	x _ aPoint x asFloat - (self a13).
	y _ aPoint y asFloat - (self a23).
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^0@0 ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 4/28/2011 09:00'!
     internalizePositions: inArray
	"Transform all the points of inArray from global into local coordinates"

	^inArray collect: [ :pt | self internalizePosition: pt ]! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 4/28/2011 08:33'!
   internalizeScalar: aNumber
	"Internalize a distance (without a direction). 
	 Only valid if we preserve aspect ratio (meaning that the scale factor is the same in all directions)."

	^aNumber / self scalarScaleFactor! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!
                            at: index
	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>
	^Float fromIEEE32Bit: (self basicAt: index)! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!
       at: index put: value
	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>
	value isFloat 
		ifTrue:[self basicAt: index put: value asIEEE32BitWord]
		ifFalse:[self at: index put: value asFloat].
	^value! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 4/28/2011 08:55'!
   inverseTransformation
	"Return the inverse transformation of the receiver.
	The inverse transformation is computed by first calculating
	the inverse offset and then computing transformations
	for the two identity vectors (1@0) and (0@1)"
	| r1 r2 r3 m |
	r3 := self internalizePosition: 0@0.
	r1 := (self internalizePosition: 1@0) - r3.
	r2 := (self internalizePosition: 0@1) - r3.
	m := self species new.
	m
		a11: r1 x; a12: r2 x; a13: r3 x;
		a21: r1 y; a22: r2 y; a23: r3 y.
	^m! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 23:19'!
                 offset
	^self a13 @ self a23! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 23:05'!
                       offset: aPoint
	self a13: aPoint x asFloat.
	self a23: aPoint y asFloat.! !
!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 2/2/2001 15:47'!
            = aMatrixTransform2x3 
	| length |
	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>
	self class = aMatrixTransform2x3 class ifFalse: [^ false].
	length := self size.
	length = aMatrixTransform2x3 size ifFalse: [^ false].
	1 to: self size do: [:i | (self at: i)
			= (aMatrixTransform2x3 at: i) ifFalse: [^ false]].
	^ true! !
!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 5/3/2001 13:02'!
         hash
	| result |
	<primitive: 'primitiveHashArray' module: 'FloatArrayPlugin'>
	result := 0.
	1 to: self size do:[:i| result := result + (self basicAt: i) ].
	^result bitAnd: 16r1FFFFFFF! !
!MatrixTransform2x3 methodsFor: 'composing' stamp: 'jmv 8/27/2012 18:54'!
                        composedWith: aTransformation
	"Return the composition of the receiver and the transformation passed in.

	The result is a MT2x3 that has the following effect:
		self externalize: (aTransformation externalize: aPoint)
		aTransformation internalize: (self internalize: aPoint).

	This means that aTransformation is considered the inner transform, and we are considered the outer transform.
	
	These are equivalent:
		((MatrixTransform2x3 withRadians: 0.3) composedWith: (MatrixTransform2x3 withOffset: 3@5)) print
		((MatrixTransform2x3 withRadians: 0.3) asMatrix * (MatrixTransform2x3 withOffset: 3@5) asMatrix) print

	These are also equivalent:
		((MatrixTransform2x3 withOffset: 3@5) composedWith: (MatrixTransform2x3 withRadians: 0.3)) print
		((MatrixTransform2x3 withOffset: 3@5) asMatrix * (MatrixTransform2x3 withRadians: 0.3) asMatrix) print
	"
	^self composedWith: aTransformation into: self class new! !
!MatrixTransform2x3 methodsFor: 'composing' stamp: 'jmv 8/27/2012 18:51'!
   composedWith: aTransformation into: result
	"Return the composition of the receiver and the transformation passed in.
	Store the composed matrix into result.
	Please see the comment at: #composedWith:"

	| a11 a12 a13 a21 a22 a23 b11 b12 b13 b21 b22 b23 matrix |
	<primitive: 'primitiveComposeMatrix' module: 'Matrix2x3Plugin'>
	matrix := aTransformation.
	a11 := self a11.		b11 := matrix a11.
	a12 := self a12.		b12 := matrix a12.
	a13 := self a13.		b13 := matrix a13.
	a21 := self a21.		b21 := matrix a21.
	a22 := self a22.		b22 := matrix a22.
	a23 := self a23.		b23 := matrix a23.
	result a11: (a11 * b11) + (a12 * b21).
	result a12: (a11 * b12) + (a12 * b22).
	result a13: a13 + (a11 * b13) + (a12 * b23).
	result a21: (a21 * b11) + (a22 * b21).
	result a22: (a21 * b12) + (a22 * b22).
	result a23: a23 + (a21 * b13) + (a22 * b23).
	^result! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!
  a11
	^self at: 1! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!
                              a11: value
	 self at: 1 put: value! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!
            a12
	^self at: 2! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!
                              a12: value
	 self at: 2 put: value! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!
            a13
	^self at: 3! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!
                              a13: value
	 self at: 3 put: value! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!
            a21
	 ^self at: 4! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!
                             a21: value
	 self at: 4 put: value! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!
            a22
	 ^self at: 5! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!
                             a22: value
	 self at: 5 put: value! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!
            a23
	 ^self at: 6! !
!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!
                             a23: value
	 self at: 6 put: value! !
!MatrixTransform2x3 methodsFor: 'initialize' stamp: 'ar 11/2/1998 23:17'!
                setIdentiy
	"Initialize the receiver to the identity transformation (e.g., not affecting points)"
	self
		a11: 1.0; a12: 0.0; a13: 0.0;
		a21: 0.0; a22: 1.0; a23: 0.0.! !
!MatrixTransform2x3 methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 16:06'!
    byteSize
	^self basicSize * self bytesPerBasicElement! !
!MatrixTransform2x3 methodsFor: 'objects from disk' stamp: 'nk 3/17/2004 15:04'!
                      bytesPerBasicElement
	"Answer the number of bytes that each of my basic elements requires.
	In other words:
		self basicSize * self bytesPerBasicElement
	should equal the space required on disk by my variable sized representation."
	^4! !
!MatrixTransform2x3 methodsFor: 'objects from disk' stamp: 'jmv 4/27/2011 15:21'!
                               restoreEndianness
	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.
	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."

	| w b1 b2 b3 b4 |
	Smalltalk  isLittleEndian ifTrue: [
		1 to: self basicSize do: [:i |
			w := self basicAt: i.
			b1 := w digitAt: 1.
			b2 := w digitAt: 2.
			b3 := w digitAt: 3.
			b4 := w digitAt: 4.
			w := (b1 << 24) + (b2 << 16) + (b3 << 8) + b4.
			self basicAt: i put: w.
		]
	].

! !
!MatrixTransform2x3 methodsFor: 'objects from disk' stamp: 'ar 8/6/2001 17:52'!
                           writeOn: aStream
	aStream nextWordsPutAll: self.! !
!MatrixTransform2x3 methodsFor: 'printing' stamp: 'jmv 8/27/2012 18:53'!
   print
	self printOn: Transcript.
	Transcript newLine! !
!MatrixTransform2x3 methodsFor: 'printing' stamp: 'jmv 8/27/2012 18:53'!
                               printOn: aStream
	aStream
		newLine;
		nextPutAll: '| ';
		nextPutAll: (self a11 printPaddedLeft: 1 decimalPlaces: 3);
		space; space;
		nextPutAll: (self a12 printPaddedLeft: 1 decimalPlaces: 3);
		space; space;
		nextPutAll: (self a13 printPaddedLeft: 1 decimalPlaces: 3);
		nextPutAll: ' |';

		newLine;
		nextPutAll: '| ';
		nextPutAll: (self a21 printPaddedLeft: 1 decimalPlaces: 3);
		space; space;
		nextPutAll: (self a22 printPaddedLeft: 1 decimalPlaces: 3);
		space; space;
		nextPutAll: (self a23 printPaddedLeft: 1 decimalPlaces: 3);
		nextPutAll: ' |';
		newLine! !
!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 2/2/2001 15:47'!
                        isIdentity
	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."
	<primitive: 'primitiveIsIdentity' module: 'Matrix2x3Plugin'>
	^self isPureTranslation and:[self a13 = 0.0 and:[self a23 = 0.0]]! !
!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 2/2/2001 15:47'!
                       isPureTranslation
	"Return true if the receiver specifies no rotation or scaling."
	<primitive: 'primitiveIsPureTranslation' module: 'Matrix2x3Plugin'>
	^self a11 = 1.0 and:[self a12 = 0.0 and:[self a22 = 0.0 and:[self a21 = 1.0]]]! !
!MatrixTransform2x3 methodsFor: 'private' stamp: 'jmv 4/28/2011 08:33'!
             scalarScaleFactor
	"Warning: Only valid if we preserve aspect ratio."

	^(self a11 squared + self a21 squared) sqrt! !
!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:17'!
  setOffset: aPoint
	"Set the raw offset in the receiver"
	| pt |
	pt := aPoint asPoint.
	self a13: pt x asFloat.
	self a23: pt y asFloat.! !
!MatrixTransform2x3 methodsFor: 'private' stamp: 'jmv 4/27/2011 15:28'!
            setRadians: radians
	"Set the raw rotation angle in the receiver"
	| s c |
	s _ radians sin.
	c _ radians cos.
	self a11: c.
	self a12: s negated.
	self a21: s.
	self a22: c! !
!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:16'!
        setScale: aPoint
	"Set the raw scale in the receiver"
	| pt |
	pt := aPoint asPoint.
	self a11: pt x asFloat.
	self a22: pt y asFloat.! !
!MatrixTransform2x3 methodsFor: 'modifying' stamp: 'jmv 4/27/2011 22:41'!
            addOffset: aPoint
	"add an offset in the receiver"
	| pt |
	pt _ aPoint asPoint.
	self a13: self a13 + pt x asFloat.
	self a23: self a23 + pt y asFloat.! !
!MatrixTransform2x3 methodsFor: 'modifying' stamp: 'jmv 4/27/2011 22:41'!
                          rotateBy: radians
	"rotate the receiver by radians angle"
	| s c a11 a12 a13 a21 a22 a23|
	s _ radians sin.
	c _ radians cos.
	a11 _ self a11.
	a12 _ self a12.
	a13 _ self a13.
	a21 _ self a21.
	a22 _ self a22.
	a23 _ self a23.
	self a11: (c * a11) - (s * a21).
	self a12: (c * a12) - (s * a22).
	self a13: (c * a13) - (s * a23).
	self a21: (s * a11) + (c * a21).
	self a22: (s * a12) + (c * a22).
	self a23: (s * a13) + (c * a23).! !
!MatrixTransform2x3 methodsFor: 'modifying' stamp: 'jmv 4/28/2011 08:02'!
   scaleBy: aPoint
	"multiply by a scale. Argument can be a point, applying different scaling in x and in y directions"
	| pt sx sy |
	pt _ aPoint asPoint.
	sx _ pt x asFloat.
	sy _ pt y asFloat.
	self a11: self a11 * sx.
	self a12: self a12 * sx.
	self a13: self a13 * sx.
	self a21: self a21 * sy.
	self a22: self a22 * sy.
	self a23: self a23 * sy.! !
!MatrixTransform2x3 methodsFor: 'modifying' stamp: 'jmv 4/28/2011 07:48'!
                      scaleByNumber: aNumber rotateBy: radians
	"rotate the receiver by radians angle. Also scale by aNumber.
	Note: the scale factor is a number, not a point. Therefore, the same scale is applied in all directions.
	This means that there is no difference between  scaling then rotating and rotating then scaling"
	| s c a11 a12 a13 a21 a22 a23|
	s _ radians sin.
	c _ radians cos.
	a11 _ self a11 * aNumber.
	a12 _ self a12 * aNumber.
	a13 _ self a13 * aNumber.
	a21 _ self a21 * aNumber.
	a22 _ self a22 * aNumber.
	a23 _ self a23 * aNumber.
	self a11: (c * a11) - (s * a21).
	self a12: (c * a12) - (s * a22).
	self a13: (c * a13) - (s * a23).
	self a21: (s * a11) + (c * a21).
	self a22: (s * a12) + (c * a22).
	self a23: (s * a13) + (c * a23).! !
!MatrixTransform2x3 methodsFor: 'converting' stamp: 'jmv 8/27/2012 18:40'!
            asMatrix
	"Answer a FloatMatrix."

	| answer |
	answer _ FloatMatrix newHeight: 3 width: 3.
	answer i: 1 j: 1 put: self a11.
	answer i: 1 j: 2 put: self a12.
	answer i: 1 j: 3 put: self a13.
	answer i: 2 j: 1 put: self a21.
	answer i: 2 j: 2 put: self a22.
	answer i: 2 j: 3 put: self a23.
	answer i: 3 j: 3 put: 1.
	^answer! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 22:50'!
 identity
	^self new setScale: 1.0! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 7/9/1998 20:09'!
     new
	^self new: 6! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'jmv 8/27/2012 18:12'!
                   newFromStream: s
	"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk."
	^ s nextWordsInto: (self new: 6)! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 02:52'!
                 withOffset: aPoint
	^self identity setOffset: aPoint! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'jmv 4/27/2011 15:28'!
                withRadians: radians
	^self new setRadians: radians! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 02:49'!
                  withScale: aPoint
	^self new setScale: aPoint! !
!FloatMatrix methodsFor: 'printing' stamp: 'jmv 8/27/2012 18:31' prior: 50341255!
                             printOn: aStream
	aStream newLine.
	1 to: height do: [ :i |
		aStream nextPutAll: '| '.
		1 to: width do: [ :j |
			aStream nextPutAll: ((self i: i j: j) printPaddedLeft: 1 decimalPlaces: 3).
			"aStream print: ((self i: i j: j) roundTo: 0.001)."
			aStream nextPut: $  ].
		aStream nextPut: $|; newLine ]! !

MatrixTransform2x3 class removeSelector: #transformFromLocal:toGlobal:!

MatrixTransform2x3 removeSelector: #bytesPerElement!

MatrixTransform2x3 removeSelector: #composedWithInner:!

MatrixTransform2x3 removeSelector: #composedWithInner:into:!

MatrixTransform2x3 removeSelector: #globalBounds:toLocal:!

MatrixTransform2x3 removeSelector: #globalBoundsToLocal:!

MatrixTransform2x3 removeSelector: #localBounds:toGlobal:!

MatrixTransform2x3 removeSelector: #localBoundsToGlobal:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1412-MatrixTransform2x3-JuanVuletich-2012Aug28-08h27m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1411] on 27 August 2012 at 6:01:48 pm'!
!Morph methodsFor: 'drawing' stamp: 'jmv 2/23/2009 14:03' prior: 16896698!
           hide
	owner ifNil: [^ self].
	self visible: false! !
!Morph methodsFor: 'drawing' stamp: 'jmv 2/23/2009 14:03' prior: 16896771!
show
	"Make sure this morph is on-stage."
	self visible: true! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/27/2012 18:01' prior: 16896781!
                    visible: aBoolean 
	"set the 'visible' attribute of the receiver to aBoolean"
	(self hasExtension not and:[aBoolean])
		ifTrue: [^ self].
	self visible == aBoolean
		ifTrue: [^ self].
	self assureExtension visible: aBoolean.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	self redrawNeeded! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1413-BrowserLayoutFix-JuanVuletich-2012Aug27-17h49m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1413] on 28 August 2012 at 8:46:35 am'!
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 8/28/2012 08:40'!
                   preferencesMenu
	"Build the preferences menu for the world."
	
	^self fillIn: (self menu: 'Preferences...') from: {
		{'Themes...' . {Theme . #changeTheme} . 'switch to another theme.'}.
		{'Icons...' . {Theme . #changeIcons} . 'show more or less icons.'}.
		{'System fonts...' . { self . #standardFontDo} . 'Choose the standard fonts to use for code, lists, menus, window titles, etc.'}.
		nil.
		{'Show taskbar' . {Taskbar . #show} . 'show the taskbar'}.
		{'Hide taskbar' . {Taskbar . #hide} . 'hide the taskbar'}.
		nil.
		{'Full screen on' . { self . #fullScreenOn} . 'puts you in full-screen mode, if not already there.'}.
		{'Full screen off' . { self . #fullScreenOff} . 'if in full-screen mode, takes you out of it.'}.
		nil.
		{'Set display depth...' . {self. #setDisplayDepth} . 'choose how many bits per pixel.'}.
		{'Set desktop color...' . {self. #changeBackgroundColor} . 'choose a uniform color to use as desktop background.'}.
		nil.
		{'All preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}. 
	}! !
!TheWorldMenu methodsFor: 'popups' stamp: 'jmv 8/28/2012 08:35'!
                         preferencesDo
	"Build and show the preferences menu for the world."

	self doPopUp: self preferencesMenu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 8/28/2012 08:35' prior: 50334670!
                             buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Preferences...'. { self. #preferencesDo}.
					'put up a menu offering many controls over appearance and system preferences.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 8/28/2012 08:40' prior: 50340111!
     helpMenu
	"Build the help menu for the world."
	| menu |
	menu _ self menu: 'Help...'.
	self
		fillIn: menu
		from: {
			{'About this System...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}. 
			nil. 
			{'Editor keyboard shortcuts'. {SmalltalkEditor. #openHelp}. 'summary of keyboard shortcuts in editors for Smalltalk code.'}
		}.
	self addGestureHelpItemsTo: menu.
	self
		fillIn: menu
		from: {
			{'Useful Expressions'. {Utilities. #openStandardWorkspace}. 'a window full of useful expressions.'}. 
			nil. 
			{'Set Code Author...'. {Utilities. #setAuthor}. 'supply initials to be used to identify the author of code and other content.'}. 
			{'VM Statistics'. {self. #vmStatistics}. 'obtain some intriguing data about the vm.'}. 
			nil. 
			{'Space Left'. {self. #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}
		}.
	^ menu! !
!Theme methodsFor: 'menus' stamp: 'jmv 8/28/2012 08:37' prior: 16975683!
  basicIcons

"Minimal menu scheme."

	^ { 
		#('open...') -> #openIcon.
		#('windows...' 'find window') -> #windowIcon.
		#('help...' 'explain' 'about this system...') -> #helpIcon.
		#('themes...') -> #appearanceIcon.
		#('do...' 'Cursor normal show.' 'do it (d)') -> #doItIcon.
		#('new morph...' 'objects (o)' 'save world as morph file') -> #morphsIcon.
		#('save' 'save project on file...' ) -> #saveIcon.
		#('save as...' 'change category...' 'rename change set (r)' 'rename') -> #saveAsIcon.
		#('save as new version') -> #saveAsNewVersionIcon.
		#('quit') -> #quitIcon.
		#('save and quit' ) -> #saveAndQuitIcon.
		#('inspect it (i)' 'inspect world'  'inspect model' 'inspect morph'
		 'inspect owner chain' 'inspect' 'inspect (i)' 'basic inspect' 'message names' 'find message names' 'inspect instances' 'inspect subinstances' 'inspect change set' 'inspect context (c)' 'inspect receiver (i)' 'start CPUWatcher')
			-> #inspectIcon.
		#('explore' 'explore it (I)' 'explore world' 'explore morph' 'explore (I)' 'explore context (C)' 'explore receiver (I)') -> #exploreIcon.
		#('find...(f)' 'find class... (f)' 'find method...' 'find recent submissions' 'show hierarchy' 'show definition' 'show comment' 'filter' 'filter message list...' 'find context... (f)') -> #findIcon.
		#('add item...' 'new category...' 'create new change set...' 'new change set... (n)' 'add new file') -> #newIcon.
		#('remove method (x)' 'remove' 'remove class (x)' 'remove method from system (x)' 'remove class from system (x)' 'remove postscript') -> #deleteIcon.
		#('delete method from changeset (d)' 'delete class from change set (d)' 'destroy change set (X)' 'revert & remove from changes' 'delete unchanged windows' 'delete non windows' 'delete both of the above' 'reset variables' 'remove contained in class categories...' 'clear this change set' 'uninstall this change set' 'delete directory...' 'delete') -> #warningIcon.
		#('do again (j)' 'Redo - multiple (Z)') -> #redoIcon.
		#('undo (z)' 'revert to previous version' 'Undo - multiple (z)') -> #undoIcon.
		#('copy (c)' 'copy class...' 'copy class chgs to other side' 'copy method to other side' 'copy all to other side (c)' 'copy name to clipboard' 'copy selector to clipboard') -> #copyIcon.
		#('paste (v)' 'Paste without Format') -> #pasteIcon.
		#('cut (x)' 'move class chgs to other side' 'move method to other side' 'submerge into other side') -> #cutIcon.
		#('paste...' 'icons...') -> #worldIcon.
}! !
!Theme methodsFor: 'menus' stamp: 'jmv 8/28/2012 08:45' prior: 50338577!
                             miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'All preferences...' 'what to show...') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.		"currently unused, but a neat icon"
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !

TheWorldMenu removeSelector: #appearanceDo!

TheWorldMenu removeSelector: #appearanceDo!

TheWorldMenu removeSelector: #appearanceMenu!

TheWorldMenu removeSelector: #appearanceMenu!

TheWorldMenu removeSelector: #worldMenuHelp!

TheWorldMenu removeSelector: #worldMenuHelp!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Theme current initialize!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1414-WorldMenuTweaks-JuanVuletich-2012Aug28-08h44m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1414] on 28 August 2012 at 11:17:42 am'!
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 8/28/2012 11:16' prior: 50377075!
                  helpMenu
	"Build the help menu for the world."
	| menu |
	menu _ self menu: 'Help...'.
	self
		fillIn: menu
		from: {
			{'About this System...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.
			nil.
			{'Editor keyboard shortcuts'. {SmalltalkEditor. #openHelp}. 'summary of keyboard shortcuts in editors for Smalltalk code.'}
		}.
	self addGestureHelpItemsTo: menu.
	self
		fillIn: menu
		from: {
			{'Useful Expressions'. {Utilities. #openStandardWorkspace}. 'a window full of useful expressions.'}.
			nil.
			{'VM Statistics'. {self. #vmStatistics}. 'obtain some intriguing data about the vm.'}.
			{'Space Left'. {self. #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}
		}.
	^ menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 8/28/2012 11:17' prior: 50376976!
       preferencesMenu
	"Build the preferences menu for the world."

	^self fillIn: (self menu: 'Preferences...') from: {
		{'Themes...' . {Theme . #changeTheme} . 'switch to another theme.'}.
		{'Icons...' . {Theme . #changeIcons} . 'show more or less icons.'}.
		{'System fonts...' . { self . #standardFontDo} . 'Choose the standard fonts to use for code, lists, menus, window titles, etc.'}.
		nil.
		{'Show taskbar' . {Taskbar . #show} . 'show the taskbar'}.
		{'Hide taskbar' . {Taskbar . #hide} . 'hide the taskbar'}.
		nil.
		{'Full screen on' . { self . #fullScreenOn} . 'puts you in full-screen mode, if not already there.'}.
		{'Full screen off' . { self . #fullScreenOff} . 'if in full-screen mode, takes you out of it.'}.
		nil.
		{'Set display depth...' . {self. #setDisplayDepth} . 'choose how many bits per pixel.'}.
		{'Set desktop color...' . {self. #changeBackgroundColor} . 'choose a uniform color to use as desktop background.'}.
		nil.
		{'Set Code Author...'. {Utilities. #setAuthor}. 'supply initials to be used to identify the author of code and other content.'}.
		{'All preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.
	}! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1415-WorldMenuTweaks-JuanVuletich-2012Aug28-11h14m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1415] on 28 August 2012 at 6:21:22 pm'!
!MatrixTransform2x3 commentStamp: 'jmv 8/28/2012 15:55' prior: 50376362!
  This class represents a transformation for points, that is a combination of scale, offset, and rotation. It is implemented as a 2x3 matrix. 

The direct transformation is equivalent as multiplying a vector by the matrix. The inverse transformation is multiplying a vector by the inverse of the matrix. By convention, we say that the direct transform is outwards (#externalizePosition:). Therefore, the inverse transform is called #internalizePosition: .

Direct transform (#externalizePosition:) is fast and cheap, while inverse transform (#internalizePosition:) is relatively expensive.

Implementation Note: In the original version, from Squeak, it is assumed that the transformation deals with Integer points. All transformations will return Integer coordinates (even though float points may be passed in here). In this version, point transformations are for Float points. The plugin needs fixing, so the plugin primitives that round to integer points are commented. Rectangle transformations were removed (they were are for Display rectangles, and are done in integer coordinates by the plugin).!
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/28/2012 16:29' prior: 50376408!
            externalizePosition: aPoint
	"Answer coordinates for aPoint in the space we are in.
	 aPoint is expressed in us."

	^self transform: aPoint! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/28/2012 16:28'!
                          inverseTransform: aPoint
	"Apply the inverse transformation to aPoint, i.e. multiply our inverse by aPoint."

	"Warning: The plugin rounds result to integers. We want Float points."
	"<primitive: 'primitiveInvertPoint' module: 'Matrix2x3Plugin'>"

	| x y det a11 a12 a21 a22 detX detY |
	x _ aPoint x asFloat - (self a13).
	y _ aPoint y asFloat - (self a23).
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^0@0 ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/28/2012 16:34'!
        inverseTransformPoints: inArray
	"Transform all the points of inArray from global into local coordinates"

	^inArray collect: [ :pt | self inverseTransform: pt ]! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/28/2012 16:05'!
    transform: aPoint
	"Apply the direct transformation to aPoint, i.e. multiply self by aPoint."

	"Warning: The plugin rounds result to integers. We want Float points."
	"<primitive: 'primitiveTransformPoint' module: 'Matrix2x3Plugin'>"

	| x y |
	x _ (aPoint x * self a11) + (aPoint y * self a12) + self a13.
	y _ (aPoint x * self a21) + (aPoint y * self a22) + self a23.
	^x @ y! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/28/2012 16:32'!
           transformPositions: inArray
	"Transform all the points of inArray from local into global coordinates"

	^inArray collect: [ :pt | self transform: pt ]! !
!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'jmv 8/28/2012 16:33'!
                   displayBoundsOfInverseTransformOf: aRectangle
	"Internalize srcRect, and find a bounding rectangle with horizontal and vertical bounds (in the inner space) and integer coordinates (i.e. a displayBounds).
	Warning. Pimitive and Smalltalk code might round differently"
	^self displayBoundsOfInverseTransformOf: aRectangle into: Rectangle new! !
!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'jmv 8/28/2012 16:34'!
                      displayBoundsOfInverseTransformOf: srcRect into: dstRect
	"Internalize srcRect, and find a bounding rectangle with horizontal and vertical bounds (in the inner space) and integer coordinates (i.e. adisplayBounds). Store result into dstRect.
	Warning. Pimitive and Smalltalk code might round differently"
	<primitive: 'primitiveInvertRectInto' module: 'Matrix2x3Plugin'>
	^Rectangle encompassing: (self inverseTransformPoints: srcRect corners)! !
!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'jmv 8/28/2012 16:33'!
               displayBoundsOfTransformOf: aRectangle
	"Externalize aRectangle, and find a bounding rectangle with horizontal and vertical bounds and integer coordinates (i.e. adisplayBounds)."

	^self displayBoundsOfTransformOf: aRectangle into: Rectangle new! !
!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'jmv 8/28/2012 16:32'!
                    displayBoundsOfTransformOf: srcRect into: dstRect
	"Externalize srcRect, and find a bounding rectangle with horizontal and vertical bounds and integer coordinates (i.e. adisplayBounds). Store result into dstRect.
	Warning. Pimitive would round"
"	<primitive: 'primitiveTransformRectInto' module: 'Matrix2x3Plugin'>"

	^Rectangle encompassing: (self transformPositions: srcRect corners)! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'jmv 8/28/2012 14:59'!
   forScaleFactor: sf originalExtent: e
	"Answer a Transfor appropriate for image rescaling. sf is the scale factor to apply (i.e. 0.5 means result is half the size of original image). e is the extent of the original image."

	^self transformFromLocal: (0.5@0.5 extent: e) toExternal: (0.5@0.5 extent: sf*e)! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'jmv 8/28/2012 14:57'!
                    transformFromLocal: localBounds toExternal: externalBounds
	"Answer a Transform to translate coordinates inside localBounds into coordinates inside externalBounds.
	Parameters are instances of Rectangle. Therefore, there's no rotation involved, just scale and offset."

	^((self withOffset: (externalBounds topLeft + externalBounds bottomRight / 2.0)) composedWith:
		(self withScale: (externalBounds extent / localBounds extent) asFloatPoint)) composedWith:
			(self withOffset: (localBounds topLeft + localBounds bottomRight / 2.0) negated)! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/28/2012 16:29' prior: 50376463!
                       internalizePosition: aPoint
	"Answer our coordinates for aPoint.
	 aPoint is expressed in the space we are in."

	^self inverseTransform: aPoint! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/28/2012 16:34' prior: 50376519!
                  inverseTransformation
	"Return the inverse transformation of the receiver.
	The inverse transformation is computed by first calculating
	the inverse offset and then computing transformations
	for the two identity vectors (1@0) and (0@1)"
	| r1 r2 r3 m |
	r3 := self inverseTransform: 0@0.
	r1 := (self inverseTransform: 1@0) - r3.
	r2 := (self inverseTransform: 0@1) - r3.
	m := self species new.
	m
		a11: r1 x; a12: r2 x; a13: r3 x;
		a21: r1 y; a22: r2 y; a23: r3 y.
	^m! !

MatrixTransform2x3 class removeSelector: #transformFromLocal:toGlobal:!

MatrixTransform2x3 removeSelector: #displayBoundsOfExternalizedOf:!

MatrixTransform2x3 removeSelector: #displayBoundsOfExternalizedOf:into:!

MatrixTransform2x3 removeSelector: #displayBoundsOfInternalizedOf:!

MatrixTransform2x3 removeSelector: #displayBoundsOfInternalizedOf:into:!

MatrixTransform2x3 removeSelector: #externalize:!

MatrixTransform2x3 removeSelector: #externalizePositions:!

MatrixTransform2x3 removeSelector: #externalizePositions:!

MatrixTransform2x3 removeSelector: #globalBounds:toLocal:!

MatrixTransform2x3 removeSelector: #globalBoundsToLocal:!

MatrixTransform2x3 removeSelector: #internalizePositions:!

MatrixTransform2x3 removeSelector: #internalizePositions:!

MatrixTransform2x3 removeSelector: #localBounds:toGlobal:!

MatrixTransform2x3 removeSelector: #localBoundsToGlobal:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1416-MatrixTransform2x3Tweaks-JuanVuletich-2012Aug28-11h28m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1416] on 28 August 2012 at 10:37:16 pm'!
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/28/2012 22:30'!
         radians
	"Answer the angle in radians applied by the receiver. Will not work correctly for shear transformations, or different scale in x and y.
	Will work correctly for scaling (if equal in all directions, i.e. if scale is a scalar), for rotations, translations, and compositions of these."

	^ self a21 arcTan: self a11! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/28/2012 22:26'!
                 scalarScale
	"Answer the angle in radians applied by the receiver. Will not work correctly for shear transformations, or different scale in x and y.
	Will work correctly for scaling (if equal in all directions, i.e. if scale is a scalar), for rotations, translations, and compositions of these."

	^(self a11 squared + self a21 squared) sqrt! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/28/2012 22:22'!
                             translation
	^self a13 @ self a23! !
!MatrixTransform2x3 methodsFor: 'private' stamp: 'jmv 8/28/2012 22:34'!
                   setRadians: radians scale: aNumber translation: aPoint
	"Set the raw rotation angle in the receiver"
	| s c pt |
	s _ radians sin * aNumber.
	c _ radians cos * aNumber.
	self a11: c.
	self a12: s negated.
	self a21: s.
	self a22: c.
	pt _ aPoint asPoint.
	self a13: pt x asFloat.
	self a23: pt y asFloat.! !
!MatrixTransform2x3 methodsFor: 'private' stamp: 'jmv 8/28/2012 22:21'!
    setTranslation: aPoint
	"Set the raw offset in the receiver"
	| pt |
	pt := aPoint asPoint.
	self a13: pt x asFloat.
	self a23: pt y asFloat.! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'jmv 8/28/2012 22:36'!
                       withRadians: radians scale: aNumber translation: aPoint
	"Translation is added at the end. This means that aPoint is in the outer coordinate space.
	MatrixTransform2x3 withRadians: -3 scale: 12 translation: 4.5@3
	"
	^self new setRadians: radians scale: aNumber translation: aPoint! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'jmv 8/28/2012 22:21'!
           withTranslation: aPoint
	^self identity setTranslation: aPoint! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/28/2012 22:25' prior: 50376432!
                       externalizeScalar: aNumber
	"Externalize a distance (without a direction).
	 Only valid if we preserve aspect ratio (meaning that the scale factor is the same in all directions)."

	^aNumber * self scalarScale! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/28/2012 22:26' prior: 50376494!
    internalizeScalar: aNumber
	"Internalize a distance (without a direction). 
	 Only valid if we preserve aspect ratio (meaning that the scale factor is the same in all directions)."

	^aNumber / self scalarScale! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'jmv 8/28/2012 22:21' prior: 50377636!
  transformFromLocal: localBounds toExternal: externalBounds
	"Answer a Transform to translate coordinates inside localBounds into coordinates inside externalBounds.
	Parameters are instances of Rectangle. Therefore, there's no rotation involved, just scale and offset."

	^((self withTranslation: (externalBounds topLeft + externalBounds bottomRight / 2.0)) composedWith:
		(self withScale: (externalBounds extent / localBounds extent) asFloatPoint)) composedWith:
			(self withTranslation: (localBounds topLeft + localBounds bottomRight / 2.0) negated)! !

MatrixTransform2x3 class removeSelector: #withOffset:!

MatrixTransform2x3 class removeSelector: #withOffset:!

MatrixTransform2x3 removeSelector: #offset!

MatrixTransform2x3 removeSelector: #offset!

MatrixTransform2x3 removeSelector: #offset:!

MatrixTransform2x3 removeSelector: #offset:!

MatrixTransform2x3 removeSelector: #scalarScaleFactor!

MatrixTransform2x3 removeSelector: #scalarScaleFactor!

MatrixTransform2x3 removeSelector: #scale!

MatrixTransform2x3 removeSelector: #setOffset:!

MatrixTransform2x3 removeSelector: #setOffset:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1417-MatrixTransform2x3Tweaks-JuanVuletich-2012Aug28-22h15m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1416] on 28 August 2012 at 10:46:19 pm'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension position layoutNeeded location'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension position layoutNeeded location '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!Morph methodsFor: 'geometry' stamp: 'jmv 8/28/2012 22:44' prior: 50375725!
       morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = self morphPositionInWorld ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	self redrawNeeded.

	"Maybe we don't really need an owner to run this method..."
	self validateOwnerNotNil.

	position _ newPositionInOwner.
	location setTranslation: newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/28/2012 22:45' prior: 50375751!
  morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	"This method MUST die"
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].

	position = newPositionInOwner ifTrue: [
		^ self ].		"Null change".

	self redrawNeeded.
	position _ newPositionInOwner.
	location setTranslation: newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'initialization' stamp: 'jmv 8/28/2012 22:43' prior: 50373208!
                     initialize
	"initialize the state of the receiver"

	| b |
	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	b _ self defaultBounds.
	position _ b topLeft.
	location _ MatrixTransform2x3 withTranslation: b topLeft.
	layoutNeeded _ false! !
!Morph methodsFor: 'private' stamp: 'jmv 8/28/2012 22:44' prior: 50375223!
    privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |

	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					location setTranslation: (owner internalizeFromWorld: oldGlobalPosition).
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					]]! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 8/28/2012 22:46' prior: 50374424!
          initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	position _ 0@0.
	location setTranslation: 0@0.
	extent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 8/28/2012 22:45' prior: 50374463!
                        initialize
	super initialize.
	position _ 0@0.
	location setTranslation: 0@0.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/28/2012 22:45' prior: 50374487!
                        viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	position _ owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ].
	location setTranslation: (owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ]).
	extent _ newViewBox extent! !

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension position location layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension position location layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Morph allSubInstancesDo: [ :m | m instVarNamed: 'location' put: (MatrixTransform2x3 withTranslation: (m instVarNamed: 'position'))]!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1418-MorphUseMT2x3asLocation-JuanVuletich-2012Aug28-22h37m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1418] on 29 August 2012 at 9:01:08 am'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension position location layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension position location layoutNeeded '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/29/2012 08:32'!
              position
	"The position of 0@0 in the external coordinate system.
	It is the translation we apply when transforming points."
	^self a13 @ self a23! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/29/2012 08:35'!
scale
	"Answer the *scalar* scale applied by the receiver. Will not work correctly for shear (skew) transformations, or different scale in x and y.
	Will work correctly for scaling (if equal in all directions, i.e. if scale is a scalar), for rotations, translations, and compositions of these."

	^(self a11 squared + self a21 squared) sqrt! !
!MatrixTransform2x3 methodsFor: 'printing' stamp: 'jmv 8/29/2012 08:22'!
                               matrixPrintString
	^String streamContents: [ :strm | self printMatrixOn: strm ]! !
!MatrixTransform2x3 methodsFor: 'printing' stamp: 'jmv 8/29/2012 08:21'!
    printMatrixOn: aStream
	aStream
		newLine;
		nextPutAll: '| ';
		nextPutAll: (self a11 printPaddedLeft: 1 decimalPlaces: 3);
		space; space;
		nextPutAll: (self a12 printPaddedLeft: 1 decimalPlaces: 3);
		space; space;
		nextPutAll: (self a13 printPaddedLeft: 1 decimalPlaces: 3);
		nextPutAll: ' |';

		newLine;
		nextPutAll: '| ';
		nextPutAll: (self a21 printPaddedLeft: 1 decimalPlaces: 3);
		space; space;
		nextPutAll: (self a22 printPaddedLeft: 1 decimalPlaces: 3);
		space; space;
		nextPutAll: (self a23 printPaddedLeft: 1 decimalPlaces: 3);
		nextPutAll: ' |';
		newLine! !
!MatrixTransform2x3 methodsFor: 'private' stamp: 'jmv 8/29/2012 08:49'!
                setPosition: aPoint
	"Set the raw offset in the receiver.
	We call it 'position' when using the instance as the location of a Morph."
	| pt |
	pt := aPoint asPoint.
	self a13: pt x asFloat.
	self a23: pt y asFloat.! !
!MatrixTransform2x3 methodsFor: 'private' stamp: 'jmv 8/29/2012 08:40'!
                              setRadians: radians scale: aNumber position: aPoint
	"Set the raw rotation angle in the receiver"
	| s c pt |
	s _ radians sin * aNumber.
	c _ radians cos * aNumber.
	self a11: c.
	self a12: s negated.
	self a21: s.
	self a22: c.
	pt _ aPoint asPoint.
	self a13: pt x asFloat.
	self a23: pt y asFloat.! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'jmv 8/29/2012 08:53'!
                       withPosition: aPoint
	"scale is one, angle is zero"

	^self identity setPosition: aPoint! !
!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'jmv 8/29/2012 08:40'!
            withRadians: radians scale: aNumber position: aPoint
	"Translation is added at the end. This means that aPoint is in the outer coordinate space.
	MatrixTransform2x3 withRadians: -3 scale: 12 translation: 4.5@3
	"
	^self new setRadians: radians scale: aNumber position: aPoint! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/29/2012 08:34' prior: 50377787!
  externalizeScalar: aNumber
	"Externalize a distance (without a direction).
	 Only valid if we preserve aspect ratio (meaning that the scale factor is the same in all directions)."

	^aNumber * self scale! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 8/29/2012 08:34' prior: 50377797!
          internalizeScalar: aNumber
	"Internalize a distance (without a direction). 
	 Only valid if we preserve aspect ratio (meaning that the scale factor is the same in all directions)."

	^aNumber / self scale! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/29/2012 08:34' prior: 50376734!
                      printOn: aStream
	"Note:
	Will not work correctly for shear (skew) transformations, or different scale in x and y.
	Will work correctly for scaling (if equal in all directions, i.e. if scale is a scalar), for rotations, translations, and compositions of these."
	aStream
		nextPutAll: self class name;
		nextPutAll: '( scale: '.
	self scale printOn: aStream.
	aStream nextPutAll: '. radians: '.
	self radians printOn: aStream.
	aStream nextPutAll: '. position: '.
	self position printOn: aStream.
	aStream nextPutAll: ') '! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/29/2012 08:26' prior: 50377718!
                        radians
	"Answer the angle in radians applied by the receiver. Will not work correctly for shear (skew) transformations, or different scale in x and y.
	Will work correctly for scaling (if equal in all directions, i.e. if scale is a scalar), for rotations, translations, and compositions of these."

	^ self a21 arcTan: self a11! !
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/29/2012 08:46' prior: 50377745!
                          translation
	"Translation and position are the same.
	Use the word translation when thinking about coordinate transformation, but use
	the word position when thinking about morph locations"

	^self a13 @ self a23! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/29/2012 08:29' prior: 50364177!
                            externalize: aPoint
	"aPoint is in own coordinates. Answer is in owner's coordinates."
	"Must include scale and rotation!!"
	self flag: #jmvVer2.
	^ location externalizePosition: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/29/2012 08:30' prior: 50359333!
                       externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates.
	BUT there is no well defined World!!"
	| inOwners |
	self flag: #jmvVer2.

	inOwners _ self externalize: aPoint.
	^owner
		ifNotNil: [ owner externalizeToWorld: inOwners ]
		ifNil: [ inOwners ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/29/2012 08:38' prior: 50365059!
                   internalize: aPoint
	"aPoint is in owner's coordinates. Answer is in own coordinates."
	"Must include scale and rotation!!"
	self flag: #jmvVer2.
	aPoint ifNil: [ 
		'---------- internalize: nil' print.
		thisContext printStack: 10.
		^nil ].	"sacar esto!!"
	^ location internalizePosition: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/29/2012 08:39' prior: 50365068!
       internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	| inOwners |
	self flag: #jmvVer2.
	aPoint ifNil: [ 
		'---------- internalizeFromWorld: nil' print.
		thisContext printStack: 10.
		^nil ].	"sacar esto!!"
	inOwners _ owner
		ifNotNil: [ owner internalizeFromWorld: aPoint ]
		ifNil: [ aPoint ].
	^self internalize: inOwners! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/29/2012 08:59' prior: 50359344!
                               morphPositionInOwner
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"

	self flag: #jmvVer2.
	"Maybe we don't really need an owner to answer this..."
	self validateOwnerNotNil.

	^ location position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/29/2012 09:00' prior: 50377865!
     morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."

	self flag: #jmvVer2.

	location position = newPositionInOwner ifTrue: [
		^ self ].		"Null change"

	self redrawNeeded.

	"Maybe we don't really need an owner to run this method..."
	self validateOwnerNotNil.

	location setPosition: newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/29/2012 08:55' prior: 50359388!
          morphPositionInWorld
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	"Most likely we don't want to use global coordinates...
	In fact, we could be in many frames of reference at the same time...
	This method makes no sense at all!!"
	self validateOwnerNotNil.

	^self externalizeToWorld: 0@0! !
!Morph methodsFor: 'geometry' stamp: 'jmv 8/29/2012 09:00' prior: 50377892!
              morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	"This method MUST die"
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].

	location position = newPositionInOwner ifTrue: [
		^ self ].		"Null change".

	self redrawNeeded.
	location setPosition: newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'initialization' stamp: 'jmv 8/29/2012 09:00' prior: 50377942!
               initialize
	"initialize the state of the receiver"

	| b |
	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	b _ self defaultBounds.
	location _ MatrixTransform2x3 withPosition: b topLeft.
	layoutNeeded _ false! !
!Morph methodsFor: 'private' stamp: 'jmv 8/29/2012 08:59' prior: 50377957!
                              privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |

	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					location setPosition: (owner internalizeFromWorld: oldGlobalPosition).
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					]]! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 8/29/2012 09:00' prior: 50377990!
            initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	location setPosition: 0@0.
	extent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 8/29/2012 09:00' prior: 50378001!
            initialize
	super initialize.
	location setPosition: 0@0.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 8/29/2012 09:00' prior: 50378010!
            viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	location setPosition: (owner
		ifNil: [ newViewBox topLeft ]
		ifNotNil: [ owner internalizeFromWorld: newViewBox topLeft ]).
	extent _ newViewBox extent! !

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension location layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'owner submorphs extension location layoutNeeded'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

MatrixTransform2x3 class removeSelector: #withRadians:scale:translation:!

MatrixTransform2x3 class removeSelector: #withRadians:scale:translation:!

MatrixTransform2x3 removeSelector: #scalarScale!

MatrixTransform2x3 removeSelector: #scalarScale!

MatrixTransform2x3 removeSelector: #setRadians:scale:translation:!

MatrixTransform2x3 removeSelector: #setRadians:scale:translation:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1419-MorphUseMT2x3asLocation-JuanVuletich-2012Aug29-08h43m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1419] on 29 August 2012 at 9:18:28 am'!
!MatrixTransform2x3 methodsFor: 'inspecting' stamp: 'jmv 8/29/2012 09:11'!
                   customizeExplorerContents

	^ true! !
!MatrixTransform2x3 methodsFor: 'inspecting' stamp: 'jmv 8/29/2012 09:17'!
               explorerContents

	^#(a11 a12 a13 a21 a22 a23) collect: [ :symbol |
		ObjectExplorerWrapper
			with: (self perform: symbol)
			name: symbol printString
			model: self ]! !
!MatrixTransform2x3 methodsFor: 'inspecting' stamp: 'jmv 8/29/2012 09:07'!
         inspectorClass 
	"Answer the class of the inspector to be used on the receiver.  Called by inspect; 
	use basicInspect to get a normal (less useful) type of inspector."

	^OrderedCollectionInspector! !

MatrixTransform2x3 removeSelector: #explorerContentsWithIndexCollect:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1420-MT2x3InspectorExplorer-JuanVuletich-2012Aug29-09h05m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1420] on 29 August 2012 at 9:27:56 am'!
!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'jmv 8/29/2012 09:26'!
               degrees
	"Answer the angle in radians applied by the receiver. Will not work correctly for shear (skew) transformations, or different scale in x and y.
	Will work correctly for scaling (if equal in all directions, i.e. if scale is a scalar), for rotations, translations, and compositions of these."

	^ self radians radiansToDegrees! !
!MatrixTransform2x3 methodsFor: 'printing' stamp: 'jmv 8/29/2012 09:27' prior: 50378183!
                       printOn: aStream
	"Note:
	Will not work correctly for shear (skew) transformations, or different scale in x and y.
	Will work correctly for scaling (if equal in all directions, i.e. if scale is a scalar), for rotations, translations, and compositions of these."
	aStream
		nextPutAll: self class name;
		nextPutAll: '( scale: '.
	self scale printOn: aStream.
	aStream nextPutAll: '. degrees: '.
	self degrees printOn: aStream.
	aStream nextPutAll: '. position: '.
	self position printOn: aStream.
	aStream nextPutAll: ') '! !
!MatrixTransform2x3 methodsFor: 'inspecting' stamp: 'jmv 8/29/2012 09:27' prior: 50378490!
                       explorerContents

	^{
		ObjectExplorerWrapper
			with: self scale
			name: 'scale'
			model: self. 
		ObjectExplorerWrapper
			with: self degrees
			name: 'degrees'
			model: self. 
		ObjectExplorerWrapper
			with: self position
			name: 'position'
			model: self }! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1421-MatrixTransform2x3Tweaks-JuanVuletich-2012Aug29-09h24m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1421] on 30 August 2012 at 10:39:38 pm'!

!classDefinition: #FormCanvas category: #'Morphic-Support'!
Object subclass: #FormCanvas
	instanceVariableNames: 'origin clipRect form port shadowColor cti currentTransformation transformations'
	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms'
	poolDictionaries: ''
	category: 'Morphic-Support'!

Object subclass: #FormCanvas
	instanceVariableNames: 'origin clipRect form port shadowColor cti currentTransformation transformations '
	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms '
	poolDictionaries: ''
	category: 'Morphic-Support'!
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/30/2012 08:38'!
                  zzfillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm
	"Fill the given rectangle."

	| displayRectangle |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	^self fillRectangle: displayRectangle colorOrInfiniteForm: aColorOrInfiniteForm! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/30/2012 08:39'!
                     zzfillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: bw borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder

	| displayRectangle |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	^self fillRectangle: displayRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: bw borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder! !
!FormCanvas methodsFor: 'morphic' stamp: 'jmv 8/30/2012 22:21'!
                         fullDraw: aMorph
	"Draw the full Morphic structure on us"

	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."
	"
	This is starting to work:
		| c |
		c _ Display getCanvas initTransformationsFor: World.
		World submorphsDo: [ :m | c fullDraw: m ].
	"

	"To replace #fullDrawOn:"
	self flag: #jmvVer3.

	aMorph visible ifFalse: [^ self].
	(self isVisible: aMorph morphFullBoundsInWorld) ifFalse: [^ self].		"Needs fullBounds 'in owner' if inside a scroller"
	aMorph isKnownFailing ifTrue: [ ^ aMorph drawErrorOn: self ].

	self into: aMorph.

	aMorph fullDrawOn: self.

	self outOf: aMorph! !
!FormCanvas methodsFor: 'morphic' stamp: 'jmv 8/30/2012 20:23'!
                   initTransformationsFor: aWorld

	currentTransformation _ aWorld location.
	cti _ 1.
	transformations
		ifNil: [ transformations _ OrderedCollection with: currentTransformation ]
		ifNotNil: [ transformations at: cti put: currentTransformation ]! !
!FormCanvas methodsFor: 'morphic' stamp: 'jmv 8/30/2012 08:55'!
        into: aMorph

	| last |
	cti _ cti + 1.
	transformations size < cti
		ifTrue: [	
			currentTransformation _ currentTransformation composedWith: aMorph location.
			transformations add: currentTransformation ]
		ifFalse: [
			"reuse the instance"
			last _ currentTransformation.
			currentTransformation _ transformations at: cti.
			last composedWith: aMorph location into: currentTransformation ]! !
!FormCanvas methodsFor: 'morphic' stamp: 'jmv 8/30/2012 08:55'!
              outOf: aMorph

	cti _ cti - 1.
	currentTransformation _ transformations at: cti! !
!Morph methodsFor: 'accessing' stamp: 'jmv 8/29/2012 22:16'!
                location
	^location! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:30' prior: 16896648!
                              drawSubmorphsOn: aCanvas 
	"Display submorphs back to front"
	submorphs isEmpty ifTrue: [ ^ self ].
	self clipsSubmorphs
		ifTrue: [
			aCanvas
				clipBy: self clippingBounds
				during: [ :clippedCanvas | 
					submorphs reverseDo:
						[ :m |  clippedCanvas fullDraw: m ] ] ]
		ifFalse: [
			submorphs reverseDo:
				[ :m |  aCanvas fullDraw: m ] ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:31' prior: 50354668!
                 fullDrawOn: aCanvas
	"Draw the full Morphic structure on the given Canvas"

	"Draw receiver itself"
	(aCanvas isVisible: self morphBoundsInWorld) ifTrue: [
		aCanvas clipBy: self morphBoundsInWorld during: [ :c | self drawOn: c ]].	"Needs bounds 'in owner' if inside a scroller"
	self drawSubmorphsOn: aCanvas.
	self drawDropHighlightOn: aCanvas.
	self drawMouseDownHighlightOn: aCanvas! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:35' prior: 16896730!
               imageForm: depth forRectangle: rect
	| canvas |
	canvas _ Display defaultCanvasClass depth: depth over: rect.
	canvas initTransformationsFor: self world.
	canvas fullDraw: self.
	^ canvas formWithOffset! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:39' prior: 50353073!
       ownShadowForm
	"Return a form representing the 'shadow' of the receiver, without including submorphs 
	regardless of clipping"
	| canvas |
	canvas _ Display defaultCanvasClass forShadowOver: self morphBoundsInWorld.
	canvas initTransformationsFor: self world.
	canvas clipBy: self morphBoundsInWorld during: [ :c | self drawOn: c ].
	^ canvas formWithOffset! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:35' prior: 50354702!
            shadowForm
	"Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."
	| bnds canvas |
	bnds _ self morphFullBoundsInWorld.
	canvas _ Display defaultCanvasClass forShadowOver: bnds.
	canvas initTransformationsFor: self world.
	canvas fullDraw: self.
	^ canvas formWithOffset! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:31' prior: 50355001!
        fullDrawOn: aCanvas 
	"A HandMorph has unusual drawing requirements:
		1. the hand itself (i.e., the cursor) appears in front of its submorphs
		2. morphs being held by the hand cast a shadow on the world/morphs below
	The illusion is that the hand plucks up morphs and carries them above the world."

	self nonCachingFullDrawOn: aCanvas.
! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:38' prior: 50355060!
                          shadowForm
	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"
	| bnds canvas |
	bnds _ Rectangle merging: (submorphs collect: [:m | m morphFullBoundsInWorld]).
	canvas _ Display defaultCanvasClass forShadowOver: bnds.
	canvas initTransformationsFor: self world.
	self drawSubmorphsOn: canvas.
	^ canvas formWithOffset! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:31' prior: 50355379!
                        drawHand: aHandMorph

	| bw r |
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth // 2.
		r _ aHandMorph morphFullBoundsInWorld.
		canvas frameRectangle: r borderWidth: bw color: Color black.
		canvas frameRectangle: (r insetBy: bw) borderWidth: bw color: Color white.
		canvas clipBy: aHandMorph morphBoundsInWorld during: [ :c | aHandMorph drawOn: c ]]
	ifFalse: [
		 canvas fullDraw: aHandMorph]! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:29' prior: 50355396!
                           drawInvalidAreasWorld: aWorld submorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |
	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ OrderedCollection new.
	(damageRecorder invalidRectsFullBounds: aWorld viewBox) do: [ :r |
		r ifNotNil: [ initialRectsToRepair addLast: r ]].
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	self flag: #jmvVer3.
	"Not sure if needed on every cycle... most likely not!! anyway, harmless"
	canvas initTransformationsFor: aWorld.

	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			(canvas copyClipRect: r) clipBy: aWorld morphBoundsInWorld during: [ :c | aWorld drawOn: c ]]].
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could merge all xrects into just one call... Most likely, that would be slower, though."
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas copyClipRect: r) fullDraw: m
		].
"		(canvas copyClipRect: rr) fullDrawMorph: m "
	].
	
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !

!classDefinition: #FormCanvas category: #'Morphic-Support'!
Object subclass: #FormCanvas
	instanceVariableNames: 'origin clipRect form port shadowColor transformations currentTransformation cti'
	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms'
	poolDictionaries: ''
	category: 'Morphic-Support'!

Object subclass: #FormCanvas
	instanceVariableNames: 'origin clipRect form port shadowColor transformations currentTransformation cti'
	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms'
	poolDictionaries: ''
	category: 'Morphic-Support'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1422-LocalCoordinates01-JuanVuletich-2012Aug30-22h24m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1422] on 30 August 2012 at 10:51:50 pm'!
!Morph methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:47' prior: 50353046!
drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		zzfillRectangle: (0@0 extent: self morphExtent)
		colorOrInfiniteForm: self color! !
!BorderedRectMorph methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:48' prior: 50373698!
             drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		zzfillRectangle: (0@0 extent: self morphExtent)
		colorOrInfiniteForm: color
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 8/30/2012 22:49' prior: 50374297!
                             drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas zzfillRectangle: (0@0 extent: self morphExtent) colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	aCanvas fillRectangle: self titleAreaInnerRect colorOrInfiniteForm: titleColor! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1423-LocalCoordinates02-JuanVuletich-2012Aug30-22h51m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1423] on 1 September 2012 at 7:39:19 pm'!
!FormCanvas methodsFor: 'drawing' stamp: 'jmv 8/31/2012 13:42'!
             zzline: pt1 to: pt2 width: w color: c
	| offset p1 p2 |
	p1 _ currentTransformation transform: pt1.
	p2 _ currentTransformation transform: pt2.
	offset _ origin - (w // 2) asPoint.
	self setPaintColor: c.
	port
		width: w;
		height: w;
		drawFrom: (p1 rounded + offset) to: (p2 rounded + offset)! !
!FormCanvas methodsFor: 'drawing-ovals' stamp: 'jmv 8/31/2012 13:49'!
               zzfillOval: r color: fillColor borderWidth: borderWidth borderColor: borderColor

	| rect displayRectangle |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: r.
	"draw the border of the oval"
	rect _ (displayRectangle translatedBy: origin) truncated.
	(borderWidth = 0 or: [borderColor isTransparent]) ifFalse:[
		self setPaintColor: borderColor.
		port frameOval: rect borderWidth: borderWidth].
	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillOval: (rect insetBy: borderWidth)].
! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/31/2012 13:37'!
        zzframeAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor
	| rect |
	rect _ (currentTransformation displayBoundsOfTransformOf: r) translatedBy: origin.
	"draw the border of the rectangle"
	borderColor isTransparent ifFalse:[
		self setPaintColor: borderColor.
		port frameRect: rect borderWidth: borderWidth ].

	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillRect: (rect insetBy: borderWidth) offset: origin ]! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/31/2012 17:18'!
                            zzframeRectangle: r borderWidth: borderWidth color: borderColor
	"
	Display getCanvas
		frameRectangle: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red
	"
	| rect |
	rect _ (currentTransformation displayBoundsOfTransformOf: r) translatedBy: origin.
	self setPaintColor: borderColor.
	port
		frameRect: rect
		borderWidth: borderWidth.! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 8/31/2012 13:53'!
               zzroundRect: aRectangle color: aColor radius: r
	"
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10
	"
	"top stripe"
	| displayRectangle |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	self
		image: (FormCanvas topLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: displayRectangle topLeft.
	self
		image: (FormCanvas topRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: displayRectangle topRight - (r@0).
	self fillRectangle: ((displayRectangle withHeight: r) insetBy: r@0) colorOrInfiniteForm: aColor.

	"center stripe"
	self fillRectangle: (displayRectangle insetBy: (0 @ r corner: 0 @ r)) colorOrInfiniteForm: aColor.
	
	"bottom stripe"
	self
		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: displayRectangle bottomLeft - (0@r).
	self
		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: displayRectangle bottomRight - (r@r) .
	self fillRectangle: ((displayRectangle bottomLeft + (r@r negated)) extent: (displayRectangle width - r - r@r)) colorOrInfiniteForm: aColor! !
!FormCanvas class methodsFor: 'instance creation' stamp: 'jmv 8/31/2012 13:12'!
                   onForm: aForm

	^ self new setForm: aForm
! !
!FormCanvas class methodsFor: 'instance creation' stamp: 'jmv 8/31/2012 13:11'!
  withExtent: extent depth: depth

	^ self new setForm: (Form extent: extent depth: depth)! !
!RectangleLikeMorph methodsFor: 'geometry testing' stamp: 'jmv 8/31/2012 13:24'!
                   isOrthoRectangularMorph
	"Answer true if I fill my bounds. I.e. I am a rectangle aligned with Display borders and
	specified by my bounds instance variable.
	If true, #containsPoint: can simply check #bounds."
	^true! !
!Form methodsFor: 'accessing' stamp: 'jmv 8/31/2012 13:12' prior: 16856860!
                        getCanvas
	"Return a Canvas that can be used to draw onto the receiver"
	^self defaultCanvasClass onForm: self! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 8/31/2012 13:04' prior: 16861315!
                              setForm: aForm

	form := aForm.
	port := self portClass toForm: form.

	"this was the contents of the #reset method"
	origin := 0@0.							"origin of the top-left corner of this cavas"
	clipRect := (0@0 corner: form extent).	"default clipping rectangle"
	shadowColor _ nil! !
!FormCanvas methodsFor: 'morphic' stamp: 'jmv 8/31/2012 13:38' prior: 50378616!
                            fullDraw: aMorph
	"Draw the full Morphic structure on us"

	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."
	"
	This is starting to work:
		| c |
		c _ Display getCanvas initTransformationsFor: World.
		World submorphsDo: [ :m | c fullDraw: m ].
	"

	"To replace #fullDrawOn:"
	self flag: #jmvVer3.

	aMorph visible ifFalse: [^ self].
	(self isVisible: aMorph morphFullBoundsInWorld) ifFalse: [^ self].		"Needs fullBounds 'in owner' if inside a scroller"

	self into: aMorph.

	aMorph isKnownFailing 
		ifTrue: [ aMorph drawErrorOn: self ]
		ifFalse: [ aMorph fullDrawOn: self ].

	self outOf: aMorph! !
!FormCanvas methodsFor: 'morphic' stamp: 'jmv 8/31/2012 12:56' prior: 50378639!
                     initTransformationsFor: aWorld

	"Maybe fold into senders"
	self flag: #jmvVer2.

	currentTransformation _ aWorld location.
	cti _ 1.
	transformations
		ifNil: [ transformations _ OrderedCollection with: currentTransformation ]
		ifNotNil: [ transformations at: cti put: currentTransformation ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/31/2012 13:46' prior: 50353029!
           drawErrorOn: aCanvas
	"The morph (or one of its submorphs) had an error in its drawing method."
	| tl br w |
	w _ 10.
	tl _ 0@0.
	br _ self morphExtent.
	aCanvas
		zzframeAndFillRectangle: (tl corner: br)
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.

	aCanvas zzline: tl +w to: br -w width: w color: Color yellow.
	aCanvas zzline: br x - w @ w to: w @ (br y - w) width: w color: Color yellow.! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 8/31/2012 13:27' prior: 16897973!
        isOrthoRectangularMorph
	"Answer true if I fill my bounds. I.e. I am a rectangle aligned with Display borders and
	specified by my bounds instance variable.
	If true, #containsPoint: can simply check #bounds."
	^false! !
!EllipseMorph methodsFor: 'drawing' stamp: 'jmv 8/31/2012 13:50' prior: 50373720!
                 drawOn: aCanvas 

	| r bc bw |
	r _ 0@0 extent: self morphExtent..
	bw _ borderWidth.
	bc _ borderColor.
	aCanvas isShadowDrawing
		ifTrue: [
			bw _ 0.
			bc _ nil ].
	aCanvas zzfillOval: r color: color borderWidth: bw borderColor: bc.
! !
!MenuMorph methodsFor: 'drawing' stamp: 'jmv 8/31/2012 13:55' prior: 50373878!
drawOn: aCanvas
	
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas zzroundRect: (0@0 extent: self morphExtent) color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			aCanvas zzfillRectangle: (0@0 extent: self morphExtent) colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #raised baseColorForBorder: color ]! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 8/31/2012 17:29' prior: 50369595!
                focusIndicatorRectangle

	| topLeft bottomRight |
	topLeft _ 0@0.
	bottomRight _ topLeft + self morphExtent.
	topLeft _ topLeft + borderWidth.
	bottomRight _ bottomRight - borderWidth.
	self vIsScrollbarShowing ifTrue: [
		bottomRight _ bottomRight x - self scrollBarClass scrollbarThickness@ bottomRight y].
	self hIsScrollbarShowing ifTrue: [
		bottomRight _ bottomRight x @ 
			(bottomRight y - self scrollBarClass scrollbarThickness)].
	^topLeft corner: bottomRight! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 8/31/2012 17:35' prior: 50353959!
            drawLinesOn: aCanvas 
	| lColor |
	lColor _ self lineColor.

	self flag: #jmvVer2. "mhhhhh y todo el manoseo este en este metodo... esta bien? o mover el dibujado a cada morph?"
	aCanvas into: scroller.

	scroller submorphs do: [ :submorph | 
		(submorph isExpanded or: [
			(aCanvas isVisible: submorph morphBoundsInWorld) or: [
				submorph nextSibling notNil and: [ aCanvas isVisible: submorph nextSibling morphBoundsInWorld ] ] ]) ifTrue: [
			aCanvas into: submorph.
			submorph
				drawLinesOn: aCanvas
				lineColor: lColor.
			aCanvas outOf: submorph ] ].
	aCanvas outOf: scroller.! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 8/31/2012 17:30' prior: 50353974!
                    drawOn: aCanvas

	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			zzframeRectangle: self focusIndicatorRectangle 
			borderWidth: Preferences focusIndicatorWidth
			color: Theme current focusIndicator ].

	"selectedMorph is subMorph of scroller... scroller is an InnerHierarchicalListMorph (as per #innerMorphClass)... This should be drawn there, imo."
	selectedMorph  ifNotNil: [
		aCanvas
			fillRectangle: (selectedMorph morphBoundsInWorld intersect: scroller morphBoundsInWorld)
			colorOrInfiniteForm: (Theme current listHighlightFocused: self hasKeyboardFocus)].

	Preferences showLinesInHierarchyViews ifTrue:[
		self drawLinesOn: aCanvas ]! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 8/31/2012 17:29' prior: 16866460!
                       keyboardFocusChange: aBoolean
	"The message is sent to a morph when its keyboard focus changes.
	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.
	In this case, all we need to do is to redraw focus feedback"

	self redrawNeeded! !
!PluggableListMorph methodsFor: 'drawing' stamp: 'jmv 8/31/2012 17:30' prior: 16913991!
                    drawOn: aCanvas
	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			zzframeRectangle: self focusIndicatorRectangle
			borderWidth: Preferences focusIndicatorWidth
			color: Theme current focusIndicator ].! !
!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 8/31/2012 17:29' prior: 16914034!
                        keyboardFocusChange: aBoolean
	"The message is sent to a morph when its keyboard focus changes.
	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.
	In this case, all we need to do is to redraw focus feedback"

	self redrawNeeded! !
!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 8/31/2012 17:30' prior: 16973727!
                        drawOn: aCanvas 
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"

	| bw bc |
	super drawOn: aCanvas.
	bw _ Preferences focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan]
			ifFalse: [
				self textMorph hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ] 
					ifFalse: [
						self textMorph hasUnacceptedEdits
							ifTrue: [
								bc _ Color red]]]].

	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [
		bc ifNil: [
			bc _ Theme current focusIndicator ]]
	ifFalse: [
		bc ifNotNil: [
			bc _ bc alphaMixed: 0.4 with: Color white ]].
	bc ifNotNil: [
		aCanvas zzframeRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !
!WorldState methodsFor: 'canvas' stamp: 'jmv 8/31/2012 13:11' prior: 16986417!
                     assuredNonDisplayCanvas
	(canvas isNil or: [
		canvas drawsOnDisplay or: [
		(canvas extent ~= viewBox extent) or: [
		canvas form depth ~= Display depth]]])
			ifTrue: [
				"allocate a new offscreen canvas the size of the window"
				self canvas: (Display defaultCanvasClass withExtent: viewBox extent depth: Display depth)].
	^ self canvas! !

PluggableScrollPane removeSelector: #invalidateBorderFeedback!

PluggableScrollPane removeSelector: #invalidateBorderFeedback!

FormCanvas class removeSelector: #extent:depth:!

FormCanvas class removeSelector: #extent:depth:!

FormCanvas class removeSelector: #on:!

FormCanvas class removeSelector: #on:!

FormCanvas removeSelector: #reset!

FormCanvas removeSelector: #reset!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1424-LocalCoordinates03-JuanVuletich-2012Sep01-19h22m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1423] on 1 September 2012 at 11:44:04 pm'!

!classDefinition: #HierarchicalListMorph category: #'Morphic-Views for Models'!
PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect columns sortingSelector getSelectionSelector setSelectionSelector lineColor menuGetter mainView'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect columns sortingSelector getSelectionSelector setSelectionSelector lineColor menuGetter mainView '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

!classDefinition: #IndentingListItemMorph category: #'Morphic-Views for Models'!
StringMorph subclass: #IndentingListItemMorph
	instanceVariableNames: 'indentLevel isExpanded complexContents firstChild container nextSibling isSelected'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

StringMorph subclass: #IndentingListItemMorph
	instanceVariableNames: 'indentLevel isExpanded complexContents firstChild container nextSibling isSelected '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/1/2012 23:07'!
                           zzimage: aForm at: aPoint
	"Draw a translucent image using the best available way of representing translucency."

	| p |
	p _ currentTransformation transform: aPoint.
	self image: aForm
		at: p rounded
		sourceRect: aForm boundingBox! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/1/2012 23:34'!
               zzdrawString: aString from: firstIndex to: lastIndex in: aRectangle font: fontOrNil color: c
	| font portRect bounds |
	bounds _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [port clipRect: portRect. ^self].
	port clipWidth = 0 ifTrue: [port clipRect: portRect. ^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin)
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/1/2012 23:33'!
               zzdrawString: s in: boundsRect font: fontOrNil color: c
	^self zzdrawString: s from: 1 to: s size in: boundsRect font: fontOrNil color: c! !
!IndentingListItemMorph methodsFor: 'accessing' stamp: 'jmv 9/1/2012 23:41'!
      isSelected: aBoolean

	isSelected _ aBoolean.
	self redrawNeeded! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/1/2012 22:57'!
             drawLineToggleToTextFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor hasToggle: hasToggle
	"If I am not the only item in my container, draw the line between:
		- my toggle (if any) or my left edge (if no toggle)
		- and my text left edge"

	| myBounds myCenter hLineY hLineLeft |
	anIndentingListItemMorph isSoleItem ifTrue: [ ^ self ].
	myBounds _ anIndentingListItemMorph toggleRectangle.
	myBounds _ anIndentingListItemMorph location displayBoundsOfTransformOf: myBounds.
	myCenter _ myBounds center.
	hLineY _ myCenter y.
	hasToggle
		ifTrue: [ hLineLeft _ myBounds right - 3 ]
		ifFalse: [ hLineLeft _ myCenter x - 1 ].
	"Draw line from toggle to text"
	aCanvas
		zzline: hLineLeft @ hLineY
		to: myBounds right + 0 @ hLineY
		width: 1
		color: lineColor! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/1/2012 22:33'!
        drawLinesFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor 
	| hasToggle |
	hasToggle _ anIndentingListItemMorph hasToggle.
	"Draw line from toggle to text"
	self
		drawLineToggleToTextFor: anIndentingListItemMorph
		on: aCanvas
		lineColor: lineColor
		hasToggle: hasToggle.

	"Draw the line from toggle to the nextSibling's toggle"
	anIndentingListItemMorph nextSibling ifNotNil: [
		self
			drawLinesToNextSiblingFor: anIndentingListItemMorph
			on: aCanvas
			lineColor: lineColor
			hasToggle: hasToggle ].

	"If it have children and am expanded, draw a line to its first child"
	(anIndentingListItemMorph firstChild notNil and: [
			anIndentingListItemMorph isExpanded ]) ifTrue: [
		self
			drawLinesToFirstChildFor: anIndentingListItemMorph
			on: aCanvas
			lineColor: lineColor]! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/1/2012 22:57'!
            drawLinesOn: aCanvas 
	| lColor |
	lColor _ Theme current line.

	self submorphs do: [ :submorph | 
		(submorph isExpanded or: [
			(aCanvas isVisible: submorph morphBoundsInWorld) or: [
				submorph nextSibling notNil and: [
					aCanvas isVisible:
						submorph nextSibling morphBoundsInWorld ] ] ])
		ifTrue: [
			self
				drawLinesFor: submorph
				on: aCanvas
				lineColor: lColor ]]! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/1/2012 22:57'!
       drawLinesToFirstChildFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor
	"Draw line from me to next sibling"

	| vLineX vLineTop vLineBottom childCenter |
	childCenter _ anIndentingListItemMorph firstChild location externalizePosition:
			anIndentingListItemMorph firstChild toggleRectangle center.
	vLineX _ childCenter x - 1.
	vLineTop _ (anIndentingListItemMorph location
		externalizePosition: anIndentingListItemMorph morphExtent) y.
	anIndentingListItemMorph firstChild hasToggle
		ifTrue: [ vLineBottom _ childCenter y - 7 ]
		ifFalse: [ vLineBottom _ childCenter y ].
	aCanvas
		zzline: vLineX @ vLineTop
		to: vLineX @vLineBottom
		width: 1
		color: lineColor! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/1/2012 22:58'!
     drawLinesToNextSiblingFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor hasToggle: hasToggle
	| vLineX myCenter vLineTop vLineBottom nextSibCenter |

	self flag: #jmvVer2. "complicated... not intuitive... who should draw this?"
	"the center of the toggle in our own coordinates (and not in those of child, that is not our child, but our sibling in the morphic hierarchy!!)"
	nextSibCenter _ anIndentingListItemMorph nextSibling location externalizePosition:
		anIndentingListItemMorph nextSibling toggleRectangle center.

	myCenter _ anIndentingListItemMorph location externalizePosition:
		 anIndentingListItemMorph toggleRectangle center.
	vLineX _ myCenter x - 1.
	hasToggle
		ifTrue: [ vLineTop _ myCenter y + 5 ]
		ifFalse: [ vLineTop _ myCenter y ].
	anIndentingListItemMorph nextSibling hasToggle
		ifTrue: [ vLineBottom _ nextSibCenter y - 7 ]
		ifFalse: [ vLineBottom _ nextSibCenter y ].
	"Draw line from me to next sibling"
	aCanvas
		zzline: vLineX @ vLineTop
		to: vLineX @ vLineBottom
		width: 1
		color: lineColor! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/1/2012 20:04'!
                            drawOn: aCanvas

	super drawOn: aCanvas.

	Preferences showLinesInHierarchyViews ifTrue:[
		self drawLinesOn: aCanvas ]! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/1/2012 20:19' prior: 50379212!
           drawOn: aCanvas

	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			zzframeRectangle: self focusIndicatorRectangle 
			borderWidth: Preferences focusIndicatorWidth
			color: Theme current focusIndicator ]! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 9/1/2012 23:41' prior: 16866755!
                          selectedMorph: aMorph

	selectedMorph ifNotNil: [
		selectedMorph isSelected: false ].
	selectedMorph _ aMorph.
	selectedMorph ifNotNil: [
		selectedMorph isSelected: true ]! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 9/1/2012 23:40' prior: 16866778!
                   selectionIndex: idx
	"Called internally to select the index-th item."
	| theMorph index |
	idx ifNil: [^ self].
	index _ idx min: scroller submorphs size max: 0.
	theMorph _ index = 0 ifTrue: [ nil ] ifFalse: [ scroller submorphs at: index ].
	self selectedMorph: theMorph.
	self scrollSelectionIntoView! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 9/1/2012 23:38' prior: 50374193!
                  drawOn: aCanvas

	| tRect sRect colorToUse sLeft aForm centeringOffset |
	isSelected ifTrue: [
		aCanvas
			zzfillRectangle: (0@0 extent: self morphExtent)
			colorOrInfiniteForm: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) ].

	complexContents hasContents ifTrue: [
		tRect _ self toggleRectangle.
		aForm _ isExpanded 
			ifTrue: [ container expandedForm ]
			ifFalse: [ container notExpandedForm ].
		centeringOffset _ ((tRect height - aForm extent y) / 2.0) rounded.
		aCanvas 
			zzimage: aForm 
			at: (tRect topLeft translatedBy: 0 @ centeringOffset) ].

	sLeft _ indentLevel * 12 + 16.
	sRect _ sLeft@0 extent: self morphExtent - (sLeft@0).
	colorToUse _ complexContents preferredColor ifNil: [ color ].
	aCanvas
		zzdrawString: contents asString
		in: sRect
		font: self fontToUse
		color: colorToUse! !
!IndentingListItemMorph methodsFor: 'initialization' stamp: 'jmv 9/1/2012 20:15' prior: 16868347!
                      initialize

	super initialize.
	indentLevel _ 0.
	isExpanded _ false.
	isSelected _ false! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 9/1/2012 20:28' prior: 50349691!
          selectionIndex: index
	"Called internally to select the index-th item."
	| row |
	row _ index ifNil: [ 0 ].
	row _ row min: self getListSize.  "make sure we don't select past the end"
	self listMorph selectedRow: row.
	self scrollSelectionIntoView! !

PluggableListMorph removeSelector: #highlightSelection!

PluggableListMorph removeSelector: #highlightSelection!

PluggableListMorph removeSelector: #unhighlightSelection!

PluggableListMorph removeSelector: #unhighlightSelection!

ListItemWrapper removeSelector: #highlightingColor!

ListItemWrapper removeSelector: #highlightingColor!

InnerHierarchicalListMorph removeSelector: #drawLinesFor:On:lineColor:!

IndentingListItemMorph removeSelector: #drawLineToggleToTextOn:lineColor:hasToggle:!

IndentingListItemMorph removeSelector: #drawLineToggleToTextOn:lineColor:hasToggle:!

IndentingListItemMorph removeSelector: #drawLinesOn:lineColor:!

IndentingListItemMorph removeSelector: #drawLinesOn:lineColor:!

IndentingListItemMorph removeSelector: #drawLinesToFirstChildOn:lineColor:!

IndentingListItemMorph removeSelector: #drawLinesToFirstChildOn:lineColor:!

IndentingListItemMorph removeSelector: #drawLinesToNextSiblingOn:lineColor:hasToggle:!

IndentingListItemMorph removeSelector: #drawLinesToNextSiblingOn:lineColor:hasToggle:!

IndentingListItemMorph removeSelector: #drawToggleOn:in:!

IndentingListItemMorph removeSelector: #drawToggleOn:in:!

IndentingListItemMorph removeSelector: #highlight!

IndentingListItemMorph removeSelector: #highlight!

IndentingListItemMorph removeSelector: #unhighlight!

IndentingListItemMorph removeSelector: #unhighlight!

!classDefinition: #IndentingListItemMorph category: #'Morphic-Views for Models'!
StringMorph subclass: #IndentingListItemMorph
	instanceVariableNames: 'indentLevel isExpanded complexContents firstChild container nextSibling isSelected'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

StringMorph subclass: #IndentingListItemMorph
	instanceVariableNames: 'indentLevel isExpanded complexContents firstChild container nextSibling isSelected'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

HierarchicalListMorph removeSelector: #columns!

HierarchicalListMorph removeSelector: #columns!

HierarchicalListMorph removeSelector: #drawLinesOn:!

HierarchicalListMorph removeSelector: #drawLinesOn:!

HierarchicalListMorph removeSelector: #highlightSelection!

HierarchicalListMorph removeSelector: #highlightSelection!

HierarchicalListMorph removeSelector: #lineColor!

HierarchicalListMorph removeSelector: #lineColor!

HierarchicalListMorph removeSelector: #unhighlightSelection!

HierarchicalListMorph removeSelector: #unhighlightSelection!

!classDefinition: #HierarchicalListMorph category: #'Morphic-Views for Models'!
PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1425-LocalCoordinates04-JuanVuletich-2012Sep01-19h39m-jmv.7.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1425] on 3 September 2012 at 9:10 pm'!

!classDefinition: #ObjectExplorerWindow category: #'Morphic-Tools'!
SystemWindow subclass: #ObjectExplorerWindow
	instanceVariableNames: 'listMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

SystemWindow subclass: #ObjectExplorerWindow
	instanceVariableNames: 'listMorph '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!
!HierarchicalListMorph methodsFor: 'accessing' stamp: 'jmv 9/3/2012 18:22'!
                        selectedMorph
	^selectedMorph! !
!ListItemWrapper methodsFor: 'accessing' stamp: 'jmv 9/3/2012 08:20'!
                         item
	^item! !
!SystemDictionary methodsFor: 'printing' stamp: 'jmv 9/3/2012 18:04'!
           printOn: aStream
	self == Smalltalk
		ifTrue: [ aStream nextPutAll: 'Smalltalk' ]
		ifFalse: [ super printOn: aStream ]! !
!Array methodsFor: 'printing' stamp: 'jmv 9/2/2012 22:10' prior: 16781927!
                          printOn: aStream

	self == Smalltalk specialObjectsArray
		ifTrue: [
			aStream nextPutAll: 'Smalltalk specialObjectsArray' ]
		ifFalse: [
			aStream nextPut: $#.
			self printElementsOn: aStream ]! !
!Dictionary methodsFor: 'comparing' stamp: 'jmv 9/3/2012 08:37' prior: 16838768!
      = aDictionary
	"Two dictionaries are equal if
	 (a) they are the same 'kind' of thing.
	 (b) they have the same set of keys.
	 (c) for each (common) key, they have the same value".

	self == aDictionary ifTrue: [^ true].	"stop recursion"
	(aDictionary isKindOf: Dictionary) ifFalse: [^false].
	self size = aDictionary size ifFalse: [^false].
	self associationsDo: [:assoc|
		(aDictionary at: assoc key ifAbsent: [^false]) = assoc value
			ifFalse: [^false]].
	^true

! !
!LookupKey methodsFor: 'printing' stamp: 'jmv 9/2/2012 21:43' prior: 16882131!
                          printOn: aStream

	super printOn: aStream.
	aStream nextPut: $(.
	key printOn: aStream.
	aStream nextPut: $)! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 9/3/2012 18:21' prior: 16905920!
                  buildMorphicWindow
	| textMorph |
	.listMorph _ HierarchicalListMorph
			model: model
			listGetter: #getList
			indexGetter: #getCurrentSelection
			indexSetter: #noteNewSelection:
			mainView: self
			menuGetter: #genericMenu
			keystrokeAction: #explorerKey:from:.
	listMorph autoDeselect: false.
	textMorph _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	self layoutMorph
		addMorph: listMorph proportionalHeight: 0.8;
		addAdjusterAndMorph: textMorph proportionalHeight: 0.2.
	self setLabel: (model rootObject printStringLimitedTo: 64)! !
!ObjectExplorerWrapper methodsFor: 'converting' stamp: 'jmv 9/3/2012 20:53' prior: 16906139!
       asString
	| explorerString string |
	explorerString _ [ item printString ]
			on: Error 
			do: ['<error in printString: evaluate "' , itemName , ' printString" to debug>'].
	string _ itemName , ': ' , explorerString.
	^ string withBlanksCondensed! !
!PointerExplorer methodsFor: 'accessing' stamp: 'jmv 9/2/2012 22:41' prior: 16916310!
               getList

	| w |
	w _ PointerExplorerWrapper
		with: rootObject
		name: rootObject identityHash asString
		model: self.
	^Array with: w! !
!PointerExplorerWrapper methodsFor: 'testing' stamp: 'jmv 9/2/2012 22:45' prior: 16916334!
                           hasContents
	"Correct, albeit slow, answer"
	"^self contents notEmpty"
	^true! !

!classDefinition: #ObjectExplorerWindow category: #'Morphic-Tools'!
SystemWindow subclass: #ObjectExplorerWindow
	instanceVariableNames: 'listMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

SystemWindow subclass: #ObjectExplorerWindow
	instanceVariableNames: 'listMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1426-AFewTweaks-JuanVuletich-2012Sep03-21h02m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1426] on 4 September 2012 at 3:34:16 pm'!

!classDefinition: #PointerExplorer category: #'Tools-Explorer'!
ObjectExplorer subclass: #PointerExplorer
	instanceVariableNames: 'includeWeakRefs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Explorer'!

ObjectExplorer subclass: #PointerExplorer
	instanceVariableNames: 'includeWeakRefs '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Explorer'!

!classDefinition: #SystemDictionaryTest category: #'System-Tests'!
TestCase subclass: #SystemDictionaryTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Tests'!

TestCase subclass: #SystemDictionaryTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Tests'!
!ProtoObject methodsFor: 'tracing' stamp: 'jmv 9/3/2012 23:20'!
        referenceDescriptionTo: anObject
	"Answer a string that describes how I reference anObject"

	self class == anObject ifTrue: [ ^ 'class' ].
	1 to: self class instSize do: [ :i |
		(self instVarAt: i) == anObject ifTrue: [ ^ self class allInstVarNames at: i ]].
	1 to: self basicSize do: [ :i |
		(self basicAt: i) == anObject ifTrue: [ ^ 'at: ', i printString ]].
	^ 'unknown'! !
!Object methodsFor: 'tracing' stamp: 'jmv 9/3/2012 22:30'!
         exploreAllPointers
	"Include Weak references."

	ObjectExplorerWindow
		open: (PointerExplorer new includeWeakRefs: true; rootObject: self)
		label: 'References (incl. weak) to ', self printString! !
!CompiledMethod methodsFor: 'tracing' stamp: 'jmv 9/3/2012 23:20'!
                     referenceDescriptionTo: anObject
	"Answer a string that describes how I reference anObject"

	self class == anObject ifTrue: [ ^ 'class' ].
	1 to: self numLiterals do: [ :index |
		(self literalAt: index) == anObject ifTrue: [ ^'literalAt: ', index printString ]].
	^ 'unknown'! !
!IndentingListItemMorph methodsFor: 'accessing' stamp: 'jmv 9/4/2012 14:45'!
                          beExpanded

	isExpanded _ true! !
!IndentingListItemMorph methodsFor: 'private-container protocol' stamp: 'jmv 9/4/2012 00:04'!
openPath: anArray adaptor: aSymbol compare: comparison

	anArray isEmpty ifTrue: [ ^container setSelectedMorph: nil ].
	self withSiblingsDo: [ :each | 
		(anArray first isNil or: [
			(each complexContents perform: aSymbol)
				perform: comparison
					with: (anArray first perform: aSymbol) ]) ifTrue: [
			each isExpanded ifFalse: [
				each toggleExpandedState.
				owner adjustExtent.
				container setScrollDeltas ].
			each redrawNeeded.
			anArray size = 1 ifTrue: [
				^container setSelectedMorph: each ].
			each firstChild ifNil: [^container setSelectedMorph: nil ].
			^each firstChild openPath: anArray allButFirst adaptor: aSymbol compare: comparison ]].
	^container setSelectedMorph: nil! !
!InspectorWindow methodsFor: 'menu commands' stamp: 'jmv 9/3/2012 22:31'!
                    exploreAllObjectPointers
	"Create and schedule a Pointers Explorer on the receiver's model's currently selected object."

	^ model selection exploreAllPointers! !
!ObjectExplorerWindow methodsFor: 'menu commands' stamp: 'jmv 9/4/2012 00:00'!
              expandPathFromRoot
	"Expand the shortest path from root references (i.e. globals).
	Only for PointerExplorers!!"
	
	| endOfRefChain chain node |
	endOfRefChain _ listMorph selectedMorph complexContents shortestPathFromRoot.
	
	chain _ OrderedCollection new.
	node _ endOfRefChain.
	[ node notNil ] whileTrue: [
		chain addFirst: node.
		node _ node parent ].
	listMorph scroller submorphs first openPath: chain adaptor: #item compare: #==! !
!ObjectExplorerWindow methodsFor: 'menu commands' stamp: 'jmv 9/3/2012 22:31'!
                       exploreAllObjectPointers
	"Create and schedule a Pointers Explorer on the receiver's model's currently selected object."

	^ model object exploreAllPointers! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 9/3/2012 18:34'!
                         scroller
^scroller! !
!PointerExplorer methodsFor: 'accessing' stamp: 'jmv 9/2/2012 22:41'!
    includeWeakRefs
	^includeWeakRefs! !
!PointerExplorer methodsFor: 'accessing' stamp: 'jmv 9/2/2012 22:18'!
                     includeWeakRefs: aBoolean
	includeWeakRefs _ aBoolean! !
!PointerExplorer methodsFor: 'initialize-release' stamp: 'jmv 9/2/2012 22:18'!
                        initialize
	super initialize.
	includeWeakRefs _ false! !
!PointerExplorerWrapper methodsFor: 'reference chain' stamp: 'jmv 9/4/2012 13:13'!
                   shortestPathFromRoot

	Smalltalk garbageCollect.
	^ self shortestPathFromRoot: { self }! !
!PointerExplorerWrapper methodsFor: 'reference chain' stamp: 'jmv 9/3/2012 23:44'!
                  shortestPathFromRoot: anArrayOfWrappers

	| nextLevel allPointers eachWrapper pointersToEachObject alreadyIncluded |
	alreadyIncluded _ IdentitySet new.
	nextLevel _ Array streamContents: [ :strm |
		allPointers _ Smalltalk pointersToEachIn: (anArrayOfWrappers collect: [ :eachWrapper1 | eachWrapper1 item ]).

		1 to: anArrayOfWrappers size do: [ :i |
			eachWrapper _ anArrayOfWrappers at: i.
			pointersToEachObject _ allPointers at: i.

			"Can we have any other root?"
			eachWrapper item == Smalltalk specialObjectsArray ifTrue: [
				^eachWrapper ].		"Found it!!"

			pointersToEachObject do: [ :pointingObject |
				"Reject PointerExplorer stuff (wrapper and main model).
				Reject weak refs, unles includeWeakRefs is true."
				(pointingObject class = self class or: [ pointingObject class = PointerExplorer or: [
				pointingObject class isWeak and: [model includeWeakRefs not]]]) ifFalse: [
					(alreadyIncluded includes: pointingObject) ifFalse: [
						alreadyIncluded add: pointingObject.
						strm nextPut: (self class
							with: pointingObject
							name: pointingObject identityHash asString
							model: model
							parent: eachWrapper )]]]]].

	"Release unneeded references"
	allPointers do: [ :oc |
		oc setContents: #() ].
	alreadyIncluded _ nil.
nextLevel size print.
	nextLevel isEmpty ifTrue: [ ^nil ].
	^self shortestPathFromRoot: nextLevel! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 9/4/2012 13:10'!
                       pointersToEachIn: anArray
	"Find all occurrences in the system of pointers to elements of the argument
	anObject.
	| p1 p2 |
	p1 _ (Smalltalk pointersTo: World).
	p2 _ (Smalltalk pointersToEachIn: {World}) first.
	p1 = p2.
	
	Maybe write a few tests...
	"
	| object lastObject pointers subject |

	Smalltalk garbageCollect.
	lastObject _ Object new.
	"big collection shouldn't grow, so it's contents array is always the same"
	pointers _ anArray collect: [ :each | OrderedCollection new: 1000 ].
	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious
	 method and block contexts out of the results"
	object _ self someObject.
	[ lastObject == object ] whileFalse: [
		object isInMemory ifTrue: [
			1 to: anArray size do: [ :i |
				subject _ anArray at: i.
				((object statePointsTo: subject)
					or: [ object class == subject ])
						ifTrue: [ (pointers at: i) add: object ]]].
		object _ object nextObject].

	pointers do: [ :oc |
		oc
			remove: anArray;
			remove: thisContext ifAbsent: nil;
			remove: thisContext sender ifAbsent: nil;
			remove: thisContext sender sender ifAbsent: nil;
			remove: oc collector ifAbsent: nil ].
	^pointers! !
!SystemDictionaryTest methodsFor: 'testing' stamp: 'jmv 9/4/2012 13:13'!
         testPointersToEachIn
	"
	SystemDictionaryTest new testPointersToEachIn
	"
	| p1 p2 |
	p1 _ (Smalltalk pointersTo: World).
	p2 _ (Smalltalk pointersToEachIn: {World}) first.
	self assert: p1 = p2! !
!Object methodsFor: 'tracing' stamp: 'jmv 9/3/2012 22:30' prior: 16905460!
               explorePointers
	"Don't include Weak references."

	ObjectExplorerWindow
		open: (PointerExplorer new rootObject: self)
		label: 'References to ', self printString! !
!Object methodsFor: 'tracing' stamp: 'jmv 9/4/2012 13:06' prior: 50340456!
              inboundPointersExcluding: objectsToExclude
"Answer a list of all objects in the system that point to me, excluding those in the collection of objectsToExclude. I do my best to avoid creating any temporary objects that point to myself, especially method and block contexts. Adapted from PointerFinder class >> #pointersTo:except:"

	| object lastObject pointers objectsToAlwaysExclude |
	Smalltalk garbageCollect.
	lastObject _ Object new.
	"big collection shouldn't grow, so it's contents array is always the same"
	pointers := OrderedCollection new: 1000.
	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious
	 method and block contexts out of the results"
	object := self someObject.
	[lastObject == object] whileFalse: [
		object isInMemory
			ifTrue: [((object statePointsTo: self)
				or: [object class == self])
					ifTrue: [pointers add: object]].
		object := object nextObject].

	objectsToAlwaysExclude := {
		pointers collector.
		thisContext.
		thisContext sender.
		thisContext sender sender.
		objectsToExclude.
	}.

	^ pointers removeAllSuchThat: [ :ea |
		(objectsToAlwaysExclude identityIncludes: ea)
			or: [ objectsToExclude identityIncludes: ea ]]! !
!FileList methodsFor: 'private' stamp: 'jmv 9/3/2012 22:47' prior: 16851612!
                postOpen

	directory ifNotNil: [
		self changed: #(openPath), directory pathParts ]! !
!IndentingListItemMorph methodsFor: 'private-container protocol' stamp: 'jmv 9/4/2012 13:36' prior: 16868438!
                           toggleExpandedState
	| newChildren toDelete c |
	isExpanded _ isExpanded not.
	toDelete _ OrderedCollection new.
	firstChild ifNotNil: [
		firstChild withSiblingsDo: [ :aNode |
			aNode recursiveAddTo: toDelete ]].
	container noteRemovalOfAll: toDelete.
	(isExpanded and: [ complexContents hasContents ]) ifFalse: [
		firstChild _ nil.
"	 	nextSibling _ firstChild _ nil."
		^ self redrawNeeded ].
	(c _ complexContents contents) isEmpty ifTrue: [ ^ self redrawNeeded ].
	newChildren _ container
		addSubmorphsAfter: self
		fromCollection: c
		allowSorting: true.
	firstChild _ newChildren first! !
!InspectorWindow methodsFor: 'menu building' stamp: 'jmv 9/3/2012 23:24' prior: 16871645!
               fieldListMenu
	"Arm the supplied menu with items for the field-list of the receiver"

	| aMenu object |
	aMenu _ MenuMorph new defaultTarget: self.

	aMenu addList: #(
		('inspect (i)'							inspectSelection)
		('explore (I)'						exploreSelection)
		('basic inspect'						inspectBasic)
		('explore pointers'					exploreObjectPointers)
		('explore all pointers (incl.weak)'	exploreAllObjectPointers)).

	object _ model object.
	(object isKindOf: Dictionary) ifTrue: [ aMenu addList: #(
		-
		('senders of this key'				sendersOfSelectedKey)
		('add key'							addEntry)
		('rename key'						renameEntry)
		('remove'							removeSelection			''		model)) ]

	ifFalse: [ (object isKindOf: Set) ifTrue: [ aMenu addList: #(
		-
		('remove'							removeSelection			''		model))]].

	aMenu addList: #(
		-
		('browse full (b)'					browseMethodFull)
		('browse hierarchy (h)'				browseHierarchy)
		('browse protocol (p)'				browseFullProtocol)).
	^ aMenu! !
!ObjectExplorerWindow methodsFor: 'building menus' stamp: 'jmv 9/4/2012 12:49' prior: 16905945!
             genericMenu
	"Borrow a menu from my inspector"
	| aMenu |
	aMenu := MenuMorph new defaultTarget: self.
	model getCurrentSelection
		ifNil: [
			aMenu
				add: '*nothing selected*'
				target: self
				selector: #yourself]
		ifNotNil: [
			aMenu addList: #(
				('inspect (i)'							inspectSelection)
				('explore (I)'						exploreSelection)
				('basic inspect'						inspectBasic)
				('explore pointers'					exploreObjectPointers)
				('explore all pointers (incl.weak)'	exploreAllObjectPointers)
				-
				('browse full (b)'					browseMethodFull)
				('browse hierarchy (h)'				browseHierarchy)
				('browse protocol (p)'				browseFullProtocol)).
			aMenu addLine;
				add: 'monitor changes'
				target: model			"Model!!"
				selector: #monitor:
				argument: model getCurrentSelection.
			model class = PointerExplorer ifTrue: [
				aMenu addLine;
					add: 'shortest ref. path from globals (slow!!)'
					target: self
					selector: #expandPathFromRoot ]].
	model basicMonitorList isEmptyOrNil
		ifFalse: [
			aMenu addLine;
				add: 'stop monitoring all'
				target: model			"Model!!"
				selector: #stopMonitoring].
	^ aMenu! !
!HierarchicalListMorph methodsFor: 'updating' stamp: 'jmv 9/4/2012 00:00' prior: 16866798!
                      update: aSymbol
	super update: aSymbol.
	aSymbol == getSelectionSelector 
		ifTrue: [
			self selection: self getCurrentSelectionItem.
			^self].
	aSymbol == getListSelector 
		ifTrue: [
			self list: self getList.
			^self].
	((aSymbol isKindOf: Array) 
		and: [ aSymbol notEmpty and: [aSymbol first == #openPath]]) 
			ifTrue: [
				^(scroller submorphs at: 1 ifAbsent: [^self]) 
					openPath: aSymbol allButFirst adaptor: #asString compare: #=]! !
!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 9/4/2012 14:45' prior: 16866814!
  addMorphsTo: morphList from: aCollection allowSorting: sortBoolean withExpandedItems: expandedItems atLevel: newIndent

	| priorMorph newCollection firstAddition |
	priorMorph _ nil.
	newCollection _ (sortBoolean and: [sortingSelector notNil]) ifTrue: [
		aCollection asOrderedCollection sort: [ :a :b | 
			(a perform: sortingSelector) <= (b perform: sortingSelector)]
	] ifFalse: [
		aCollection
	].
	firstAddition _ nil.
	newCollection do: [:item | 
		priorMorph _ self indentingItemClass basicNew 
			initWithContents: item 
			prior: priorMorph 
			forList: self
			indentLevel: newIndent.
		firstAddition ifNil: [firstAddition _ priorMorph].
		morphList add: priorMorph.
		((item hasEquivalentIn: expandedItems) or: [priorMorph isExpanded]) ifTrue: [
			priorMorph beExpanded.
			priorMorph 
				addChildrenForList: self 
				addingTo: morphList
				withExpandedItems: expandedItems.
		].
	].
	^firstAddition
	
! !
!PointerExplorerWrapper methodsFor: 'accessing' stamp: 'jmv 9/4/2012 12:53' prior: 16916338!
          contents
	| objects |
	Smalltalk garbageCollect.
	objects _ Smalltalk pointersTo: item except: (Array with: self).
	^ (objects reject: [ :each |
		"Reject PointerExplorer stuff (wrapper and main model).
		Reject weak refs, unles includeWeakRefs is true."
		each class = self class or: [ each class = PointerExplorer or: [
				each class isWeak and: [model includeWeakRefs not]]]])
			collect: [ :each |
				self class
					with: each
					name: '<-- #', (each referenceDescriptionTo: item), ' <--(', each identityHash asString, ')'
					model: model
					parent: self ]! !
!Theme methodsFor: 'menus' stamp: 'jmv 9/4/2012 12:50' prior: 50377106!
                           basicIcons

"Minimal menu scheme."

	^ { 
		#('open...') -> #openIcon.
		#('windows...' 'find window') -> #windowIcon.
		#('help...' 'explain' 'about this system...') -> #helpIcon.
		#('themes...') -> #appearanceIcon.
		#('do...' 'Cursor normal show.' 'do it (d)') -> #doItIcon.
		#('new morph...' 'objects (o)' 'save world as morph file') -> #morphsIcon.
		#('save' 'save project on file...' ) -> #saveIcon.
		#('save as...' 'change category...' 'rename change set (r)' 'rename') -> #saveAsIcon.
		#('save as new version') -> #saveAsNewVersionIcon.
		#('quit') -> #quitIcon.
		#('save and quit' ) -> #saveAndQuitIcon.
		#('inspect it (i)' 'inspect world'  'inspect model' 'inspect morph'
		 'inspect owner chain' 'inspect' 'inspect (i)' 'basic inspect' 'message names' 'find message names' 'inspect instances' 'inspect subinstances' 'inspect change set' 'inspect context (c)' 'inspect receiver (i)' 'start CPUWatcher')
			-> #inspectIcon.
		#('explore' 'explore it (I)' 'explore world' 'explore morph' 'explore (I)' 'explore context (C)' 'explore receiver (I)' 'explore pointers' 'explore all pointers (incl.weak)' 'shortest ref. path from globals (slow!!)') -> #exploreIcon.
		#('find...(f)' 'find class... (f)' 'find method...' 'find recent submissions' 'show hierarchy' 'show definition' 'show comment' 'filter' 'filter message list...' 'find context... (f)') -> #findIcon.
		#('add item...' 'new category...' 'create new change set...' 'new change set... (n)' 'add new file') -> #newIcon.
		#('remove method (x)' 'remove' 'remove class (x)' 'remove method from system (x)' 'remove class from system (x)' 'remove postscript') -> #deleteIcon.
		#('delete method from changeset (d)' 'delete class from change set (d)' 'destroy change set (X)' 'revert & remove from changes' 'delete unchanged windows' 'delete non windows' 'delete both of the above' 'reset variables' 'remove contained in class categories...' 'clear this change set' 'uninstall this change set' 'delete directory...' 'delete') -> #warningIcon.
		#('do again (j)' 'Redo - multiple (Z)') -> #redoIcon.
		#('undo (z)' 'revert to previous version' 'Undo - multiple (z)') -> #undoIcon.
		#('copy (c)' 'copy class...' 'copy class chgs to other side' 'copy method to other side' 'copy all to other side (c)' 'copy name to clipboard' 'copy selector to clipboard') -> #copyIcon.
		#('paste (v)' 'Paste without Format') -> #pasteIcon.
		#('cut (x)' 'move class chgs to other side' 'move method to other side' 'submerge into other side') -> #cutIcon.
		#('paste...' 'icons...') -> #worldIcon.
}! !

!classDefinition: #PointerExplorer category: #'Tools-Explorer'!
ObjectExplorer subclass: #PointerExplorer
	instanceVariableNames: 'includeWeakRefs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Explorer'!

ObjectExplorer subclass: #PointerExplorer
	instanceVariableNames: 'includeWeakRefs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Explorer'!

IndentingListItemMorph removeSelector: #isExpanded:!

IndentingListItemMorph removeSelector: #isExpanded:!

IndentingListItemMorph removeSelector: #openPath:!

IndentingListItemMorph removeSelector: #openPath:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Theme current initialize!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1427-PointerExplorerEnh-JuanVuletich-2012Sep04-15h05m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1427] on 4 September 2012 at 6:13:51 pm'!
!Morph methodsFor: 'change reporting' stamp: 'jmv 9/4/2012 18:08'!
          zzinvalidRect: aRectangle

	"warning. Senders are using global coordinates. Redesign!!"
	self flag: #jmvVer2.	"ok?"
	"local now!!!!!!!!!!"
	owner ifNotNil: [
		owner zzinvalidRect: (location displayBoundsOfTransformOf: aRectangle) ]! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 9/4/2012 17:47'!
          invalidRect: damageRect
        "Clip damage reports to my bounds, since drawing is clipped to my bounds."

        self == self outermostWorldMorph 
                ifTrue: [ worldState recordDamagedRect: (damageRect intersect: self morphBoundsInWorld ) ]
                ifFalse: [ super invalidRect: damageRect ]
! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 9/4/2012 17:57'!
                      zzinvalidRect: damageRect
        "Clip damage reports to my bounds, since drawing is clipped to my bounds."

        self == self outermostWorldMorph 
                ifTrue: [ worldState recordDamagedRect: (damageRect intersect: self morphBoundsInWorld ) ]
                ifFalse: [ super zzinvalidRect: damageRect ]
! !
!Morph methodsFor: 'change reporting' stamp: 'jmv 9/4/2012 17:49' prior: 50359307!
         invalidRect: aRectangle

	"warning. Senders are using global coordinates. Redesign!!"
	self flag: #jmvVer2.	"ok?"
	owner ifNotNil: [
		owner invalidRect: aRectangle ]! !
!Morph methodsFor: 'updating' stamp: 'jmv 9/4/2012 18:08' prior: 50375833!
           redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Just ours, or include submorphs if we don't clip.
	Think about it. We don't to know about a specific rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"

	
	self layoutSubmorphsIfNeeded.
	self zzinvalidRect: (0@0 extent: self morphExtent)! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 17:52' prior: 16864846!
                             restoreSavedPatchOn: aCanvas 
	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."

	hasChanged _ false.
	savedPatch ifNotNil: [
		aCanvas image: savedPatch at: savedPatch offset.
		submorphs notEmpty ifTrue: [ ^self ].

		"Make the transition to using hardware cursor. Clear savedPatch and
		 report one final damage rectangle to erase the image of the software cursor."
		self invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset).
		Sensor currentCursor == Cursor normal ifFalse: [ Cursor normal show ].	"show hardware cursor"
		savedPatch _ nil ]! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 17:18' prior: 50376037!
         draw: item atRow: row on: canvas
	"display the given item at row row"
	| drawBounds f |
	drawBounds _ self drawBoundsForRow: row.
	drawBounds _ drawBounds intersect: (0@0 extent: extent).
	f _ (item is: #Text) ifTrue: [ font emphasized: (item emphasisAt: 1) ] ifFalse: [ font ].
	canvas zzdrawString: item in: drawBounds font: f color: (self colorForRow: row).! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 17:20' prior: 50376054!
 drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"
	selectionDrawBounds _ self drawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: (0@0 extent: extent).
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas zzfillRectangle: selectionDrawBounds colorOrInfiniteForm: c! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 17:25' prior: 50376077!
                              drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (0@0 extent: extent).
	aCanvas
		zzfillRectangle: selectionDrawBounds
		colorOrInfiniteForm: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 9/4/2012 17:57' prior: 16906583!
 onBlinkCursor
	"Blink the cursor"
	showCaret _ showCaret not | pauseBlinking.
	pauseBlinking _ false.
	caretRect ifNotNil: [ :r | self zzinvalidRect: r]! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 9/4/2012 17:57' prior: 16906591!
        pauseBlinking
	"Show a solid cursor (non blinking) for a short while"
	pauseBlinking _ true.
	"Show cursor right now if needed"
	showCaret ifFalse: [
		showCaret _ true.
		caretRect ifNotNil: [ :r | self zzinvalidRect: r ]]! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 9/4/2012 17:57' prior: 16906611!
 stopBlinking
	"And do not show cursor anymore."
	self stopSteppingSelector: #onBlinkCursor.
	"Hide cursor right now if needed"
	showCaret ifTrue: [
		showCaret _ false.
		caretRect ifNotNil: [ :r | self zzinvalidRect: r ]]! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 17:35' prior: 50357123!
       displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas
	| caretColor x1 isBold isItalic x0 h w halfW r d |
	isBold _ emphasis allMask: 1.
	isItalic _ emphasis allMask: 2.
	caretColor _ Theme current insertionPoint.
	h _ bottom - top.
	w _ isBold
		ifTrue: [ h // 25 + 2 ]
		ifFalse: [ h // 30 + 1 ].
	halfW _ w // 2.
	isItalic
		ifTrue: [	
			"Keep tweaking if needed!!"
			d _ isBold ifTrue: [ 3 ] ifFalse: [ h // 24].
			x0 _ x- (h*5//24) + d.
			x1 _ x + d ]
		ifFalse: [
			x0 _ x.
			x1 _ x].
	x0 < halfW ifTrue: [
		x1 _ x1 - x0 + halfW.
		x0 _ halfW ].
	r _ self morphExtentInOwner x-halfW-1.
	r < x1 ifTrue: [
		x0 _ x0 + r - x1.
		x1 _ r ].
	caretRect _ x0-halfW-1@ top corner: x1+halfW+1+1 @ bottom.
	aCanvas
		zzline: x0@(bottom-halfW) to: x1@(top+halfW)
		width: w color: caretColor! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 17:37' prior: 50357152!
                drawCaretOn: aCanvas
	"Essentially copied from #displayInsertionMarkAtX:top:bottom:emphasis:on:"
	|  bottom x |

	showCaret ifTrue: [
		bottom _ self baseFont height.
		x _ self fontToUse widthOfString: contents from: 1 to: editor startIndex-1.
		self displayInsertionMarkAtX: x top: 0 bottom: bottom emphasis: emphasis on: aCanvas ]! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 17:33' prior: 50353837!
                        drawSelectionOn: aCanvas
	| rightX leftX bottom |

	bottom _ self baseFont height.
	leftX _ self fontToUse widthOfString: contents from: 1 to: editor startIndex-1.
	rightX _ self fontToUse widthOfString: contents from: 1 to: editor stopIndex-1.

	aCanvas
		zzfillRectangle: (leftX @ 0 corner: rightX @ bottom)
		colorOrInfiniteForm: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!Sonogram methodsFor: 'all' stamp: 'jmv 9/4/2012 18:10' prior: 50361321!
           plotColumn: dataArray

	| chm1 i normVal r |
	columnForm unhibernate.
	chm1 _ columnForm height - 1.
	0 to: chm1 do: [ :y | 
		i _ y*(dataArray size-1)//chm1 + 1.
		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).
		normVal < 0.0 ifTrue: [normVal _ 0.0].
		normVal > 1.0 ifTrue: [normVal _ 1.0].
		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].
	(lastX _ lastX + 1) > (image width - 1) ifTrue:
		[self scroll].
	image copy: (r _ (lastX@0 extent: 1@image height))
			from: (32//image depth-1)@0
			in: columnForm rule: Form over.
	"self changed."
	self zzinvalidRect: r! !
!SystemWindow methodsFor: 'top window' stamp: 'jmv 9/4/2012 17:26' prior: 50357887!
activateAndForceLabelToShow
	self activate.
	self morphPositionInOwner y < 0 ifTrue: [
		self morphPositionInOwner: (self morphPositionInOwner x @ 0)]! !
!SystemWindow methodsFor: 'change reporting' stamp: 'jmv 9/4/2012 18:12' prior: 50357895!
            invalidateTitleArea

	"not really pretty... also invalidating the top border, regardless of it being above or below the title area
	(#titleAreaRect and #titleAreaInnerRect)"
	self zzinvalidRect: (0@0 extent: self morphExtent x @ (self labelHeight + borderWidth))! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 9/4/2012 17:30' prior: 50354438!
   testHorizontalAlignment

	self should: [ taskbar morphPositionInWorld x = 0 ]! !

PasteUpMorph removeSelector: #invalidRect:from:!

PasteUpMorph removeSelector: #invalidRect:from:!

HandMorph removeSelector: #invalidRect:!

HandMorph removeSelector: #invalidRect:from:!

HandMorph removeSelector: #invalidRect:from:!

Morph removeSelector: #invalidRect:from:!

Morph removeSelector: #invalidRect:from:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1428-MorphInvalidateTweaks-JuanVuletich-2012Sep04-17h16m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1428] on 4 September 2012 at 9:08 pm'!
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 20:23' prior: 50353204!
   drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness e |
	e _ self morphExtent.
	aCanvas zzframeAndFillRectangle: (0@0 extent: e) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ e x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			zzframeRectangle: (e x - scrollbarThickness@0
				extent: scrollbarThickness @ e y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			zzimage: (FormCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: e x - scrollbarThickness@0.
		aCanvas
			zzimage: (FormCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: 0@0 + e - scrollbarThickness.
		h _ e y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			zzfillRectangle: (e x - scrollbarThickness+2@y1 corner:  e x-2 @ y2)
			colorOrInfiniteForm: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas zzfillRectangle: rectangle colorOrInfiniteForm: (Theme current listHighlightFocused: true) ].
			aCanvas
				zzdrawString: (completer entries at: index) asString
				in: rectangle
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!ImageMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 20:49' prior: 50353415!
    drawOn: aCanvas

	aCanvas zzimage: image at: 0@0! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 9/4/2012 20:00' prior: 16870410!
                         selectionChanged
	self paragraph selectionRects do: [:r | self zzinvalidRect: r ]! !
!MagnifierMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 20:50' prior: 16885101!
                        drawOn: aCanvas
	RecursionLock == self ifFalse: [
		super drawOn: aCanvas.		"border and fill"
		aCanvas isShadowDrawing ifFalse: [
			"Optimize because #magnifiedForm is expensive"
			aCanvas zzimage: self magnifiedForm at: borderWidth@borderWidth]]! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 21:02' prior: 50373943!
                  drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			"self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"
			self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas zzimage: backgroundImage at: 0@0 ]]
				ifFalse: [ aCanvas zzimage: backgroundImage at: 0@0 ]]

		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [color class == TranslucentColor])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt current toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: 0@0 in: nil
						fillColor: color rule: Form over]
				ifFalse: [ super drawOn: aCanvas ]]! !
!Preferences class methodsFor: 'standard queries' stamp: 'jmv 9/4/2012 20:14' prior: 16920618!
                      fastDragWindowForMorphic
	^ "self
		valueOfFlag: #fastDragWindowForMorphic
		ifAbsent: [ false ]"true not
		"resizeo, completar... O matar esta preferencia?"! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 9/4/2012 21:03' prior: 50359073!
           drawOn: aCanvas
	"
	Transcript
		showOnDisplay: true;
		bounds: bounds;
		displayOn: aCanvas form.
	"
	Transcript
		showOnDisplay: true;
		morphBoundsInWorld: (0@0 extent: self morphExtentInWorld);
		displayOn: form;
		morphBoundsInWorld: self morphBoundsInWorld.
	aCanvas zzimage: form at: 0@0! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 9/4/2012 19:55' prior: 16978558!
   endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	para
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	para composeAll.
	d _ para extent y - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ para characterBlockAtPoint:
			0@0 + (0@(d+StrikeFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		paragraph: para
		bounds: (4@4 + frame topLeft extent: Display extent)
		color: Color black
		selectionColor: Color blue! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 9/4/2012 20:12' prior: 50375974!
                        displayWorld: aWorld submorphs: submorphs
	"Update this world's display."

	| deferredUpdateMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.
	deferredUpdateMode ifFalse: [ self assuredNonDisplayCanvas ].

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.

	"Check which hands need to be drawn (they are not the hardware mouse pointer)"
	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"Draw hands (usually carying morphs) onto world canvas"
	handsToDraw reverseDo: [ :h | self drawHand: h ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ aWorld flashRects: allDamage ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateMode
		ifTrue: [ self forceDamageToScreen: allDamage ]
		ifFalse: [ canvas showAt: aWorld viewBox origin invalidRects: allDamage ].

	"Restore world canvas under hands and their carried morphs"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].
	Display deferUpdates: false; forceDisplayUpdate! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 9/4/2012 20:14' prior: 50378767!
                           drawHand: aHandMorph
	"Draw a hand that carries morphs, or needs to be drawn by us, because of not being the hardware mouse pointer."
	| bw r |
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth // 2.
		r _ aHandMorph morphFullBoundsInWorld.
		canvas frameRectangle: r borderWidth: bw color: Color black.
		canvas frameRectangle: (r insetBy: bw) borderWidth: bw color: Color white.
		canvas clipBy: aHandMorph morphBoundsInWorld during: [ :c | aHandMorph drawOn: c ]]
	ifFalse: [
		 canvas fullDraw: aHandMorph]! !

InnerTextMorph removeSelector: #selectionRects!

InnerTextMorph removeSelector: #selectionRects!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1429-LocalCoordinates05-JuanVuletich-2012Sep04-19h46m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1429] on 7 September 2012 at 7:49:21 pm'!
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/7/2012 18:33' prior: 50378600!
            zzfillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: borderWidth borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder

	| displayRectangle bw |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	bw _ (currentTransformation externalizeScalar: borderWidth) rounded.
	^self fillRectangle: displayRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: bw borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/7/2012 18:33' prior: 50379003!
      zzroundRect: aRectangle color: aColor radius: radious
	"
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10
	"
	"top stripe"
	| displayRectangle r |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	r _ (currentTransformation externalizeScalar: radious) rounded.
	self
		image: (FormCanvas topLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: displayRectangle topLeft.
	self
		image: (FormCanvas topRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: displayRectangle topRight - (r@0).
	self fillRectangle: ((displayRectangle withHeight: r) insetBy: r@0) colorOrInfiniteForm: aColor.

	"center stripe"
	self fillRectangle: (displayRectangle insetBy: (0 @ r corner: 0 @ r)) colorOrInfiniteForm: aColor.
	
	"bottom stripe"
	self
		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: displayRectangle bottomLeft - (0@r).
	self
		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: displayRectangle bottomRight - (r@r) .
	self fillRectangle: ((displayRectangle bottomLeft + (r@r negated)) extent: (displayRectangle width - r - r@r)) colorOrInfiniteForm: aColor! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/7/2012 19:49' prior: 50353008!
               morphExtentInWorld
	"eventually, remove. If not, at least translate!!!!!!!!!!"
	self flag: #jmvVer2.
	^self morphExtent! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 9/7/2012 19:03' prior: 50356501!
      createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	self addMorph: result.
	result morphPositionInOwner: 29@90.
	result morphExtent: 93@27.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 9/7/2012 19:04' prior: 50356513!
                      createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	self addMorph: result.
	result morphPositionInOwner: 149@90.
	result morphExtent: 93@27.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 9/7/2012 19:04' prior: 50356525!
                     createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	self addMorph: result.
	result morphPositionInOwner: 30@7.
	result morphExtent: 239@15.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 9/7/2012 19:03' prior: 50356536!
                createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval
				allowStyler: true.
	result morphExtent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result morphPositionInOwner: 14@25.
	result morphExtent: self morphExtent-(28@62).
	^ result! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 18:40' prior: 50373731!
          drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				zzroundRect: (0@0 extent: self morphExtent)
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		zzfillRectangle: (14@25 extent: self morphExtent-(28@62))
		colorOrInfiniteForm: (Theme current paneBackgroundFrom: color)! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 9/7/2012 19:22' prior: 50356789!
       adjustExtent
	"And reposition submorphs"
	| w h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	y _ 0.
	self submorphsDo: [ :m |
		m
			morphPositionInOwner: 0@y;
			morphWidth: w.
		h _ m morphHeight.
		y _ y + h ].
	self morphExtent: w@y! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 9/7/2012 19:46' prior: 50376027!
          drawBoundsForRow: row
	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"

	self flag: #jmvVer2.
	"revisar senders"
	^ 0 @ (row - 1 * font height) extent: extent x @ font height! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 9/7/2012 19:46' prior: 50369130!
                   extentForComposing
	self flag: #jmvVer2.	"like #extent ..."
	^wrapFlag
		ifTrue: [ extent x @ 9999999 ]
		ifFalse: [ 9999999@9999999 ]! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 19:47' prior: 50380619!
                               displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas
	| caretColor x1 isBold isItalic x0 h w halfW r d |
	isBold _ emphasis allMask: 1.
	isItalic _ emphasis allMask: 2.
	caretColor _ Theme current insertionPoint.
	h _ bottom - top.
	w _ isBold
		ifTrue: [ h // 25 + 2 ]
		ifFalse: [ h // 30 + 1 ].
	halfW _ w // 2.
	isItalic
		ifTrue: [	
			"Keep tweaking if needed!!"
			d _ isBold ifTrue: [ 3 ] ifFalse: [ h // 24].
			x0 _ x- (h*5//24) + d.
			x1 _ x + d ]
		ifFalse: [
			x0 _ x.
			x1 _ x].
	x0 < halfW ifTrue: [
		x1 _ x1 - x0 + halfW.
		x0 _ halfW ].
	r _ extent x-halfW-1.
	r < x1 ifTrue: [
		x0 _ x0 + r - x1.
		x1 _ r ].
	caretRect _ x0-halfW-1@ top corner: x1+halfW+1+1 @ bottom.
	aCanvas
		zzline: x0@(bottom-halfW) to: x1@(top+halfW)
		width: w color: caretColor! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/7/2012 19:18' prior: 50369438!
                               focusIndicatorExtent
	| e |
	e _ self morphExtent - borderWidth - borderWidth.
	self vIsScrollbarShowing ifTrue: [
		e _ e x - self scrollBarClass scrollbarThickness @ e y ].
	self hIsScrollbarShowing ifTrue: [
		e _ e x @ (e y - self scrollBarClass scrollbarThickness) ].
	^e! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/7/2012 19:17' prior: 50357382!
               hScrollBarWidth
	"Return the width of the horizontal scrollbar"

	| w |	
	w _ self morphWidth - (2 * borderWidth).
	self vIsScrollbarShowing
		ifTrue: [ w _ w - self scrollBarClass scrollbarThickness ].
	^w! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/7/2012 19:16' prior: 50357392!
                     updateScrollBarsBounds
	
	| t |
	hideScrollBars ifTrue: [^self].
	t _ self scrollBarClass scrollbarThickness.
	scrollBar
		morphPositionInOwner: self morphWidth-t-borderWidth @ borderWidth;
		morphExtent: t @ self vScrollBarHeight.
	hScrollBar
		morphPositionInOwner: borderWidth @ (self morphHeight - t - borderWidth);
		morphExtent: self hScrollBarWidth@t! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/7/2012 19:17' prior: 50357409!
                              vScrollBarHeight
	^self morphHeight - (2 * borderWidth)! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 9/7/2012 19:46' prior: 50369842!
    itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last internalPoint |
	internalPoint _ scroller internalize: aPoint.
	scroller hasSubmorphs ifFalse: [ ^nil ].
	(internalPoint > (0@0) and: [ internalPoint < scroller morphExtent ]) ifFalse: [ ^nil ].
	ptY _ internalPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	scroller firstSubmorph morphPositionInOwner y > ptY ifTrue: [ ^nil ].
	last _ scroller lastSubmorph.
	last morphPositionInOwner y + last morphExtent y < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^scroller 
		findSubmorphBinary: [ :m |
			(m morphPositionInOwner y <= ptY and: [ m morphPositionInOwner y + m morphExtent y >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPositionInOwner y + (m morphExtent y // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 9/7/2012 19:46' prior: 50369655!
                        scrollSelectionIntoView

	selectedMorph ifNotNil: [
		self flag: #jmvVer2.	"traducir mejor el rectangulo..."
		self scrollToShow: ((scroller externalize: selectedMorph morphPositionInOwner) extent: selectedMorph morphExtent) ]! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 9/7/2012 19:39' prior: 50375929!
          layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww |
	thickness _ 4.
	cornerExtent _ 20.
	ww _ extent x.
	wh _ extent y.
	w _ ww - cornerExtent - cornerExtent.
	h _ ww - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster)
		morphPositionInOwner: cornerExtent@0;
		morphExtent: w@thickness.
	(adjusters at: #bottomAdjuster)
		morphPositionInOwner: cornerExtent@(wh-thickness);
		morphExtent: w@thickness.
	(adjusters at: #leftAdjuster)
		morphPositionInOwner: 0@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #rightAdjuster)
		morphPositionInOwner: ww-thickness@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #topLeftAdjuster)
		morphPositionInOwner: 0@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster)
		morphPositionInOwner: 0@(wh-cornerExtent);
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster)
		morphPositionInOwner: ww-cornerExtent@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster)
		morphPositionInOwner: ww@wh-cornerExtent;
		morphExtent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		layoutMorph morphBoundsInWorld: self layoutBounds ].
	
	layoutNeeded _ false! !

RectangleLikeMorph removeSelector: #morphExtentInOwner!

RectangleLikeMorph removeSelector: #morphExtentInOwner!

Morph removeSelector: #morphExtentInOwner!

Morph removeSelector: #morphExtentInOwner!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1430-LocalCoordinates06-JuanVuletich-2012Sep07-19h14m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1429] on 7 September 2012 at 11:25:51 pm'!
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/7/2012 23:25'!
                               morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: extent x@aNumber! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/7/2012 23:25'!
                      morphWidth: aNumber

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: aNumber@extent y! !
!BorderedRectMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 19:53' prior: 50378903!
         drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		zzfillRectangle: (0@0 extent: extent)
		colorOrInfiniteForm: color
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 19:52' prior: 50380741!
  drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas zzframeAndFillRectangle: (0@0 extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			zzframeRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			zzimage: (FormCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: extent x - scrollbarThickness@0.
		aCanvas
			zzimage: (FormCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: 0@0 + extent - scrollbarThickness.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			zzfillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			colorOrInfiniteForm: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas zzfillRectangle: rectangle colorOrInfiniteForm: (Theme current listHighlightFocused: true) ].
			aCanvas
				zzdrawString: (completer entries at: index) asString
				in: rectangle
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!EllipseMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 19:53' prior: 50379146!
              drawOn: aCanvas 

	| r bc bw |
	r _ 0@0 extent: extent.
	bw _ borderWidth.
	bc _ borderColor.
	aCanvas isShadowDrawing
		ifTrue: [
			bw _ 0.
			bc _ nil ].
	aCanvas zzfillOval: r color: color borderWidth: bw borderColor: bc.
! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 9/7/2012 23:03' prior: 50353281!
containsPoint: aPoint

	| radius other delta xOverY e |
	(self morphBoundsInWorld containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"
	e _ self morphExtentInWorld.
	e > (1@1)
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	radius _ e y asFloat / 2.
	other _ e x asFloat / 2.
	delta _ aPoint - self morphPositionInWorld - (other@radius).
	xOverY _ e x asFloat / e y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 9/7/2012 19:54' prior: 50381088!
                           createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval
				allowStyler: true.
	result morphExtent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result morphPositionInOwner: 14@25.
	result morphExtent: extent-(28@62).
	^ result! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 19:54' prior: 50381108!
                    drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				zzroundRect: (0@0 extent: extent)
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		zzfillRectangle: (14@25 extent: extent-(28@62))
		colorOrInfiniteForm: (Theme current paneBackgroundFrom: color)! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/7/2012 23:17' prior: 50374608!
             addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleLikeMorph new
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph morphHeight + 5).
	nameBackground morphBoundsInWorld: (nameMorph morphBoundsInWorld outsetBy: 2).
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/7/2012 23:16' prior: 50358578!
    basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self handleSize.
	anExtent _ ((extent x + self handleSize + 8) max: minSide) @
				((extent y + self handleSize + 8) max: minSide).
	aBox _ Rectangle center: self morphBoundsInWorld center extent: anExtent.
	w _ self world ifNil: [ target outermostWorldMorph ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: 8@8) ]! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 19:54' prior: 50379604!
                 drawOn: aCanvas

	| tRect sRect colorToUse sLeft aForm centeringOffset |
	isSelected ifTrue: [
		aCanvas
			zzfillRectangle: (0@0 extent: extent)
			colorOrInfiniteForm: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) ].

	complexContents hasContents ifTrue: [
		tRect _ self toggleRectangle.
		aForm _ isExpanded 
			ifTrue: [ container expandedForm ]
			ifFalse: [ container notExpandedForm ].
		centeringOffset _ ((tRect height - aForm extent y) / 2.0) rounded.
		aCanvas 
			zzimage: aForm 
			at: (tRect topLeft translatedBy: 0 @ centeringOffset) ].

	sLeft _ indentLevel * 12 + 16.
	sRect _ sLeft@0 extent: extent - (sLeft@0).
	colorToUse _ complexContents preferredColor ifNil: [ color ].
	aCanvas
		zzdrawString: contents asString
		in: sRect
		font: self fontToUse
		color: colorToUse! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 9/7/2012 23:16' prior: 50346027!
                       model: aTextModel wrappedTo: width
	"Accept new text contents.  Lay it out, wrapping to width.
	Then fit my height to the result."
	wrapFlag _ true.
	self basicExtent: width truncated@extent y.
	self model: aTextModel! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/7/2012 23:14' prior: 50355101!
                     popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition - self morphPosition.
	sourceItem owner owner addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last - (extent x @ 0) value: false;
		value: rightOrLeftPoint first value: true! !
!MenuMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 19:55' prior: 50379156!
                  drawOn: aCanvas
	
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas zzroundRect: (0@0 extent: extent) color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			aCanvas zzfillRectangle: (0@0 extent: extent) colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #raised baseColorForBorder: color ]! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/7/2012 19:57' prior: 50381183!
     focusIndicatorExtent
	| e |
	e _ extent - borderWidth - borderWidth.
	self vIsScrollbarShowing ifTrue: [
		e _ e x - self scrollBarClass scrollbarThickness @ e y ].
	self hIsScrollbarShowing ifTrue: [
		e _ e x @ (e y - self scrollBarClass scrollbarThickness) ].
	^e! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/7/2012 19:58' prior: 50379172!
                         focusIndicatorRectangle

	| topLeft bottomRight |
	topLeft _ borderWidth@borderWidth.
	bottomRight _ extent - borderWidth.
	self vIsScrollbarShowing ifTrue: [
		bottomRight _ bottomRight x - self scrollBarClass scrollbarThickness@ bottomRight y].
	self hIsScrollbarShowing ifTrue: [
		bottomRight _ bottomRight x @ 
			(bottomRight y - self scrollBarClass scrollbarThickness)].
	^topLeft corner: bottomRight! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/7/2012 23:15' prior: 50381195!
            hScrollBarWidth
	"Return the width of the horizontal scrollbar"

	| w |	
	w _ extent x - (2 * borderWidth).
	self vIsScrollbarShowing
		ifTrue: [ w _ w - self scrollBarClass scrollbarThickness ].
	^w! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/7/2012 23:15' prior: 50381205!
                            updateScrollBarsBounds
	
	| t |
	hideScrollBars ifTrue: [^self].
	t _ self scrollBarClass scrollbarThickness.
	scrollBar
		morphPositionInOwner: extent x - t - borderWidth @ borderWidth;
		morphExtent: t @ self vScrollBarHeight.
	hScrollBar
		morphPositionInOwner: borderWidth @ (extent y - t - borderWidth);
		morphExtent: self hScrollBarWidth@t! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/7/2012 23:16' prior: 50381220!
         vScrollBarHeight
	^extent y - (2 * borderWidth)! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 9/7/2012 23:17' prior: 50381225!
            itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last internalPoint |
	internalPoint _ scroller internalize: aPoint.
	scroller hasSubmorphs ifFalse: [ ^nil ].
	(internalPoint > (0@0) and: [ internalPoint < scroller morphExtent ]) ifFalse: [ ^nil ].
	ptY _ internalPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	scroller firstSubmorph morphPositionInOwner y > ptY ifTrue: [ ^nil ].
	last _ scroller lastSubmorph.
	last morphPositionInOwner y + last morphHeight < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^scroller 
		findSubmorphBinary: [ :m |
			(m morphPositionInOwner y <= ptY and: [ m morphPositionInOwner y + m morphHeight >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPositionInOwner y + (m morphHeight // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 9/7/2012 23:14' prior: 50346341!
                            initialize
	super initialize.
	scroller morphWidth: extent x.
	scroller color: self textColor.! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 9/7/2012 23:18' prior: 50350700!
               freeSliderRoom
	"Answer the length or height of the free slider area, i.e. substract the slider itself"

	^ (self isHorizontal
		ifTrue: [ extent x - slider morphWidth]
		ifFalse: [ extent y - slider morphHeight])
			- (borderWidth * 2) - (self buttonExtent * 2).! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 9/7/2012 20:00' prior: 50350712!
      totalSliderRoom
	"Answer the length or height of the slider area"

	^ (self isHorizontal
		ifTrue: [ extent x ]
		ifFalse: [ extent y ])
			- (borderWidth * 2) - (self buttonExtent * 2).! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 9/7/2012 20:00' prior: 50351535!
                 initializeDownButton
	"initialize the receiver's downButton"

	| e |
	e _ self buttonExtent.
	downButton _ self buttonClass new.
	downButton model: self.
	self addMorph: downButton.
	downButton
		morphPositionInOwner: extent - borderWidth - e;
		morphExtent: e@e.
	self isHorizontal
		ifTrue: [ downButton updateRightButtonImage ]
		ifFalse: [ downButton updateDownButtonImage ]! !
!ScrollBar methodsFor: 'testing' stamp: 'jmv 9/7/2012 20:00' prior: 50350721!
                    isHorizontal

	^extent x > extent y! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:12' prior: 50378916!
        drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas zzfillRectangle: (0@0 extent: extent) colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	"A border was drawn at the left, top and right of the title area.
	The look is that the title area is inside the window"
	aCanvas zzfillRectangle: (borderWidth@borderWidth extent: extent x - (2*borderWidth)@ self labelHeight) colorOrInfiniteForm: titleColor! !
!SystemWindow methodsFor: 'change reporting' stamp: 'jmv 9/7/2012 23:13' prior: 50380707!
                             invalidateTitleArea

	"not really pretty... also invalidating the top border, regardless of it being above or below the title area
	(Different themes use various looks, this covers them all)"
	self zzinvalidRect: (0@0 extent: extent x @ (self labelHeight + borderWidth))! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 9/7/2012 19:52' prior: 50381266!
                              layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww |
	thickness _ 4.
	cornerExtent _ 20.
	ww _ extent x.
	wh _ extent y.
	w _ ww - cornerExtent - cornerExtent.
	h _ wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster)
		morphPositionInOwner: cornerExtent@0;
		morphExtent: w@thickness.
	(adjusters at: #bottomAdjuster)
		morphPositionInOwner: cornerExtent@(wh-thickness);
		morphExtent: w@thickness.
	(adjusters at: #leftAdjuster)
		morphPositionInOwner: 0@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #rightAdjuster)
		morphPositionInOwner: ww-thickness@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #topLeftAdjuster)
		morphPositionInOwner: 0@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster)
		morphPositionInOwner: 0@(wh-cornerExtent);
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster)
		morphPositionInOwner: ww-cornerExtent@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster)
		morphPositionInOwner: ww@wh-cornerExtent;
		morphExtent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		layoutMorph morphBoundsInWorld: self layoutBounds ].
	
	layoutNeeded _ false! !

SystemWindow removeSelector: #titleAreaInnerRect!

SystemWindow removeSelector: #titleAreaInnerRect!

Morph removeSelector: #morphHeight:!

Morph removeSelector: #morphHeight:!

Morph removeSelector: #morphWidth:!

Morph removeSelector: #morphWidth:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1431-LocalCoordinates07-JuanVuletich-2012Sep07-19h49m-jmv.5.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1431] on 8 September 2012 at 12:18:42 am'!
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/7/2012 23:39'!
    zzroundRect: aRectangle color: aColor radius: radious gradientTop: topFactor gradientBottom: bottomFactor gradientHeight: h
	"
	Display restore.
	FormCanvas clearFormsCache. 
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10 gradientTop: 1.0 gradientBottom: 0.5 gradientHeight: 35
	"
	| bottomColor displayRectangle r |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	r _ (currentTransformation externalizeScalar: radious) rounded.
	"top stripe"
	self
		image: (FormCanvas topLeftCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topLeft.
	self
		image: (FormCanvas topRightCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topRight - (r@0).
	self
		fillRectangle: ((displayRectangle withHeight: h) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.
	"center stripe"
	self fillRectangle: (displayRectangle insetBy: (0 @ h corner: 0 @ r)) colorOrInfiniteForm: bottomColor.
	
	"bottom stripe"
	self
		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomLeft - (0@r).
	self
		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomRight - (r@r) .
	self fillRectangle: ((displayRectangle bottomLeft + (r@r negated)) extent: (displayRectangle width - r - r@r)) colorOrInfiniteForm: bottomColor! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/7/2012 23:45'!
         zzwindowFrame: aRectangle color: aColor radius: radious border: borderWidth labelHeight: labelHeight gradientTop: topFactor gradientBottom: bottomFactor insideColor: insideColor
	"
	Display getCanvas windowFrame: (10@10 extent: 200@100) color: Color red radius: 10  border: 5 labelHeight: 25 gradientTop: 1.0 gradientBottom: 0.5 insideColor: Color green
	"
	"top stripe"
	| bottomColor he tl tr displayRectangle r bw lh |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	r _ (currentTransformation externalizeScalar: radious) rounded.
	bw _ (currentTransformation externalizeScalar: borderWidth) rounded.
	lh _ (currentTransformation externalizeScalar: labelHeight) rounded.
	self
		image: (FormCanvas topLeftCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topLeft.
	self
		image: (FormCanvas topRightCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topRight - (r@0).
	self
		fillRectangle: ((displayRectangle withHeight: lh) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.

	"left and right borders"
	tl _ displayRectangle topLeft + (0@lh).
	tr _ displayRectangle topRight + (bw negated@lh).
	he _ bw@(displayRectangle height - lh - r).
	self fillRectangle: (tl extent: he) colorOrInfiniteForm: bottomColor.
	self fillRectangle: (tr extent: he) colorOrInfiniteForm: bottomColor.
	
	"bottom stripe"
	self
		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomLeft - (0@r).
	self
		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomRight - (r@r) .
	self fillRectangle: ((displayRectangle bottomLeft + (r@bw negated)) extent: (displayRectangle width - r - r@bw)) colorOrInfiniteForm: bottomColor.

	"inside"
	self fillRectangle: (displayRectangle insetBy: (bw@lh corner: bw@bw)) colorOrInfiniteForm: insideColor! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/8/2012 00:03'!
zzdrawString: s at: pt font: aFont color: aColor

	^ self zzdrawString: s from: 1 to: s size at: pt font: aFont color: aColor! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/8/2012 00:03'!
                           zzdrawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c
	| font p1 |
	p1 _ currentTransformation transform: aPoint.
	port colorMap: nil.
	font _ fontOrNil ifNil: [StrikeFont default].
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (origin + p1)
		strikeFont: font
		kern: font baseKern negated! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/8/2012 00:17'!
                zzdrawStringEmbossed: aString from: firstIndex to: lastIndex in: aRectangle font: fontOrNil color: aColor
	| font portRect insideColor bounds |
	bounds _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	insideColor _ shadowColor ifNil: [ aColor ].
	insideColor = Color black ifFalse: [ | topColor |
		topColor _ insideColor alphaMixed: 0.25 with: Color black.
		port installStrikeFont: font foregroundColor: topColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin)
			strikeFont: font
			kern: font baseKern negated ].
	insideColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ insideColor alphaMixed: 0.22 with: Color white.
		port installStrikeFont: font foregroundColor: bottomColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin + (0@2))
			strikeFont: font
			kern: font baseKern negated ].
	port installStrikeFont: font foregroundColor: insideColor.
	port
		displayString: aString asString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin + (0@1))
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/8/2012 00:17'!
       zzdrawStringEmbossed: s in: boundsRect font: fontOrNil color: c
	^self zzdrawStringEmbossed: s from: 1 to: s size in: boundsRect font: fontOrNil color: c! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/7/2012 23:48' prior: 50376159!
         fillRectangle: displayRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: bw borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder

	"
	| if |
	if _ InfiniteForm verticalGradient: 24 topColor: Color green bottomColor:Color red.
	Display getCanvas
		fillRectangle: (10@10 extent: 300@200)
		colorOrInfiniteForm: if
		borderWidth: 5
		borderStyleSymbol: #raised
		baseColorForBorder: if asColor
	"

	"
Pretty ugly.
#fillRectangle:color::borderWidth:borderStyleSymbol:  is much better but has trouble with silly transparent morphs
	"
	
	self fillRectangle: (displayRectangle insetBy: bw) colorOrInfiniteForm: aColorOrInfiniteForm.
	self frameRectangle: displayRectangle color: baseColorForBorder borderWidth: bw borderStyleSymbol: aSymbol! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/7/2012 23:48' prior: 50380981!
          zzfillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: borderWidth borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder

	| displayRectangle bw |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	bw _ (currentTransformation externalizeScalar: borderWidth) rounded.
	self fillRectangle: (displayRectangle insetBy: bw) colorOrInfiniteForm: aColorOrInfiniteForm.
	self frameRectangle: displayRectangle color: baseColorForBorder borderWidth: bw borderStyleSymbol: aSymbol! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:57' prior: 50354652!
                     drawDropHighlightOn: aCanvas

	self highlightedForDrop ifTrue: [
		aCanvas zzframeRectangle: (0@0 extent: self morphExtent) borderWidth: 1 color: self dropHighlightColor ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:57' prior: 50354660!
       drawMouseDownHighlightOn: aCanvas
	self highlightedForMouseDown ifTrue: [
		aCanvas zzframeRectangle: (0@0 extent: self morphExtent) borderWidth: 1 color: self color darker darker ]! !
!FrameRateMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 00:04' prior: 50353315!
                    drawOn: aCanvas
	super drawOn: aCanvas.
	meanStepDelta ifNotNil: [
		aCanvas zzdrawString: lastStepDelta rounded printString at: 0@0 font: StrikeFont default color: Color black.
		aCanvas zzdrawString: meanStepDelta rounded printString at: 0@14 font: StrikeFont default color: Color black.
		"aCanvas drawString: lastStepStamp printString at: bounds topLeft + (0@28) font: StrikeFont default color: Color black "
		]! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:31' prior: 50353404!
         drawOn: aCanvas

	| b |
	aCanvas zzroundRect: (0@0 extent: extent) color: self color radius: 4.
	b _ self morphBoundsInWorld.
	aCanvas
		paragraph: paragraph
		bounds: (b insetBy: 4)
		color: Color black
		selectionColor: (Theme current textHighlightFocused: false)! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:56' prior: 50360986!
debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"

	self paragraph lines do: [ :line |
		aCanvas
			zzframeRectangle: line rectangle
			borderWidth: 1
			color: Color brown ]
! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:57' prior: 50373799!
      drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		paragraph: self paragraph
		bounds: self morphBoundsInWorld
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:49' prior: 50376303!
                     drawOn: aCanvas

	aCanvas
		zzfillRectangle: (0@0 extent: extent)
		colorOrInfiniteForm: color
		borderWidth: 2
		borderStyleSymbol: #raised
		baseColorForBorder: color! !
!MinimalStringMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 00:12' prior: 50373893!
                             drawOn: aCanvas

	aCanvas zzdrawString: contents in: (0@0 extent: extent) font: self fontToUse color: color! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 00:12' prior: 50373932!
                          drawOn: aCanvas
	self hasSelection ifTrue: [ self drawSelectionOn: aCanvas ].
	self hasVisibleCaret ifTrue: [ self drawCaretOn: aCanvas ].
	aCanvas
		zzdrawString: contents
		in: (0@0 extent: extent)
		font: self fontToUse
		color: color! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:50' prior: 50376319!
                      draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		zzfillRectangle: (0@0 extent: extent)
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:51' prior: 16913576!
     drawOn: aCanvas

	self isRoundButton
		ifTrue: [
			icon ifNil: [
				self drawRoundGradientLookOn: aCanvas ]]
		ifFalse: [
			 self draw3DLookOn: aCanvas ].

	icon ifNotNil: [
		self drawInconOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:40' prior: 50374076!
                     drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas
					zzroundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas zzroundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!RectangleIndicatorMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:58' prior: 50357569!
                              drawOn: aCanvas
	| bw b |
	bw _ self defaultBorderWidth.
	b _ 0@0 extent: extent.
	aCanvas zzframeRectangle: b borderWidth: bw color: Color black.
	aCanvas zzframeRectangle: (b insetBy: bw) borderWidth: bw color: Color white! !
!ScrollBar methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:52' prior: 50374144!
              drawOn: aCanvas

	aCanvas
		zzfillRectangle: (0@0 extent: extent)
		colorOrInfiniteForm: (color alphaMixed: 0.3 with: Color white)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!StringMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 00:13' prior: 50374186!
                drawOn: aCanvas
	aCanvas
		zzdrawString: contents
		in: (0@0 extent: extent)
		font: self fontToUse
		color: color! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 9/7/2012 23:55' prior: 50356988!
                      contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker.
	marker morphPosition: self morphPositionInWorld + (0@2)! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 00:11' prior: 50374231!
                    drawOn: aCanvas 
	| stringColor stringBounds leftEdge |

	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas zzfillRectangle: (0@0 extent: extent) colorOrInfiniteForm: Theme current menuHighlight].
	leftEdge _ 0.
	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ].
			aCanvas zzimage: iconForm at: 1 @ (extent y - iconForm height // 2).
			leftEdge _ iconForm width + self iconSeparation].

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + self submorphBounds width + 8 ].

	stringBounds _  leftEdge @ 1 extent: extent.

	aCanvas
		zzdrawString: contents
		in: stringBounds
		font: self fontToUse
		color: stringColor.
	subMenu ifNotNil: [
		aCanvas
			zzimage: SubMenuMarker
			at: extent x - 8 @ (extent y - SubMenuMarker height // 2) ]! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/7/2012 23:55' prior: 16887142!
                 offImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.9) 
			borderWidth: 1 borderColor: Color black.
	^form! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/7/2012 23:55' prior: 16887154!
            onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) 
			borderWidth: 1 borderColor: Color black;
		fillRectangle: (form boundingBox insetBy: 2) colorOrInfiniteForm: Color black.
	^form! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 9/8/2012 00:17' prior: 16964963!
                             drawLabelOn: aCanvas

	Theme current embossedTitles
		ifFalse: [
			aCanvas
				zzdrawString: labelString
				in: self labelRectangle
				font: Preferences windowTitleFont
				color: Theme current windowLabel ]
		ifTrue: [
			aCanvas
				zzdrawStringEmbossed: labelString
				in: self labelRectangleForEmbossed
				font: Preferences windowTitleFont
				color: Theme current windowLabel ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:46' prior: 50374312!
        drawRoundedFrameOn: aCanvas color: widgetsColor
	"Title area is not inside window borders"
	| bottomFactor topFactor |
	Theme current useWindowTitleGradient
		ifTrue: [
			topFactor _ Theme current titleGradientTopFactor.
			bottomFactor _ Theme current titleGradientBottomFactor ]
		ifFalse: [
			topFactor _ 1.
			bottomFactor _ 1 ].
	aCanvas
		zzwindowFrame: (0@0 extent: extent)
		color: widgetsColor * Theme current titleGradientExtraLightness
		radius: Theme current roundedWindowRadius
		border: borderWidth
		labelHeight: self labelHeight + borderWidth
		gradientTop: topFactor
		gradientBottom: bottomFactor
		insideColor: color! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 9/8/2012 00:15' prior: 50357784!
             labelRectangle
	"Actually the whole label area"

	| e x0 y0 x1 y1|
	e _ self boxExtent.
	x0 _  e x * 4 + 14.
	y0 _ 2.
	x1 _ extent x - 1.
	y1 _ e y + 1.
	^x0@y0 corner: x1@y1
	
	
	
! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 9/8/2012 00:18' prior: 50357796!
                     labelRectangleForEmbossed
	"Actually the whole label area"

	| e x0 y0 x1 y1 |
	e _ self boxExtent.
	x0 _ e x * 4 + 14.
	y0 _ 1.
	x1 _ extent x - 1.
	y1 _ e y + 2.
	^x0@y0 corner: x1@y1
	
	
	
! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 9/4/2012 20:14' prior: 50380950!
             drawHand: aHandMorph
	"Draw a hand that carries morphs, or needs to be drawn by us, because of not being the hardware mouse pointer."
	| bw r |
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth // 2.
		r _ aHandMorph morphFullBoundsInWorld.
		canvas frameRectangle: r borderWidth: bw color: Color black.
		canvas frameRectangle: (r insetBy: bw) borderWidth: bw color: Color white.
		canvas clipBy: aHandMorph morphBoundsInWorld during: [ :c | aHandMorph drawOn: c ]]
	ifFalse: [
		 canvas fullDraw: aHandMorph]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1432-LocalCoordinates08-JuanVuletich-2012Sep07-23h37m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1432] on 8 September 2012 at 12:28:09 am'!
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 00:26' prior: 50374015!
              drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ extent // 2.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ extent x - labelMargin - labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			zzdrawStringEmbossed: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: colorForLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 00:24' prior: 50374052!
               drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ extent // 2.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ extent x - labelMargin - labelMargin - 1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			zzdrawString: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/7/2012 23:40' prior: 50382193!
 drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas
					zzroundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas zzroundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !

FormCanvas removeSelector: #drawString:from:to:in:font:color:!

FormCanvas removeSelector: #drawString:from:to:in:font:color:!

FormCanvas removeSelector: #drawString:in:font:color:!

FormCanvas removeSelector: #drawString:in:font:color:!

FormCanvas removeSelector: #drawStringEmbossed:from:to:in:font:color:!

FormCanvas removeSelector: #drawStringEmbossed:from:to:in:font:color:!

FormCanvas removeSelector: #drawStringEmbossed:in:font:color:!

FormCanvas removeSelector: #drawStringEmbossed:in:font:color:!

FormCanvas removeSelector: #fillOval:color:borderWidth:borderColor:!

FormCanvas removeSelector: #fillOval:color:borderWidth:borderColor:!

FormCanvas removeSelector: #fillRectangle:colorOrInfiniteForm:borderWidth:borderStyleSymbol:!

FormCanvas removeSelector: #fillRectangle:colorOrInfiniteForm:borderWidth:borderStyleSymbol:!

FormCanvas removeSelector: #fillRectangle:colorOrInfiniteForm:borderWidth:borderStyleSymbol:baseColorForBorder:!

FormCanvas removeSelector: #fillRectangle:colorOrInfiniteForm:borderWidth:borderStyleSymbol:baseColorForBorder:!

FormCanvas removeSelector: #roundRect:color:radius:gradientTop:gradientBottom:gradientHeight:!

FormCanvas removeSelector: #roundRect:color:radius:gradientTop:gradientBottom:gradientHeight:!

FormCanvas removeSelector: #windowFrame:color:radius:border:labelHeight:gradientTop:gradientBottom:insideColor:!

FormCanvas removeSelector: #windowFrame:color:radius:border:labelHeight:gradientTop:gradientBottom:insideColor:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1433-LocalCoordinates09-JuanVuletich-2012Sep08-00h22m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1433] on 8 September 2012 at 8:17:09 pm'!
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:16'!
           initialize
	super initialize.
	extent _ 200@100! !
!Morph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:10' prior: 50378375!
                            initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	location _ MatrixTransform2x3 identity.
	layoutNeeded _ false! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:11' prior: 50374389!
            initialize
	super initialize.
	extent _ 50@40.
	color _ self defaultColor! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:14' prior: 50378421!
                              initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	extent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!MenuItemMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:14' prior: 16887084!
     initialize
	"initialize the state of the receiver"
	super initialize.
	""
	extent _ 10@10.
	contents _ ''.
	isEnabled _ true.
	subMenu _ nil.
	isSelected _ false.
	target _ nil.
	selector _ nil.
	arguments _ nil.
	font _ Preferences standardMenuFont! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:13' prior: 50374458!
          initialize
	super initialize.
	extent _ 50 @ 2! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:15' prior: 50378431!
                         initialize
	super initialize.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 9/8/2012 20:16' prior: 16934963!
               initialize
	super initialize.
	extent _ self class scrollbarThickness @ 100.
	value _ 0.0.
	self recreateSubmorphs.
	scrollDelta _ 0.02.
	pageDelta _ 0.2! !

ScrollBar removeSelector: #defaultBounds!

ScrollBar removeSelector: #defaultBounds!

PluggableMorph removeSelector: #defaultBounds!

PluggableMorph removeSelector: #defaultBounds!

MenuItemMorph removeSelector: #defaultBounds!

MenuItemMorph removeSelector: #defaultBounds!

Morph removeSelector: #defaultBounds!

Morph removeSelector: #defaultBounds!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1434-LocalCoordinates10-JuanVuletich-2012Sep08-19h57m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1433] on 8 September 2012 at 8:43:08 pm'!
!Morph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 20:40'!
                    zzclippingBounds
	"Return the bounds to which any submorphs should be clipped if the property is set"
	"Maybe shouldn't exist"
	self flag: #jmvVer2.
	^self zzinnerBounds! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/8/2012 20:37'!
                        zzinnerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

"would be better In own coordinates!!"
	self flag: #jmvVer2.
	^ self morphBoundsInWorld! !
!Morph methodsFor: 'layout' stamp: 'jmv 9/8/2012 20:39'!
                              zzlayoutBounds
	"Return the bounds for laying out children of the receiver"
	^self zzinnerBounds! !
!BorderedRectMorph methodsFor: 'geometry' stamp: 'jmv 9/8/2012 20:37'!
                     zzinnerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

	^ self morphBoundsInWorld insetBy: borderWidth! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 9/8/2012 20:40'!
                    zzinitialIndicatorBounds
	^self morphBoundsInWorld outsetBy: 1! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 9/8/2012 20:37'!
                            zzinnerBounds
	"Exclude the label area"

	^ self morphBoundsInWorld insetBy: (borderWidth @ (self labelHeight+borderWidth) corner: borderWidth @ borderWidth)! !
!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 9/8/2012 20:41'!
                zzinitialIndicatorBounds
	^owner morphBoundsInWorld! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 20:40' prior: 50378673!
                               drawSubmorphsOn: aCanvas 
	"Display submorphs back to front"
	submorphs isEmpty ifTrue: [ ^ self ].
	self clipsSubmorphs
		ifTrue: [
			aCanvas
				clipBy: self zzclippingBounds
				during: [ :clippedCanvas | 
					submorphs reverseDo:
						[ :m |  clippedCanvas fullDraw: m ] ] ]
		ifFalse: [
			submorphs reverseDo:
				[ :m |  aCanvas fullDraw: m ] ]! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 9/8/2012 20:41' prior: 50367699!
  mouseDown: aMouseButtonEvent localPosition: localEventPosition

	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	self cursor show.
	hand _ aMouseButtonEvent hand.
	self startStepping.
	Preferences fastDragWindowForMorphic ifTrue: [
		indicator _ RectangleIndicatorMorph new.
		indicator morphBoundsInWorld: self zzinitialIndicatorBounds.
		indicator openInWorld ]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 9/8/2012 20:39' prior: 50375397!
           layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		layoutNeeded _ false.
		^self].

	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self zzlayoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self zzlayoutBounds ].

	layoutNeeded _ false! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 20:33' prior: 50382299!
          drawOn: aCanvas 
	| stringColor stringBounds leftEdge |

	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas zzfillRectangle: (0@0 extent: extent) colorOrInfiniteForm: Theme current menuHighlight].
	leftEdge _ 0.

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + submorphs first morphWidth + 8 ].

	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ].
			aCanvas zzimage: iconForm at: leftEdge+1 @ (extent y - iconForm height // 2).
			leftEdge _ leftEdge + iconForm width + self iconSeparation].

	stringBounds _  leftEdge @ 1 extent: extent.

	aCanvas
		zzdrawString: contents
		in: stringBounds
		font: self fontToUse
		color: stringColor.
	subMenu ifNotNil: [
		aCanvas
			zzimage: SubMenuMarker
			at: extent x - 8 @ (extent y - SubMenuMarker height // 2) ]! !
!MenuItemMorph methodsFor: 'layout' stamp: 'jmv 9/8/2012 20:30' prior: 16887103!
                            minItemWidth
	| fontToUse iconWidth subMenuWidth markerWidth |
	fontToUse _ self fontToUse.
	subMenuWidth _ self hasSubMenu
				ifFalse: [0]
				ifTrue: [10].
	iconWidth _ self hasIcon
				ifTrue: [self icon width + self iconSeparation]
				ifFalse: [0].
	markerWidth _ self hasMarker
		ifTrue: [ submorphs first morphWidth + 8 ]
		ifFalse: [ 0 ].
	^ (fontToUse widthOfString: contents)
		+ subMenuWidth + iconWidth + markerWidth.! !
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 9/8/2012 20:26' prior: 16887260!
                              addBlankIconsIfNecessary: anIcon
	"If any of my items have an icon, ensure that all do by using anIcon for those that don't"

	| withIcons withoutIcons |
	withIcons _ Set new.
	withoutIcons _ Set new.
	self items do: [ :item |
		item hasIcon | item hasMarker
			ifTrue: [ withIcons add: item ]
			ifFalse: [ withoutIcons add: item ].
		item hasSubMenu ifTrue: [ item subMenu addBlankIconsIfNecessary: anIcon ]].
	(withIcons isEmpty or: [ withoutIcons isEmpty ]) ifTrue: [ ^self ].
	withoutIcons do: [ :item | item icon: anIcon ].! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 20:40' prior: 50380814!
                          drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			"self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"
			self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self zzclippingBounds
					during: [ :canvas | canvas zzimage: backgroundImage at: 0@0 ]]
				ifFalse: [ aCanvas zzimage: backgroundImage at: 0@0 ]]

		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [color class == TranslucentColor])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt current toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: 0@0 in: nil
						fillColor: color rule: Form over]
				ifFalse: [ super drawOn: aCanvas ]]! !
!ProgressBarMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 20:38' prior: 16923265!
                              drawOn: aCanvas
	| width inner |
	super drawOn: aCanvas.
	inner _ self zzinnerBounds.
	width _ (inner width * value) truncated min: inner width.
	aCanvas fillRectangle: (inner origin extent: width @ inner height) colorOrInfiniteForm: progressColor.! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 9/8/2012 20:39' prior: 50381757!
                    layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww |
	thickness _ 4.
	cornerExtent _ 20.
	ww _ extent x.
	wh _ extent y.
	w _ ww - cornerExtent - cornerExtent.
	h _ wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster)
		morphPositionInOwner: cornerExtent@0;
		morphExtent: w@thickness.
	(adjusters at: #bottomAdjuster)
		morphPositionInOwner: cornerExtent@(wh-thickness);
		morphExtent: w@thickness.
	(adjusters at: #leftAdjuster)
		morphPositionInOwner: 0@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #rightAdjuster)
		morphPositionInOwner: ww-thickness@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #topLeftAdjuster)
		morphPositionInOwner: 0@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster)
		morphPositionInOwner: 0@(wh-cornerExtent);
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster)
		morphPositionInOwner: ww-cornerExtent@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster)
		morphPositionInOwner: ww@wh-cornerExtent;
		morphExtent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		layoutMorph morphBoundsInWorld: self zzlayoutBounds ].
	
	layoutNeeded _ false! !

WindowEdgeAdjustingMorph removeSelector: #initialIndicatorBounds!

WindowEdgeAdjustingMorph removeSelector: #initialIndicatorBounds!

SystemWindow removeSelector: #innerBounds!

SystemWindow removeSelector: #innerBounds!

MenuItemMorph removeSelector: #hasIconOrMarker!

MenuItemMorph removeSelector: #hasIconOrMarker!

LayoutAdjustingMorph removeSelector: #initialIndicatorBounds!

LayoutAdjustingMorph removeSelector: #initialIndicatorBounds!

BorderedRectMorph removeSelector: #innerBounds!

BorderedRectMorph removeSelector: #innerBounds!

Morph removeSelector: #clippingBounds!

Morph removeSelector: #clippingBounds!

Morph removeSelector: #innerBounds!

Morph removeSelector: #innerBounds!

Morph removeSelector: #layoutBounds!

Morph removeSelector: #layoutBounds!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1435-LocalCoordinates11-JuanVuletich-2012Sep08-20h17m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1435] on 8 September 2012 at 11:01:28 pm'!
!FormCanvas methodsFor: 'initialization' stamp: 'jmv 9/8/2012 22:02'!
   initialize
	super initialize.

	currentTransformation _ MatrixTransform2x3 identity.
	cti _ 1.
	transformations
		ifNil: [ transformations _ OrderedCollection with: currentTransformation ]
		ifNotNil: [ transformations at: cti put: currentTransformation ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 22:47' prior: 50378702!
                   imageForm: depth forRectangle: rect
	| canvas |
	canvas _ Display defaultCanvasClass depth: depth over: rect.
	canvas fullDraw: self.
	^ canvas formWithOffset! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 22:44' prior: 50378711!
                    ownShadowForm
	"Return a form representing the 'shadow' of the receiver, without including submorphs 
	regardless of clipping"
	| canvas |
	canvas _ Display defaultCanvasClass forShadowOver: self morphBoundsInWorld.
	canvas into: self.
	canvas clipBy: self morphBoundsInWorld during: [ :c | self drawOn: c ].
	^ canvas formWithOffset! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 22:45' prior: 50378725!
     shadowForm
	"Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."
	| bnds canvas |
	bnds _ self morphFullBoundsInWorld.
	canvas _ Display defaultCanvasClass forShadowOver: bnds.
	canvas into: self.
	canvas fullDraw: self.
	^ canvas formWithOffset! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 22:58' prior: 50380517!
 restoreSavedPatchOn: aCanvas 
	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."

	hasChanged _ false.
	savedPatch ifNotNil: [
		aCanvas zzimage: savedPatch at: savedPatch offset.
		submorphs notEmpty ifTrue: [ ^self ].

		"Make the transition to using hardware cursor. Clear savedPatch and
		 report one final damage rectangle to erase the image of the software cursor."
		self invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset).
		Sensor currentCursor == Cursor normal ifFalse: [ Cursor normal show ].	"show hardware cursor"
		savedPatch _ nil ]! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 22:45' prior: 50378753!
            shadowForm
	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"
	| bnds canvas |
	bnds _ Rectangle merging: (submorphs collect: [:m | m morphFullBoundsInWorld]).
	canvas _ Display defaultCanvasClass forShadowOver: bnds.
	canvas into: self.
	self drawSubmorphsOn: canvas.
	^ canvas formWithOffset! !
!WorldState methodsFor: 'canvas' stamp: 'jmv 9/8/2012 22:54' prior: 16986433!
                  canvas: aFormCanvas
	canvas _ aFormCanvas.
	self flag: #jmvVer2.
	"should be our world..."
	aFormCanvas ifNotNil: [
		aFormCanvas into: World ].
	damageRecorder
		ifNil: [ damageRecorder _ DamageRecorder new]
		ifNotNil: [ damageRecorder doFullRepaint]! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 9/8/2012 22:55' prior: 50378784!
                 drawInvalidAreasWorld: aWorld submorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |
	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ OrderedCollection new.
	(damageRecorder invalidRectsFullBounds: aWorld viewBox) do: [ :r |
		r ifNotNil: [ initialRectsToRepair addLast: r ]].
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			(canvas copyClipRect: r) clipBy: aWorld morphBoundsInWorld during: [ :c | aWorld drawOn: c ]]].
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could merge all xrects into just one call... Most likely, that would be slower, though."
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas copyClipRect: r) fullDraw: m
		].
"		(canvas copyClipRect: rr) fullDrawMorph: m "
	].
	
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !

FormCanvas removeSelector: #image:at:!

FormCanvas removeSelector: #image:at:!

FormCanvas removeSelector: #initTransformationsFor:!

FormCanvas removeSelector: #initTransformationsFor:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1436-LocalCoordinates12-JuanVuletich-2012Sep08-22h53m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1436] on 9 September 2012 at 12:18:12 am'!
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/8/2012 23:05'!
             zzimage: aForm at: aPoint sourceRect: sourceRect
	"Draw a translucent image using the best available way of representing translucency.
	Note: This will be fixed in the future."
	| r p |
	p _ currentTransformation transform: aPoint.
	self isShadowDrawing ifTrue: [
		^self stencil: aForm at: p rounded sourceRect: sourceRect color: shadowColor ].
	r _ (self depth < 32 or: [ aForm mightBeTranslucent not]) 
		ifTrue: [
			"Rule Form paint treats pixels with a value of zero as transparent"
			Form paint]
		ifFalse: [ Form blend ].
	self image: aForm
		at: p rounded
		sourceRect: sourceRect
		rule: r! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/8/2012 23:07'!
                              zzimage: aForm multipliedBy: aColor at: aPoint
	"Multiply aForm and aColor, then blend over destination.
	aForm is a kind of advanced stencil, supplying brightness and opacity at each pixel

	Display getCanvas image: (SystemWindow roundedCornerTR: 20)multipliedBy: Color red at: 20@20
	"
	AccessProtect critical: [
		self buildAuxWith: aForm multipliedWith: aColor.
		self zzimage: AuxForm at: aPoint sourceRect: aForm boundingBox ]! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 00:16'!
  fillRectangle: r color: fillColor
	| rect |
	rect _ r translatedBy: origin.
	"draw the border of the rectangle"

	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillRect: rect offset: origin ]! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/8/2012 23:49'!
   zzfillRectangle: aRectangle infiniteForm: anInfiniteForm multipliedBy: aColor
	"Fill aRectangle with the equivalent of anInfiniteForm multiplied by aColor
	aForm is a kind of advanced stencil, supplying brightness and opacity at each pixel
	Similar to #image:multipliedBy:at:


	Display getCanvas fillRectangle: (10@10 extent: 100@100) infiniteForm: (SystemWindow titleGradient: 12) multipliedBy: Color red.
	"

	| f displayRectangle |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	f _ anInfiniteForm form.
	AccessProtect critical: [
		self buildAuxWith: f multipliedWith: aColor.
		self fillRectangle: displayRectangle tilingWith: AuxForm sourceRect: f boundingBox rule: Form paint ]! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 00:09'!
 zzframeRectangle: r color: aColor borderWidth: borderWidth borderStyleSymbol: aSymbol
	"
	Display getCanvas zzfillRectangle: (10@10 extent: 300@200) colorOrInfiniteForm: Color white.
	Display getCanvas
		zzframeRectangle: (10@10 extent: 300@200)
		color: Color green
		borderWidth: 2
		borderStyleSymbol: #raised.
	"

	| displayRectangle bw |
		bw _ (currentTransformation externalizeScalar: borderWidth) rounded.
	aSymbol == #raised ifTrue: [
		displayRectangle _ currentTransformation displayBoundsOfTransformOf: r.
		^ self
			frameRectangle: displayRectangle
			borderWidth: bw
			topLeftColor: aColor quiteWhiter
			bottomRightColor: aColor quiteBlacker ].

	aSymbol == #inset ifTrue: [
		displayRectangle _ currentTransformation displayBoundsOfTransformOf: r.
		^ self
			frameRectangle: displayRectangle
			borderWidth: bw
			topLeftColor: aColor quiteBlacker
			bottomRightColor: aColor quiteWhiter ].
	
	"Unrecognized border style. Draw some border..."
	self zzframeRectangle: r borderWidth: bw color: aColor! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/8/2012 23:49'!
                  zzroundRect: aRectangle color: aColor radius: r gradientTop: topFactor gradientCenter: centerFactor gradientBottom: bottomFactor gradient1Height: h1
	"
	Display restore.
	FormCanvas clearFormsCache. 
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10 gradientTop: 1.0 gradientCenter: 0.0 gradientBottom: 1.0 gradient1Height: 35
	"
	| h2 |
	"top stripe"
	self
		zzimage: (FormCanvas topLeftCorner: r height: h1 gradientTop: topFactor gradientBottom: centerFactor)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		zzimage: (FormCanvas topRightCorner: r height: h1 gradientTop: topFactor gradientBottom: centerFactor)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self
		zzfillRectangle: ((aRectangle withHeight: h1) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: h1 gradientTop: topFactor gradientBottom: centerFactor)
		multipliedBy: aColor.
	
	"bottom stripe"
	h2 _ aRectangle height - h1.
	self
		zzimage: (FormCanvas bottomLeftCorner: r height: h2 gradientTop: centerFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topLeft + (0@h1).
	self
		zzimage: (FormCanvas bottomRightCorner: r height: h2 gradientTop: centerFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topRight + (r negated@h1).
	self
		zzfillRectangle: ((aRectangle topLeft + (r@h1)) extent: (aRectangle width-r-r@h2))
		infiniteForm: (FormCanvas verticalGrayGradient: h2 gradientTop: centerFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.! !
!Color class methodsFor: 'examples' stamp: 'jmv 9/8/2012 23:19' prior: 16818903!
       experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Color fromUser.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas zzfillRectangle: (0@0 extent: height@height) colorOrInfiniteForm: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Color basicNew setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	Display forceToScreen
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Color basicNew setHue: h chroma: c luminance: selectedLuminance.
"		color _ Color basicNew setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Color black ].
"		color _ Color basicNew setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Color basicNew setHue: h chroma: selectedChroma luminance: v.
"		color _ Color basicNew setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Color black ].
"		color _ Color basicNew setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	Display forceToScreen
].! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/8/2012 23:05' prior: 50379382!
                  zzimage: aForm at: aPoint
	"Draw a translucent image using the best available way of representing translucency."

	self zzimage: aForm
		at: aPoint
		sourceRect: aForm boundingBox! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/8/2012 23:23' prior: 50378588!
               zzfillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm
	"Fill the given rectangle."

	| f colorOrInfiniteForm displayRectangle |

	colorOrInfiniteForm _ aColorOrInfiniteForm.
	self isShadowDrawing
		ifTrue: [
			colorOrInfiniteForm _ shadowColor ]
		ifFalse: [
			(aColorOrInfiniteForm isKindOf: InfiniteForm) ifTrue: [
				displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
				f _ aColorOrInfiniteForm form.
				^self fillRectangle: displayRectangle tilingWith: f sourceRect: f boundingBox rule: Form paint ]].

	^self 
		zzframeAndFillRectangle: aRectangle
		fillColor: colorOrInfiniteForm
		borderWidth: 0
		borderColor: Color transparent! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 00:09' prior: 50382055!
                   zzfillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: borderWidth borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder

	self zzfillRectangle: (aRectangle insetBy: borderWidth) colorOrInfiniteForm: aColorOrInfiniteForm.
	self zzframeRectangle: aRectangle color: baseColorForBorder borderWidth: borderWidth borderStyleSymbol: aSymbol! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/8/2012 23:18' prior: 50381000!
     zzroundRect: aRectangle color: aColor radius: r
	"
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10
	"
	"radious is not scaled properly..."
	"top stripe"
	self
		zzimage: (FormCanvas topLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		zzimage: (FormCanvas topRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self zzfillRectangle: ((aRectangle withHeight: r) insetBy: r@0) colorOrInfiniteForm: aColor.

	"center stripe"
	self zzfillRectangle: (aRectangle insetBy: (0 @ r corner: 0 @ r)) colorOrInfiniteForm: aColor.
	
	"bottom stripe"
	self
		zzimage: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle bottomLeft - (0@r).
	self
		zzimage: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle bottomRight - (r@r) .
	self zzfillRectangle: ((aRectangle bottomLeft + (r@r negated)) extent: (aRectangle width - r - r@r)) colorOrInfiniteForm: aColor! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/8/2012 23:51' prior: 50381815!
       zzroundRect: displayRectangle color: aColor radius: r gradientTop: topFactor gradientBottom: bottomFactor gradientHeight: h
	"
	Display restore.
	FormCanvas clearFormsCache. 
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10 gradientTop: 1.0 gradientBottom: 0.5 gradientHeight: 35
	"
	| bottomColor |
	"top stripe"
	self
		zzimage: (FormCanvas topLeftCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topLeft.
	self
		zzimage: (FormCanvas topRightCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topRight - (r@0).
	self
		zzfillRectangle: ((displayRectangle withHeight: h) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.
	"center stripe"
	self zzfillRectangle: (displayRectangle insetBy: (0 @ h corner: 0 @ r)) colorOrInfiniteForm: bottomColor.
	
	"bottom stripe"
	self
		zzimage: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomLeft - (0@r).
	self
		zzimage: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomRight - (r@r) .
	self zzfillRectangle: ((displayRectangle bottomLeft + (r@r negated)) extent: (displayRectangle width - r - r@r)) colorOrInfiniteForm: bottomColor! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/8/2012 23:52' prior: 50381871!
                 zzwindowFrame: aRectangle color: aColor radius: r border: bw labelHeight: lh gradientTop: topFactor gradientBottom: bottomFactor insideColor: insideColor
	"
	Display getCanvas windowFrame: (10@10 extent: 200@100) color: Color red radius: 10  border: 5 labelHeight: 25 gradientTop: 1.0 gradientBottom: 0.5 insideColor: Color green
	"
	"top stripe"
	| bottomColor he tl tr |
	self
		zzimage: (FormCanvas topLeftCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		zzimage: (FormCanvas topRightCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self
		zzfillRectangle: ((aRectangle withHeight: lh) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.

	"left and right borders"
	tl _ aRectangle topLeft + (0@lh).
	tr _ aRectangle topRight + (bw negated@lh).
	he _ bw@(aRectangle height - lh - r).
	self zzfillRectangle: (tl extent: he) colorOrInfiniteForm: bottomColor.
	self zzfillRectangle: (tr extent: he) colorOrInfiniteForm: bottomColor.
	
	"bottom stripe"
	self
		zzimage: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: aRectangle bottomLeft - (0@r).
	self
		zzimage: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: aRectangle bottomRight - (r@r) .
	self zzfillRectangle: ((aRectangle bottomLeft + (r@bw negated)) extent: (aRectangle width - r - r@bw)) colorOrInfiniteForm: bottomColor.

	"inside"
	self zzfillRectangle: (aRectangle insetBy: (bw@lh corner: bw@bw)) colorOrInfiniteForm: insideColor! !
!FormCanvas class methodsFor: 'cached forms' stamp: 'jmv 9/8/2012 23:49' prior: 16861459!
          steButtonForm: extent
	^CachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				zzroundRect: (0@0 extent: extent)
				color: (Color gray: 0.4)
				radius: 4.
			canvas
				zzroundRect: (1@1 extent: extent-2)
				color: Color white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!GrafPort methodsFor: 'drawing support' stamp: 'jmv 9/8/2012 23:03' prior: 16863487!
    image: aForm at: aPoint sourceRect: sourceRect rule: rule
	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."

	sourceForm _ aForm.
	combinationRule _ rule.
	self sourceRect: sourceRect.
	self destOrigin: aPoint.
	self copyBits! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 23:45' prior: 50373746!
 drawOn: aCanvas

	aCanvas
		zzimage: (self class circleForm: extent)
		multipliedBy: (color alpha: 0.57)
		at: 0@0! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 00:10' prior: 50382328!
                        offImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		zzframeAndFillRectangle: form boundingBox fillColor: (Color gray: 0.9) 
			borderWidth: 1 borderColor: Color black.
	^form! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/8/2012 23:24' prior: 50382340!
          onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		zzframeAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) 
			borderWidth: 1 borderColor: Color black;
		zzfillRectangle: (form boundingBox insetBy: 2) colorOrInfiniteForm: Color black.
	^form! !
!MenuLineMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 23:25' prior: 50353705!
                        drawOn: aCanvas 
	| baseColor r |
	baseColor _ owner color.
	r _ self morphBoundsInWorld.
	aCanvas
		zzfillRectangle: (r topLeft corner: r rightCenter)
		colorOrInfiniteForm: baseColor twiceDarker.
			
	aCanvas
		zzfillRectangle: (r leftCenter corner: r bottomRight)
		colorOrInfiniteForm: baseColor twiceLighter! !
!Paragraph methodsFor: 'display' stamp: 'jmv 9/9/2012 00:16' prior: 16908926!
                      displaySelectionStartBlock: startBlock stopBlock: stopBlock InLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft  selectionColor: sc
	| leftX rightX idx caretFont t b caretAttributes |

	startBlock ifNil: [^self].	"No selection"
	startBlock = stopBlock 
		ifTrue: [
			"Only show caret on line where clicked"
			startBlock textLine first = line first ifFalse: [
				^self ].
			leftX _ paragraphTopLeft x + startBlock left.
			idx _ startBlock stringIndex.
			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].
			caretFont _ caretAttributes
				ifNil: [ model actualContents fontAt: idx ]
				ifNotNil: [ model actualContents fontIfApplying: caretAttributes ].
			b _ paragraphTopLeft y + line top + line baseline + caretFont descent-1.
			t _ paragraphTopLeft y + line top + line baseline - caretFont ascent.
			showCaret ifTrue: [
				self
					displayInsertionMarkAtX: leftX
					top: t
					bottom: b
					emphasis: caretFont emphasis
					on: aCanvas
					paragraphTopLeft: paragraphTopLeft ]]
		ifFalse: [
			"Test entire selection before or after here"
			(stopBlock stringIndex < line first 
				or: [startBlock stringIndex > (line last + 1)])
					ifTrue: [^self].	"No selection on this line"
			(stopBlock stringIndex = line first 
				and: [stopBlock textLine ~= line])
					ifTrue: [^self].	"Selection ends on line above"
			(startBlock stringIndex = (line last + 1) 
				and: [stopBlock textLine ~= line])
					ifTrue: [^self].
			lastCaretRect _ nil.
			leftX _  paragraphTopLeft x + (startBlock stringIndex < line first 
				ifTrue: [ line ]
				ifFalse: [ startBlock ]) left.
			rightX _  paragraphTopLeft x + ((stopBlock stringIndex > (line last + 1) or: [
					stopBlock stringIndex = (line last + 1) 
						and: [stopBlock textLine ~= line]]) 
				ifTrue: [line right]
				ifFalse: [stopBlock left]).
			aCanvas
				fillRectangle: (leftX @ (line top +  paragraphTopLeft y) corner: rightX @ (line bottom +  paragraphTopLeft y))
				color: sc ].	"Selection begins on line below"! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/8/2012 23:46' prior: 50353892!
  drawInconOn: aCanvas

	| theIcon |
	theIcon _ self magnifiedIcon.
	aCanvas
		zzimage: theIcon
		multipliedBy: self iconColor
		at: (extent - theIcon extent //2)! !
!ProgressBarMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:13' prior: 50382872!
       drawOn: aCanvas

	super drawOn: aCanvas.
	aCanvas
		zzfillRectangle: (borderWidth@borderWidth extent: extent x - borderWidth - borderWidth * value @ extent y - borderWidth-borderWidth)
		colorOrInfiniteForm: progressColor! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:17' prior: 50382411!
                drawHand: aHandMorph
	"Draw a hand that carries morphs, or needs to be drawn by us, because of not being the hardware mouse pointer."
	| bw r |
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth // 2.
		r _ aHandMorph morphFullBoundsInWorld.
		canvas zzframeRectangle: r borderWidth: bw color: Color black.
		canvas zzframeRectangle: (r insetBy: bw) borderWidth: bw color: Color white.
		canvas clipBy: aHandMorph morphBoundsInWorld during: [ :c | aHandMorph drawOn: c ]]
	ifFalse: [
		 canvas fullDraw: aHandMorph]! !

ScrollBar removeSelector: #zzzdrawOn:!

FormCanvas removeSelector: #fillRectangle:colorOrInfiniteForm:!

FormCanvas removeSelector: #fillRectangle:colorOrInfiniteForm:!

FormCanvas removeSelector: #fillRectangle:fillColor:!

FormCanvas removeSelector: #fillRectangle:infiniteForm:multipliedBy:!

FormCanvas removeSelector: #fillRectangle:infiniteForm:multipliedBy:!

FormCanvas removeSelector: #frameAndFillRectangle:fillColor:borderWidth:borderColor:!

FormCanvas removeSelector: #frameAndFillRectangle:fillColor:borderWidth:borderColor:!

FormCanvas removeSelector: #frameRectangle:borderWidth:color:!

FormCanvas removeSelector: #frameRectangle:borderWidth:color:!

FormCanvas removeSelector: #frameRectangle:color:borderWidth:borderStyleSymbol:!

FormCanvas removeSelector: #frameRectangle:color:borderWidth:borderStyleSymbol:!

FormCanvas removeSelector: #image:at:sourceRect:!

FormCanvas removeSelector: #image:at:sourceRect:!

FormCanvas removeSelector: #image:multipliedBy:at:!

FormCanvas removeSelector: #image:multipliedBy:at:!

FormCanvas removeSelector: #roundRect:color:radius:!

FormCanvas removeSelector: #roundRect:color:radius:!

FormCanvas removeSelector: #roundRect:color:radius:gradientTop:gradientCenter:gradientBottom:gradient1Height:!

FormCanvas removeSelector: #roundRect:color:radius:gradientTop:gradientCenter:gradientBottom:gradient1Height:!

FormCanvas removeSelector: #zzzfillRectangle:colorOrInfiniteForm:borderWidth:borderStyleSymbol:baseColorForBorder:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1437-LocalCoordinates13-JuanVuletich-2012Sep09-00h05m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1436] on 9 September 2012 at 12:34:30 am'!
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 00:29'!
       zzfillRectangle: aRectangle color: aColor
	"Fill the given rectangle."

	| color |

	color _ aColor.
	self isShadowDrawing ifTrue: [
		color _ shadowColor ].

	^self 
		zzframeAndFillRectangle: aRectangle
		fillColor: color
		borderWidth: 0
		borderColor: Color transparent! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 00:30'!
 zzfillRectangle: aRectangle color: aColor borderWidth: borderWidth borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder

	self zzfillRectangle: (aRectangle insetBy: borderWidth) color: aColor.
	self zzframeRectangle: aRectangle color: baseColorForBorder borderWidth: borderWidth borderStyleSymbol: aSymbol! !
!GrafPort methodsFor: 'drawing support' stamp: 'jmv 9/9/2012 00:33'!
                         fillRect: rect

	destX _ rect left.
	destY _ rect top.
	sourceX _ 0.
	sourceY _ 0.
	width _ rect width.
	height _ rect height.
	self copyBits! !
!Color class methodsFor: 'examples' stamp: 'jmv 9/9/2012 00:30' prior: 50383303!
                              experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Color fromUser.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas zzfillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Color basicNew setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	Display forceToScreen
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Color basicNew setHue: h chroma: c luminance: selectedLuminance.
"		color _ Color basicNew setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Color black ].
"		color _ Color basicNew setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Color basicNew setHue: h chroma: selectedChroma luminance: v.
"		color _ Color basicNew setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Color black ].
"		color _ Color basicNew setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	Display forceToScreen
].! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 00:33' prior: 50383182!
                            fillRectangle: r color: fillColor
	| rect |
	rect _ r translatedBy: origin.
	"draw the border of the rectangle"

	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillRect: rect ]! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 00:33' prior: 50378970!
  zzframeAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor
	| rect |
	rect _ (currentTransformation displayBoundsOfTransformOf: r) translatedBy: origin.
	"draw the border of the rectangle"
	borderColor isTransparent ifFalse:[
		self setPaintColor: borderColor.
		port frameRect: rect borderWidth: borderWidth ].

	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillRect: (rect insetBy: borderWidth) ]! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/9/2012 00:30' prior: 50383405!
                     zzroundRect: aRectangle color: aColor radius: r
	"
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10
	"
	"radious is not scaled properly..."
	"top stripe"
	self
		zzimage: (FormCanvas topLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		zzimage: (FormCanvas topRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self zzfillRectangle: ((aRectangle withHeight: r) insetBy: r@0) color: aColor.

	"center stripe"
	self zzfillRectangle: (aRectangle insetBy: (0 @ r corner: 0 @ r)) color: aColor.
	
	"bottom stripe"
	self
		zzimage: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle bottomLeft - (0@r).
	self
		zzimage: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle bottomRight - (r@r) .
	self zzfillRectangle: ((aRectangle bottomLeft + (r@r negated)) extent: (aRectangle width - r - r@r)) color: aColor! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/9/2012 00:30' prior: 50383444!
                 zzroundRect: displayRectangle color: aColor radius: r gradientTop: topFactor gradientBottom: bottomFactor gradientHeight: h
	"
	Display restore.
	FormCanvas clearFormsCache. 
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10 gradientTop: 1.0 gradientBottom: 0.5 gradientHeight: 35
	"
	| bottomColor |
	"top stripe"
	self
		zzimage: (FormCanvas topLeftCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topLeft.
	self
		zzimage: (FormCanvas topRightCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topRight - (r@0).
	self
		zzfillRectangle: ((displayRectangle withHeight: h) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.
	"center stripe"
	self zzfillRectangle: (displayRectangle insetBy: (0 @ h corner: 0 @ r)) color: bottomColor.
	
	"bottom stripe"
	self
		zzimage: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomLeft - (0@r).
	self
		zzimage: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomRight - (r@r) .
	self zzfillRectangle: ((displayRectangle bottomLeft + (r@r negated)) extent: (displayRectangle width - r - r@r)) color: bottomColor! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/9/2012 00:31' prior: 50383496!
             zzwindowFrame: aRectangle color: aColor radius: r border: bw labelHeight: lh gradientTop: topFactor gradientBottom: bottomFactor insideColor: insideColor
	"
	Display getCanvas windowFrame: (10@10 extent: 200@100) color: Color red radius: 10  border: 5 labelHeight: 25 gradientTop: 1.0 gradientBottom: 0.5 insideColor: Color green
	"
	"top stripe"
	| bottomColor he tl tr |
	self
		zzimage: (FormCanvas topLeftCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		zzimage: (FormCanvas topRightCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self
		zzfillRectangle: ((aRectangle withHeight: lh) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.

	"left and right borders"
	tl _ aRectangle topLeft + (0@lh).
	tr _ aRectangle topRight + (bw negated@lh).
	he _ bw@(aRectangle height - lh - r).
	self zzfillRectangle: (tl extent: he) color: bottomColor.
	self zzfillRectangle: (tr extent: he) color: bottomColor.
	
	"bottom stripe"
	self
		zzimage: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: aRectangle bottomLeft - (0@r).
	self
		zzimage: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: aRectangle bottomRight - (r@r) .
	self zzfillRectangle: ((aRectangle bottomLeft + (r@bw negated)) extent: (aRectangle width - r - r@bw)) color: bottomColor.

	"inside"
	self zzfillRectangle: (aRectangle insetBy: (bw@lh corner: bw@bw)) color: insideColor! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 9/9/2012 00:22' prior: 16861330!
             setPaintColor: aColor
	"Install a new color used for filling."
	| paintColor screen patternWord |
	paintColor _ shadowColor ifNil: [ aColor ].
	paintColor ifNil: [ paintColor _ Color transparent].
	port sourceForm: nil.
	(paintColor isOpaque) ifTrue: [
		port fillPattern: paintColor.
		port combinationRule: Form paint.
		self depth = 8 ifTrue:[
			"In 8 bit depth it's usually a good idea to use a stipple pattern"
			port fillColor: (form balancedPatternFor: paintColor)].
		^self].

	self depth > 8 ifTrue:[
		"BitBlt setup for alpha mapped transfer"
		port fillPattern: paintColor.
		self depth = 16
			ifTrue:[port alphaBits: paintColor privateAlpha; combinationRule: 31]
			ifFalse:[port combinationRule: Form blend].
		^self].

	"Can't represent actual transparency -- use stipple pattern"
	screen _ Color translucentMaskFor: paintColor alpha depth: self depth.
	patternWord _ form pixelWordFor: paintColor.
	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).
	port combinationRule: Form paint! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:31' prior: 50378893!
            drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		zzfillRectangle: (0@0 extent: self morphExtent)
		color: self color! !
!BorderedRectMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:26' prior: 50381337!
                            drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		zzfillRectangle: (0@0 extent: extent)
		color: color
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:30' prior: 50381349!
                drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas zzframeAndFillRectangle: (0@0 extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			zzframeRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			zzimage: (FormCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: extent x - scrollbarThickness@0.
		aCanvas
			zzimage: (FormCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: 0@0 + extent - scrollbarThickness.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			zzfillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas zzfillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				zzdrawString: (completer entries at: index) asString
				in: rectangle
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:30' prior: 50381450!
   drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				zzroundRect: (0@0 extent: extent)
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		zzfillRectangle: (14@25 extent: extent-(28@62))
		color: (Theme current paneBackgroundFrom: color)! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:31' prior: 50381507!
              drawOn: aCanvas

	| tRect sRect colorToUse sLeft aForm centeringOffset |
	isSelected ifTrue: [
		aCanvas
			zzfillRectangle: (0@0 extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) ].

	complexContents hasContents ifTrue: [
		tRect _ self toggleRectangle.
		aForm _ isExpanded 
			ifTrue: [ container expandedForm ]
			ifFalse: [ container notExpandedForm ].
		centeringOffset _ ((tRect height - aForm extent y) / 2.0) rounded.
		aCanvas 
			zzimage: aForm 
			at: (tRect topLeft translatedBy: 0 @ centeringOffset) ].

	sLeft _ indentLevel * 12 + 16.
	sRect _ sLeft@0 extent: extent - (sLeft@0).
	colorToUse _ complexContents preferredColor ifNil: [ color ].
	aCanvas
		zzdrawString: contents asString
		in: sRect
		font: self fontToUse
		color: colorToUse! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:31' prior: 50380556!
       drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"
	selectionDrawBounds _ self drawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: (0@0 extent: extent).
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas zzfillRectangle: selectionDrawBounds color: c! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:31' prior: 50380576!
            drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (0@0 extent: extent).
	aCanvas
		zzfillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:26' prior: 50382141!
                  drawOn: aCanvas

	aCanvas
		zzfillRectangle: (0@0 extent: extent)
		color: color
		borderWidth: 2
		borderStyleSymbol: #raised
		baseColorForBorder: color! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:31' prior: 50382766!
                drawOn: aCanvas 
	| stringColor stringBounds leftEdge |

	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas zzfillRectangle: (0@0 extent: extent) color: Theme current menuHighlight].
	leftEdge _ 0.

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + submorphs first morphWidth + 8 ].

	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ].
			aCanvas zzimage: iconForm at: leftEdge+1 @ (extent y - iconForm height // 2).
			leftEdge _ leftEdge + iconForm width + self iconSeparation].

	stringBounds _  leftEdge @ 1 extent: extent.

	aCanvas
		zzdrawString: contents
		in: stringBounds
		font: self fontToUse
		color: stringColor.
	subMenu ifNotNil: [
		aCanvas
			zzimage: SubMenuMarker
			at: extent x - 8 @ (extent y - SubMenuMarker height // 2) ]! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 00:31' prior: 50383605!
         onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		zzframeAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) 
			borderWidth: 1 borderColor: Color black;
		zzfillRectangle: (form boundingBox insetBy: 2) color: Color black.
	^form! !
!MenuLineMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:31' prior: 50383620!
      drawOn: aCanvas 
	| baseColor r |
	baseColor _ owner color.
	r _ self morphBoundsInWorld.
	aCanvas
		zzfillRectangle: (r topLeft corner: r rightCenter)
		color: baseColor twiceDarker.
			
	aCanvas
		zzfillRectangle: (r leftCenter corner: r bottomRight)
		color: baseColor twiceLighter! !
!MenuMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:26' prior: 50381576!
                  drawOn: aCanvas
	
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas zzroundRect: (0@0 extent: extent) color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			aCanvas zzfillRectangle: (0@0 extent: extent) color: color borderWidth: borderWidth borderStyleSymbol: #raised baseColorForBorder: color ]! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:31' prior: 50380662!
                     drawSelectionOn: aCanvas
	| rightX leftX bottom |

	bottom _ self baseFont height.
	leftX _ self fontToUse widthOfString: contents from: 1 to: editor startIndex-1.
	rightX _ self fontToUse widthOfString: contents from: 1 to: editor stopIndex-1.

	aCanvas
		zzfillRectangle: (leftX @ 0 corner: rightX @ bottom)
		color: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:26' prior: 50382168!
         draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		zzfillRectangle: (0@0 extent: extent)
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !
!ProgressBarMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:31' prior: 50383707!
                       drawOn: aCanvas

	super drawOn: aCanvas.
	aCanvas
		zzfillRectangle: (borderWidth@borderWidth extent: extent x - borderWidth - borderWidth * value @ extent y - borderWidth-borderWidth)
		color: progressColor! !
!ScrollBar methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:27' prior: 50382245!
                               drawOn: aCanvas

	aCanvas
		zzfillRectangle: (0@0 extent: extent)
		color: (color alphaMixed: 0.3 with: Color white)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 9/9/2012 00:31' prior: 50381724!
                             drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas zzfillRectangle: (0@0 extent: extent) color: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	"A border was drawn at the left, top and right of the title area.
	The look is that the title area is inside the window"
	aCanvas zzfillRectangle: (borderWidth@borderWidth extent: extent x - (2*borderWidth)@ self labelHeight) color: titleColor! !

GrafPort removeSelector: #fillRect:offset:!

GrafPort removeSelector: #fillRect:offset:!

FormCanvas removeSelector: #zzfillRectangle:colorOrInfiniteForm:!

FormCanvas removeSelector: #zzfillRectangle:colorOrInfiniteForm:!

FormCanvas removeSelector: #zzfillRectangle:colorOrInfiniteForm:borderWidth:borderStyleSymbol:baseColorForBorder:!

FormCanvas removeSelector: #zzfillRectangle:colorOrInfiniteForm:borderWidth:borderStyleSymbol:baseColorForBorder:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1438-LocalCoordinates14JuanVuletich-2012Sep09-00h18m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1438] on 9 September 2012 at 12:43:38 am'!
!Form class methodsFor: 'fileIn/Out' stamp: 'jmv 9/9/2012 00:41' prior: 16860285!
      services
	"Currently, no services for bitmap graphic files
	(GIF, JPG, PNG, 'Form storeOn: (run coded)' and BMP)"
	^ #()! !

Form class removeSelector: #openAsBackground:!

Form class removeSelector: #openAsBackground:!

Form class removeSelector: #serviceImageAsBackground!

Form class removeSelector: #serviceImageAsBackground!

Form removeSelector: #setAsBackground!

Form removeSelector: #setAsBackground!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1439-RemoveOpenAsBackground-JuanVuletich-2012Sep09-00h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1439] on 9 September 2012 at 11:42:09 pm'!
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/9/2012 23:19'!
        zzstencil: stencilForm at: aPoint color: aColor
	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"
	^self zzstencil: stencilForm
		at: aPoint
		sourceRect: stencilForm boundingBox
		color: aColor! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/9/2012 23:20'!
                            zzstencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor
	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"
	| p |
	p _ currentTransformation transform: aPoint.
	self setPaintColor: aColor.
	port colorMap: stencilForm maskingMap.
	port stencil: stencilForm
		at: p + origin
		sourceRect: sourceRect.! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 23:02'!
        zzdrawString: aString from: firstIndex to: lastIndex at: aPoint font: font color: c kern: kern

	| p1 |
	p1 _ currentTransformation transform: aPoint.
	port colorMap: nil.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (origin + p1)
		strikeFont: font
		kern: kern! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 22:50'!
              zzparagraph: aParagraph bounds: boundsRect color: c selectionColor: sc
	| displayScanner leftInRun line boundsInWorld tl |

	tl _ boundsRect topLeft.
	boundsInWorld _ currentTransformation displayBoundsOfTransformOf: boundsRect.
	self setPaintColor: c.

	displayScanner _ MorphicScanner new 
		text: aParagraph paragraphText
		foreground: (shadowColor ifNil: [ c ])
		ignoreColorChanges: self isShadowDrawing.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	(aParagraph lineIndexForPoint: (0@0 max: clipRect origin- boundsInWorld origin))
		to: (aParagraph lineIndexForPoint: (boundsInWorld extent min: clipRect corner - boundsInWorld origin))
		do: [ :i |
			line _ aParagraph lines at: i.
			aParagraph
				zzdisplaySelectionInLine: line
				on: self
				paragraphTopLeft: tl
				selectionColor: sc.
			leftInRun _ displayScanner zzdisplayLine: line paragraphTopLeft: tl leftInRun: leftInRun  ]! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:37'!
                             zzshadowForm
	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"
	| bnds canvas |
	bnds _ Rectangle merging: (submorphs collect: [:m | m morphFullBoundsInWorld]).
	canvas _ Display defaultCanvasClass forShadowOver: bnds.
	canvas into: self.
	self drawSubmorphsOn: canvas.
	^ canvas form offset: bnds topLeft - self morphPositionInWorld! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/9/2012 23:10'!
                   zzdisplayBulletIfAppropriateFor: textLine paragraphTopLeft: paragraphTopLeft
	"paragraphTopLeft is relative to the morph currently being drawn"

	| paragraphEnd count pattern |
	paragraphStyle ifNotNil: [
		(textLine isFirstLine and: [ paragraphStyle isListStyle ]) ifTrue: [
			pattern _ paragraphStyle listBulletPattern.
			"Count how many paragraphs before this one already used the pattern"
			count _ 0.
			paragraphEnd _ textLine first-1.
			[
			paragraphEnd > 0 and: [ ((text paragraphStyleOrNilAt: paragraphEnd) ifNotNil: [ :ps | ps listBulletPattern ]) = pattern ]] whileTrue: [
				count _ count + 1.
				paragraphEnd _ text string endOfParagraphBefore: paragraphEnd ].
			"Our number in the list, is one more than the count of previous contiguous paragraphs with this pattern"
			self
				zzdisplayBulletParagraphTopLeft: paragraphTopLeft
				number: count + 1]]! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/9/2012 23:10'!
              zzdisplayBulletParagraphTopLeft: paragraphTopLeft number: bulletNumber
	"paragraphTopLeft is relative to the morph currently being drawn"

	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern _ paragraphStyle listBulletPattern.
	bullet _ pattern.
	(i _ pattern indexOf: $%) > 0
		ifTrue: [ bullet _ bulletNumber asString]
		ifFalse: [
			(i _ pattern indexOf: $z) > 0
				ifTrue: [ bullet _ (Character value: 96 + bulletNumber) asString ]
				ifFalse: [
					(i _ pattern indexOf: $Z) > 0
						ifTrue: [ bullet _ (Character value: 64 + bulletNumber) asString ]]].
	prefix _ 0.
	i > 0 ifTrue: [
		c _ pattern at: i.
		j _ i.
		s _ pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].
		j _ j - 1.
		bulletSize _ j-i+1.
		prefix _ bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos _ paragraphStyle firstIndent + paragraphTopLeft x + ((font widthOf: $9) * prefix)@destY.
	canvas
		zzdrawString: bullet
		from: 1
		to: bullet size
		at: bulletPos
		font: font
		color: foregroundColor
		kern: kern! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/9/2012 23:14'!
   zzdisplayLine: textLine paragraphTopLeft: paragraphTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"paragraphTopLeft is relative to the morph currently being drawn"
	| done stopCondition nowLeftInRun startIndex string lastPos priorFont |

	paraTopLeft _ paragraphTopLeft.
	line _ textLine.
	lineY _ line top + paragraphTopLeft y.
	lineHeight _ line lineHeight.
	rightMargin _ line rightMargin + paragraphTopLeft x.
	lastIndex _ line first.
	leftInRun <= 0 ifTrue: [self setStopConditions].
	leftMargin _ (line leftMarginForAlignment: alignment) + paragraphTopLeft x.
	destX _ runX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				""
				foregroundColor _ paragraphColor.
				priorFont _ font.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				priorFont ifNotNil: [ destX _ destX + priorFont descentKern ].
				destX _ destX - font descentKern.
				kern _ 0 - font baseKern.
				spaceWidth _ font widthOf: Character space.
				xTable _ font xTable.
				map _ font characterToGlyphMap.
				stopConditions _ DefaultStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]
				""
			]
		].
		self zzdisplayBulletIfAppropriateFor: textLine paragraphTopLeft: paragraphTopLeft.
		^leftInRun ].

	self zzdisplayBulletIfAppropriateFor: textLine paragraphTopLeft: paragraphTopLeft.

	lastIndex _ line first.
	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	done _ false.
	string _ text string.

	self placeEmbeddedObject.
	[ done ] whileFalse: [
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions
			kern: kern.
		lastIndex >= startIndex ifTrue: [
			canvas  
				zzdrawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor
				kern: kern ].
		"see setStopConditions for stopping conditions for displaying."
		done _ self perform: stopCondition ].
	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !
!Paragraph methodsFor: 'display' stamp: 'jmv 9/9/2012 22:54'!
                  zzdisplayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas paragraphLeft: paragraphLeft
	"x, top, bottom, paragraphLeft are relative to the morph currently being drawn."

	| caretColor x1 isBold isItalic x0 h w halfW r d |
	isBold _ emphasis allMask: 1.
	isItalic _ emphasis allMask: 2.
	caretColor _ Theme current insertionPoint.
	h _ bottom - top.
	w _ isBold
		ifTrue: [ h // 25 + 2 ]
		ifFalse: [ h // 30 + 1 ].
	halfW _ w // 2.
	isItalic
		ifTrue: [	
			"Keep tweaking if needed!! For italics with descenders (i.e. p), cursor shows a bit to the left..."
			d _ isBold ifTrue: [ h // 8 ] ifFalse: [ h // 9].
			x0 _ x- (h*5//24) + d.
			x1 _ x + d ]
		ifFalse: [
			x0 _ x.
			x1 _ x].
	x0-paragraphLeft < halfW ifTrue: [
		x1 _ x1 - x0 + halfW+paragraphLeft.
		x0 _ halfW+paragraphLeft ].
	r _ extentForComposing x-halfW-1.
	r < (x1-paragraphLeft) ifTrue: [
		x0 _ x0 + r - x1+paragraphLeft.
		x1 _ r +paragraphLeft].

	lastCaretRect _ x0-halfW@ top corner: x1+halfW+1 @ (bottom+1).
	aCanvas
		zzline: x0@(bottom-halfW) to: x1@(top+halfW)
		width: w color: caretColor! !
!Paragraph methodsFor: 'display' stamp: 'jmv 9/9/2012 22:51'!
                     zzdisplaySelectionInLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft  selectionColor: sc

	"paragraphTopLeft is relative to the morph currently being drawn"
	selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |
		self
			zzdisplaySelectionStartBlock: startBlock
			stopBlock: stopBlock
			InLine: line
			on: aCanvas
			paragraphTopLeft: paragraphTopLeft
			selectionColor: sc ]! !
!Paragraph methodsFor: 'display' stamp: 'jmv 9/9/2012 22:53'!
  zzdisplaySelectionStartBlock: startBlock stopBlock: stopBlock InLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft  selectionColor: sc
	"paragraphTopLeft is relative to the morph currently being drawn"

	| leftX rightX idx caretFont t b caretAttributes |

	startBlock ifNil: [^self].	"No selection"
	startBlock = stopBlock 
		ifTrue: [
			"Only show caret on line where clicked"
			startBlock textLine first = line first ifFalse: [
				^self ].
			leftX _ paragraphTopLeft x + startBlock left.
			idx _ startBlock stringIndex.
			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].
			caretFont _ caretAttributes
				ifNil: [ model actualContents fontAt: idx ]
				ifNotNil: [ model actualContents fontIfApplying: caretAttributes ].
			b _ paragraphTopLeft y + line top + line baseline + caretFont descent-1.
			t _ paragraphTopLeft y + line top + line baseline - caretFont ascent.
			showCaret ifTrue: [
				self
					zzdisplayInsertionMarkAtX: leftX
					top: t
					bottom: b
					emphasis: caretFont emphasis
					on: aCanvas
					paragraphLeft: paragraphTopLeft x ]]
		ifFalse: [
			"Test entire selection before or after here"
			(stopBlock stringIndex < line first 
				or: [startBlock stringIndex > (line last + 1)])
					ifTrue: [^self].	"No selection on this line"
			(stopBlock stringIndex = line first 
				and: [stopBlock textLine ~= line])
					ifTrue: [^self].	"Selection ends on line above"
			(startBlock stringIndex = (line last + 1) 
				and: [stopBlock textLine ~= line])
					ifTrue: [^self].
			lastCaretRect _ nil.
			leftX _  paragraphTopLeft x + (startBlock stringIndex < line first 
				ifTrue: [ line ]
				ifFalse: [ startBlock ]) left.
			rightX _  paragraphTopLeft x + ((stopBlock stringIndex > (line last + 1) or: [
					stopBlock stringIndex = (line last + 1) 
						and: [stopBlock textLine ~= line]]) 
				ifTrue: [line right]
				ifFalse: [stopBlock left]).
			aCanvas
				zzfillRectangle: (leftX @ (line top +  paragraphTopLeft y) corner: rightX @ (line bottom +  paragraphTopLeft y))
				color: sc ].	"Selection begins on line below"! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/9/2012 23:21' prior: 50383144!
                            zzimage: aForm at: aPoint sourceRect: sourceRect
	"Draw a translucent image using the best available way of representing translucency.
	Note: This will be fixed in the future."
	| r p |
	p _ currentTransformation transform: aPoint.
	self isShadowDrawing ifTrue: [
		^self zzstencil: aForm at: aPoint sourceRect: sourceRect color: shadowColor ].
	r _ (self depth < 32 or: [ aForm mightBeTranslucent not]) 
		ifTrue: [
			"Rule Form paint treats pixels with a value of zero as transparent"
			Form paint]
		ifFalse: [ Form blend ].
	self image: aForm
		at: p rounded
		sourceRect: sourceRect
		rule: r! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:21' prior: 50376247!
                       drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		zzstencil: Cursor move
		at: 0@0
		color: Color black! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:38' prior: 16864813!
            nonCachingFullDrawOn: aCanvas
	| shadowForm |
	"A HandMorph has unusual drawing requirements:
		1. the hand itself (i.e., the cursor) appears in front of its submorphs
		2. morphs being held by the hand cast a shadow on the world/morphs below
	The illusion is that the hand plucks up morphs and carries them above the world."
	"Note: This version does not cache an image of the morphs being held by the hand.
	 Thus, it is slower for complex morphs, but consumes less space."

	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"

	"Note: We use a shadow form here to prevent drawing
	overlapping morphs multiple times using the transparent
	shadow color."
	shadowForm _ self zzshadowForm.

	"draw shadows"
	aCanvas zzstencil: shadowForm at: shadowForm offset  + self shadowOffset color: (Color black alpha: 0.5).
	
	"draw morphs in front of shadows"
	self drawSubmorphsOn: aCanvas.
	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:04' prior: 50382108!
                        drawOn: aCanvas

	| r |
	r _ 0@0 extent: extent.
	aCanvas zzroundRect: r color: self color radius: 4.
	aCanvas
		zzparagraph: paragraph
		bounds: (r insetBy: 4)
		color: Color black
		selectionColor: (Theme current textHighlightFocused: false)! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:04' prior: 50382128!
                      drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		zzparagraph: self paragraph
		bounds: (0@0 extent: extent)
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/9/2012 23:08' prior: 16870454!
                    onBlinkCursor
	"Blink the cursor"
	paragraph ifNil: [ ^nil ].
	paragraph showCaret: paragraph showCaret not | pauseBlinking.
	pauseBlinking _ false.
	paragraph lastCaretRect ifNotNil: [ :r | self zzinvalidRect: r].! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/9/2012 23:13' prior: 50351512!
                  placeEmbeddedObject: anchoredFormOrMorph

	"This method should be redone calling reasonable protocol on the canvas"
	self flag: #jmvVer2.

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph morphWidth)@
				(lineY+ line baseline - anchoredFormOrMorph morphHeight)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph width @ (destY + line baseline - anchoredFormOrMorph height)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!String methodsFor: 'displaying' stamp: 'jmv 9/9/2012 23:16' prior: 16956444!
                         displayOn: aDisplayMedium at: aPoint textColor: aColor
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color"

	aDisplayMedium getCanvas zzdrawString: self at: aPoint font: nil color: aColor! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/9/2012 23:16' prior: 50350088!
                  displayOn: aForm
	"
	Transcript displayOn: Display
	"
	| font count i string x y fh f bw r canvas |
	bw _ self borderWidth  .
	r _ innerRectangle outsetBy: bw + self padding.
	aForm border: r width: bw. 
	aForm fill: r fillColor: Color white.
	font _ StrikeFont default.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.
	y _ innerRectangle top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	canvas _ aForm getCanvas.
	canvas setOrigin: 0@0 clipRect: innerRectangle.
	[
		string _ entries at: i.	
		canvas zzdrawString: string at: x@y font: font color: Color veryDarkGray.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.
	canvas zzdrawString: string at: x@y font: font color: Color veryDarkGray! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/9/2012 23:16' prior: 50350123!
          displayUnfinishedEntryOn: aForm

	| font count string x y fh canvas |
	font _ StrikeFont default.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.

	string _ unfinishedEntry contents.
	y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerRectangle top.
	canvas _ aForm getCanvas.
	canvas setOrigin: 0@0 clipRect: innerRectangle.
	canvas zzdrawString: string at: x@y font: font color: Color veryDarkGray! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 9/9/2012 23:04' prior: 50380873!
              endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	para
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	para composeAll.
	d _ para extent y - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ para characterBlockAtPoint:
			0@0 + (0@(d+StrikeFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		zzparagraph: para
		bounds: (4@4 + frame topLeft extent: Display extent)
		color: Color black
		selectionColor: Color blue! !

Paragraph removeSelector: #displayInsertionMarkAtX:top:bottom:emphasis:on:paragraphLeft:!

Paragraph removeSelector: #displaySelectionInLine:on:paragraphTopLeft:selectionColor:!

Paragraph removeSelector: #displaySelectionInLine:on:paragraphTopLeft:selectionColor:!

Paragraph removeSelector: #displaySelectionStartBlock:stopBlock:InLine:on:paragraphTopLeft:selectionColor:!

Paragraph removeSelector: #displaySelectionStartBlock:stopBlock:InLine:on:paragraphTopLeft:selectionColor:!

MorphicScanner removeSelector: #displayBulletIfAppropriateFor:paragraphTopLeft:!

MorphicScanner removeSelector: #displayBulletIfAppropriateFor:paragraphTopLeft:!

MorphicScanner removeSelector: #displayBulletParagraphTopLeft:number:!

MorphicScanner removeSelector: #displayBulletParagraphTopLeft:number:!

MorphicScanner removeSelector: #displayLine:paragraphTopLeft:leftInRun:!

MorphicScanner removeSelector: #displayLine:paragraphTopLeft:leftInRun:!

HandMorph removeSelector: #shadowForm!

HandMorph removeSelector: #shadowForm!

Morph removeSelector: #shadowForm!

Morph removeSelector: #shadowForm!

Morph removeSelector: #zzshadowForm!

FormCanvas removeSelector: #drawString:at:font:color:!

FormCanvas removeSelector: #drawString:at:font:color:!

FormCanvas removeSelector: #drawString:from:to:at:font:color:!

FormCanvas removeSelector: #drawString:from:to:at:font:color:!

FormCanvas removeSelector: #drawString:from:to:at:font:color:kern:!

FormCanvas removeSelector: #fillRectangle:color:!

FormCanvas removeSelector: #fillRectangle:color:!

FormCanvas removeSelector: #line:to:width:color:!

FormCanvas removeSelector: #line:to:width:color:!

FormCanvas removeSelector: #paragraph:bounds:color:selectionColor:!

FormCanvas removeSelector: #paragraph:bounds:color:selectionColor:!

FormCanvas removeSelector: #stencil:at:color:!

FormCanvas removeSelector: #stencil:at:color:!

FormCanvas removeSelector: #stencil:at:sourceRect:color:!

FormCanvas removeSelector: #stencil:at:sourceRect:color:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1440-LocalCoordinates15-JuanVuletich-2012Sep09-22h45m-jmv.7.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1439] on 10 September 2012 at 12:02:57 am'!
!FormCanvas methodsFor: 'drawing' stamp: 'jmv 9/10/2012 00:00'!
    line: pt1 to: pt2 width: w color: c
	| offset p1 p2 |
	p1 _ currentTransformation transform: pt1.
	p2 _ currentTransformation transform: pt2.
	offset _ origin - (w // 2) asPoint.
	self setPaintColor: c.
	port
		width: w;
		height: w;
		drawFrom: (p1 rounded + offset) to: (p2 rounded + offset)! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/9/2012 23:58'!
                 image: aForm at: aPoint
	"Draw a translucent image using the best available way of representing translucency."

	self image: aForm
		at: aPoint
		sourceRect: aForm boundingBox! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/9/2012 23:59'!
       image: aForm at: aPoint sourceRect: sourceRect
	"Draw a translucent image using the best available way of representing translucency.
	Note: This will be fixed in the future."
	| r p |
	p _ currentTransformation transform: aPoint.
	self isShadowDrawing ifTrue: [
		^self stencil: aForm at: aPoint sourceRect: sourceRect color: shadowColor ].
	r _ (self depth < 32 or: [ aForm mightBeTranslucent not]) 
		ifTrue: [
			"Rule Form paint treats pixels with a value of zero as transparent"
			Form paint]
		ifFalse: [ Form blend ].
	self image: aForm
		at: p rounded
		sourceRect: sourceRect
		rule: r! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/9/2012 23:58'!
   image: aForm multipliedBy: aColor at: aPoint
	"Multiply aForm and aColor, then blend over destination.
	aForm is a kind of advanced stencil, supplying brightness and opacity at each pixel

	Display getCanvas image: (SystemWindow roundedCornerTR: 20)multipliedBy: Color red at: 20@20
	"
	AccessProtect critical: [
		self buildAuxWith: aForm multipliedWith: aColor.
		self image: AuxForm at: aPoint sourceRect: aForm boundingBox ]! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/9/2012 23:59'!
          stencil: stencilForm at: aPoint color: aColor
	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"
	^self stencil: stencilForm
		at: aPoint
		sourceRect: stencilForm boundingBox
		color: aColor! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/9/2012 23:59'!
stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor
	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"
	| p |
	p _ currentTransformation transform: aPoint.
	self setPaintColor: aColor.
	port colorMap: stencilForm maskingMap.
	port stencil: stencilForm
		at: p + origin
		sourceRect: sourceRect.! !
!FormCanvas methodsFor: 'drawing-ovals' stamp: 'jmv 9/9/2012 23:56'!
         fillOval: r color: fillColor borderWidth: borderWidth borderColor: borderColor

	| rect displayRectangle |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: r.
	"draw the border of the oval"
	rect _ (displayRectangle translatedBy: origin) truncated.
	(borderWidth = 0 or: [borderColor isTransparent]) ifFalse:[
		self setPaintColor: borderColor.
		port frameOval: rect borderWidth: borderWidth].
	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillOval: (rect insetBy: borderWidth)].
! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 23:55'!
           fillRectangle: aRectangle color: aColor
	"Fill the given rectangle."

	| color |

	color _ aColor.
	self isShadowDrawing ifTrue: [
		color _ shadowColor ].

	^self 
		frameAndFillRectangle: aRectangle
		fillColor: color
		borderWidth: 0
		borderColor: Color transparent! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 23:56'!
     fillRectangle: aRectangle color: aColor borderWidth: borderWidth borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder

	self fillRectangle: (aRectangle insetBy: borderWidth) color: aColor.
	self frameRectangle: aRectangle color: baseColorForBorder borderWidth: borderWidth borderStyleSymbol: aSymbol! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 23:54'!
                          fillRectangle: aRectangle infiniteForm: anInfiniteForm multipliedBy: aColor
	"Fill aRectangle with the equivalent of anInfiniteForm multiplied by aColor
	aForm is a kind of advanced stencil, supplying brightness and opacity at each pixel
	Similar to #image:multipliedBy:at:


	Display getCanvas fillRectangle: (10@10 extent: 100@100) infiniteForm: (SystemWindow titleGradient: 12) multipliedBy: Color red.
	"

	| f displayRectangle |
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	f _ anInfiniteForm form.
	AccessProtect critical: [
		self buildAuxWith: f multipliedWith: aColor.
		self fillRectangle: displayRectangle tilingWith: AuxForm sourceRect: f boundingBox rule: Form paint ]! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 23:55'!
   frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor
	| rect |
	rect _ (currentTransformation displayBoundsOfTransformOf: r) translatedBy: origin.
	"draw the border of the rectangle"
	borderColor isTransparent ifFalse:[
		self setPaintColor: borderColor.
		port frameRect: rect borderWidth: borderWidth ].

	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillRect: (rect insetBy: borderWidth) ]! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 23:55'!
              frameRectangle: r borderWidth: borderWidth color: borderColor
	"
	Display getCanvas
		frameRectangle: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red
	"
	| rect |
	rect _ (currentTransformation displayBoundsOfTransformOf: r) translatedBy: origin.
	self setPaintColor: borderColor.
	port
		frameRect: rect
		borderWidth: borderWidth.! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/9/2012 23:56'!
                         frameRectangle: r color: aColor borderWidth: borderWidth borderStyleSymbol: aSymbol
	"
	Display getCanvas zzfillRectangle: (10@10 extent: 300@200) colorOrInfiniteForm: Color white.
	Display getCanvas
		zzframeRectangle: (10@10 extent: 300@200)
		color: Color green
		borderWidth: 2
		borderStyleSymbol: #raised.
	"

	| displayRectangle bw |
		bw _ (currentTransformation externalizeScalar: borderWidth) rounded.
	aSymbol == #raised ifTrue: [
		displayRectangle _ currentTransformation displayBoundsOfTransformOf: r.
		^ self
			frameRectangle: displayRectangle
			borderWidth: bw
			topLeftColor: aColor quiteWhiter
			bottomRightColor: aColor quiteBlacker ].

	aSymbol == #inset ifTrue: [
		displayRectangle _ currentTransformation displayBoundsOfTransformOf: r.
		^ self
			frameRectangle: displayRectangle
			borderWidth: bw
			topLeftColor: aColor quiteBlacker
			bottomRightColor: aColor quiteWhiter ].
	
	"Unrecognized border style. Draw some border..."
	self frameRectangle: r borderWidth: bw color: aColor! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/9/2012 23:58'!
                      roundRect: aRectangle color: aColor radius: r
	"
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10
	"
	"radious is not scaled properly..."
	"top stripe"
	self
		image: (FormCanvas topLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		image: (FormCanvas topRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self fillRectangle: ((aRectangle withHeight: r) insetBy: r@0) color: aColor.

	"center stripe"
	self fillRectangle: (aRectangle insetBy: (0 @ r corner: 0 @ r)) color: aColor.
	
	"bottom stripe"
	self
		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle bottomLeft - (0@r).
	self
		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: aColor
		at: aRectangle bottomRight - (r@r) .
	self fillRectangle: ((aRectangle bottomLeft + (r@r negated)) extent: (aRectangle width - r - r@r)) color: aColor! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/9/2012 23:59'!
                 roundRect: displayRectangle color: aColor radius: r gradientTop: topFactor gradientBottom: bottomFactor gradientHeight: h
	"
	Display restore.
	FormCanvas clearFormsCache. 
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10 gradientTop: 1.0 gradientBottom: 0.5 gradientHeight: 35
	"
	| bottomColor |
	"top stripe"
	self
		image: (FormCanvas topLeftCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topLeft.
	self
		image: (FormCanvas topRightCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: displayRectangle topRight - (r@0).
	self
		fillRectangle: ((displayRectangle withHeight: h) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: h gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.
	"center stripe"
	self fillRectangle: (displayRectangle insetBy: (0 @ h corner: 0 @ r)) color: bottomColor.
	
	"bottom stripe"
	self
		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomLeft - (0@r).
	self
		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: displayRectangle bottomRight - (r@r) .
	self fillRectangle: ((displayRectangle bottomLeft + (r@r negated)) extent: (displayRectangle width - r - r@r)) color: bottomColor! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/9/2012 23:59'!
             roundRect: aRectangle color: aColor radius: r gradientTop: topFactor gradientCenter: centerFactor gradientBottom: bottomFactor gradient1Height: h1
	"
	Display restore.
	FormCanvas clearFormsCache. 
	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10 gradientTop: 1.0 gradientCenter: 0.0 gradientBottom: 1.0 gradient1Height: 35
	"
	| h2 |
	"top stripe"
	self
		image: (FormCanvas topLeftCorner: r height: h1 gradientTop: topFactor gradientBottom: centerFactor)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		image: (FormCanvas topRightCorner: r height: h1 gradientTop: topFactor gradientBottom: centerFactor)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self
		fillRectangle: ((aRectangle withHeight: h1) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: h1 gradientTop: topFactor gradientBottom: centerFactor)
		multipliedBy: aColor.
	
	"bottom stripe"
	h2 _ aRectangle height - h1.
	self
		image: (FormCanvas bottomLeftCorner: r height: h2 gradientTop: centerFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topLeft + (0@h1).
	self
		image: (FormCanvas bottomRightCorner: r height: h2 gradientTop: centerFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topRight + (r negated@h1).
	self
		fillRectangle: ((aRectangle topLeft + (r@h1)) extent: (aRectangle width-r-r@h2))
		infiniteForm: (FormCanvas verticalGrayGradient: h2 gradientTop: centerFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.! !
!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 9/9/2012 23:59'!
                     windowFrame: aRectangle color: aColor radius: r border: bw labelHeight: lh gradientTop: topFactor gradientBottom: bottomFactor insideColor: insideColor
	"
	Display getCanvas windowFrame: (10@10 extent: 200@100) color: Color red radius: 10  border: 5 labelHeight: 25 gradientTop: 1.0 gradientBottom: 0.5 insideColor: Color green
	"
	"top stripe"
	| bottomColor he tl tr |
	self
		image: (FormCanvas topLeftCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		image: (FormCanvas topRightCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self
		fillRectangle: ((aRectangle withHeight: lh) insetBy: r@0)
		infiniteForm: (FormCanvas verticalGrayGradient: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.

	"left and right borders"
	tl _ aRectangle topLeft + (0@lh).
	tr _ aRectangle topRight + (bw negated@lh).
	he _ bw@(aRectangle height - lh - r).
	self fillRectangle: (tl extent: he) color: bottomColor.
	self fillRectangle: (tr extent: he) color: bottomColor.
	
	"bottom stripe"
	self
		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: aRectangle bottomLeft - (0@r).
	self
		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)
		multipliedBy: bottomColor
		at: aRectangle bottomRight - (r@r) .
	self fillRectangle: ((aRectangle bottomLeft + (r@bw negated)) extent: (aRectangle width - r - r@bw)) color: bottomColor.

	"inside"
	self fillRectangle: (aRectangle insetBy: (bw@lh corner: bw@bw)) color: insideColor! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 23:45'!
            drawString: s at: pt font: aFont color: aColor

	^ self drawString: s from: 1 to: s size at: pt font: aFont color: aColor! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 23:45'!
                               drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c
	| font p1 |
	p1 _ currentTransformation transform: aPoint.
	port colorMap: nil.
	font _ fontOrNil ifNil: [StrikeFont default].
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (origin + p1)
		strikeFont: font
		kern: font baseKern negated! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 23:47'!
                  drawString: aString from: firstIndex to: lastIndex at: aPoint font: font color: c kern: kern

	| p1 |
	p1 _ currentTransformation transform: aPoint.
	port colorMap: nil.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (origin + p1)
		strikeFont: font
		kern: kern! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 23:47'!
                drawString: aString from: firstIndex to: lastIndex in: aRectangle font: fontOrNil color: c
	| font portRect bounds |
	bounds _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [port clipRect: portRect. ^self].
	port clipWidth = 0 ifTrue: [port clipRect: portRect. ^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin)
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 23:47'!
                 drawString: s in: boundsRect font: fontOrNil color: c
	^self drawString: s from: 1 to: s size in: boundsRect font: fontOrNil color: c! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 23:48'!
                   drawStringEmbossed: aString from: firstIndex to: lastIndex in: aRectangle font: fontOrNil color: aColor
	| font portRect insideColor bounds |
	bounds _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	insideColor _ shadowColor ifNil: [ aColor ].
	insideColor = Color black ifFalse: [ | topColor |
		topColor _ insideColor alphaMixed: 0.25 with: Color black.
		port installStrikeFont: font foregroundColor: topColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin)
			strikeFont: font
			kern: font baseKern negated ].
	insideColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ insideColor alphaMixed: 0.22 with: Color white.
		port installStrikeFont: font foregroundColor: bottomColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin + (0@2))
			strikeFont: font
			kern: font baseKern negated ].
	port installStrikeFont: font foregroundColor: insideColor.
	port
		displayString: aString asString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin + (0@1))
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 23:48'!
         drawStringEmbossed: s in: boundsRect font: fontOrNil color: c
	^self drawStringEmbossed: s from: 1 to: s size in: boundsRect font: fontOrNil color: c! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/9/2012 23:49'!
   paragraph: aParagraph bounds: boundsRect color: c selectionColor: sc
	| displayScanner leftInRun line boundsInWorld tl |

	tl _ boundsRect topLeft.
	boundsInWorld _ currentTransformation displayBoundsOfTransformOf: boundsRect.
	self setPaintColor: c.

	displayScanner _ MorphicScanner new 
		text: aParagraph paragraphText
		foreground: (shadowColor ifNil: [ c ])
		ignoreColorChanges: self isShadowDrawing.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	(aParagraph lineIndexForPoint: (0@0 max: clipRect origin- boundsInWorld origin))
		to: (aParagraph lineIndexForPoint: (boundsInWorld extent min: clipRect corner - boundsInWorld origin))
		do: [ :i |
			line _ aParagraph lines at: i.
			aParagraph
				displaySelectionInLine: line
				on: self
				paragraphTopLeft: tl
				selectionColor: sc.
			leftInRun _ displayScanner displayLine: line paragraphTopLeft: tl leftInRun: leftInRun  ]! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/10/2012 00:00'!
  shadowForm
	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"
	| bnds canvas |
	bnds _ Rectangle merging: (submorphs collect: [:m | m morphFullBoundsInWorld]).
	canvas _ Display defaultCanvasClass forShadowOver: bnds.
	canvas into: self.
	self drawSubmorphsOn: canvas.
	^ canvas form offset: bnds topLeft - self morphPositionInWorld! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/9/2012 23:43'!
                     displayBulletIfAppropriateFor: textLine paragraphTopLeft: paragraphTopLeft
	"paragraphTopLeft is relative to the morph currently being drawn"

	| paragraphEnd count pattern |
	paragraphStyle ifNotNil: [
		(textLine isFirstLine and: [ paragraphStyle isListStyle ]) ifTrue: [
			pattern _ paragraphStyle listBulletPattern.
			"Count how many paragraphs before this one already used the pattern"
			count _ 0.
			paragraphEnd _ textLine first-1.
			[
			paragraphEnd > 0 and: [ ((text paragraphStyleOrNilAt: paragraphEnd) ifNotNil: [ :ps | ps listBulletPattern ]) = pattern ]] whileTrue: [
				count _ count + 1.
				paragraphEnd _ text string endOfParagraphBefore: paragraphEnd ].
			"Our number in the list, is one more than the count of previous contiguous paragraphs with this pattern"
			self
				displayBulletParagraphTopLeft: paragraphTopLeft
				number: count + 1]]! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/9/2012 23:47'!
                  displayBulletParagraphTopLeft: paragraphTopLeft number: bulletNumber
	"paragraphTopLeft is relative to the morph currently being drawn"

	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern _ paragraphStyle listBulletPattern.
	bullet _ pattern.
	(i _ pattern indexOf: $%) > 0
		ifTrue: [ bullet _ bulletNumber asString]
		ifFalse: [
			(i _ pattern indexOf: $z) > 0
				ifTrue: [ bullet _ (Character value: 96 + bulletNumber) asString ]
				ifFalse: [
					(i _ pattern indexOf: $Z) > 0
						ifTrue: [ bullet _ (Character value: 64 + bulletNumber) asString ]]].
	prefix _ 0.
	i > 0 ifTrue: [
		c _ pattern at: i.
		j _ i.
		s _ pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].
		j _ j - 1.
		bulletSize _ j-i+1.
		prefix _ bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos _ paragraphStyle firstIndent + paragraphTopLeft x + ((font widthOf: $9) * prefix)@destY.
	canvas
		drawString: bullet
		from: 1
		to: bullet size
		at: bulletPos
		font: font
		color: foregroundColor
		kern: kern! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/9/2012 23:47'!
       displayLine: textLine paragraphTopLeft: paragraphTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"paragraphTopLeft is relative to the morph currently being drawn"
	| done stopCondition nowLeftInRun startIndex string lastPos priorFont |

	paraTopLeft _ paragraphTopLeft.
	line _ textLine.
	lineY _ line top + paragraphTopLeft y.
	lineHeight _ line lineHeight.
	rightMargin _ line rightMargin + paragraphTopLeft x.
	lastIndex _ line first.
	leftInRun <= 0 ifTrue: [self setStopConditions].
	leftMargin _ (line leftMarginForAlignment: alignment) + paragraphTopLeft x.
	destX _ runX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				""
				foregroundColor _ paragraphColor.
				priorFont _ font.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				priorFont ifNotNil: [ destX _ destX + priorFont descentKern ].
				destX _ destX - font descentKern.
				kern _ 0 - font baseKern.
				spaceWidth _ font widthOf: Character space.
				xTable _ font xTable.
				map _ font characterToGlyphMap.
				stopConditions _ DefaultStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]
				""
			]
		].
		self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paragraphTopLeft.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paragraphTopLeft.

	lastIndex _ line first.
	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	done _ false.
	string _ text string.

	self placeEmbeddedObject.
	[ done ] whileFalse: [
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions
			kern: kern.
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor
				kern: kern ].
		"see setStopConditions for stopping conditions for displaying."
		done _ self perform: stopCondition ].
	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !
!Paragraph methodsFor: 'display' stamp: 'jmv 9/10/2012 00:00'!
                         displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas paragraphLeft: paragraphLeft
	"x, top, bottom, paragraphLeft are relative to the morph currently being drawn."

	| caretColor x1 isBold isItalic x0 h w halfW r d |
	isBold _ emphasis allMask: 1.
	isItalic _ emphasis allMask: 2.
	caretColor _ Theme current insertionPoint.
	h _ bottom - top.
	w _ isBold
		ifTrue: [ h // 25 + 2 ]
		ifFalse: [ h // 30 + 1 ].
	halfW _ w // 2.
	isItalic
		ifTrue: [	
			"Keep tweaking if needed!! For italics with descenders (i.e. p), cursor shows a bit to the left..."
			d _ isBold ifTrue: [ h // 8 ] ifFalse: [ h // 9].
			x0 _ x- (h*5//24) + d.
			x1 _ x + d ]
		ifFalse: [
			x0 _ x.
			x1 _ x].
	x0-paragraphLeft < halfW ifTrue: [
		x1 _ x1 - x0 + halfW+paragraphLeft.
		x0 _ halfW+paragraphLeft ].
	r _ extentForComposing x-halfW-1.
	r < (x1-paragraphLeft) ifTrue: [
		x0 _ x0 + r - x1+paragraphLeft.
		x1 _ r +paragraphLeft].

	lastCaretRect _ x0-halfW@ top corner: x1+halfW+1 @ (bottom+1).
	aCanvas
		line: x0@(bottom-halfW) to: x1@(top+halfW)
		width: w color: caretColor! !
!Paragraph methodsFor: 'display' stamp: 'jmv 9/9/2012 23:44'!
                         displaySelectionInLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft  selectionColor: sc

	"paragraphTopLeft is relative to the morph currently being drawn"
	selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |
		self
			displaySelectionStartBlock: startBlock
			stopBlock: stopBlock
			InLine: line
			on: aCanvas
			paragraphTopLeft: paragraphTopLeft
			selectionColor: sc ]! !
!Paragraph methodsFor: 'display' stamp: 'jmv 9/9/2012 23:53'!
      displaySelectionStartBlock: startBlock stopBlock: stopBlock InLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft  selectionColor: sc
	"paragraphTopLeft is relative to the morph currently being drawn"

	| leftX rightX idx caretFont t b caretAttributes |

	startBlock ifNil: [^self].	"No selection"
	startBlock = stopBlock 
		ifTrue: [
			"Only show caret on line where clicked"
			startBlock textLine first = line first ifFalse: [
				^self ].
			leftX _ paragraphTopLeft x + startBlock left.
			idx _ startBlock stringIndex.
			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].
			caretFont _ caretAttributes
				ifNil: [ model actualContents fontAt: idx ]
				ifNotNil: [ model actualContents fontIfApplying: caretAttributes ].
			b _ paragraphTopLeft y + line top + line baseline + caretFont descent-1.
			t _ paragraphTopLeft y + line top + line baseline - caretFont ascent.
			showCaret ifTrue: [
				self
					displayInsertionMarkAtX: leftX
					top: t
					bottom: b
					emphasis: caretFont emphasis
					on: aCanvas
					paragraphLeft: paragraphTopLeft x ]]
		ifFalse: [
			"Test entire selection before or after here"
			(stopBlock stringIndex < line first 
				or: [startBlock stringIndex > (line last + 1)])
					ifTrue: [^self].	"No selection on this line"
			(stopBlock stringIndex = line first 
				and: [stopBlock textLine ~= line])
					ifTrue: [^self].	"Selection ends on line above"
			(startBlock stringIndex = (line last + 1) 
				and: [stopBlock textLine ~= line])
					ifTrue: [^self].
			lastCaretRect _ nil.
			leftX _  paragraphTopLeft x + (startBlock stringIndex < line first 
				ifTrue: [ line ]
				ifFalse: [ startBlock ]) left.
			rightX _  paragraphTopLeft x + ((stopBlock stringIndex > (line last + 1) or: [
					stopBlock stringIndex = (line last + 1) 
						and: [stopBlock textLine ~= line]]) 
				ifTrue: [line right]
				ifFalse: [stopBlock left]).
			aCanvas
				fillRectangle: (leftX @ (line top +  paragraphTopLeft y) corner: rightX @ (line bottom +  paragraphTopLeft y))
				color: sc ].	"Selection begins on line below"! !
!Color class methodsFor: 'examples' stamp: 'jmv 9/9/2012 23:51' prior: 50383823!
       experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Color fromUser.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Color basicNew setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	Display forceToScreen
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Color basicNew setHue: h chroma: c luminance: selectedLuminance.
"		color _ Color basicNew setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Color black ].
"		color _ Color basicNew setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Color basicNew setHue: h chroma: selectedChroma luminance: v.
"		color _ Color basicNew setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Color black ].
"		color _ Color basicNew setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	Display forceToScreen
].! !
!FormCanvas class methodsFor: 'cached forms' stamp: 'jmv 9/9/2012 23:50' prior: 50383556!
                              steButtonForm: extent
	^CachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (0@0 extent: extent)
				color: (Color gray: 0.4)
				radius: 4.
			canvas
				roundRect: (1@1 extent: extent-2)
				color: Color white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:55' prior: 50382075!
                   drawDropHighlightOn: aCanvas

	self highlightedForDrop ifTrue: [
		aCanvas frameRectangle: (0@0 extent: self morphExtent) borderWidth: 1 color: self dropHighlightColor ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/10/2012 00:00' prior: 50379120!
        drawErrorOn: aCanvas
	"The morph (or one of its submorphs) had an error in its drawing method."
	| tl br w |
	w _ 10.
	tl _ 0@0.
	br _ self morphExtent.
	aCanvas
		frameAndFillRectangle: (tl corner: br)
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.

	aCanvas line: tl +w to: br -w width: w color: Color yellow.
	aCanvas line: br x - w @ w to: w @ (br y - w) width: w color: Color yellow.! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:56' prior: 50382083!
                        drawMouseDownHighlightOn: aCanvas

	self highlightedForMouseDown ifTrue: [
		aCanvas frameRectangle: (0@0 extent: self morphExtent) borderWidth: 1 color: self color darker darker ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:53' prior: 50384087!
                              drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		fillRectangle: (0@0 extent: self morphExtent)
		color: self color! !
!BorderedRectMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:53' prior: 50384097!
                              drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		fillRectangle: (0@0 extent: extent)
		color: color
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:57' prior: 50384109!
                  drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (0@0 extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (FormCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: extent x - scrollbarThickness@0.
		aCanvas
			image: (FormCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: 0@0 + extent - scrollbarThickness.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				in: rectangle
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!EllipseMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:56' prior: 50381401!
                        drawOn: aCanvas 

	| r bc bw |
	r _ 0@0 extent: extent.
	bw _ borderWidth.
	bc _ borderColor.
	aCanvas isShadowDrawing
		ifTrue: [
			bw _ 0.
			bc _ nil ].
	aCanvas fillOval: r color: color borderWidth: bw borderColor: bc.
! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:51' prior: 50384160!
    drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				roundRect: (0@0 extent: extent)
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		fillRectangle: (14@25 extent: extent-(28@62))
		color: (Theme current paneBackgroundFrom: color)! !
!FrameRateMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:45' prior: 50382092!
                          drawOn: aCanvas
	super drawOn: aCanvas.
	meanStepDelta ifNotNil: [
		aCanvas drawString: lastStepDelta rounded printString at: 0@0 font: StrikeFont default color: Color black.
		aCanvas drawString: meanStepDelta rounded printString at: 0@14 font: StrikeFont default color: Color black.
		"aCanvas drawString: lastStepStamp printString at: bounds topLeft + (0@28) font: StrikeFont default color: Color black "
		]! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:58' prior: 50383586!
            drawOn: aCanvas

	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: (color alpha: 0.57)
		at: 0@0! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:59' prior: 50384823!
                              drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: 0@0
		color: Color black! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/10/2012 00:01' prior: 50384832!
             nonCachingFullDrawOn: aCanvas
	| shadowForm |
	"A HandMorph has unusual drawing requirements:
		1. the hand itself (i.e., the cursor) appears in front of its submorphs
		2. morphs being held by the hand cast a shadow on the world/morphs below
	The illusion is that the hand plucks up morphs and carries them above the world."
	"Note: This version does not cache an image of the morphs being held by the hand.
	 Thus, it is slower for complex morphs, but consumes less space."

	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"

	"Note: We use a shadow form here to prevent drawing
	overlapping morphs multiple times using the transparent
	shadow color."
	shadowForm _ self shadowForm.

	"draw shadows"
	aCanvas stencil: shadowForm at: shadowForm offset  + self shadowOffset color: (Color black alpha: 0.5).
	
	"draw morphs in front of shadows"
	self drawSubmorphsOn: aCanvas.
	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:57' prior: 50383002!
 restoreSavedPatchOn: aCanvas 
	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."

	hasChanged _ false.
	savedPatch ifNotNil: [
		aCanvas image: savedPatch at: savedPatch offset.
		submorphs notEmpty ifTrue: [ ^self ].

		"Make the transition to using hardware cursor. Clear savedPatch and
		 report one final damage rectangle to erase the image of the software cursor."
		self invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset).
		Sensor currentCursor == Cursor normal ifFalse: [ Cursor normal show ].	"show hardware cursor"
		savedPatch _ nil ]! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:55' prior: 50379570!
  drawOn: aCanvas

	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle 
			borderWidth: Preferences focusIndicatorWidth
			color: Theme current focusIndicator ]! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:50' prior: 50384866!
     drawOn: aCanvas

	| r |
	r _ 0@0 extent: extent.
	aCanvas roundRect: r color: self color radius: 4.
	aCanvas
		paragraph: paragraph
		bounds: (r insetBy: 4)
		color: Color black
		selectionColor: (Theme current textHighlightFocused: false)! !
!ImageMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:57' prior: 50380792!
                              drawOn: aCanvas

	aCanvas image: image at: 0@0! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/10/2012 00:00' prior: 50379433!
              drawLineToggleToTextFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor hasToggle: hasToggle
	"If I am not the only item in my container, draw the line between:
		- my toggle (if any) or my left edge (if no toggle)
		- and my text left edge"

	| myBounds myCenter hLineY hLineLeft |
	anIndentingListItemMorph isSoleItem ifTrue: [ ^ self ].
	myBounds _ anIndentingListItemMorph toggleRectangle.
	myBounds _ anIndentingListItemMorph location displayBoundsOfTransformOf: myBounds.
	myCenter _ myBounds center.
	hLineY _ myCenter y.
	hasToggle
		ifTrue: [ hLineLeft _ myBounds right - 3 ]
		ifFalse: [ hLineLeft _ myCenter x - 1 ].
	"Draw line from toggle to text"
	aCanvas
		line: hLineLeft @ hLineY
		to: myBounds right + 0 @ hLineY
		width: 1
		color: lineColor! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/10/2012 00:00' prior: 50379503!
                         drawLinesToFirstChildFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor
	"Draw line from me to next sibling"

	| vLineX vLineTop vLineBottom childCenter |
	childCenter _ anIndentingListItemMorph firstChild location externalizePosition:
			anIndentingListItemMorph firstChild toggleRectangle center.
	vLineX _ childCenter x - 1.
	vLineTop _ (anIndentingListItemMorph location
		externalizePosition: anIndentingListItemMorph morphExtent) y.
	anIndentingListItemMorph firstChild hasToggle
		ifTrue: [ vLineBottom _ childCenter y - 7 ]
		ifFalse: [ vLineBottom _ childCenter y ].
	aCanvas
		line: vLineX @ vLineTop
		to: vLineX @vLineBottom
		width: 1
		color: lineColor! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/10/2012 00:00' prior: 50379527!
                      drawLinesToNextSiblingFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor hasToggle: hasToggle
	| vLineX myCenter vLineTop vLineBottom nextSibCenter |

	self flag: #jmvVer2. "complicated... not intuitive... who should draw this?"
	"the center of the toggle in our own coordinates (and not in those of child, that is not our child, but our sibling in the morphic hierarchy!!)"
	nextSibCenter _ anIndentingListItemMorph nextSibling location externalizePosition:
		anIndentingListItemMorph nextSibling toggleRectangle center.

	myCenter _ anIndentingListItemMorph location externalizePosition:
		 anIndentingListItemMorph toggleRectangle center.
	vLineX _ myCenter x - 1.
	hasToggle
		ifTrue: [ vLineTop _ myCenter y + 5 ]
		ifFalse: [ vLineTop _ myCenter y ].
	anIndentingListItemMorph nextSibling hasToggle
		ifTrue: [ vLineBottom _ nextSibCenter y - 7 ]
		ifFalse: [ vLineBottom _ nextSibCenter y ].
	"Draw line from me to next sibling"
	aCanvas
		line: vLineX @ vLineTop
		to: vLineX @ vLineBottom
		width: 1
		color: lineColor! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:48' prior: 50380542!
                          draw: item atRow: row on: canvas
	"display the given item at row row"
	| drawBounds f |
	drawBounds _ self drawBoundsForRow: row.
	drawBounds _ drawBounds intersect: (0@0 extent: extent).
	f _ (item is: #Text) ifTrue: [ font emphasized: (item emphasisAt: 1) ] ifFalse: [ font ].
	canvas drawString: item in: drawBounds font: f color: (self colorForRow: row).! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:52' prior: 50384203!
   drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"
	selectionDrawBounds _ self drawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: (0@0 extent: extent).
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas fillRectangle: selectionDrawBounds color: c! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:52' prior: 50384222!
              drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (0@0 extent: extent).
	aCanvas
		fillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:55' prior: 50382119!
                          debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"

	self paragraph lines do: [ :line |
		aCanvas
			frameRectangle: line rectangle
			borderWidth: 1
			color: Color brown ]
! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:49' prior: 50384877!
        drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		paragraph: self paragraph
		bounds: (0@0 extent: extent)
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:53' prior: 50384237!
                        drawOn: aCanvas

	aCanvas
		fillRectangle: (0@0 extent: extent)
		color: color
		borderWidth: 2
		borderStyleSymbol: #raised
		baseColorForBorder: color! !
!MagnifierMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:57' prior: 50380803!
                 drawOn: aCanvas
	RecursionLock == self ifFalse: [
		super drawOn: aCanvas.		"border and fill"
		aCanvas isShadowDrawing ifFalse: [
			"Optimize because #magnifiedForm is expensive"
			aCanvas image: self magnifiedForm at: borderWidth@borderWidth]]! !
!MenuLineMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:52' prior: 50384288!
                   drawOn: aCanvas 
	| baseColor r |
	baseColor _ owner color.
	r _ self morphBoundsInWorld.
	aCanvas
		fillRectangle: (r topLeft corner: r rightCenter)
		color: baseColor twiceDarker.
			
	aCanvas
		fillRectangle: (r leftCenter corner: r bottomRight)
		color: baseColor twiceLighter! !
!MenuMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:54' prior: 50384300!
                      drawOn: aCanvas
	
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas roundRect: (0@0 extent: extent) color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			aCanvas fillRectangle: (0@0 extent: extent) color: color borderWidth: borderWidth borderStyleSymbol: #raised baseColorForBorder: color ]! !
!MinimalStringMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:48' prior: 50382150!
                         drawOn: aCanvas

	aCanvas drawString: contents in: (0@0 extent: extent) font: self fontToUse color: color! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 9/10/2012 00:00' prior: 50381154!
                           displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas
	| caretColor x1 isBold isItalic x0 h w halfW r d |
	isBold _ emphasis allMask: 1.
	isItalic _ emphasis allMask: 2.
	caretColor _ Theme current insertionPoint.
	h _ bottom - top.
	w _ isBold
		ifTrue: [ h // 25 + 2 ]
		ifFalse: [ h // 30 + 1 ].
	halfW _ w // 2.
	isItalic
		ifTrue: [	
			"Keep tweaking if needed!!"
			d _ isBold ifTrue: [ 3 ] ifFalse: [ h // 24].
			x0 _ x- (h*5//24) + d.
			x1 _ x + d ]
		ifFalse: [
			x0 _ x.
			x1 _ x].
	x0 < halfW ifTrue: [
		x1 _ x1 - x0 + halfW.
		x0 _ halfW ].
	r _ extent x-halfW-1.
	r < x1 ifTrue: [
		x0 _ x0 + r - x1.
		x1 _ r ].
	caretRect _ x0-halfW-1@ top corner: x1+halfW+1+1 @ bottom.
	aCanvas
		line: x0@(bottom-halfW) to: x1@(top+halfW)
		width: w color: caretColor! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:48' prior: 50382157!
   drawOn: aCanvas
	self hasSelection ifTrue: [ self drawSelectionOn: aCanvas ].
	self hasVisibleCaret ifTrue: [ self drawCaretOn: aCanvas ].
	aCanvas
		drawString: contents
		in: (0@0 extent: extent)
		font: self fontToUse
		color: color! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:53' prior: 50384315!
                          drawSelectionOn: aCanvas
	| rightX leftX bottom |

	bottom _ self baseFont height.
	leftX _ self fontToUse widthOfString: contents from: 1 to: editor startIndex-1.
	rightX _ self fontToUse widthOfString: contents from: 1 to: editor stopIndex-1.

	aCanvas
		fillRectangle: (leftX @ 0 corner: rightX @ bottom)
		color: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:57' prior: 50382833!
                   drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			"self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"
			self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self zzclippingBounds
					during: [ :canvas | canvas image: backgroundImage at: 0@0 ]]
				ifFalse: [ aCanvas image: backgroundImage at: 0@0 ]]

		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [color class == TranslucentColor])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt current toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: 0@0 in: nil
						fillColor: color rule: Form over]
				ifFalse: [ super drawOn: aCanvas ]]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:54' prior: 50384330!
                              draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: (0@0 extent: extent)
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:49' prior: 50382439!
                     drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ extent // 2.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ extent x - labelMargin - labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawStringEmbossed: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: colorForLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:59' prior: 50383699!
                 drawInconOn: aCanvas

	| theIcon |
	theIcon _ self magnifiedIcon.
	aCanvas
		image: theIcon
		multipliedBy: self iconColor
		at: (extent - theIcon extent //2)! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:48' prior: 50382475!
     drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ extent // 2.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ extent x - labelMargin - labelMargin - 1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:50' prior: 50382498!
   drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableListMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:56' prior: 50379250!
       drawOn: aCanvas
	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: Preferences focusIndicatorWidth
			color: Theme current focusIndicator ].! !
!ProgressBarMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:53' prior: 50384345!
    drawOn: aCanvas

	super drawOn: aCanvas.
	aCanvas
		fillRectangle: (borderWidth@borderWidth extent: extent x - borderWidth - borderWidth * value @ extent y - borderWidth-borderWidth)
		color: progressColor! !
!RectangleIndicatorMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:56' prior: 50382235!
                   drawOn: aCanvas
	| bw b |
	bw _ self defaultBorderWidth.
	b _ 0@0 extent: extent.
	aCanvas frameRectangle: b borderWidth: bw color: Color black.
	aCanvas frameRectangle: (b insetBy: bw) borderWidth: bw color: Color white! !
!ScrollBar methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:54' prior: 50384355!
                  drawOn: aCanvas

	aCanvas
		fillRectangle: (0@0 extent: extent)
		color: (color alphaMixed: 0.3 with: Color white)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!String methodsFor: 'displaying' stamp: 'jmv 9/9/2012 23:45' prior: 50384926!
  displayOn: aDisplayMedium at: aPoint textColor: aColor
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color"

	aDisplayMedium getCanvas drawString: self at: aPoint font: nil color: aColor! !
!StringMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:48' prior: 50382255!
                            drawOn: aCanvas
	aCanvas
		drawString: contents
		in: (0@0 extent: extent)
		font: self fontToUse
		color: color! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:57' prior: 50384175!
                 drawOn: aCanvas

	| tRect sRect colorToUse sLeft aForm centeringOffset |
	isSelected ifTrue: [
		aCanvas
			fillRectangle: (0@0 extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) ].

	complexContents hasContents ifTrue: [
		tRect _ self toggleRectangle.
		aForm _ isExpanded 
			ifTrue: [ container expandedForm ]
			ifFalse: [ container notExpandedForm ].
		centeringOffset _ ((tRect height - aForm extent y) / 2.0) rounded.
		aCanvas 
			image: aForm 
			at: (tRect topLeft translatedBy: 0 @ centeringOffset) ].

	sLeft _ indentLevel * 12 + 16.
	sRect _ sLeft@0 extent: extent - (sLeft@0).
	colorToUse _ complexContents preferredColor ifNil: [ color ].
	aCanvas
		drawString: contents asString
		in: sRect
		font: self fontToUse
		color: colorToUse! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:57' prior: 50384245!
              drawOn: aCanvas 
	| stringColor stringBounds leftEdge |

	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas fillRectangle: (0@0 extent: extent) color: Theme current menuHighlight].
	leftEdge _ 0.

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + submorphs first morphWidth + 8 ].

	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ].
			aCanvas image: iconForm at: leftEdge+1 @ (extent y - iconForm height // 2).
			leftEdge _ leftEdge + iconForm width + self iconSeparation].

	stringBounds _  leftEdge @ 1 extent: extent.

	aCanvas
		drawString: contents
		in: stringBounds
		font: self fontToUse
		color: stringColor.
	subMenu ifNotNil: [
		aCanvas
			image: SubMenuMarker
			at: extent x - 8 @ (extent y - SubMenuMarker height // 2) ]! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 50383593!
                 offImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.9) 
			borderWidth: 1 borderColor: Color black.
	^form! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 50384274!
            onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) 
			borderWidth: 1 borderColor: Color black;
		fillRectangle: (form boundingBox insetBy: 2) color: Color black.
	^form! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:54' prior: 50384365!
           drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas fillRectangle: (0@0 extent: extent) color: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	"A border was drawn at the left, top and right of the title area.
	The look is that the title area is inside the window"
	aCanvas fillRectangle: (borderWidth@borderWidth extent: extent x - (2*borderWidth)@ self labelHeight) color: titleColor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:49' prior: 50382355!
      drawLabelOn: aCanvas

	Theme current embossedTitles
		ifFalse: [
			aCanvas
				drawString: labelString
				in: self labelRectangle
				font: Preferences windowTitleFont
				color: Theme current windowLabel ]
		ifTrue: [
			aCanvas
				drawStringEmbossed: labelString
				in: self labelRectangleForEmbossed
				font: Preferences windowTitleFont
				color: Theme current windowLabel ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:51' prior: 50382370!
            drawRoundedFrameOn: aCanvas color: widgetsColor
	"Title area is not inside window borders"
	| bottomFactor topFactor |
	Theme current useWindowTitleGradient
		ifTrue: [
			topFactor _ Theme current titleGradientTopFactor.
			bottomFactor _ Theme current titleGradientBottomFactor ]
		ifFalse: [
			topFactor _ 1.
			bottomFactor _ 1 ].
	aCanvas
		windowFrame: (0@0 extent: extent)
		color: widgetsColor * Theme current titleGradientExtraLightness
		radius: Theme current roundedWindowRadius
		border: borderWidth
		labelHeight: self labelHeight + borderWidth
		gradientTop: topFactor
		gradientBottom: bottomFactor
		insideColor: color! !
!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:56' prior: 50379274!
              drawOn: aCanvas 
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"

	| bw bc |
	super drawOn: aCanvas.
	bw _ Preferences focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan]
			ifFalse: [
				self textMorph hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ] 
					ifFalse: [
						self textMorph hasUnacceptedEdits
							ifTrue: [
								bc _ Color red]]]].

	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [
		bc ifNil: [
			bc _ Theme current focusIndicator ]]
	ifFalse: [
		bc ifNotNil: [
			bc _ bc alphaMixed: 0.4 with: Color white ]].
	bc ifNotNil: [
		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/9/2012 23:45' prior: 50384938!
              displayOn: aForm
	"
	Transcript displayOn: Display
	"
	| font count i string x y fh f bw r canvas |
	bw _ self borderWidth  .
	r _ innerRectangle outsetBy: bw + self padding.
	aForm border: r width: bw. 
	aForm fill: r fillColor: Color white.
	font _ StrikeFont default.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.
	y _ innerRectangle top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	canvas _ aForm getCanvas.
	canvas setOrigin: 0@0 clipRect: innerRectangle.
	[
		string _ entries at: i.	
		canvas drawString: string at: x@y font: font color: Color veryDarkGray.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.
	canvas drawString: string at: x@y font: font color: Color veryDarkGray! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/9/2012 23:45' prior: 50384969!
              displayUnfinishedEntryOn: aForm

	| font count string x y fh canvas |
	font _ StrikeFont default.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.

	string _ unfinishedEntry contents.
	y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerRectangle top.
	canvas _ aForm getCanvas.
	canvas setOrigin: 0@0 clipRect: innerRectangle.
	canvas drawString: string at: x@y font: font color: Color veryDarkGray! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:57' prior: 50380861!
               drawOn: aCanvas
	"
	Transcript
		showOnDisplay: true;
		bounds: bounds;
		displayOn: aCanvas form.
	"
	Transcript
		showOnDisplay: true;
		morphBoundsInWorld: (0@0 extent: self morphExtentInWorld);
		displayOn: form;
		morphBoundsInWorld: self morphBoundsInWorld.
	aCanvas image: form at: 0@0! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 9/9/2012 23:49' prior: 50384987!
     endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	para
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	para composeAll.
	d _ para extent y - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ para characterBlockAtPoint:
			0@0 + (0@(d+StrikeFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		paragraph: para
		bounds: (4@4 + frame topLeft extent: Display extent)
		color: Color black
		selectionColor: Color blue! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:56' prior: 50383717!
                        drawHand: aHandMorph
	"Draw a hand that carries morphs, or needs to be drawn by us, because of not being the hardware mouse pointer."
	| bw r |
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth // 2.
		r _ aHandMorph morphFullBoundsInWorld.
		canvas frameRectangle: r borderWidth: bw color: Color black.
		canvas frameRectangle: (r insetBy: bw) borderWidth: bw color: Color white.
		canvas clipBy: aHandMorph morphBoundsInWorld during: [ :c | aHandMorph drawOn: c ]]
	ifFalse: [
		 canvas fullDraw: aHandMorph]! !

Paragraph removeSelector: #zzdisplayInsertionMarkAtX:top:bottom:emphasis:on:paragraphLeft:!

Paragraph removeSelector: #zzdisplayInsertionMarkAtX:top:bottom:emphasis:on:paragraphLeft:!

Paragraph removeSelector: #zzdisplaySelectionInLine:on:paragraphTopLeft:selectionColor:!

Paragraph removeSelector: #zzdisplaySelectionInLine:on:paragraphTopLeft:selectionColor:!

Paragraph removeSelector: #zzdisplaySelectionStartBlock:stopBlock:InLine:on:paragraphTopLeft:selectionColor:!

Paragraph removeSelector: #zzdisplaySelectionStartBlock:stopBlock:InLine:on:paragraphTopLeft:selectionColor:!

MorphicScanner removeSelector: #zzdisplayBulletIfAppropriateFor:paragraphTopLeft:!

MorphicScanner removeSelector: #zzdisplayBulletIfAppropriateFor:paragraphTopLeft:!

MorphicScanner removeSelector: #zzdisplayBulletParagraphTopLeft:number:!

MorphicScanner removeSelector: #zzdisplayBulletParagraphTopLeft:number:!

MorphicScanner removeSelector: #zzdisplayLine:paragraphTopLeft:leftInRun:!

MorphicScanner removeSelector: #zzdisplayLine:paragraphTopLeft:leftInRun:!

HandMorph removeSelector: #zzshadowForm!

HandMorph removeSelector: #zzshadowForm!

FormCanvas removeSelector: #zzdrawString:at:font:color:!

FormCanvas removeSelector: #zzdrawString:at:font:color:!

FormCanvas removeSelector: #zzdrawString:from:to:at:font:color:!

FormCanvas removeSelector: #zzdrawString:from:to:at:font:color:!

FormCanvas removeSelector: #zzdrawString:from:to:at:font:color:kern:!

FormCanvas removeSelector: #zzdrawString:from:to:at:font:color:kern:!

FormCanvas removeSelector: #zzdrawString:from:to:in:font:color:!

FormCanvas removeSelector: #zzdrawString:from:to:in:font:color:!

FormCanvas removeSelector: #zzdrawString:in:font:color:!

FormCanvas removeSelector: #zzdrawString:in:font:color:!

FormCanvas removeSelector: #zzdrawStringEmbossed:from:to:in:font:color:!

FormCanvas removeSelector: #zzdrawStringEmbossed:from:to:in:font:color:!

FormCanvas removeSelector: #zzdrawStringEmbossed:in:font:color:!

FormCanvas removeSelector: #zzdrawStringEmbossed:in:font:color:!

FormCanvas removeSelector: #zzfillOval:color:borderWidth:borderColor:!

FormCanvas removeSelector: #zzfillOval:color:borderWidth:borderColor:!

FormCanvas removeSelector: #zzfillRectangle:color:!

FormCanvas removeSelector: #zzfillRectangle:color:!

FormCanvas removeSelector: #zzfillRectangle:color:borderWidth:borderStyleSymbol:baseColorForBorder:!

FormCanvas removeSelector: #zzfillRectangle:color:borderWidth:borderStyleSymbol:baseColorForBorder:!

FormCanvas removeSelector: #zzfillRectangle:infiniteForm:multipliedBy:!

FormCanvas removeSelector: #zzfillRectangle:infiniteForm:multipliedBy:!

FormCanvas removeSelector: #zzframeAndFillRectangle:fillColor:borderWidth:borderColor:!

FormCanvas removeSelector: #zzframeAndFillRectangle:fillColor:borderWidth:borderColor:!

FormCanvas removeSelector: #zzframeRectangle:borderWidth:color:!

FormCanvas removeSelector: #zzframeRectangle:borderWidth:color:!

FormCanvas removeSelector: #zzframeRectangle:color:borderWidth:borderStyleSymbol:!

FormCanvas removeSelector: #zzframeRectangle:color:borderWidth:borderStyleSymbol:!

FormCanvas removeSelector: #zzimage:at:!

FormCanvas removeSelector: #zzimage:at:!

FormCanvas removeSelector: #zzimage:at:sourceRect:!

FormCanvas removeSelector: #zzimage:at:sourceRect:!

FormCanvas removeSelector: #zzimage:multipliedBy:at:!

FormCanvas removeSelector: #zzimage:multipliedBy:at:!

FormCanvas removeSelector: #zzline:to:width:color:!

FormCanvas removeSelector: #zzline:to:width:color:!

FormCanvas removeSelector: #zzparagraph:bounds:color:selectionColor:!

FormCanvas removeSelector: #zzparagraph:bounds:color:selectionColor:!

FormCanvas removeSelector: #zzroundRect:color:radius:!

FormCanvas removeSelector: #zzroundRect:color:radius:!

FormCanvas removeSelector: #zzroundRect:color:radius:gradientTop:gradientBottom:gradientHeight:!

FormCanvas removeSelector: #zzroundRect:color:radius:gradientTop:gradientBottom:gradientHeight:!

FormCanvas removeSelector: #zzroundRect:color:radius:gradientTop:gradientCenter:gradientBottom:gradient1Height:!

FormCanvas removeSelector: #zzroundRect:color:radius:gradientTop:gradientCenter:gradientBottom:gradient1Height:!

FormCanvas removeSelector: #zzstencil:at:color:!

FormCanvas removeSelector: #zzstencil:at:color:!

FormCanvas removeSelector: #zzstencil:at:sourceRect:color:!

FormCanvas removeSelector: #zzstencil:at:sourceRect:color:!

FormCanvas removeSelector: #zzwindowFrame:color:radius:border:labelHeight:gradientTop:gradientBottom:insideColor:!

FormCanvas removeSelector: #zzwindowFrame:color:radius:border:labelHeight:gradientTop:gradientBottom:insideColor:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1441-LocalCoordinates16-JuanVuletich-2012Sep09-23h42m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1441] on 11 September 2012 at 10:42:02 pm'!

!classDefinition: #FormCanvas category: #'Morphic-Support'!
Object subclass: #FormCanvas
	instanceVariableNames: 'origin clipRect form port shadowColor transformations currentTransformation cti'
	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms'
	poolDictionaries: ''
	category: 'Morphic-Support'!

Object subclass: #FormCanvas
	instanceVariableNames: 'origin clipRect form port shadowColor transformations currentTransformation cti '
	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms '
	poolDictionaries: ''
	category: 'Morphic-Support'!
!FormCanvas methodsFor: 'accessing' stamp: 'jmv 9/11/2012 22:22'!
    canvasOrigin
	"Return the current origin for drawing operations"
	self flag: #jmvVer2. "shouldn't be needed I believe."
	^ transformations first position! !
!FormCanvas methodsFor: 'accessing' stamp: 'jmv 9/11/2012 22:26' prior: 50360742!
                 clipRect
	"Return the currently active clipping rectangle"
	^ clipRect translatedBy: self canvasOrigin negated! !
!FormCanvas methodsFor: 'accessing' stamp: 'jmv 9/11/2012 22:26' prior: 16860443!
                            contentsOfArea: aRectangle into: aForm
	| bb o |
	bb _ BitBlt toForm: aForm.
	o _ self canvasOrigin.
	bb sourceForm: form; combinationRule: Form over;
		sourceX: (aRectangle left + o x); sourceY: (aRectangle top + o y);
		width: aRectangle width; height: aRectangle height;
		copyBits.
	^aForm! !
!FormCanvas methodsFor: 'accessing' stamp: 'jmv 9/11/2012 22:24' prior: 16860460!
     formWithOffset

	^ form offset: self canvasOrigin negated! !
!FormCanvas methodsFor: 'copying' stamp: 'jmv 9/11/2012 22:29' prior: 50360748!
                   copyClipRect: aRectangle
	| o |
	o _ self canvasOrigin.
	^ self copyOrigin: o clipRect: (aRectangle translatedBy: o)
! !
!FormCanvas methodsFor: 'drawing' stamp: 'jmv 9/11/2012 22:27' prior: 50385087!
                       line: pt1 to: pt2 width: w color: c
	| offset p1 p2 |
	p1 _ currentTransformation transform: pt1.
	p2 _ currentTransformation transform: pt2.
	offset _ w // 2.
	self setPaintColor: c.
	port
		width: w;
		height: w;
		drawFrom: (p1 rounded + offset) to: (p2 rounded + offset)! !
!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 9/11/2012 22:15' prior: 50385153!
                   stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor
	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"
	| p |
	p _ currentTransformation transform: aPoint.
	self setPaintColor: aColor.
	port colorMap: stencilForm maskingMap.
	port stencil: stencilForm
		at: p
		sourceRect: sourceRect! !
!FormCanvas methodsFor: 'drawing-ovals' stamp: 'jmv 9/11/2012 22:20' prior: 50385166!
  fillOval: r color: fillColor borderWidth: borderWidth borderColor: borderColor

	| displayRectangle |
	displayRectangle _ (currentTransformation displayBoundsOfTransformOf: r) truncated.
	"draw the border of the oval"
	(borderWidth = 0 or: [borderColor isTransparent]) ifFalse:[
		self setPaintColor: borderColor.
		port frameOval: displayRectangle borderWidth: borderWidth].
	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillOval: (displayRectangle insetBy: borderWidth)].
! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/11/2012 22:26' prior: 50385235!
                      frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor
	| rect |
	rect _ currentTransformation displayBoundsOfTransformOf: r.
	"draw the border of the rectangle"
	borderColor isTransparent ifFalse:[
		self setPaintColor: borderColor.
		port frameRect: rect borderWidth: borderWidth ].

	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillRect: (rect insetBy: borderWidth) ]! !
!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 9/11/2012 22:17' prior: 50385253!
                    frameRectangle: r borderWidth: borderWidth color: borderColor
	"
	Display getCanvas
		frameRectangle: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red
	"
	| rect |
	rect _ currentTransformation displayBoundsOfTransformOf: r.
	self setPaintColor: borderColor.
	port
		frameRect: rect
		borderWidth: borderWidth.! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/11/2012 22:16' prior: 50385504!
     drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c
	| font p1 |
	p1 _ currentTransformation transform: aPoint.
	port colorMap: nil.
	font _ fontOrNil ifNil: [StrikeFont default].
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: p1
		strikeFont: font
		kern: font baseKern negated! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/11/2012 22:28' prior: 50385524!
            drawString: aString from: firstIndex to: lastIndex at: aPoint font: font color: c kern: kern

	| p1 |
	p1 _ currentTransformation transform: aPoint.
	port colorMap: nil.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: p1
		strikeFont: font
		kern: kern! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/11/2012 22:28' prior: 50385542!
          drawString: aString from: firstIndex to: lastIndex in: aRectangle font: fontOrNil color: c
	| font portRect bounds |
	bounds _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left
		y1: bounds top
		x2: bounds right
		y2: bounds bottom.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [port clipRect: portRect. ^self].
	port clipWidth = 0 ifTrue: [port clipRect: portRect. ^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: bounds topLeft
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 9/11/2012 22:16' prior: 50385578!
                          drawStringEmbossed: aString from: firstIndex to: lastIndex in: aRectangle font: fontOrNil color: aColor
	| font portRect insideColor bounds |
	bounds _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left
		y1: bounds top
		x2: bounds right
		y2: bounds bottom.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	insideColor _ shadowColor ifNil: [ aColor ].
	insideColor = Color black ifFalse: [ | topColor |
		topColor _ insideColor alphaMixed: 0.25 with: Color black.
		port installStrikeFont: font foregroundColor: topColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: bounds topLeft
			strikeFont: font
			kern: font baseKern negated ].
	insideColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ insideColor alphaMixed: 0.22 with: Color white.
		port installStrikeFont: font foregroundColor: bottomColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: bounds topLeft + (0@2)
			strikeFont: font
			kern: font baseKern negated ].
	port installStrikeFont: font foregroundColor: insideColor.
	port
		displayString: aString asString
		from: firstIndex
		to: lastIndex
		at: bounds topLeft + (0@1)
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'initialization' stamp: 'jmv 9/11/2012 22:11' prior: 50382957!
      initialize
	super initialize.

	"We currently set up these only in #initialize.
	This is safe (wrt walkbacks during world redraw) because a new instance is created
	each time the world is redrawn. See #drawInvalidAreasWorld:submorphs:
	Maybe this cleanup should be in an aux method that can be called each time on an existing instance..."
	currentTransformation _ MatrixTransform2x3 identity.
	cti _ 1.
	transformations
		ifNil: [ transformations _ OrderedCollection with: currentTransformation ]
		ifNotNil: [ transformations at: cti put: currentTransformation ]! !
!FormCanvas methodsFor: 'testing' stamp: 'jmv 9/11/2012 22:18' prior: 16861175!
                         isFullyVisible: aRectangle
	"Optimization"
	aRectangle right > clipRect right		ifTrue: [^ false].
	aRectangle left < clipRect left			ifTrue: [^ false].
	aRectangle bottom > clipRect bottom	ifTrue: [^ false].
	aRectangle top < clipRect top			ifTrue: [^ false].
	^ true
! !
!FormCanvas methodsFor: 'testing' stamp: 'jmv 9/11/2012 22:40' prior: 16861192!
isVisible: aRectangle

| o |
self flag: #jmvVer2.
"should receive local coordinates, and do the conversion here!!!!!!!!!!"
"This goes together with removing #morphFullBoundsInWorld and #morphBoundsInWorld"

	o _ self canvasOrigin.
	"Optimization"
	(aRectangle right + o x) < clipRect left		ifTrue: [^ false].
	(aRectangle left + o x) > clipRect right		ifTrue: [^ false].
	(aRectangle bottom + o y) < clipRect top	ifTrue: [^ false].
	(aRectangle top + o y) > clipRect bottom	ifTrue: [^ false].
	^ true
! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 9/11/2012 22:19' prior: 50360800!
                       fillRectangle: rInPortTerms tilingWith: aForm sourceRect: patternBox rule: aCombinationRule
	"We assume that aForm is part of an InfiniteForm.
	aRectangle is in form coordinates, no transformation is done."
	| additionalOffset clippedPort targetTopLeft clipOffset ex 
	targetBox savedMap top left |

	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.
	something better is needed, but not now"

	ex _ patternBox extent.
	additionalOffset _ 0@0.
	clippedPort _ port clippedBy: rInPortTerms.
	targetTopLeft _ clippedPort clipRect topLeft truncateTo: ex.
	clipOffset _ rInPortTerms topLeft - targetTopLeft.
	additionalOffset _ (clipOffset \\ ex) - ex.

	"do it iteratively"
	targetBox _ clippedPort clipRect.
	savedMap _ clippedPort colorMap.
	clippedPort sourceForm: aForm;
		fillColor: nil;
		combinationRule: aCombinationRule;
		sourceRect: patternBox;
		colorMap: (aForm colormapIfNeededFor: clippedPort destForm).
	top _ (targetBox top truncateTo: patternBox height) + additionalOffset y.
	left _  (targetBox left truncateTo: patternBox width) + additionalOffset x.

	left to: (targetBox right - 1) by: patternBox width do: [:x |
		top to: (targetBox bottom - 1) by: patternBox height do: [:y |
			clippedPort destOrigin: x@y; copyBits]].
	clippedPort colorMap: savedMap! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 9/11/2012 22:17' prior: 50360844!
                frameRectangle: rect borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor
	"
	rect and borderWidth are in form coordinates. No transformation is done.
	Display getCanvas
		frameRectangle: (10@10 extent: 300@200)
		borderWidth: 20
		topLeftColor: Color green
		bottomRightColor: Color red
	Display getCanvas fillRectangle: (10@10 extent: 300@200) color: Color white
	"
	| w h |
	self setPaintColor: topLeftColor.

	port frameRectTopLeft: rect borderWidth: borderWidth.

	borderWidth isNumber
		ifTrue: [w _ h _ borderWidth]
		ifFalse: [w _ borderWidth x.   h _ borderWidth y].
	self setPaintColor: bottomRightColor.
	port 
		 frameRectRight: rect width: w;
		 frameRectBottom: rect height: h! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 9/11/2012 22:28' prior: 16861290!
                        image: aForm at: aPoint sourceRect: sourceRect rule: rule 
	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."
	port colorMap: (aForm colormapIfNeededFor: form); fillColor: nil.
	port image: aForm at: aPoint sourceRect: sourceRect rule: rule.! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 9/11/2012 22:41' prior: 50379072!
                      setForm: aForm

	form _ aForm.
	port _ self portClass toForm: form.

	"this was the contents of the #reset method"

	"origin of the top-left corner of this cavas"
	transformations first setTranslation: 0@0.
	clipRect _ (0@0 corner: form extent).	"default clipping rectangle"
	shadowColor _ nil! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 9/11/2012 22:41' prior: 16861320!
       setOrigin: aPoint

	transformations first setTranslation: aPoint.! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 9/11/2012 22:41' prior: 16861324!
           setOrigin: aPoint clipRect: aRectangle

	transformations first setTranslation: aPoint.
	clipRect _ aRectangle.
	port clipRect: aRectangle.
! !
!FormCanvas methodsFor: 'morphic' stamp: 'jmv 9/11/2012 22:40' prior: 50379084!
 fullDraw: aMorph
	"Draw the full Morphic structure on us"

	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."
	"
	This is starting to work:
		| c |
		c _ Display getCanvas initTransformationsFor: World.
		World submorphsDo: [ :m | c fullDraw: m ].
	"

	"To replace #fullDrawOn:"
	self flag: #jmvVer3.

	aMorph visible ifFalse: [^ self].

	self into: aMorph.

	aMorph layoutSubmorphsIfNeeded.
	(self isVisible: aMorph morphFullBoundsInWorld) ifFalse: [
		self outOf: aMorph.
		^ self].

	aMorph isKnownFailing 
		ifTrue: [ aMorph drawErrorOn: self ]
		ifFalse: [ aMorph fullDrawOn: self ].

	self outOf: aMorph! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/11/2012 22:40' prior: 50378687!
                   fullDrawOn: aCanvas
	"Draw the full Morphic structure on the given Canvas"

	"Draw receiver itself"
	(aCanvas isVisible: self morphBoundsInWorld) ifTrue: [
		aCanvas clipBy: self morphBoundsInWorld during: [ :c | self drawOn: c ]].	"Needs bounds 'in owner' if inside a scroller"
	self drawSubmorphsOn: aCanvas.
	self drawDropHighlightOn: aCanvas.
	self drawMouseDownHighlightOn: aCanvas! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/11/2012 22:38' prior: 50375710!
              morphFullBoundsInWorld
	"Morphs should know nothing about absolute coordinates..."
	"Should implement in some reasonable way... including submorphs?"

	self flag: #jmvVer2.
	"IF I remove this, then layout of buttons in FileList breaks when selecting / deselecting code files. Besides, ProgressMorph example breaks too"
	self layoutSubmorphsIfNeeded.

	self flag: #jmvVer2.	"consider submorphs!!!!!!!!!!"
	^self morphBoundsInWorld! !
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 9/11/2012 22:33' prior: 16815160!
                         browseHierarchy
	"Create and schedule a new hierarchy browser on the currently selected class or meta."

	model hierarchyBrowser ifNotNil: [ :newBrowser |
		HierarchyBrowserWindow
			openNoSysCat: newBrowser
			label: newBrowser labelString.
		newBrowser assureSelectionsShow ]! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/11/2012 22:23' prior: 50360911!
                        savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| ownBnds fullBnds bw |
	ownBnds _ self morphBoundsInWorld.
	fullBnds _ self morphFullBoundsInWorld.
	(savedPatch isNil or: [savedPatch extent ~= fullBnds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBnds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: (fullBnds translatedBy: aCanvas canvasOrigin)
		into: savedPatch.
	savedPatch offset: fullBnds topLeft.
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth.
		aStream nextPut: ownBnds.
		prevBounds ifNotNil: [ aStream nextPut: prevBounds ].
		(fullBnds areasOutside: (fullBnds insetBy: bw)) do: [ :r |
			aStream nextPut: r ].
		prevFullBounds ifNotNil: [
			(prevFullBounds areasOutside: (prevFullBounds insetBy: bw)) do: [ :r |
				aStream nextPut: r ]]]
	ifFalse: [
		prevFullBounds ifNil: [
			aStream nextPut: fullBnds ]
		ifNotNil: [
			aStream nextPut: (fullBnds merge: prevFullBounds)]].
	prevBounds _ ownBnds.
	prevFullBounds _ fullBnds! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/11/2012 22:40' prior: 50379488!
                         drawLinesOn: aCanvas 
	| lColor |
	lColor _ Theme current line.

	self submorphs do: [ :submorph | 
		(submorph isExpanded or: [
			(aCanvas isVisible: submorph morphBoundsInWorld) or: [
				submorph nextSibling notNil and: [
					aCanvas isVisible:
						submorph nextSibling morphBoundsInWorld ] ] ])
		ifTrue: [
			self
				drawLinesFor: submorph
				on: aCanvas
				lineColor: lColor ]]! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 9/11/2012 22:01' prior: 50379818!
                       buildMorphicWindow

	| textMorph |
	listMorph _ HierarchicalListMorph
			model: model
			listGetter: #getList
			indexGetter: #getCurrentSelection
			indexSetter: #noteNewSelection:
			mainView: self
			menuGetter: #genericMenu
			keystrokeAction: #explorerKey:from:.
	listMorph autoDeselect: false.
	textMorph _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	self layoutMorph
		addMorph: listMorph proportionalHeight: 0.8;
		addAdjusterAndMorph: textMorph proportionalHeight: 0.2.
	self setLabel: (model rootObject printStringLimitedTo: 64)! !

FormCanvas removeSelector: #origin!

FormCanvas removeSelector: #origin!

FormCanvas removeSelector: #zzisVisible:!

!classDefinition: #FormCanvas category: #'Morphic-Support'!
Object subclass: #FormCanvas
	instanceVariableNames: 'clipRect form port shadowColor transformations currentTransformation cti'
	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms'
	poolDictionaries: ''
	category: 'Morphic-Support'!

Object subclass: #FormCanvas
	instanceVariableNames: 'clipRect form port shadowColor transformations currentTransformation cti'
	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms'
	poolDictionaries: ''
	category: 'Morphic-Support'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1442-RemoveCanvasOrigin-JuanVuletich-2012Sep11-22h01m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1442] on 17 September 2012 at 9:15:51 pm'!
!Morph methodsFor: 'change reporting' stamp: 'jmv 9/17/2012 21:05'!
         invalidateRect: aRectangle

	"warning. Senders are using global coordinates. Redesign!!"
	self flag: #jmvVer2.	"ok?"
	"local now!!!!!!!!!!"
	owner ifNotNil: [
		owner invalidateRect: (location displayBoundsOfTransformOf: aRectangle) ]! !
!BorderedRectMorph methodsFor: 'drawing' stamp: 'jmv 9/17/2012 20:54'!
           clipsSubmorphs
	"Drawing specific. If this property is set, clip the receiver's  
	submorphs to the receiver's clipping bounds.
	Maybe move up to RectangleLikeMorph"
	^ self
		valueOfProperty: #clipSubmorphs
		ifAbsent: [true]! !
!BorderedRectMorph methodsFor: 'geometry' stamp: 'jmv 9/17/2012 20:57'!
                  zzclippingBounds
	"Return the bounds to which any submorphs should be clipped if the property is set"
	"Maybe shouldn't exist"
	self flag: #jmvVer2.

	^ self morphBoundsInWorld insetBy: borderWidth! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 9/17/2012 21:05'!
            invalidateRect: damageRect
        "Clip damage reports to my bounds, since drawing is clipped to my bounds."

        self == self outermostWorldMorph 
                ifTrue: [ worldState recordDamagedRect: (damageRect intersect: (0@0 extent: self morphExtent) ) ]
                ifFalse: [ super invalidateRect: damageRect ]
! !
!RectangleIndicatorMorph methodsFor: 'resizong' stamp: 'jmv 9/17/2012 11:01'!
     windowBottom: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld bottom: aNumber)! !
!RectangleIndicatorMorph methodsFor: 'resizong' stamp: 'jmv 9/17/2012 11:01'!
                      windowBottomLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self morphBoundsInWorld: (aPoint x @ self morphBoundsInWorld top corner: self morphBoundsInWorld right @ aPoint y)! !
!RectangleIndicatorMorph methodsFor: 'resizong' stamp: 'jmv 9/17/2012 11:02'!
                             windowBottomRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self morphBoundsInWorld: (self morphPositionInWorld corner: aPoint)! !
!RectangleIndicatorMorph methodsFor: 'resizong' stamp: 'jmv 9/17/2012 11:02'!
           windowLeft: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld left: aNumber)! !
!RectangleIndicatorMorph methodsFor: 'resizong' stamp: 'jmv 9/17/2012 11:02'!
                          windowRight: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld right: aNumber)! !
!RectangleIndicatorMorph methodsFor: 'resizong' stamp: 'jmv 9/17/2012 11:02'!
                        windowTop: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld top: aNumber)! !
!RectangleIndicatorMorph methodsFor: 'resizong' stamp: 'jmv 9/17/2012 11:02'!
                            windowTopLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self morphBoundsInWorld: (aPoint corner: self morphBoundsInWorld corner)! !
!RectangleIndicatorMorph methodsFor: 'resizong' stamp: 'jmv 9/17/2012 11:02'!
          windowTopRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self morphBoundsInWorld: (self morphBoundsInWorld left @ aPoint y corner: aPoint x @ self morphBoundsInWorld bottom)! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 9/17/2012 21:00'!
        zzlayoutBounds
	"Return the bounds for laying out children of the receiver"
	"Exclude the label area"

	^ self morphBoundsInWorld insetBy: (borderWidth @ (self labelHeight+borderWidth) corner: borderWidth @ borderWidth)! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 9/17/2012 10:46' prior: 50360372!
              alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor mouseButton2Pressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor mouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translatedBy: delta negated.
					newBuffRect
						areasOutside: buffRect
						do: [ :r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin ].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				prevP _ p]]]! !
!DisplayMedium methodsFor: 'bordering' stamp: 'jmv 9/17/2012 10:44' prior: 16839928!
          border: aRectangle widthRectangle: insets rule: combinationRule fillColor: aHalfTone
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of each edge of the border is determined by the four coordinates 
	of insets. Uses aHalfTone and combinationRule for drawing the border."

	aRectangle
		areasOutside: (aRectangle insetBy: insets)
		do: [ :edgeStrip |
			self fill: edgeStrip rule: combinationRule fillColor: aHalfTone ]! !
!DisplayScreen methodsFor: 'displaying' stamp: 'jmv 9/17/2012 10:44' prior: 16840492!
      forceDamageToScreen: allDamage
	"Force all the damage rects to the screen."
	| rectList excluded remaining regions |
	rectList _ allDamage.
	"Note: Reset extra regions at the beginning to prevent repeated errors"
	regions _ extraRegions.
	extraRegions _ nil.
	regions ifNotNil: [
		"exclude extra regions"
		regions do: [ :drawerAndRect |
			excluded _ drawerAndRect at: 2.
			remaining _ WriteStream on: #().
			rectList do: [ :r |
				r areasOutside: excluded do: [ :each |
					remaining nextPut: each ]].
			rectList _ remaining contents].
	].
	rectList do: [ :r | self forceToScreen: r ].
	regions ifNotNil:[
		"Have the drawers paint what is needed"
		regions do: [ :drawerAndRect | (drawerAndRect at: 1) forceToScreen ].
	]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/17/2012 20:57' prior: 50382670!
                      zzclippingBounds
	"Return the bounds to which any submorphs should be clipped if the property is set"
	"Maybe shouldn't exist"
	self flag: #jmvVer2.
	^ self morphBoundsInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/17/2012 21:01' prior: 50382689!
 zzlayoutBounds
	"Return the bounds for laying out children of the receiver"

	self flag: #jmvVer2.
	^ self zzclippingBounds! !
!Morph methodsFor: 'updating' stamp: 'jmv 9/17/2012 21:05' prior: 50380500!
                     redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Include submorphs if we don't clip!!
	Think about it. We don't to know about a specific display rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"
	
	self layoutSubmorphsIfNeeded.
	self invalidateRect: (0@0 extent: self morphExtent).
	self clipsSubmorphs ifFalse: [
		self submorphsDo: [ :m | m redrawNeeded ]]! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/17/2012 21:04' prior: 50386232!
                   restoreSavedPatchOn: aCanvas 
	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."

	hasChanged _ false.
	savedPatch ifNotNil: [
		aCanvas image: savedPatch at: savedPatch offset.
		submorphs notEmpty ifTrue: [ ^self ].

		"Make the transition to using hardware cursor. Clear savedPatch and
		 report one final damage rectangle to erase the image of the software cursor."
		owner invalidateRect: (savedPatch offset extent: savedPatch extent + self shadowOffset).
		Sensor currentCursor == Cursor normal ifFalse: [ Cursor normal show ].	"show hardware cursor"
		savedPatch _ nil ]! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/17/2012 10:46' prior: 50387684!
         savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| ownBnds fullBnds bw |
	ownBnds _ self morphBoundsInWorld.
	fullBnds _ self morphFullBoundsInWorld.
	(savedPatch isNil or: [savedPatch extent ~= fullBnds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBnds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: (fullBnds translatedBy: aCanvas canvasOrigin)
		into: savedPatch.
	savedPatch offset: fullBnds topLeft.
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth.
		aStream nextPut: ownBnds.
		prevBounds ifNotNil: [ aStream nextPut: prevBounds ].
		fullBnds
			areasOutside: (fullBnds insetBy: bw)
			do: [ :r | aStream nextPut: r ].
		prevFullBounds ifNotNil: [
			prevFullBounds areasOutside: (prevFullBounds insetBy: bw) do: [ :r |
				aStream nextPut: r ]]]
	ifFalse: [
		prevFullBounds ifNil: [
			aStream nextPut: fullBnds ]
		ifNotNil: [
			aStream nextPut: (fullBnds merge: prevFullBounds)]].
	prevBounds _ ownBnds.
	prevFullBounds _ fullBnds! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 9/17/2012 21:04' prior: 50380797!
      selectionChanged

	self paragraph selectionRects do: [:r | self invalidateRect: r ]! !
!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/17/2012 21:04' prior: 50384890!
             onBlinkCursor
	"Blink the cursor"
	paragraph ifNil: [ ^nil ].
	paragraph showCaret: paragraph showCaret not | pauseBlinking.
	pauseBlinking _ false.
	paragraph lastCaretRect ifNotNil: [ :r | self invalidateRect: r].! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 9/17/2012 21:05' prior: 50380591!
        onBlinkCursor
	"Blink the cursor"
	showCaret _ showCaret not | pauseBlinking.
	pauseBlinking _ false.
	caretRect ifNotNil: [ :r | self invalidateRect: r]! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 9/17/2012 21:05' prior: 50380599!
      pauseBlinking
	"Show a solid cursor (non blinking) for a short while"
	pauseBlinking _ true.
	"Show cursor right now if needed"
	showCaret ifFalse: [
		showCaret _ true.
		caretRect ifNotNil: [ :r | self invalidateRect: r ]]! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 9/17/2012 21:05' prior: 50380609!
                               stopBlinking
	"And do not show cursor anymore."
	self stopSteppingSelector: #onBlinkCursor.
	"Hide cursor right now if needed"
	showCaret ifTrue: [
		showCaret _ false.
		caretRect ifNotNil: [ :r | self invalidateRect: r ]]! !
!Preferences class methodsFor: 'standard queries' stamp: 'jmv 3/28/2011 19:14' prior: 50380853!
                             fastDragWindowForMorphic
	^ self
		valueOfFlag: #fastDragWindowForMorphic
		ifAbsent: [ false ]! !
!RectangleIndicatorMorph methodsFor: 'drawing' stamp: 'jmv 9/17/2012 11:07' prior: 50386733!
drawOn: aCanvas
	| bw b |

	"We are using a regular #drawOn:, and invalidating in the usual way when resizing.
	This effectively defeats the purpose of this class: optimize redraws durin resize.
	It is true that the window is not resized until finished, and no layout is done while resizing,
	but the invalidate / redraw is slow too. Think of a better implementation. But without asking
	too much to the canvas form (like xoring a pattern... is that ok? Then, we would not be a
	standard morph, and we need to replace the usual invalidate / redraw behavior with this
	xoring strategy...)
	"
	self flag: #jmvVer2.

	bw _ self defaultBorderWidth.
	b _ 0@0 extent: extent.
	aCanvas frameRectangle: b borderWidth: bw color: Color black.
	aCanvas frameRectangle: (b insetBy: bw) borderWidth: bw color: Color white! !
!Sonogram methodsFor: 'all' stamp: 'jmv 9/17/2012 21:05' prior: 50380677!
          plotColumn: dataArray

	| chm1 i normVal r |
	columnForm unhibernate.
	chm1 _ columnForm height - 1.
	0 to: chm1 do: [ :y | 
		i _ y*(dataArray size-1)//chm1 + 1.
		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).
		normVal < 0.0 ifTrue: [normVal _ 0.0].
		normVal > 1.0 ifTrue: [normVal _ 1.0].
		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].
	(lastX _ lastX + 1) > (image width - 1) ifTrue:
		[self scroll].
	image copy: (r _ (lastX@0 extent: 1@image height))
			from: (32//image depth-1)@0
			in: columnForm rule: Form over.
	"self changed."
	self invalidateRect: r! !
!SystemWindow methodsFor: 'change reporting' stamp: 'jmv 9/17/2012 21:05' prior: 50381745!
                        invalidateTitleArea

	"not really pretty... also invalidating the top border, regardless of it being above or below the title area
	(Different themes use various looks, this covers them all)"
	self invalidateRect: (0@0 extent: extent x @ (self labelHeight + borderWidth))! !

SystemWindow removeSelector: #zzinnerBounds!

SystemWindow removeSelector: #zzinnerBounds!

PluggableScrollPane removeSelector: #clipsSubmorphs!

PluggableScrollPane removeSelector: #clipsSubmorphs!

PluggableButtonMorph removeSelector: #clipsSubmorphs!

PluggableButtonMorph removeSelector: #clipsSubmorphs!

PasteUpMorph removeSelector: #invalidRect:!

PasteUpMorph removeSelector: #invalidRect:!

PasteUpMorph removeSelector: #zzinvalidRect:!

PasteUpMorph removeSelector: #zzinvalidRect:!

LayoutMorph removeSelector: #clipsSubmorphs!

LayoutMorph removeSelector: #clipsSubmorphs!

HaloMorph removeSelector: #redrawNeeded!

HaloMorph removeSelector: #redrawNeeded!

BorderedRectMorph removeSelector: #zzinnerBounds!

BorderedRectMorph removeSelector: #zzinnerBounds!

Morph removeSelector: #invalidRect:!

Morph removeSelector: #invalidRect:!

Morph removeSelector: #zzinnerBounds!

Morph removeSelector: #zzinnerBounds!

Morph removeSelector: #zzinvalidRect:!

Morph removeSelector: #zzinvalidRect:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1443-CuisCore-JuanVuletich-2012Sep17-21h09m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1443] on 18 September 2012 at 11:01:18 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 9/18/2012 22:59'!
                        clippingBoundsInWorld
	"Return the bounds to which any submorphs should be clipped if the property is set"
	"Should be a region, like our shadow"
	self flag: #jmvVer2.
	^ self morphBoundsInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/18/2012 22:37'!
                              layoutBounds
	"Return the bounds for laying out children of the receiver"
	self flag: #jmvVer2.
	^ 0@0 extent: self morphExtent! !
!BorderedRectMorph methodsFor: 'geometry' stamp: 'jmv 9/18/2012 22:59'!
                     clippingBoundsInWorld
	"Return the bounds to which any submorphs should be clipped if the property is set"
	"Should be a region, like our shadow"
	self flag: #jmvVer2.
	^ super clippingBoundsInWorld insetBy: borderWidth! !
!BorderedRectMorph methodsFor: 'geometry' stamp: 'jmv 9/18/2012 22:38'!
                         layoutBounds
	"Return the bounds for laying out children of the receiver"
	self flag: #jmvVer2.
	^ super layoutBounds insetBy: borderWidth! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 9/18/2012 23:00'!
      initialIndicatorBoundsInWorld
	^self morphBoundsInWorld outsetBy: 1! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 9/18/2012 22:40'!
                      layoutBounds
	"Return the bounds for laying out children of the receiver"
	"Exclude the label area"

	^ super layoutBounds insetBy: (0 @ (self labelHeight) corner: 0 @ 0)! !
!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 9/18/2012 23:00'!
  initialIndicatorBoundsInWorld
	^owner morphBoundsInWorld! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/18/2012 22:59' prior: 50382723!
                         drawSubmorphsOn: aCanvas 
	"Display submorphs back to front"
	submorphs isEmpty ifTrue: [ ^ self ].
	self clipsSubmorphs
		ifTrue: [
			aCanvas
				clipBy: self clippingBoundsInWorld
				during: [ :clippedCanvas | 
					submorphs reverseDo:
						[ :m |  clippedCanvas fullDraw: m ] ] ]
		ifFalse: [
			submorphs reverseDo:
				[ :m |  aCanvas fullDraw: m ] ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/18/2012 22:45' prior: 50378289!
         morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."

	self flag: #jmvVer2.

	location position = newPositionInOwner ifTrue: [
		^ self ].		"Null change"

	self redrawNeeded.

	"Maybe we don't really need an owner to run this method..."
	self validateOwnerNotNil.

	location setPosition: newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'layout' stamp: 'jmv 9/18/2012 22:34' prior: 50375799!
                  layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."
	"Only specific subclasses do layout. They redefine this method."

	layoutNeeded _ false! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/18/2012 22:45' prior: 50373169!
                    morphExtent: aPoint
	"assume it is always in our coordinates!!"
	self flag: #jmvVer2.
	self basicExtent: aPoint! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 9/18/2012 23:00' prior: 50382737!
                    mouseDown: aMouseButtonEvent localPosition: localEventPosition

	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	self cursor show.
	hand _ aMouseButtonEvent hand.
	self startStepping.
	Preferences fastDragWindowForMorphic ifTrue: [
		indicator _ RectangleIndicatorMorph new.
		indicator morphBoundsInWorld: self initialIndicatorBoundsInWorld.
		indicator openInWorld ]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 9/18/2012 22:53' prior: 50382752!
     layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		layoutNeeded _ false.
		^self].

	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self layoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self layoutBounds ].

	layoutNeeded _ false! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 9/18/2012 22:56' prior: 50375411!
                layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight t |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableWidth _ boundsForLayout width - ((submorphs size + 1) * xSep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth _ usableWidth - sumOfFixed.
	normalizationFactor _ self proportionalWidthNormalizationFactor.
	availableForPropWidth _ availableForPropWidth * normalizationFactor.
	widths _ submorphs collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + xSep max: 0) +  boundsForLayout left.
	usableHeight _ boundsForLayout height - (2*ySep) max: 0.
	boundsTop _ boundsForLayout top.	
	boundsRight _ boundsForLayout right.
	submorphs size to: 1 by: -1 do: [ :index | | m w h ls |
		m _ submorphs at: index.
		"major direction"
		w _ widths at: index.
		"minor direction"
		ls _ m layoutSpec.
		h _ (ls heightFor: usableHeight) min: usableHeight.
		t _ (usableHeight - h) * ls minorDirectionPadding + ySep + boundsTop.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		m
			morphPositionInOwner: l rounded @ t rounded;
			morphExtent: (w rounded min: boundsForLayout width)@ h rounded.
		w > 0 ifTrue: [
			l _ l + w + xSep min: boundsRight ]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 9/18/2012 22:56' prior: 50375459!
       layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom l |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableHeight _ boundsForLayout height - ((submorphs size + 1) * ySep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight _ usableHeight - sumOfFixed.
	normalizationFactor _ self proportionalHeightNormalizationFactor.
	availableForPropHeight _ availableForPropHeight * normalizationFactor.
	heights _ submorphs collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + ySep max: 0) +  boundsForLayout top.
	usableWidth _ boundsForLayout width - (2*xSep) max: 0.
	boundsLeft _ boundsForLayout left.	
	boundsBottom _ boundsForLayout bottom.
	submorphs size to: 1 by: -1 do: [ :index | | m h w ls |
		m _ submorphs at: index.
		"major direction"
		h _ heights at: index.
		"minor direction"
		ls _ m layoutSpec.
		w _ (ls widthFor: usableWidth) min: usableWidth.
		l _ (usableWidth - w) * ls minorDirectionPadding + xSep + boundsLeft.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		m
			morphPositionInOwner: l rounded @ t rounded;
			morphExtent: w rounded @ (h rounded min: boundsForLayout height).
		h > 0 ifTrue: [
			t _ t + h + ySep min: boundsBottom ]]! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 9/18/2012 22:59' prior: 50386550!
                    drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			"self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"
			self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBoundsInWorld
					during: [ :canvas | canvas image: backgroundImage at: 0@0 ]]
				ifFalse: [ aCanvas image: backgroundImage at: 0@0 ]]

		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [color class == TranslucentColor])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt current toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: 0@0 in: nil
						fillColor: color rule: Form over]
				ifFalse: [ super drawOn: aCanvas ]]! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 9/18/2012 22:46' prior: 50382883!
 layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww b |
	thickness _ 4.
	cornerExtent _ 20.
	ww _ extent x.
	wh _ extent y.
	w _ ww - cornerExtent - cornerExtent.
	h _ wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster)
		morphPositionInOwner: cornerExtent@0;
		morphExtent: w@thickness.
	(adjusters at: #bottomAdjuster)
		morphPositionInOwner: cornerExtent@(wh-thickness);
		morphExtent: w@thickness.
	(adjusters at: #leftAdjuster)
		morphPositionInOwner: 0@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #rightAdjuster)
		morphPositionInOwner: ww-thickness@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #topLeftAdjuster)
		morphPositionInOwner: 0@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster)
		morphPositionInOwner: 0@(wh-cornerExtent);
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster)
		morphPositionInOwner: ww-cornerExtent@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster)
		morphPositionInOwner: ww@wh-cornerExtent;
		morphExtent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		b _ self layoutBounds.
		layoutMorph
			morphPositionInOwner: b origin;
			morphExtent: b extent ].
	
	layoutNeeded _ false! !

WindowEdgeAdjustingMorph removeSelector: #zzinitialIndicatorBounds!

WindowEdgeAdjustingMorph removeSelector: #zzinitialIndicatorBounds!

SystemWindow removeSelector: #zzlayoutBounds!

SystemWindow removeSelector: #zzlayoutBounds!

LayoutMorph removeSelector: #zzlayoutSubmorphsHorizontallyIn:!

LayoutMorph removeSelector: #zzlayoutSubmorphsVerticallyIn:!

LayoutAdjustingMorph removeSelector: #zzinitialIndicatorBounds!

LayoutAdjustingMorph removeSelector: #zzinitialIndicatorBounds!

BorderedRectMorph removeSelector: #zzclippingBounds!

BorderedRectMorph removeSelector: #zzclippingBounds!

BorderedRectMorph removeSelector: #zzlayoutBounds!

Morph removeSelector: #zzclippingBounds!

Morph removeSelector: #zzclippingBounds!

Morph removeSelector: #zzlayoutBounds!

Morph removeSelector: #zzlayoutBounds!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1444-CuisCore-JuanVuletich-2012Sep18-22h31m-jmv.5.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1444] on 19 September 2012 at 6:35:42 pm'!

!classDefinition: #HandMorph category: #'Morphic-Kernel'!
RectangleLikeMorph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

RectangleLikeMorph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!classDefinition: #ScrollBar category: #'Morphic-Support'!
PluggableMorph subclass: #ScrollBar
	instanceVariableNames: 'slider value setValueSelector sliderShadow upButton downButton scrollDelta pageDelta interval nextPageDirection grabPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

PluggableMorph subclass: #ScrollBar
	instanceVariableNames: 'slider value setValueSelector sliderShadow upButton downButton scrollDelta pageDelta interval nextPageDirection grabPosition '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!FormCanvas methodsFor: 'accessing' stamp: 'jmv 9/19/2012 17:17'!
       currentTransformation
	"Warning. Only valid inside a #drawOn: method"
	^currentTransformation! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 9/19/2012 18:22'!
                              scrollTo: handPositionRelativeToSlider
	| v handPositionRelativeToUs |
	handPositionRelativeToUs _ slider externalize: handPositionRelativeToSlider.
	v _ (self isHorizontal
		ifTrue: [ handPositionRelativeToUs x - grabPosition x ]
		ifFalse: [ handPositionRelativeToUs y - grabPosition y ])
			- borderWidth - self buttonExtent * 1.0
				/ self freeSliderRoom.
	self setValue: v! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 9/19/2012 18:22'!
 sliderGrabbedAt: handPositionRelativeToSlider

	grabPosition _ handPositionRelativeToSlider.
	sliderShadow
		morphPositionInOwner: slider morphPositionInOwner;
		morphExtent: slider morphExtent;
		show! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/19/2012 17:54' prior: 50368407!
                              processMouseDown: aMouseButtonEvent localPosition: localEventPosition
	"System level event handling."
	aMouseButtonEvent wasHandled ifTrue: [ ^self ]. "not interested"
	aMouseButtonEvent hand removePendingBalloonFor: self.
	aMouseButtonEvent wasHandled: true.
	self activateWindow.

	"Make me modal during mouse transitions"
	aMouseButtonEvent hand newMouseFocus: self.
	aMouseButtonEvent mouseButton3Changed ifTrue: [ ^self mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition ].

	self mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.

	(self handlesMouseStillDown: aMouseButtonEvent) ifTrue:[
		self startStepping: #processMouseStillDown:localPosition:
			at: Time millisecondClockValue + self mouseStillDownThreshold
			arguments: {aMouseButtonEvent copy resetHandlerFields . localEventPosition}
			stepTime: self mouseStillDownStepRate ].
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/19/2012 17:27' prior: 50378248!
                           internalize: aPoint
	"aPoint is in owner's coordinates. Answer is in own coordinates."
	^ location internalizePosition: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/19/2012 17:28' prior: 50378260!
                  internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	| inOwners |
	self flag: #jmvVer2.
	inOwners _ owner
		ifNotNil: [ owner internalizeFromWorld: aPoint ]
		ifNil: [ aPoint ].
	^self internalize: inOwners! !
!DraggeableButtonMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 17:47' prior: 50367912!
          mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Inform the model that this button has been released. "
	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	grabSelector ifNotNil: [
		model perform: grabSelector with: localEventPosition ]! !
!DraggeableButtonMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 17:50' prior: 50367923!
                 mouseMove: aMouseMoveEvent localPosition: localEventPosition

	dragSelector ifNotNil: [
		model perform: dragSelector with: localEventPosition ]! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 9/19/2012 17:53' prior: 50356756!
                   attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m morphExtentInWorld // 2.
	m morphPosition: (self morphPosition - delta).! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 9/19/2012 17:54' prior: 50343199!
                grabMorph: aMorph from: formerOwner
	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."

	self releaseMouseFocus. "Break focus"
	self addMorphBack: aMorph.
	aMorph justGrabbedFrom: formerOwner.! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 9/19/2012 16:57' prior: 50353452!
   rowAtLocation: aPoint
	"return the number of the row at aPoint"

	^aPoint y // font height + 1 min: listItems size max: 1! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/19/2012 17:20' prior: 16869539!
               bottomVisibleRowForCanvas: aCanvas
	"return the bottom visible row in aCanvas's clip rectangle"
	| tx |
	tx _ aCanvas currentTransformation.
	^ (self rowAtLocation: (tx internalizePosition: aCanvas clipRect bottomLeft))
		max: (self rowAtLocation: (tx internalizePosition: aCanvas clipRect bottomRight))! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/19/2012 17:21' prior: 16869588!
                         drawOn: aCanvas

	listItems size = 0 ifTrue: [ ^self ].
 
	self drawSelectionOn: aCanvas.

	(self topVisibleRowForCanvas: aCanvas)
		to: (self bottomVisibleRowForCanvas: aCanvas)
		do: [ :row |
			(owner itemSelectedAmongMultiple:  row) ifTrue: [
				self drawBackgroundForMulti: row on: aCanvas. ].
			self draw: (self item: row) asStringOrText atRow: row on: aCanvas ]! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 9/19/2012 17:21' prior: 16869626!
                      topVisibleRowForCanvas: aCanvas
	"return the top visible row in aCanvas's clip rectangle"
	| tx |
	tx _ aCanvas currentTransformation.
	^ (self rowAtLocation: (tx internalizePosition: aCanvas clipRect topLeft))
		min: (self rowAtLocation: (tx internalizePosition: aCanvas clipRect topRight))! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 9/19/2012 17:54' prior: 50368914!
    didClickAndHalf

	clickAndHalfDone ifFalse: [
		clickAndHalfSelector ifNotNil: [
			"Focus was lost at buttonUp. Set it again."
			lastClickDown hand newMouseFocus: clickClient.
			clickClient perform: clickAndHalfSelector with: lastClickDown with: self lastClickLocalPosition ].
		clickAndHalfDone _ true ]! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 9/19/2012 17:54' prior: 50368936!
                    didCoubleClickAndHalf

	doubleClickAndHalfDone ifFalse: [
		dblClickAndHalfSelector ifNotNil: [
			"Focus was lost at buttonUp. Set it again."
			lastClickDown hand newMouseFocus: clickClient.
			clickClient perform: dblClickAndHalfSelector with: lastClickDown with: self lastClickLocalPosition ].
		doubleClickAndHalfDone _ true ]! !
!PluggableListMorph methodsFor: 'accessing' stamp: 'jmv 9/19/2012 17:00' prior: 16913975!
                       rowAtLocation: aPoint
	"Return the row at the given point or 0 if outside"

	| m |
	m _ self listMorph.
	^m rowAtLocation: (m internalize: aPoint)! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 17:00' prior: 50368028!
                   doubleClick: aMouseButtonEvent localPosition: localEventPosition
	| index |
	doubleClickSelector ifNil: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	index _ self rowAtLocation: localEventPosition.
	index = 0 ifTrue: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."
	^ self model perform: doubleClickSelector! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 17:01' prior: 50369666!
                            mouseDown: aMouseButtonEvent localPosition: localEventPosition

	| row |
	"First check for option (menu) click"
	aMouseButtonEvent mouseButton2Pressed ifTrue: [
		^ self mouseButton2Activity ].
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self.
		"If we are focusing, deselect, so that later selection doesn't result in deselect."
		self listMorph noSelection].
	row _ self rowAtLocation: localEventPosition.
	row = 0  ifTrue: [ ^super mouseDown: aMouseButtonEvent localPosition: localEventPosition ].
	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 17:02' prior: 50368075!
      mouseUp: aMouseButtonEvent localPosition: localEventPosition
	"The mouse came up within the list; take appropriate action"

	| row |
	row _ self rowAtLocation: localEventPosition.
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	(autoDeselect == false and: [row = 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"
	"No change if model is locked"
	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])
		ifTrue: [self changeModelSelection: 0]
		ifFalse: [self changeModelSelection: row].
	Cursor normal show.
! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 9/19/2012 17:02' prior: 50368096!
                             mouseDown: aMouseButtonEvent localPosition: localEventPosition

	| oldIndex oldVal row w |
	aMouseButtonEvent mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].

	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self ].

	row _ self rowAtLocation: localEventPosition.

	row = 0 ifTrue: [ ^super mouseDown: aMouseButtonEvent localPosition: localEventPosition ].

	w _ self ownerThatIsA: SystemWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Set or clear new primary selection (listIndex)"
		dragOnOrOff
			ifTrue: [self changeModelSelection: row]
			ifFalse: [self changeModelSelection: 0].

		"Need to restore the old one, due to how model works, and set new one."
		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
		self listSelectionAt: row put: dragOnOrOff.
		"event hand releaseMouseFocus: aMorph."
		"aMorph changed"
	].
	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 9/19/2012 17:05' prior: 50368142!
     mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (localEventPosition y < 0 and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: 0@0) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [ self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!PointerExplorerWrapper methodsFor: 'reference chain' stamp: 'jmv 9/19/2012 17:29' prior: 50380025!
                       shortestPathFromRoot: anArrayOfWrappers

	| nextLevel allPointers eachWrapper pointersToEachObject alreadyIncluded |
	alreadyIncluded _ IdentitySet new.
	nextLevel _ Array streamContents: [ :strm |
		allPointers _ Smalltalk pointersToEachIn: (anArrayOfWrappers collect: [ :eachWrapper1 | eachWrapper1 item ]).

		1 to: anArrayOfWrappers size do: [ :i |
			eachWrapper _ anArrayOfWrappers at: i.
			pointersToEachObject _ allPointers at: i.

			"Can we have any other root?"
			eachWrapper item == Smalltalk specialObjectsArray ifTrue: [
				^eachWrapper ].		"Found it!!"

			pointersToEachObject do: [ :pointingObject |
				"Reject PointerExplorer stuff (wrapper and main model).
				Reject weak refs, unles includeWeakRefs is true."
				(pointingObject class = self class or: [ pointingObject class = PointerExplorer or: [
				pointingObject class isWeak and: [model includeWeakRefs not]]]) ifFalse: [
					(alreadyIncluded includes: pointingObject) ifFalse: [
						alreadyIncluded add: pointingObject.
						strm nextPut: (self class
							with: pointingObject
							name: pointingObject identityHash asString
							model: model
							parent: eachWrapper )]]]]].

	"Release unneeded references"
	allPointers do: [ :oc |
		oc setContents: #() ].
	alreadyIncluded _ nil.
	nextLevel isEmpty ifTrue: [ ^nil ].
	^self shortestPathFromRoot: nextLevel! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 9/19/2012 17:47' prior: 50374809!
   initializeSlider
	"initialize the receiver's slider"

	sliderShadow _ RectangleLikeMorph new.
	self addMorph: sliderShadow.
	sliderShadow hide.
		
	slider _ self sliderClass new.
	slider model: self.
	slider grabSelector: #sliderGrabbedAt:.
	slider dragSelector: #scrollTo:.
	slider action: #sliderReleased.
	self addMorph: slider.

	self computeSlider! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 9/19/2012 17:48' prior: 16935091!
           sliderReleased

	grabPosition _ nil.
	sliderShadow hide! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'jmv 9/19/2012 18:34' prior: 50354451!
         visibleHeight

	^morph owner morphHeight! !

ScrollBar removeSelector: #scrollAbsolute:!

ScrollBar removeSelector: #scrollAbsolute:!

ScrollBar removeSelector: #scrollTo::!

ScrollBar removeSelector: #sliderGrabbed!

ScrollBar removeSelector: #sliderGrabbed!

!classDefinition: #ScrollBar category: #'Morphic-Support'!
PluggableMorph subclass: #ScrollBar
	instanceVariableNames: 'slider value setValueSelector sliderShadow upButton downButton scrollDelta pageDelta interval nextPageDirection grabPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

PluggableMorph subclass: #ScrollBar
	instanceVariableNames: 'slider value setValueSelector sliderShadow upButton downButton scrollDelta pageDelta interval nextPageDirection grabPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

Rectangle removeSelector: #isZero!

Rectangle removeSelector: #isZero!

PluggableListMorph removeSelector: #zzrowAtLocation:!

MouseEvent removeSelector: #targetPoint!

MouseEvent removeSelector: #targetPoint!

InnerListMorph removeSelector: #zzrowAtLocation:!

HandMorph removeSelector: #newMouseFocus:event:!

HandMorph removeSelector: #newMouseFocus:event:!

HandMorph removeSelector: #targetOffset!

HandMorph removeSelector: #targetOffset!

!classDefinition: #HandMorph category: #'Morphic-Kernel'!
RectangleLikeMorph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

RectangleLikeMorph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Morph removeSelector: #validateNotSent!

Morph removeSelector: #validateNotSent!

Collection removeSelector: #isZero!

Collection removeSelector: #isZero!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1445-CuisCore-JuanVuletich-2012Sep19-16h41m-jmv.6.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1445] on 19 September 2012 at 10:43:58 pm'!
!Morph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:35'!
                          morphContainsPoint: aPoint
	| shadow |
	"Most morphs answer true to to #isOrthoRectangularMorph, or redefine this method..."
	self isOrthoRectangularMorph ifTrue: [
		^ self morphBoundsInWorld containsPoint: aPoint ].
	
	"...But for those who not, provide correct albeit expensive behavior."
	shadow _ self ownShadowForm.
	^(shadow pixelValueAt: aPoint - shadow offset) > 0! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:35'!
                            morphContainsPoint: aPoint

	| radius other delta xOverY e |
	(self morphBoundsInWorld containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"
	e _ self morphExtentInWorld.
	e > (1@1)
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	radius _ e y asFloat / 2.
	other _ e x asFloat / 2.
	delta _ aPoint - self morphPositionInWorld - (other@radius).
	xOverY _ e x asFloat / e y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !
!HaloMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:36'!
             morphContainsPoint: aPoint 
	"This method is overridden so that, once up, the handles will stay up as long as the mouse is within the box that encloses all the handles even if it is not over any handle or over its owner."

	^target
		ifNil: [ super morphContainsPoint: aPoint ] 
		ifNotNil: [ false ]! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:35'!
                             morphContainsPoint: aPoint

	| iconOrigin |
	(self morphBoundsInWorld containsPoint: aPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin _ self morphBoundsInWorld center - (magnifiedIcon extent // 2).
			(magnifiedIcon isTransparentAt: aPoint - iconOrigin) not ]]! !
!WindowEdgeAdjustingMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:35'!
     morphContainsPoint: aPoint
	| sensitiveBorder b |
	b _ self morphBoundsInWorld.
	(b containsPoint: aPoint) ifFalse: [ ^false ].
	sensitiveBorder _ 4.
	selector caseOf: {
		[ #windowTopLeft: ] -> [ ^ aPoint x - b left < sensitiveBorder or: [ aPoint y - b top < sensitiveBorder ]].
		[ #windowTopRight: ] -> [ ^ b right - aPoint x <= sensitiveBorder or: [ aPoint y - b top < sensitiveBorder ]].
		[ #windowBottomLeft: ] -> [ ^ aPoint x - b left < sensitiveBorder or: [ b bottom - aPoint y <= sensitiveBorder ]].
		[ #windowBottomRight: ] -> [ ^ b right - aPoint x <= sensitiveBorder or: [ b bottom - aPoint y <= sensitiveBorder ]].
	}
	otherwise: [
		"all the morph is sensitive for horizontal and vertical (i.e. non corner) instances."
		^true ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/19/2012 22:37' prior: 50354715!
                               containsPoint: aPoint event: anEvent
	"Return true if aPoint is considered to be inside the receiver for the given event.
	The default implementation treats locked children as integral part of their owners."
	(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [ ^false ].
	(self morphContainsPoint: aPoint) ifTrue: [ ^true ].
	self submorphsDo: [ :m |
		(m isLocked and: [ m fullContainsPoint: aPoint ]) ifTrue: [ ^true ]].
	^false! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:37' prior: 50354745!
               fullContainsPoint: aPoint
"
	This alternative implementation is included in this comment because it could be useful someday.
	If we start to rely heavily on the use of #ownShadowForm in #containsPoint, this could be cheaper.
	
	| shadow |
	self clipSubmorphs
		ifTrue: [ ^self morphContainsPoint: aPoint ]
		ifFalse: [
			(self fullBounds containsPoint: aPoint) ifFalse: [^ false].
			(self morphContainsPoint: aPoint) ifTrue: [^ true].
			shadow _ self shadowForm.
			^(shadow pixelValueAt: aPoint - shadow offset) > 0 ]
"
	
	self flag: #jmvVer2.
	"Is the comment relevant now?"
	
	(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [ ^ false ].  "quick elimination"
	(self morphContainsPoint: aPoint) ifTrue: [ ^ true ].  "quick acceptance"
	submorphs do: [:m | (m fullContainsPoint: aPoint) ifTrue: [ ^ true ]].
	^ false! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/19/2012 22:37' prior: 50354838!
    morphsAt: aPoint behind: aMorph unlocked: aBool 
	"Return all morphs at aPoint that are behind frontMorph; if aBool is true return only unlocked, visible morphs."

	| isBack found all |
	all _ (aMorph isNil or: [owner isNil]) 
				ifTrue: [
					"Traverse down"
					(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [^#()].
					(aBool and: [self isLocked or: [self visible not]]) ifTrue: [^#()].
					nil]
				ifFalse: ["Traverse up"
					all _ owner 
								morphsAt: aPoint
								behind: self
								unlocked: aBool.
					WriteStream with: all].
	isBack _ aMorph isNil.
	self submorphsDo: [ :m |
			isBack 
				ifTrue: [
					found _ m 
								morphsAt: aPoint
								behind: nil
								unlocked: aBool.
					found notEmpty 
						ifTrue: 
							[all ifNil: [all _ WriteStream on: #()].
							all nextPutAll: found]].
			m == aMorph ifTrue: [isBack _ true]].
	(isBack and: [self morphContainsPoint: aPoint]) 
		ifTrue: 
			[all ifNil: [^Array with: self].
			all nextPut: self].
	^all ifNil: [#()] ifNotNil: [all contents]! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/19/2012 22:37' prior: 50354874!
               morphsAt: aPoint unlocked: aBool do: aBlock
	"Evaluate aBlock with all the morphs starting at the receiver which appear at aPoint. If aBool is true take only visible, unlocked morphs into account."
	| |
	(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse:[^self].
	(aBool and:[self isLocked or:[self visible not]]) ifTrue:[^self].
	self submorphsDo: [ :m |
		m morphsAt: aPoint unlocked: aBool do: aBlock].
	(self morphContainsPoint: aPoint) ifTrue:  [aBlock value: self ]! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 22:36' prior: 50369778!
    mouseUp: aMouseButtonEvent localPosition: localEventPosition
	(self morphContainsPoint: aMouseButtonEvent eventPosition)
		ifTrue: [
			self selected: (localEventPosition y // self class itemHeight) +  self firstVisible.
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!FillInTheBlankMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 22:37' prior: 50367580!
                         mouseDown: aMouseButtonEvent localPosition: localEventPosition

	(self morphContainsPoint: aMouseButtonEvent eventPosition) ifFalse: [
		^ Beeper beep]. "sent in response to outside modal click"
	aMouseButtonEvent hand grabMorph: self. "allow repositioning"! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/19/2012 22:39' prior: 50362529!
            doRecolor: evt with: aHandle
	"The mouse went down in the 'recolor' halo handle.  Allow the user to change the color of the innerTarget"

	evt hand obtainHalo: self.
	(aHandle morphContainsPoint: evt eventPosition)
		ifFalse: [  "only do it if mouse still in handle on mouse up"
			self delete.
			target addHalo: evt]
		ifTrue: [
			target changeColor]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/19/2012 22:39' prior: 50343017!
            maybeCollapse: evt with: collapseHandle 
	"Ask hand to collapse my target if mouse comes up in it."

	evt hand obtainHalo: self.
	self delete.
	(collapseHandle morphContainsPoint: evt eventPosition) 
		ifFalse: [
			target addHalo: evt ]
		ifTrue: [
			target collapse ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/19/2012 22:39' prior: 50343028!
                               maybeDismiss: evt with: dismissHandle
	"Ask hand to dismiss my target if mouse comes up in it."

	evt hand obtainHalo: self.
	(dismissHandle morphContainsPoint: evt eventPosition)
		ifFalse: [
			self delete.
			target addHalo: evt]
		ifTrue: [
			target resistsRemoval ifTrue: [
				(PopUpMenu
					confirm: 'Really throw this away'
					trueChoice: 'Yes'
					falseChoice: 'Um, no, let me reconsider') ifFalse: [^ self]].

			self delete.
			target dismissViaHalo]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/19/2012 22:39' prior: 50343046!
                           setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle morphContainsPoint: evt eventPosition)
		ifFalse: [ Color red muchLighter ]
		ifTrue: [ Color lightGray ].
	dismissHandle color: colorToUse! !
!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 9/19/2012 22:37' prior: 50343381!
                  step
	"got the #mouseLeave: message"
	| p |
	hand ifNil: [
		indicator ifNotNil: [
			indicator delete.
			indicator _ nil ].
		Cursor currentCursor == self cursor ifTrue: [
			Cursor normal show ].
		^self stopStepping ].

	"hasn't got the #mouseLeave: message (yet)"
	p _ self handPoint.
	hand lastEvent mouseButton1Pressed
		ifTrue: [
			indicator
				ifNil: [ self adjustOwnerAt: p ]
				ifNotNil: [ self adjustIndicatorAt: p ]]
		ifFalse: [
			indicator ifNotNil: [
				indicator delete.
				indicator _ nil.
				self adjustOwnerAt: p ].
			"If the button was unpressed outside the morph (can happen if you try to go outside container),
			we might not get the #mouseLeave: message"
			(self morphContainsPoint: hand morphPosition) ifFalse: [
				hand _ nil.
				Cursor normal show.
				self stopStepping ]]! !
!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 9/19/2012 22:24' prior: 50344071!
                       morphToGrab: event
	"Return the morph to grab from a mouse down event. If none, return nil."
	self submorphsDo: [ :m |
		((m rejectsEvent: event) not and: [
			m fullContainsPoint: event eventPosition ])
		ifTrue: [ ^m ]].
	^nil! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 22:37' prior: 50367902!
                               mouseUp: aMouseButtonEvent localPosition: localEventPosition

	isPressed _ false.
	mouseIsOver _ false.
	(actWhen == #buttonUp and: [ self morphContainsPoint: aMouseButtonEvent eventPosition ])
		ifTrue: [ self performAction ].
	self redrawNeeded! !

WindowEdgeAdjustingMorph removeSelector: #containsPoint:!

WindowEdgeAdjustingMorph removeSelector: #containsPoint:!

PluggableButtonMorph removeSelector: #containsPoint:!

PluggableButtonMorph removeSelector: #containsPoint:!

Paragraph removeSelector: #containsPoint:!

Paragraph removeSelector: #containsPoint:!

Paragraph removeSelector: #paragraphContainsPoint:!

HaloMorph removeSelector: #containsPoint:!

HaloMorph removeSelector: #containsPoint:!

EllipseMorph removeSelector: #containsPoint:!

EllipseMorph removeSelector: #containsPoint:!

Morph removeSelector: #containsPoint:!

Morph removeSelector: #containsPoint:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1446-CuisCore-JuanVuletich-2012Sep19-22h32m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1445] on 19 September 2012 at 10:52:09 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/19/2012 22:44'!
                               zzcontainsPoint: aPoint event: anEvent
	"Return true if aPoint is considered to be inside the receiver for the given event.
	The default implementation treats locked children as integral part of their owners."
	(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [ ^false ].
	(self morphContainsPoint: aPoint) ifTrue: [ ^true ].
	self submorphsDo: [ :m |
		(m isLocked and: [ m fullContainsPoint: aPoint ]) ifTrue: [ ^true ]].
	^false! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:44'!
                             zzfullContainsPoint: aPoint
"
	This alternative implementation is included in this comment because it could be useful someday.
	If we start to rely heavily on the use of #ownShadowForm in #containsPoint, this could be cheaper.
	
	| shadow |
	self clipSubmorphs
		ifTrue: [ ^self morphContainsPoint: aPoint ]
		ifFalse: [
			(self fullBounds containsPoint: aPoint) ifFalse: [^ false].
			(self morphContainsPoint: aPoint) ifTrue: [^ true].
			shadow _ self shadowForm.
			^(shadow pixelValueAt: aPoint - shadow offset) > 0 ]
"
	
	self flag: #jmvVer2.
	"Is the comment relevant now?"
	
	(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [ ^ false ].  "quick elimination"
	(self morphContainsPoint: aPoint) ifTrue: [ ^ true ].  "quick acceptance"
	submorphs do: [:m | (m fullContainsPoint: aPoint) ifTrue: [ ^ true ]].
	^ false! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:44'!
                     zzmorphContainsPoint: aPoint
	| shadow |
	"Most morphs answer true to to #isOrthoRectangularMorph, or redefine this method..."
	self isOrthoRectangularMorph ifTrue: [
		^ self morphBoundsInWorld containsPoint: aPoint ].
	
	"...But for those who not, provide correct albeit expensive behavior."
	shadow _ self ownShadowForm.
	^(shadow pixelValueAt: aPoint - shadow offset) > 0! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:44'!
                          zzmorphContainsPoint: aPoint

	| radius other delta xOverY e |
	(self morphBoundsInWorld containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"
	e _ self morphExtentInWorld.
	e > (1@1)
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	radius _ e y asFloat / 2.
	other _ e x asFloat / 2.
	delta _ aPoint - self morphPositionInWorld - (other@radius).
	xOverY _ e x asFloat / e y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 9/19/2012 22:44'!
          zzcontainsPoint: aPoint event: aMorphicEvent
	"mouseButton3 events are handled by the halo"

	(aMorphicEvent isMouse and: [
		aMorphicEvent isMouseDown and: [ aMorphicEvent mouseButton3Pressed ]])
	ifTrue: [
		^ self morphFullBoundsInWorld containsPoint: aMorphicEvent eventPosition ].

	^ super containsPoint: aPoint event: aMorphicEvent! !
!HaloMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:44'!
  zzmorphContainsPoint: aPoint 
	"This method is overridden so that, once up, the handles will stay up as long as the mouse is within the box that encloses all the handles even if it is not over any handle or over its owner."

	^target
		ifNil: [ super morphContainsPoint: aPoint ] 
		ifNotNil: [ false ]! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:44'!
                           zzmorphContainsPoint: aPoint

	| iconOrigin |
	(self morphBoundsInWorld containsPoint: aPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin _ self morphBoundsInWorld center - (magnifiedIcon extent // 2).
			(magnifiedIcon isTransparentAt: aPoint - iconOrigin) not ]]! !
!WindowEdgeAdjustingMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 22:44'!
   zzmorphContainsPoint: aPoint
	| sensitiveBorder b |
	b _ self morphBoundsInWorld.
	(b containsPoint: aPoint) ifFalse: [ ^false ].
	sensitiveBorder _ 4.
	selector caseOf: {
		[ #windowTopLeft: ] -> [ ^ aPoint x - b left < sensitiveBorder or: [ aPoint y - b top < sensitiveBorder ]].
		[ #windowTopRight: ] -> [ ^ b right - aPoint x <= sensitiveBorder or: [ aPoint y - b top < sensitiveBorder ]].
		[ #windowBottomLeft: ] -> [ ^ aPoint x - b left < sensitiveBorder or: [ b bottom - aPoint y <= sensitiveBorder ]].
		[ #windowBottomRight: ] -> [ ^ b right - aPoint x <= sensitiveBorder or: [ b bottom - aPoint y <= sensitiveBorder ]].
	}
	otherwise: [
		"all the morph is sensitive for horizontal and vertical (i.e. non corner) instances."
		^true ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1447-CuisCore-JuanVuletich-2012Sep19-22h43m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1445] on 19 September 2012 at 11:06:32 pm'!

!classDefinition: #InnerTextMorph category: #'Morphic-Views for Models'!
InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 9/19/2012 23:05'!
                     mutex
	mutex
		ifNil: [ mutex := Mutex new ].
	^mutex! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 9/19/2012 23:06' prior: 16869858!
                 editor
	"Return my current editor, or install a new one."
	self mutex critical: [
		editor ifNil: [ self installEditorAndParagraph ]].
	^editor! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 9/19/2012 22:54' prior: 16870356!
                         installEditorAndParagraph
	"Install an editor for my paragraph. Install also the paragraph."
	editor _ model editorClass new morph: self.
	editor model: model.

	"...Code here to recreate the paragraph... We positively know it is nil."
	paragraph _ Paragraph new.
	paragraph
		setModel: model;
		extentForComposing: self extentForComposing.
	editor paragraph: paragraph.
	paragraph editor: editor.
	editor setEmphasisHereFromText.
	paragraph composeAll.
	self fit.
	editor resetState.
	self selectionChanged! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 9/19/2012 23:06' prior: 16870381!
             paragraph
	"Paragraph instantiation is lazy -- create it only when needed"
	self mutex critical: [
		paragraph ifNil: [ self installEditorAndParagraph ]].
	^paragraph! !

!classDefinition: #InnerTextMorph category: #'Morphic-Views for Models'!
InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1448-CuisCore-JuanVuletich-2012Sep19-22h52m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1448] on 20 September 2012 at 12:16:48 am'!
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/19/2012 23:38'!
                               submorphsShadowForm
	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"
	| bnds canvas |
	bnds _ Rectangle merging: (submorphs collect: [:m | m morphFullBoundsInWorld]).
	canvas _ Display defaultCanvasClass forShadowOver: bnds.
	canvas into: self.
	self drawSubmorphsOn: canvas.
	^ canvas form offset: bnds topLeft - self morphPositionInWorld! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 9/20/2012 00:04' prior: 50342368!
                            storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."

	| bufSize stereoBuffer reverseBytes  |
	self reset.
	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"
	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.
	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.

	'Storing audio...' displayProgressAt: World activeHand morphPositionInOwner
		from: 0 to: samplesToStore during: [:bar | | remaining out |
			remaining _ samplesToStore.
			[remaining > 0] whileTrue: [
				bar value: samplesToStore - remaining.
				stereoBuffer primFill: 0.  "clear the buffer"
				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.
				self isStereo
					ifTrue: [out _ stereoBuffer]
					ifFalse: [out _ stereoBuffer extractLeftChannel].
				reverseBytes ifTrue: [out reverseEndianness].
				(aBinaryStream isKindOf: StandardFileStream)
					ifTrue: [  "optimization for files: write sound buffer directly to file"
						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"
					ifFalse: [  "for non-file streams:"
						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].
				remaining _ remaining - bufSize]].
! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/19/2012 23:15' prior: 50382976!
                        ownShadowForm
	"Return a form representing the 'shadow' of the receiver, without including submorphs 
	regardless of clipping"
	| canvas |
	canvas _ Display defaultCanvasClass forShadowOver: self morphBoundsInWorld.
	canvas into: self.
	canvas clipBy: self morphBoundsInWorld during: [ :c | self drawOn: c ].
	^ canvas form! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/19/2012 23:40' prior: 50389327!
    containsPoint: aPoint event: anEvent
	"Return true if aPoint is considered to be inside the receiver for the given event.
	The default implementation treats locked children as integral part of their owners."
	(self morphContainsPoint: aPoint) ifTrue: [ ^true ].
	self clipsSubmorphs ifFalse: [
		self submorphsDo: [ :m |
			(m isLocked and: [ m fullContainsPoint: (m internalize: aPoint) ])
				ifTrue: [ ^true ]]].
	^false! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/19/2012 23:55' prior: 50365744!
processMouseOver: aMouseEvent localPosition: localEventPosition
	"System level event handling."
	aMouseEvent hand mouseFocus == self ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: localEventPosition event: aMouseEvent) ifFalse: [
			^self ]].
	aMouseEvent hand noticeMouseOver: self event: aMouseEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/20/2012 00:15' prior: 50362936!
   rejectDropEvent: aMorphicEvent
	"This hook allows the receiver to repel a drop operation currently executed. The method is called prior to checking children so the receiver must validate that the event was really designated for it.
	Note that the ordering of the tests below is designed to avoid a (possibly expensive) #fullContainsPoint: test. If the receiver doesn't want to repel the morph anyways we don't need to check after all."
	(self repelsMorph: aMorphicEvent contents event: aMorphicEvent) ifFalse: [^self]. "not repelled"
	(self fullContainsPoint: (self internalizeFromWorld: aMorphicEvent eventPosition)) ifFalse: [^self]. "not for me"
	"Throw it away"
	aMorphicEvent wasHandled: true.
	aMorphicEvent contents rejectDropMorphEvent: aMorphicEvent! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 23:39' prior: 50389344!
                  fullContainsPoint: aPoint
"
	This alternative implementation is included in this comment because it could be useful someday.
	If we start to rely heavily on the use of #ownShadowForm in #morphContainsPoint, this could be cheaper.
	
	| shadow |
	self clipSubmorphs
		ifTrue: [ ^self morphContainsPoint: aPoint ]
		ifFalse: [
			(self fullBounds containsPoint: aPoint) ifFalse: [^ false].
			(self morphContainsPoint: aPoint) ifTrue: [^ true].
			shadow _ self shadowForm.
			^(shadow pixelValueAt: aPoint - shadow offset) > 0 ]
"
	
	self flag: #jmvVer2.
	"Is the comment relevant now?"

	(self morphContainsPoint: aPoint) ifTrue: [ ^ true ].  "quick acceptance"
	self clipsSubmorphs ifFalse: [
		submorphs do: [ :m |
			(m fullContainsPoint: (m internalize: aPoint)) ifTrue: [ ^ true ]]].
	^ false! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 23:16' prior: 50389241!
            morphContainsPoint: aPoint
	| shadow |
	"Most morphs answer true to to #isOrthoRectangularMorph, or redefine this method..."
	self isOrthoRectangularMorph ifTrue: [
		^ (0@0 extent: self morphExtent) containsPoint: aPoint ].
	
	"...But for those who not, provide correct albeit expensive behavior."
	shadow _ self ownShadowForm.
	^(shadow pixelValueAt: aPoint) > 0! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 9/20/2012 00:06' prior: 50342633!
                      editBalloonHelpContent: aString
	| reply |
	reply _ FillInTheBlank
		multiLineRequest: 'Edit the balloon help text for ' , (self printStringLimitedTo: 40)
		centerAt: self world activeHand morphPositionInOwner
		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])
		answerHeight: 200.
	reply ifNil: [^ self].  "User cancelled out of the dialog"
	(reply isEmpty or: [reply asString = self noHelpString])
		ifTrue: [self setBalloonText: nil]
		ifFalse: [self setBalloonText: reply]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 9/19/2012 23:42' prior: 50365079!
               transferHalo: event from: formerHaloOwner
	"Progressively transfer the halo to the next likely recipient"
	| w eventLocalPos |

	"Never transfer halo to top-most world"
	(self isWorldMorph and:[owner isNil]) ifFalse: [
		(formerHaloOwner ~~ self) 
			ifTrue: [ ^self addHalo: event from: formerHaloOwner ]].

	eventLocalPos _ self internalizeFromWorld: event eventPosition.
	event shiftPressed ifTrue: [
		"Pass it outwards"
		owner ifNotNil: [ ^owner transferHalo: event from: formerHaloOwner ].
		"We're at the top level; throw the event back in to find recipient"
		formerHaloOwner removeHalo.
		^self dispatchEvent: event copy resetHandlerFields localPosition: eventLocalPos.
	].
	self submorphsDo: [ :m |
		(m fullContainsPoint: (m internalize: eventLocalPos)) 
			ifTrue: [ ^m transferHalo: event from: formerHaloOwner ].
	].
	"We're at the bottom most level; throw the event back up to the root to find recipient"
	formerHaloOwner removeHalo.
	(w _ self world) ifNil: [ ^self ].
	^w dispatchEvent: event copy resetHandlerFields localPosition: event eventPosition! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/20/2012 00:12' prior: 50389373!
                        morphsAt: aPoint behind: aMorph unlocked: aBool 
	"Return all morphs at aPoint that are behind frontMorph; if aBool is true return only unlocked, visible morphs."

	| isBack found all |
	all _ (aMorph isNil or: [owner isNil]) 
				ifTrue: [
					"Traverse down"
					(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse: [^#()].
					(aBool and: [self isLocked or: [self visible not]]) ifTrue: [^#()].
					nil]
				ifFalse: ["Traverse up"
					all _ owner 
								morphsAt: aPoint
								behind: self
								unlocked: aBool.
					WriteStream with: all].
	isBack _ aMorph isNil.
	self submorphsDo: [ :m |
			isBack 
				ifTrue: [
					found _ m 
								morphsAt: aPoint
								behind: nil
								unlocked: aBool.
					found notEmpty 
						ifTrue: 
							[all ifNil: [all _ WriteStream on: #()].
							all nextPutAll: found]].
			m == aMorph ifTrue: [isBack _ true]].
	(isBack and: [self morphContainsPoint: (self internalizeFromWorld: aPoint)]) 
		ifTrue: 
			[all ifNil: [^Array with: self].
			all nextPut: self].
	^all ifNil: [#()] ifNotNil: [all contents]! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/20/2012 00:12' prior: 50389409!
                  morphsAt: aPoint unlocked: aBool do: aBlock
	"Evaluate aBlock with all the morphs starting at the receiver which appear at aPoint. If aBool is true take only visible, unlocked morphs into account."
	| |
	(self morphFullBoundsInWorld containsPoint: aPoint) ifFalse:[^self].
	(aBool and:[self isLocked or:[self visible not]]) ifTrue:[^self].
	self submorphsDo: [ :m |
		m morphsAt: aPoint unlocked: aBool do: aBlock].
	(self morphContainsPoint: (self internalizeFromWorld: aPoint)) ifTrue:  [ aBlock value: self ]! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 23:58' prior: 50389427!
      mouseUp: aMouseButtonEvent localPosition: localEventPosition
	(self morphContainsPoint: localEventPosition)
		ifTrue: [
			self selected: (localEventPosition y // self class itemHeight) +  self firstVisible.
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 23:17' prior: 50389256!
   morphContainsPoint: aPoint

	| radius other delta xOverY e |
	((0@0 extent: self morphExtent) containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"
	e _ self morphExtent.
	e > (1@1)
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	radius _ e y asFloat / 2.
	other _ e x asFloat / 2.
	delta _ aPoint - (other@radius).
	xOverY _ e x asFloat / e y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !
!FillInTheBlankMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 23:58' prior: 50389440!
                         mouseDown: aMouseButtonEvent localPosition: localEventPosition

	(self morphContainsPoint: localEventPosition) ifFalse: [
		^ Beeper beep]. "sent in response to outside modal click"
	aMouseButtonEvent hand grabMorph: self. "allow repositioning"! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 9/20/2012 00:04' prior: 50342771!
                               request: queryString
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph request: 'What is your favorite color?'"

	^ self
		request: queryString
		initialAnswer: ''
		centerAt: World activeHand morphPositionInOwner! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 9/20/2012 00:05' prior: 50342786!
        request: queryString initialAnswer: defaultAnswer 
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'"

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: World activeHand morphPositionInOwner! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 9/19/2012 23:34' prior: 50363006!
  containsPoint: aPoint event: aMorphicEvent
	"mouseButton3 events are handled by the halo"

	(aMorphicEvent isMouse and: [
		aMorphicEvent isMouseDown and: [ aMorphicEvent mouseButton3Pressed ]])
	ifTrue: [
		^ (0@0 extent: extent) containsPoint: aPoint ].

	^false! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 9/19/2012 23:43' prior: 16863713!
                           rejectsEvent: anEvent
	"Return true to reject the given event. Rejecting an event means neither the receiver nor any of it's submorphs will be given any chance to handle it."
	(super rejectsEvent: anEvent) ifTrue: [^true].
	anEvent isDropEvent ifTrue: [^true]. "never attempt to drop on halos"
	^false! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:00' prior: 50389451!
doRecolor: evt with: aHandle
	"The mouse went down in the 'recolor' halo handle.  Allow the user to change the color of the innerTarget"

	evt hand obtainHalo: self.
	(aHandle morphContainsPoint: (aHandle internalizeFromWorld: evt eventPosition))
		ifFalse: [  "only do it if mouse still in handle on mouse up"
			self delete.
			target addHalo: evt]
		ifTrue: [
			target changeColor]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:01' prior: 50389465!
            maybeCollapse: evt with: collapseHandle 
	"Ask hand to collapse my target if mouse comes up in it."

	evt hand obtainHalo: self.
	self delete.
	(collapseHandle morphContainsPoint: (collapseHandle internalizeFromWorld: evt eventPosition)) 
		ifFalse: [
			target addHalo: evt ]
		ifTrue: [
			target collapse ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:01' prior: 50389477!
                        maybeDismiss: evt with: dismissHandle
	"Ask hand to dismiss my target if mouse comes up in it."

	evt hand obtainHalo: self.
	(dismissHandle morphContainsPoint: (dismissHandle internalizeFromWorld: evt eventPosition))
		ifFalse: [
			self delete.
			target addHalo: evt]
		ifTrue: [
			target resistsRemoval ifTrue: [
				(PopUpMenu
					confirm: 'Really throw this away'
					trueChoice: 'Yes'
					falseChoice: 'Um, no, let me reconsider') ifFalse: [^ self]].

			self delete.
			target dismissViaHalo]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:01' prior: 50389495!
                     setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle morphContainsPoint:  (dismissHandle internalizeFromWorld: evt eventPosition))
		ifFalse: [ Color red muchLighter ]
		ifTrue: [ Color lightGray ].
	dismissHandle color: colorToUse! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/19/2012 23:38' prior: 50386199!
                       nonCachingFullDrawOn: aCanvas
	| shadowForm |
	"A HandMorph has unusual drawing requirements:
		1. the hand itself (i.e., the cursor) appears in front of its submorphs
		2. morphs being held by the hand cast a shadow on the world/morphs below
	The illusion is that the hand plucks up morphs and carries them above the world."
	"Note: This version does not cache an image of the morphs being held by the hand.
	 Thus, it is slower for complex morphs, but consumes less space."

	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"

	"Note: We use a shadow form here to prevent drawing
	overlapping morphs multiple times using the transparent
	shadow color."
	shadowForm _ self submorphsShadowForm.

	"draw shadows"
	aCanvas stencil: shadowForm at: shadowForm offset  + self shadowOffset color: (Color black alpha: 0.5).
	
	"draw morphs in front of shadows"
	self drawSubmorphsOn: aCanvas.
	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 9/20/2012 00:05' prior: 50353387!
           popUpForHand: aHand
	"Pop up the receiver as balloon help for the given hand"

	| xcess |
	(contents isNil or: [ contents isEmpty ]) ifTrue: [ ^self ].
	aHand world addMorphFront: self.
	self morphPosition: aHand morphPositionInOwner + (-6@20).
	xcess _ self morphPositionInWorld x + self morphExtentInWorld x - aHand world morphWidth.
	xcess > 0 ifTrue: [
		self morphPosition: self morphPosition - (xcess@0) ].
	aHand balloonHelp: self! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 9/20/2012 00:05' prior: 50353628!
           handPoint

	^ hand morphPositionInOwner adhereTo: owner morphBoundsInWorld! !
!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 9/20/2012 00:10' prior: 50389509!
                       step
	"got the #mouseLeave: message"
	| p |
	hand ifNil: [
		indicator ifNotNil: [
			indicator delete.
			indicator _ nil ].
		Cursor currentCursor == self cursor ifTrue: [
			Cursor normal show ].
		^self stopStepping ].

	"hasn't got the #mouseLeave: message (yet)"
	p _ self handPoint.
	hand lastEvent mouseButton1Pressed
		ifTrue: [
			indicator
				ifNil: [ self adjustOwnerAt: p ]
				ifNotNil: [ self adjustIndicatorAt: p ]]
		ifFalse: [
			indicator ifNotNil: [
				indicator delete.
				indicator _ nil.
				self adjustOwnerAt: p ].
			"If the button was unpressed outside the morph (can happen if you try to go outside container),
			we might not get the #mouseLeave: message"
			(self morphContainsPoint: (self internalizeFromWorld: hand morphPositionInOwner)) ifFalse: [
				hand _ nil.
				Cursor normal show.
				self stopStepping ]]! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 9/20/2012 00:05' prior: 50343421!
                           chooseMagnification: evt
	| handle origin aHand currentMag |
	currentMag _ magnification.
	aHand _ evt ifNil: [ self world activeHand ] ifNotNil: [evt hand].
	origin _ aHand morphPositionInOwner y.
	handle _ HandleMorph new forEachPointDo:
		[ :newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag ].
	aHand attachMorph: handle.
	handle startStepping.
	self redrawNeeded. ! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 9/20/2012 00:05' prior: 50356977!
                              sourcePoint
	"If we are being dragged use our center, otherwise use pointer position"
	^ (trackPointer not or: [owner notNil and: [owner is: #HandMorph]])
		ifTrue: [ self morphBoundsInWorld center ]
		ifFalse: [ self activeHand morphPositionInOwner ]! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/20/2012 00:14' prior: 50343495!
               activateOwnerMenu: evt
	"Activate our owner menu; e.g., pass control to it"
	owner ifNil: [ ^false ]. "not applicable"
	(owner morphContainsPoint: (owner internalizeFromWorld: evt eventPosition))
		ifFalse: [ ^false ].
	owner activate: evt.
	^true! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/20/2012 00:15' prior: 50343505!
                   activateSubmenu: evt
	"Activate our submenu; e.g., pass control to it"
	subMenu ifNil: [ ^false ]. "not applicable"
	(subMenu morphContainsPoint: (subMenu internalizeFromWorld: evt eventPosition)) ifFalse:[^false].
	subMenu activate: evt.
	self removeAlarm: #deselectTimeOut:.
	^true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/20/2012 00:05' prior: 50343573!
                  popUpForHand: hand in: aWorld
	| p |
	"Present this menu under control of the given hand."

	p _ hand morphPositionInOwner truncated.
	^self popUpAt: p forHand: hand in: aWorld
! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/20/2012 00:06' prior: 50343581!
                            popUpInWorld: aWorld
	"Present this menu under control of the given hand."
	^self
		popUpAt: aWorld activeHand morphPositionInOwner
		forHand: aWorld activeHand
		in: aWorld
! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 23:40' prior: 50367766!
mouseDown: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse down event."
	(stayUp or: [ self fullContainsPoint:localEventPosition ]) 
		ifFalse: [ ^self deleteIfPopUp: aMouseButtonEvent ]. "click outside"
	self isSticky ifTrue: [ ^self ].
	"Grab the menu and drag it to some other place"
	aMouseButtonEvent hand grabMorph: self! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 23:40' prior: 50367780!
                   mouseUp: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event.
	Note: This might be sent from a modal shell."
	(self fullContainsPoint: localEventPosition) ifFalse:[
		"Mouse up outside. Release eventual focus and delete if pop up."
		aMouseButtonEvent hand releaseMouseFocus: self.
		^ self deleteIfPopUp: aMouseButtonEvent ].
	stayUp ifFalse: [
		"Still in pop-up transition; keep focus"
		aMouseButtonEvent hand newMouseFocus: self ]! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 9/20/2012 00:06' prior: 50343648!
   sightTarget: event 
	| bullseye menu newTarget |
	owner
		ifNil: [^ self ].
	bullseye _ Point fromUserWithCursor: Cursor target.
	ActiveHand morphPositionInOwner: bullseye.
	menu _ CustomMenu new.
	(owner morphsAt: bullseye) do: [ :m |
		menu add: m printString action: m ].
	menu title: self printString, ' targets... '.
	newTarget _ menu startUp.
	newTarget
		ifNil: [^ self].
	self target: newTarget! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 9/20/2012 00:05' prior: 50343664!
                     invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu"

	^ self invokeModalAt: ActiveHand morphPositionInOwner in: ActiveWorld allowKeyboard: allowKeyboardControl! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:06' prior: 50353772!
       positionAt: aPoint relativeTo: aMenuItem
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	self morphBoundsInWorld right > owner world morphBoundsInWorld right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ self morphBoundsInWorld amountToTranslateWithin:
		(owner world morphBoundsInWorld withHeight: ((owner world morphExtentInWorld y - 18) max: (ActiveHand morphPositionInOwner y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 9/20/2012 00:05' prior: 50347049!
             informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ ActiveWorld.
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph morphWidth: titleString width + 8.
		self morphPositionInOwner: w activeHand morphPositionInOwner.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 9/19/2012 23:55' prior: 50365235!
              dispatchWith: aMorph localPosition: positionInAMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside eventPositionInChild |
	"See if we're fully outside aMorphs bounds"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: positionInAMorph event: self ].
	inside ifTrue: [ ^ self sentTo: aMorph localPosition: positionInAMorph ].
	^ #rejected! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 9/19/2012 23:54' prior: 50368997!
                       dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside eventPositionInChild |

	"Try to get out quickly"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: self.
	self wasHandled ifTrue: [^self ].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: positionInAMorph event: self ].
	inside ifTrue: [ ^ self sentTo: aMorph localPosition: positionInAMorph].
	^#rejected! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/19/2012 23:55' prior: 50365353!
                             dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| globalPt aMorphHandlesIt handledByInner lastHandler answer eventPositionInChild |

	"Only for MouseDown"
	self isMouseDown
		ifFalse: [ ^super dispatchWith: aMorph localPosition: positionInAMorph ].

	"Try to get out quickly"
	globalPt _ self eventPosition.
	(aMorph morphFullBoundsInWorld containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ eventHandler.
	aMorphHandlesIt _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isPlayfieldLike or: [ self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self)
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ aMorph containsPoint: positionInAMorph event: self ])
		ifTrue:[
			"aMorph is in the top-most unlocked, visible morph in the chain."
			aMorphHandlesIt ifTrue: [ self sentTo: aMorph localPosition: positionInAMorph ].
			answer _ self ]
		ifFalse: [
			"Mouse was not on aMorph nor any of its children"
			answer _ #rejected ].

	eventHandler _ lastHandler.
	^answer! !
!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 9/19/2012 23:43' prior: 50389538!
morphToGrab: event
	"Return the morph to grab from a mouse down event. If none, return nil."
	| p |
	p _ event eventPosition.
	self submorphsDo: [ :m |
		((m rejectsEvent: event) not and: [
			m fullContainsPoint: (m internalize: p) ])
		ifTrue: [ ^m ]].
	^nil! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 9/19/2012 23:59' prior: 50389549!
                               mouseUp: aMouseButtonEvent localPosition: localEventPosition

	isPressed _ false.
	mouseIsOver _ false.
	(actWhen == #buttonUp and: [ self morphContainsPoint: localEventPosition ])
		ifTrue: [ self performAction ].
	self redrawNeeded! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 23:17' prior: 50389287!
                morphContainsPoint: aPoint

	| iconOrigin |
	((0@0 extent: self morphExtent) containsPoint: aPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin _ self morphExtent - magnifiedIcon extent // 2.
			(magnifiedIcon isTransparentAt: aPoint - iconOrigin) not ]]! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 9/20/2012 00:06' prior: 50344508!
       startUpWithoutKeyboard
	"Display and make a selection from the receiver as long as the button  is pressed. Answer the current selection.  Do not allow keyboard input into the menu"
	
	^ self startUpWithCaption: nil at: ActiveHand morphPositionInOwner allowKeyboard: false! !
!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 9/20/2012 00:06' prior: 50344968!
             handPoint
	^ hand morphPositionInOwner! !
!WindowEdgeAdjustingMorph methodsFor: 'geometry testing' stamp: 'jmv 9/19/2012 23:18' prior: 50389300!
               morphContainsPoint: aPoint
	| sensitiveBorder b |
	b _ 0@0 extent: self morphExtent.
	(b containsPoint: aPoint) ifFalse: [ ^false ].
	sensitiveBorder _ 4.
	selector caseOf: {
		[ #windowTopLeft: ] -> [ ^ aPoint x - b left < sensitiveBorder or: [ aPoint y - b top < sensitiveBorder ]].
		[ #windowTopRight: ] -> [ ^ b right - aPoint x <= sensitiveBorder or: [ aPoint y - b top < sensitiveBorder ]].
		[ #windowBottomLeft: ] -> [ ^ aPoint x - b left < sensitiveBorder or: [ b bottom - aPoint y <= sensitiveBorder ]].
		[ #windowBottomRight: ] -> [ ^ b right - aPoint x <= sensitiveBorder or: [ b bottom - aPoint y <= sensitiveBorder ]].
	}
	otherwise: [
		"all the morph is sensitive for horizontal and vertical (i.e. non corner) instances."
		^true ]! !

WindowEdgeAdjustingMorph removeSelector: #zzmorphContainsPoint:!

WindowEdgeAdjustingMorph removeSelector: #zzmorphContainsPoint:!

PluggableButtonMorph removeSelector: #zzmorphContainsPoint:!

PluggableButtonMorph removeSelector: #zzmorphContainsPoint:!

HandMorph removeSelector: #shadowForm!

HandMorph removeSelector: #shadowForm!

HaloMorph removeSelector: #morphContainsPoint:!

HaloMorph removeSelector: #morphContainsPoint:!

HaloMorph removeSelector: #zzcontainsPoint:event:!

HaloMorph removeSelector: #zzcontainsPoint:event:!

HaloMorph removeSelector: #zzmorphContainsPoint:!

HaloMorph removeSelector: #zzmorphContainsPoint:!

EllipseMorph removeSelector: #zzmorphContainsPoint:!

EllipseMorph removeSelector: #zzmorphContainsPoint:!

Morph removeSelector: #zzcontainsPoint:event:!

Morph removeSelector: #zzcontainsPoint:event:!

Morph removeSelector: #zzfullContainsPoint:!

Morph removeSelector: #zzfullContainsPoint:!

Morph removeSelector: #zzmorphContainsPoint:!

Morph removeSelector: #zzmorphContainsPoint:!

Morph removeSelector: #zzownShadowForm!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1449-CuisCore-JuanVuletich-2012Sep19-23h53m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1449] on 20 September 2012 at 10:37:17 pm'!
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 9/20/2012 22:11'!
    itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last |
	self hasSubmorphs ifFalse: [ ^nil ].
	(aPoint > (0@0) and: [ aPoint < extent ]) ifFalse: [ ^nil ].
	ptY _ aPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	self firstSubmorph morphPositionInOwner y > ptY ifTrue: [ ^nil ].
	last _ self lastSubmorph.
	last morphPositionInOwner y + last morphHeight < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^self 
		findSubmorphBinary: [ :m |
			(m morphPositionInOwner y <= ptY and: [ m morphPositionInOwner y + m morphHeight >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPositionInOwner y + (m morphHeight // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 9/20/2012 22:12' prior: 50381648!
        itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	^scroller itemFromPoint: (scroller internalize: aPoint)! !
!InnerPluggableMorph methodsFor: 'geometry' stamp: 'jmv 9/20/2012 22:05' prior: 50353421!
            adjustExtent
	self flag: #jmvVer2.	"Do it just adding submorph extents!!"
	self submorphBounds ifNotNil: [ :r |
		self morphExtent: r bottomRight - self morphPositionInWorld ]! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/20/2012 21:55' prior: 50386284!
             drawLineToggleToTextFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor hasToggle: hasToggle
	"If I am not the only item in my container, draw the line between:
		- my toggle (if any) or my left edge (if no toggle)
		- and my text left edge"

	| aMorphCenter hLineY hLineLeft rect right |
	anIndentingListItemMorph isSoleItem ifTrue: [ ^ self ].
	rect _ anIndentingListItemMorph toggleRectangle.
	aMorphCenter _ anIndentingListItemMorph externalize: rect center.
	right _ (anIndentingListItemMorph externalize: rect rightCenter) x.
	hLineY _ aMorphCenter y.
	hasToggle
		ifTrue: [ hLineLeft _ right - 3 ]
		ifFalse: [ hLineLeft _ aMorphCenter x - 1 ].
	"Draw line from toggle to text"
	aCanvas
		line: hLineLeft @ hLineY
		to: right + 0 @ hLineY
		width: 1
		color: lineColor! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/20/2012 22:36' prior: 50387727!
          drawLinesOn: aCanvas 
	| lColor bottomY topY tx |
	lColor _ Theme current line.
	tx _ aCanvas currentTransformation.
	topY _ (tx internalizePosition: aCanvas clipRect topLeft) y min: (tx internalizePosition: aCanvas clipRect topRight) y.
	bottomY _ (tx internalizePosition: aCanvas clipRect bottomLeft) y max: (tx internalizePosition: aCanvas clipRect bottomRight) y.
	self submorphs do: [ :submorph | 
		(submorph isExpanded or: [
			(submorph morphPositionInOwner y between: topY and: bottomY) or: [
				submorph nextSibling notNil and: [
					submorph nextSibling morphPositionInOwner y between: topY and: bottomY ] ] ])
		ifTrue: [
			self
				drawLinesFor: submorph
				on: aCanvas
				lineColor: lColor ]]
	! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/20/2012 21:49' prior: 50386312!
                   drawLinesToFirstChildFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor
	"Draw line from me to next sibling"

	| vLineX vLineTop vLineBottom childCenter firstChild |
	"child in the drawn tree. it is acually our submorph"
	firstChild _ anIndentingListItemMorph firstChild.
	childCenter _ firstChild externalize: firstChild toggleRectangle center.
	vLineX _ childCenter x - 1.
	vLineTop _ (anIndentingListItemMorph
		externalize: anIndentingListItemMorph morphExtent) y.
	firstChild hasToggle
		ifTrue: [ vLineBottom _ childCenter y - 7 ]
		ifFalse: [ vLineBottom _ childCenter y ].
	aCanvas
		line: vLineX @ vLineTop
		to: vLineX @vLineBottom
		width: 1
		color: lineColor! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/20/2012 21:47' prior: 50386337!
                 drawLinesToNextSiblingFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor hasToggle: hasToggle
	| vLineX aMorphCenter vLineTop vLineBottom nextSibCenter nextSibling |

	nextSibling _ anIndentingListItemMorph nextSibling.
	nextSibCenter _ nextSibling externalize: nextSibling toggleRectangle center.

	aMorphCenter _ anIndentingListItemMorph externalize:
		 anIndentingListItemMorph toggleRectangle center.
	vLineX _ aMorphCenter x - 1.
	hasToggle
		ifTrue: [ vLineTop _ aMorphCenter y + 5 ]
		ifFalse: [ vLineTop _ aMorphCenter y ].
	nextSibling hasToggle
		ifTrue: [ vLineBottom _ nextSibCenter y - 7 ]
		ifFalse: [ vLineBottom _ nextSibCenter y ].
	"Draw line from me to next sibling"
	aCanvas
		line: vLineX @ vLineTop
		to: vLineX @ vLineBottom
		width: 1
		color: lineColor! !

InnerHierarchicalListMorph removeSelector: #bottomVisibleItemForCanvas:!

InnerHierarchicalListMorph removeSelector: #topVisibleItemForCanvas:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1450-CuisCore-JuanVuletich-2012Sep20-21h37m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1450] on 21 September 2012 at 2:46:24 pm'!
!PasteUpMorph methodsFor: 'halos and balloon help' stamp: 'jmv 9/21/2012 14:37'!
                           wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"

	self isWorldMorph ifFalse: [
		^super wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph ].

	^#(addDebugHandle: addMenuHandle: addHelpHandle:)
		statePointsTo: aSelector! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 9/21/2012 14:40' prior: 50362312!
                               addHandlesTo: aHaloMorph box: box
	"Add halo handles to the halo.  Apply the halo filter if appropriate"

	aHaloMorph haloBox: box.
	Preferences haloSpecifications do: [ :aSpec |
		(self
			wantsHaloHandleWithSelector: aSpec addHandleSelector
			inHalo: aHaloMorph) ifTrue: [
		aHaloMorph
			perform: aSpec addHandleSelector
			with: aSpec ]].
	aHaloMorph target
		addOptionalHandlesTo: aHaloMorph
		box: box! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 9/21/2012 14:39' prior: 16898276!
          wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"

	Preferences selectiveHalos ifFalse: [
		^true ].

	(#(#addDismissHandle: ) includes: aSelector)
		ifTrue: [ ^ self resistsRemoval not ].
	(#(#addDragHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToBrownDragEasily ].
	(#(#addGrowHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToResizeEasily ].
	(#(#addRotateHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToRotateEasily ].
	(#(#addRecolorHandle: ) includes: aSelector)
		ifTrue: [ ^ self wantsRecolorHandle ].
	^ true! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/21/2012 14:44' prior: 50375271!
                   addHandles
	| box |
	self removeAllMorphs.  "remove old handles, if any"
	self morphBoundsInWorld: target worldBoundsForHalo.  "update my size"
	box _ self basicBox.

	target addHandlesTo: self box: box.

	self addNameBeneath: self basicBox string: (target printStringLimitedTo: 40).
	growingOrRotating _ false.
	self redrawNeeded! !

Preferences class removeSelector: #haloSpecificationsForWorld!

Preferences class removeSelector: #haloSpecificationsForWorld!

HaloMorph removeSelector: #addHandlesForWorldHalos!

HaloMorph removeSelector: #addHandlesForWorldHalos!

HaloMorph removeSelector: #addName!

HaloMorph removeSelector: #addName!

Morph removeSelector: #addWorldHandlesTo:box:!

Morph removeSelector: #addWorldHandlesTo:box:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1451-CuisCore-JuanVuletich-2012Sep21-14h31m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1450] on 21 September 2012 at 2:53:57 pm'!

!classDefinition: #HandleMorph category: #'Morphic-Widgets'!
EllipseMorph subclass: #HandleMorph
	instanceVariableNames: 'pointBlock lastPointBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

EllipseMorph subclass: #HandleMorph
	instanceVariableNames: 'pointBlock lastPointBlock '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/21/2012 14:49' prior: 50381465!
                             addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleLikeMorph new
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph morphHeight + 5).
	nameBackground morphPositionInOwner: nameMorph morphPositionInOwner - 2.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	^nameMorph! !

HandleMorph removeSelector: #justDroppedInto:event:!

HandleMorph removeSelector: #justDroppedInto:event:!

!classDefinition: #HandleMorph category: #'Morphic-Widgets'!
EllipseMorph subclass: #HandleMorph
	instanceVariableNames: 'pointBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

EllipseMorph subclass: #HandleMorph
	instanceVariableNames: 'pointBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1452-CuisCore-JuanVuletich-2012Sep21-14h46m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1450] on 21 September 2012 at 3:18:04 pm'!
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/21/2012 15:05' prior: 50388133!
                  savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| ownBnds fullBnds |
	ownBnds _ self morphBoundsInWorld.
	fullBnds _ self morphFullBoundsInWorld.
	(savedPatch isNil or: [savedPatch extent ~= fullBnds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBnds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: (fullBnds translatedBy: aCanvas canvasOrigin)
		into: savedPatch.
	savedPatch offset: fullBnds topLeft.
	prevFullBounds
		ifNil: [ aStream nextPut: fullBnds ]
		ifNotNil: [ aStream nextPut: (fullBnds merge: prevFullBounds)].
	prevBounds _ ownBnds.
	prevFullBounds _ fullBnds! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 9/21/2012 15:06' prior: 50388425!
                       mouseDown: aMouseButtonEvent localPosition: localEventPosition

	super mouseDown: aMouseButtonEvent localPosition: localEventPosition.
	self cursor show.
	hand _ aMouseButtonEvent hand.
	self startStepping! !
!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 9/21/2012 15:17' prior: 50390341!
                    step
	"got the #mouseLeave: message"
	| p |
	hand ifNil: [
		Cursor currentCursor == self cursor ifTrue: [
			Cursor normal show ].
		^self stopStepping ].

	"hasn't got the #mouseLeave: message (yet)"
	p _ hand morphPositionInOwner.
	hand lastEvent mouseButton1Pressed
		ifTrue: [
			self adjustOwnerAt: p ]
		ifFalse: [
			"If the button was unpressed outside the morph (can happen if you try to go outside container),
			we might not get the #mouseLeave: message"
			(self morphContainsPoint: (self internalizeFromWorld: p)) ifFalse: [
				hand _ nil.
				Cursor normal show.
				self stopStepping ]]! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 9/21/2012 15:06' prior: 50361806!
           cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(simpleMenus false)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(allowUnderscoreAssignments false)
		(allowUnderscoreSelectors false)
		(syntaxHighlightingAsYouTypeAnsiAssignment false)
		(syntaxHighlightingAsYouTypeLeftArrowAssignment false)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 9/21/2012 15:06' prior: 50350281!
           slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(simpleMenus false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 9/21/2012 15:07' prior: 50380904!
      displayWorld: aWorld submorphs: submorphs
	"Update this world's display."

	| deferredUpdateMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.
	deferredUpdateMode ifFalse: [ self assuredNonDisplayCanvas ].

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.

	"Check which hands need to be drawn (they are not the hardware mouse pointer)"
	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"Draw hands (usually carying morphs) onto world canvas"
	handsToDraw reverseDo: [ :h | canvas fullDraw: h ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ aWorld flashRects: allDamage ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateMode
		ifTrue: [ self forceDamageToScreen: allDamage ]
		ifFalse: [ canvas showAt: aWorld viewBox origin invalidRects: allDamage ].

	"Restore world canvas under hands and their carried morphs"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].
	Display deferUpdates: false; forceDisplayUpdate! !

WorldState removeSelector: #drawHand:!

WorldState removeSelector: #drawHand:!

WindowEdgeAdjustingMorph removeSelector: #adjustIndicatorAt:!

WindowEdgeAdjustingMorph removeSelector: #adjustIndicatorAt:!

WindowEdgeAdjustingMorph removeSelector: #handPoint!

WindowEdgeAdjustingMorph removeSelector: #handPoint!

WindowEdgeAdjustingMorph removeSelector: #initialIndicatorBoundsInWorld!

WindowEdgeAdjustingMorph removeSelector: #initialIndicatorBoundsInWorld!

Preferences class removeSelector: #fastDragWindowForMorphic!

Preferences class removeSelector: #fastDragWindowForMorphic!

LayoutAdjustingMorph removeSelector: #adjustIndicatorAt:!

LayoutAdjustingMorph removeSelector: #adjustIndicatorAt:!

LayoutAdjustingMorph removeSelector: #handPoint!

LayoutAdjustingMorph removeSelector: #handPoint!

LayoutAdjustingMorph removeSelector: #initialIndicatorBoundsInWorld!

LayoutAdjustingMorph removeSelector: #initialIndicatorBoundsInWorld!

HandMorph class removeSelector: #fastDragBorderWidth!

HandMorph class removeSelector: #fastDragBorderWidth!

Smalltalk removeClassNamed: #RectangleIndicatorMorph!

Smalltalk removeClassNamed: #RectangleIndicatorMorph!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1453-CuisCore-JuanVuletich-2012Sep21-14h53m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1453] on 22 September 2012 at 2:54:35 pm'!
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 14:47' prior: 16864196!
   endInteraction
	"Clean up after a user interaction with the a halo control"

	(target isInWorld not or: [owner isNil]) ifTrue: [^self].
	self isInWorld 
		ifTrue: [
			"make sure handles show in front"
			self comeToFront.
			self addHandles]! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 9/22/2012 14:52' prior: 50371481!
                  example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane addMorph: (StringMorph contents: '1').

rect1 := BorderedRectMorph new color: (Color lightOrange); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect2.
pane
	color: Color lightGreen;
	openInWorld;
	morphPositionInOwner: 120 @ 50;
	morphExtent: 180 @ 100.

pane _ LayoutMorph newRow separation: 5. "2"
pane addMorph: (StringMorph contents: '2').

rect1 := BorderedRectMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane
	color: Color lightGreen;
	openInWorld;
	morphPositionInOwner: 320 @ 50;
	morphExtent: 180 @ 100.


pane _ LayoutMorph newRow separation: 5. "3"
pane addMorph: (StringMorph contents: '3').

rect1 := BorderedRectMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := BorderedRectMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	openInWorld;
	morphPositionInOwner: 520 @ 50;
	morphExtent: 180 @ 100! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1454-CuisCore-JuanVuletich-2012Sep22-14h47m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1453] on 22 September 2012 at 3:42:33 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:31' prior: 50345732!
                       morphPosition
	"Answer our position inside our owner, in owner's coordinates."

	^ location position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:32' prior: 50345742!
            morphPosition: aPoint
	"Change the position of this morph. Argument is in owner's coordinates."

	location position = aPoint ifTrue: [
		^ self ].		"Null change"

	self redrawNeeded.
	location setPosition: aPoint.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 9/22/2012 15:33' prior: 50389844!
storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."

	| bufSize stereoBuffer reverseBytes  |
	self reset.
	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"
	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.
	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.

	'Storing audio...' displayProgressAt: World activeHand morphPosition
		from: 0 to: samplesToStore during: [:bar | | remaining out |
			remaining _ samplesToStore.
			[remaining > 0] whileTrue: [
				bar value: samplesToStore - remaining.
				stereoBuffer primFill: 0.  "clear the buffer"
				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.
				self isStereo
					ifTrue: [out _ stereoBuffer]
					ifFalse: [out _ stereoBuffer extractLeftChannel].
				reverseBytes ifTrue: [out reverseEndianness].
				(aBinaryStream isKindOf: StandardFileStream)
					ifTrue: [  "optimization for files: write sound buffer directly to file"
						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"
					ifFalse: [  "for non-file streams:"
						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].
				remaining _ remaining - bufSize]].
! !
!AutoCompleter methodsFor: 'menu morph' stamp: 'jmv 9/22/2012 15:01' prior: 50342422!
                    openCompletionMenu
	| theEditor |
	theEditor _ textMorph editor.
	position _ theEditor startIndex - 1.
	self closeMenu.
	self computeEntries.
	entries notEmpty
		ifTrue: [ 
			menuMorph _  AutoCompleterMorph 
				completer: self
				position: theEditor startBlock bottomLeft + textMorph morphPositionInWorld ]! !
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 9/22/2012 15:38' prior: 50374567!
      buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ RectangleLikeMorph new.
	outerBox
		morphExtent: finalSizeInteger asPoint * resizeFactor;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox morphBoundsInWorld.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPosition: 12@8.	"not a clue why these numbers work..."
	
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:42' prior: 50356086!
      morphBoundsInWorld: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.

	oldExtent _ self morphExtentInWorld.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPositionInWorld: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPositionInWorld: newBounds topLeft; morphExtent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self morphExtent: newExtent; morphPositionInWorld: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:56' prior: 50373180!
             morphExtent
	"In our own coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ 50 @ 40! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:41' prior: 50378308!
       morphPositionInWorld

	self flag: #jmvVer2.
	"Most likely we don't want to use global coordinates...
	In fact, we could be in many frames of reference at the same time...
	This method makes no sense at all!!"

	^self externalizeToWorld: 0@0! !
!Morph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:33' prior: 50378326!
morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	"This method MUST die"

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].

	location position = newPositionInOwner ifTrue: [
		^ self ].		"Null change".

	self redrawNeeded.
	location setPosition: newPositionInOwner.
	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 9/22/2012 15:37' prior: 50390011!
  editBalloonHelpContent: aString
	| reply |
	reply _ FillInTheBlank
		multiLineRequest: 'Edit the balloon help text for ' , (self printStringLimitedTo: 40)
		centerAt: self world activeHand morphPosition
		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])
		answerHeight: 200.
	reply ifNil: [^ self].  "User cancelled out of the dialog"
	(reply isEmpty or: [reply asString = self noHelpString])
		ifTrue: [self setBalloonText: nil]
		ifFalse: [self setBalloonText: reply]! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 9/22/2012 15:17' prior: 50346642!
                        addMorphFrontFromWorldPosition: aMorph
	| positionInWorld |
	positionInWorld _ aMorph morphPositionInWorld.
	self addMorphFront: aMorph.
	aMorph morphPositionInWorld: positionInWorld! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/22/2012 15:27' prior: 50384900!
                 placeEmbeddedObject: anchoredFormOrMorph

	"This method should be redone calling reasonable protocol on the canvas.
	Also check use of global coordinates..."
	self flag: #jmvVer2.
	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPositionInWorld:
				((destX - anchoredFormOrMorph morphWidth)@
				(lineY+ line baseline - anchoredFormOrMorph morphHeight)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph width @ (destY + line baseline - anchoredFormOrMorph height)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 9/22/2012 15:37' prior: 50390734!
                         startUpWithoutKeyboard
	"Display and make a selection from the receiver as long as the button  is pressed. Answer the current selection.  Do not allow keyboard input into the menu"
	
	^ self startUpWithCaption: nil at: ActiveHand morphPosition allowKeyboard: false! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:57' prior: 50375254!
                           basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ??? --- DEBE SER EN OWN COORDINATES"
	extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	extent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	self redrawNeeded! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:56' prior: 50374410!
           morphExtent
	"In our own coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ extent! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:56' prior: 50373686!
                           morphHeight

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ extent y! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:57' prior: 50381323!
          morphHeight: aNumber

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: extent x@aNumber! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:57' prior: 50373692!
         morphWidth

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ extent x! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:57' prior: 50381330!
           morphWidth: aNumber

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: aNumber@extent y! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 9/22/2012 15:38' prior: 50346651!
    setCompleter: anAutoCompleter position: aPoint 
	completer _ anAutoCompleter.
	self resetMenu.
	self openInWorld.
	self morphPosition: aPoint.! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 9/22/2012 15:38' prior: 50381051!
              createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	self addMorph: result.
	result morphPosition: 29@90.
	result morphExtent: 93@27.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 9/22/2012 15:38' prior: 50381064!
                            createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	self addMorph: result.
	result morphPosition: 149@90.
	result morphExtent: 93@27.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 9/22/2012 15:38' prior: 50381077!
                           createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	self addMorph: result.
	result morphPosition: 30@7.
	result morphExtent: 239@15.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 9/22/2012 15:38' prior: 50381430!
                      createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval
				allowStyler: true.
	result morphExtent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result morphPosition: 14@25.
	result morphExtent: extent-(28@62).
	^ result! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 9/22/2012 15:33' prior: 50390165!
          request: queryString
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph request: 'What is your favorite color?'"

	^ self
		request: queryString
		initialAnswer: ''
		centerAt: World activeHand morphPosition! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 9/22/2012 15:33' prior: 50390180!
               request: queryString initialAnswer: defaultAnswer 
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'"

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: World activeHand morphPosition! !
!HaloMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 9/22/2012 15:02' prior: 50359557!
         startDrag: evt with: dragHandle
	"Drag my target without removing it from its owner."

	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	positionOffset _ dragHandle referencePosition - target morphPositionInWorld! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 9/22/2012 15:01' prior: 50372214!
                     mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition
	"Transfer the halo to the next likely recipient"
	target ifNil:[^self delete].
	aMouseButtonEvent hand obtainHalo: self.
	positionOffset _ aMouseButtonEvent eventPosition - target morphPositionInWorld.
	"wait for drags or transfer"
	aMouseButtonEvent hand 
		waitForClicksOrDrag: self 
		event: aMouseButtonEvent
		clkSel: #transferHalo:localPosition:
		dblClkSel: nil! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 9/22/2012 15:18' prior: 50367606!
                       mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Drag our target around"
	| thePoint |
	thePoint _ aMouseMoveEvent eventPosition - positionOffset.
	target morphPositionInWorld: thePoint! !
!HaloMorph methodsFor: 'event handling' stamp: 'jmv 9/22/2012 15:01' prior: 50366165!
                               popUpFor: aMorph event: aMorphicEvent
	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."

	| hand anEvent |
	self flag: #workAround.	"We should really have some event/hand here..."
	anEvent _ aMorphicEvent
				ifNil: [
					hand _ aMorph world activeHand.
					hand ifNil: [ hand _ aMorph world firstHand ]. 
					hand lastEvent ]
				ifNotNil: [
					hand _ aMorphicEvent hand.
					aMorphicEvent ].
	hand halo: self.
	hand world addMorphFront: self.
	self target: aMorph.
	positionOffset _ anEvent eventPosition - aMorph morphPositionInWorld.
	self startStepping! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 9/22/2012 15:19' prior: 50373753!
       step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target morphBoundsInWorld]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = self morphBoundsInWorld
		ifTrue: [^ self].
	newBounds extent = extent
		ifTrue: [^ self morphPositionInWorld: newBounds origin].
	growingOrRotating ifFalse: [
		submorphs size > 1
			ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self morphBoundsInWorld: newBounds! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:38' prior: 50362113!
                        addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPosition: 0@0 ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:33' prior: 50391082!
                               addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleLikeMorph new
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPositionInWorld: (namePosition min: w viewBox bottomRight - nameMorph morphHeight + 5).
	nameBackground morphPosition: nameMorph morphPosition - 2.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:18' prior: 50342948!
                        doDrag: evt with: dragHandle
	| thePoint |
	evt hand obtainHalo: self.
	thePoint _ evt eventPosition - positionOffset.
	target morphPositionInWorld: thePoint! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:18' prior: 50375302!
                doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target morphPositionInWorld.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target morphExtent: newExtent.
	growHandle morphPositionInWorld: evt eventPosition - (growHandle morphExtent // 2)! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:18' prior: 50375323!
                       doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPositionInWorld: evt eventPosition - (rotHandle morphExtent // 2)! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/22/2012 15:34' prior: 50367348!
                    startMouseDispatch: aMouseEvent

	aMouseEvent isMouseOver ifTrue: [
		^self mouseFocus
			ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
			ifNil: [ owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition ]].

	"any mouse event but mouseOver"
	lastMouseEvent _ aMouseEvent.	
	lastMouseEventTime _ Time millisecondClockValue.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	aMouseEvent isMove
		ifTrue: [
			self morphPosition: aMouseEvent eventPosition.
			self mouseFocus
				ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
				ifNil: [ owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition ]
		] ifFalse: [
			"Issue a synthetic move event if we're not at the position of the event"
			aMouseEvent eventPosition = self morphPosition ifFalse: [
				"Issue a mouse move event to make the receiver appear at the given position"
				self startMouseDispatch: (MouseMoveEvent new
					setType: #mouseMove
					position: aMouseEvent eventPosition
					buttons: aMouseEvent buttons
					hand: self
					stamp: aMouseEvent timeStamp) ].
			"Drop submorphs on button events"
			self hasSubmorphs
				ifTrue: [ self dropMorphs: aMouseEvent ]
				ifFalse: [
					self mouseFocus
						ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
						ifNil: [ owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition ]]].
		self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 9/22/2012 15:34' prior: 50388814!
                attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m morphExtentInWorld // 2.
	m morphPositionInWorld: (self morphPosition - delta)! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 9/22/2012 15:34' prior: 50364526!
          dropMorph: aMorph event: aMouseEvent
	"Drop the given morph which was carried by the hand"
	| dropEvent |
	(aMouseEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue: [ ^self ].
	dropEvent _ DropEvent new setPosition: self morphPosition contents: aMorph hand: self.
	owner dispatchEvent: dropEvent localPosition: dropEvent eventPosition.
	dropEvent wasHandled ifFalse: [ aMorph rejectDropMorphEvent: dropEvent ].
	self mouseOverHandler processMouseOver: aMouseEvent! !
!HandMorph methodsFor: 'paste buffer' stamp: 'jmv 9/22/2012 15:34' prior: 50360953!
              pasteMorph

	| pastee |
	pastee _ Clipboard retrieveMorph.
	pastee ifNil: [^ self inform: 'Nothing to paste.'].
	self attachMorph: pastee.
	pastee aligned: pastee referencePosition with: self morphPosition! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 9/22/2012 15:34' prior: 50343228!
                         generateKeyboardEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [stamp _ Time millisecondClockValue].
	(evtBuf sixth <= 0 or: [
		(keyValue _ (Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth)) isNil ])
			ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue].
	pressType = EventSensor eventKeyUp ifTrue: [type _ #keyUp].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [		"Control key pressed"
			keyValue < 27 ifTrue: [
				
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [		"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ 	"If Equal, Ctrl-alphabetic in Windows => do translate"
							lastKeyDownValue < 47 ]) ifTrue: [		"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifFalse: [ keyValue + 96 ]	"shift not pressed: conver to lowercase letter"
							ifTrue: [ keyValue + 64 ]].	"shift pressed: conver to uppercase letter"
					]
				].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [
				modifiers _ modifiers bitOr: 8 ]
			]].
	buttons _ modifiers bitShift: 3.
	^KeyboardEvent new 
		setType: type
		buttons: buttons
		position: self morphPosition
		keyValue: keyValue
		hand: self
		stamp: stamp! !
!HandleMorph methodsFor: 'events' stamp: 'jmv 9/22/2012 15:34' prior: 50366202!
                    keyStroke: aKeyboardEvent
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ aKeyboardEvent keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - (1@0) ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + (1@0) ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - (0@1) ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + (0@1) ].
	"Special case for return"
	aKeyboardEvent isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 9/22/2012 15:35' prior: 50390318!
                              popUpForHand: aHand
	"Pop up the receiver as balloon help for the given hand"

	| xcess |
	(contents isNil or: [ contents isEmpty ]) ifTrue: [ ^self ].
	aHand world addMorphFront: self.
	self morphPosition: aHand morphPosition + (-6@20).
	xcess _ self morphPosition x + self morphExtent x - aHand world morphWidth.
	xcess > 0 ifTrue: [
		self morphPosition: self morphPosition - (xcess@0) ].
	aHand balloonHelp: self! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:38' prior: 50381124!
                           adjustExtent
	"And reposition submorphs"
	| w h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	y _ 0.
	self submorphsDo: [ :m |
		m
			morphPosition: 0@y;
			morphWidth: w.
		h _ m morphHeight.
		y _ y + h ].
	self morphExtent: w@y! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:35' prior: 50390818!
           itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last |
	self hasSubmorphs ifFalse: [ ^nil ].
	(aPoint > (0@0) and: [ aPoint < extent ]) ifFalse: [ ^nil ].
	ptY _ aPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	self firstSubmorph morphPosition y > ptY ifTrue: [ ^nil ].
	last _ self lastSubmorph.
	last morphPosition y + last morphHeight < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^self 
		findSubmorphBinary: [ :m |
			(m morphPosition y <= ptY and: [ m morphPosition y + m morphHeight >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPosition y + (m morphHeight // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/22/2012 15:35' prior: 50390890!
             drawLinesOn: aCanvas 
	| lColor bottomY topY tx |
	lColor _ Theme current line.
	tx _ aCanvas currentTransformation.
	topY _ (tx internalizePosition: aCanvas clipRect topLeft) y min: (tx internalizePosition: aCanvas clipRect topRight) y.
	bottomY _ (tx internalizePosition: aCanvas clipRect bottomLeft) y max: (tx internalizePosition: aCanvas clipRect bottomRight) y.
	self submorphs do: [ :submorph | 
		(submorph isExpanded or: [
			(submorph morphPosition y between: topY and: bottomY) or: [
				submorph nextSibling notNil and: [
					submorph nextSibling morphPosition y between: topY and: bottomY ] ] ])
		ifTrue: [
			self
				drawLinesFor: submorph
				on: aCanvas
				lineColor: lColor ]]
	! !
!InnerTextMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 9/22/2012 15:10' prior: 50346566!
addMorphFrontFromWorldPosition: aMorph
	"Overridden for more specific re-layout and positioning"
	| positionInWorld |
	positionInWorld _ aMorph morphPositionInWorld.
	^self anchorMorph: aMorph at: positionInWorld! !
!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 9/22/2012 15:35' prior: 50391172!
             step
	"got the #mouseLeave: message"
	| p |
	hand ifNil: [
		Cursor currentCursor == self cursor ifTrue: [
			Cursor normal show ].
		^self stopStepping ].

	"hasn't got the #mouseLeave: message (yet)"
	p _ hand morphPosition.
	hand lastEvent mouseButton1Pressed
		ifTrue: [
			self adjustOwnerAt: p ]
		ifFalse: [
			"If the button was unpressed outside the morph (can happen if you try to go outside container),
			we might not get the #mouseLeave: message"
			(self morphContainsPoint: (self internalizeFromWorld: p)) ifFalse: [
				hand _ nil.
				Cursor normal show.
				self stopStepping ]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 9/22/2012 15:38' prior: 50388454!
                        layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight t |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableWidth _ boundsForLayout width - ((submorphs size + 1) * xSep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth _ usableWidth - sumOfFixed.
	normalizationFactor _ self proportionalWidthNormalizationFactor.
	availableForPropWidth _ availableForPropWidth * normalizationFactor.
	widths _ submorphs collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + xSep max: 0) +  boundsForLayout left.
	usableHeight _ boundsForLayout height - (2*ySep) max: 0.
	boundsTop _ boundsForLayout top.	
	boundsRight _ boundsForLayout right.
	submorphs size to: 1 by: -1 do: [ :index | | m w h ls |
		m _ submorphs at: index.
		"major direction"
		w _ widths at: index.
		"minor direction"
		ls _ m layoutSpec.
		h _ (ls heightFor: usableHeight) min: usableHeight.
		t _ (usableHeight - h) * ls minorDirectionPadding + ySep + boundsTop.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		m
			morphPosition: l rounded @ t rounded;
			morphExtent: (w rounded min: boundsForLayout width)@ h rounded.
		w > 0 ifTrue: [
			l _ l + w + xSep min: boundsRight ]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 9/22/2012 15:38' prior: 50388505!
              layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom l |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableHeight _ boundsForLayout height - ((submorphs size + 1) * ySep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight _ usableHeight - sumOfFixed.
	normalizationFactor _ self proportionalHeightNormalizationFactor.
	availableForPropHeight _ availableForPropHeight * normalizationFactor.
	heights _ submorphs collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + ySep max: 0) +  boundsForLayout top.
	usableWidth _ boundsForLayout width - (2*xSep) max: 0.
	boundsLeft _ boundsForLayout left.	
	boundsBottom _ boundsForLayout bottom.
	submorphs size to: 1 by: -1 do: [ :index | | m h w ls |
		m _ submorphs at: index.
		"major direction"
		h _ heights at: index.
		"minor direction"
		ls _ m layoutSpec.
		w _ (ls widthFor: usableWidth) min: usableWidth.
		l _ (usableWidth - w) * ls minorDirectionPadding + xSep + boundsLeft.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		m
			morphPosition: l rounded @ t rounded;
			morphExtent: w rounded @ (h rounded min: boundsForLayout height).
		h > 0 ifTrue: [
			t _ t + h + ySep min: boundsBottom ]]! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 9/22/2012 15:39' prior: 50391333!
                     example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane addMorph: (StringMorph contents: '1').

rect1 := BorderedRectMorph new color: (Color lightOrange); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect2.
pane
	color: Color lightGreen;
	openInWorld;
	morphPosition: 120 @ 50;
	morphExtent: 180 @ 100.

pane _ LayoutMorph newRow separation: 5. "2"
pane addMorph: (StringMorph contents: '2').

rect1 := BorderedRectMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane
	color: Color lightGreen;
	openInWorld;
	morphPosition: 320 @ 50;
	morphExtent: 180 @ 100.


pane _ LayoutMorph newRow separation: 5. "3"
pane addMorph: (StringMorph contents: '3').

rect1 := BorderedRectMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := BorderedRectMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	openInWorld;
	morphPosition: 520 @ 50;
	morphExtent: 180 @ 100! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 9/22/2012 15:35' prior: 50390371!
                 chooseMagnification: evt
	| handle origin aHand currentMag |
	currentMag _ magnification.
	aHand _ evt ifNil: [ self world activeHand ] ifNotNil: [evt hand].
	origin _ aHand morphPosition y.
	handle _ HandleMorph new forEachPointDo:
		[ :newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag ].
	aHand attachMorph: handle.
	handle startStepping.
	self redrawNeeded. ! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 9/22/2012 15:36' prior: 50390387!
     sourcePoint
	"If we are being dragged use our center, otherwise use pointer position"
	^ (trackPointer not or: [owner notNil and: [owner is: #HandMorph]])
		ifTrue: [ self morphBoundsInWorld center ]
		ifFalse: [ self activeHand morphPosition ]! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 9/22/2012 15:38' prior: 50382262!
                   contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker.
	marker morphPosition: (0@2)! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 9/22/2012 15:38' prior: 50374781!
              addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ RectangleLikeMorph new.
	titleMorph color: Theme current menuTitleBar.
	pp _ 8@2.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s.
		s morphPosition: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphHeight: pp y; morphWidth: w + 8.
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/22/2012 15:36' prior: 50381546!
                            popUpAdjacentTo: rightOrLeftPointInWorld forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/22/2012 15:36' prior: 50390421!
                popUpForHand: hand in: aWorld
	| p |
	"Present this menu under control of the given hand."

	p _ hand morphPosition truncated.
	^self popUpAt: p forHand: hand in: aWorld
! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/22/2012 15:36' prior: 50390430!
   popUpInWorld: aWorld
	"Present this menu under control of the given hand."
	^self
		popUpAt: aWorld activeHand morphPosition
		forHand: aWorld activeHand
		in: aWorld
! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 9/22/2012 15:38' prior: 50347017!
                             displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m isKindOf: MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	"warning: needs not to clip children!!"
	self flag: #jmvVer2.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock.
		feedbackMorph morphPosition: (0@ -20).
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self submorphs last delete.
		self removeProperty: #feedbackMorph ].
	matches size = 1 ifTrue: [
		self
			selectItem: matches first
			event: evt ].! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 9/22/2012 15:38' prior: 50390469!
                              sightTarget: event 
	| bullseye menu newTarget |
	owner
		ifNil: [^ self ].
	bullseye _ Point fromUserWithCursor: Cursor target.
	ActiveHand morphPosition: bullseye.
	menu _ CustomMenu new.
	(owner morphsAt: bullseye) do: [ :m |
		menu add: m printString action: m ].
	menu title: self printString, ' targets... '.
	newTarget _ menu startUp.
	newTarget
		ifNil: [^ self].
	self target: newTarget! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 9/22/2012 15:36' prior: 50390485!
                            invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu"

	^ self invokeModalAt: ActiveHand morphPosition in: ActiveWorld allowKeyboard: allowKeyboardControl! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:38' prior: 50353748!
              adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each morphWidth])].

	w _ w + 4.
	p _ 5 @ 5.
	submorphs do: [ :m |
		m morphWidth: w.
		m morphPosition: p.
		p _ p + (0@(m morphHeight + 1)) ].

	self morphExtent: w @ p y + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:37' prior: 50390497!
                positionAt: aPoint relativeTo: aMenuItem
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	self morphBoundsInWorld right > owner world morphBoundsInWorld right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ self morphBoundsInWorld amountToTranslateWithin:
		(owner world morphBoundsInWorld withHeight: ((owner world morphExtentInWorld y - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!MenuMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:36' prior: 50357100!
                       moveRight: aNumber
	self morphPosition: ((aNumber - extent x) @ self morphPosition y)! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 9/22/2012 15:35' prior: 50390529!
                    informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ ActiveWorld.
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph morphWidth: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 9/22/2012 15:38' prior: 50357222!
                      acceptDroppingMorph: dropped event: evt 
	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"

	| aMorph |
	aMorph := self morphToDropFrom: dropped.
	self isWorldMorph 
		ifTrue: [	"Add the given morph to this world and start stepping it if it wants to be."

			self addMorphFront: aMorph.
			(aMorph morphFullBoundsInWorld intersects: self viewBox) 
				ifFalse: [
					Beeper beep.
					aMorph morphPosition: extent // 2]]
		ifFalse: [super acceptDroppingMorph: aMorph event: evt].
	aMorph submorphsDo: [ :m | (m isKindOf: HaloMorph) ifTrue: [ m delete ]].
	self world startSteppingSubmorphsOf: aMorph! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:58' prior: 50375593!
      morphExtent: aPoint
	"In our own coordinates"

	self flag: #jmvVer2.
	extent = aPoint ifFalse: [
		self redrawNeeded.
		extent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = self morphBoundsInWorld ifFalse: [
				worldState canvas: nil.
				worldState viewBox: self morphBoundsInWorld ]]]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 9/22/2012 15:28' prior: 50357266!
                            addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect _ Rectangle center: aPoint extent: aMorph morphFullBoundsInWorld extent.
	delta _ trialRect amountToTranslateWithin: self morphBoundsInWorld.
	self addMorph: aMorph.
	aMorph morphPositionInWorld: trialRect origin + delta.! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 9/22/2012 15:39' prior: 50350589!
                   addToScroller: aMorph

	scroller addMorph: aMorph.
	aMorph morphPosition: 0@0! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:37' prior: 50369615!
                     scrollerOffset
	^(scroller morphPosition negated + borderWidth + self xtraBorder)! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:39' prior: 50350595!
                 scrollerOffset: newOffset
	| delta |
	delta _ borderWidth + self xtraBorder.
	scroller morphPosition: delta@delta - newOffset! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:39' prior: 50381629!
     updateScrollBarsBounds
	
	| t |
	hideScrollBars ifTrue: [^self].
	t _ self scrollBarClass scrollbarThickness.
	scrollBar
		morphPosition: extent x - t - borderWidth @ borderWidth;
		morphExtent: t @ self vScrollBarHeight.
	hScrollBar
		morphPosition: borderWidth @ (extent y - t - borderWidth);
		morphExtent: self hScrollBarWidth@t! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 9/22/2012 15:35' prior: 50381256!
                   scrollSelectionIntoView

	selectedMorph ifNotNil: [
		self flag: #jmvVer2.	"traducir mejor el rectangulo..."
		self scrollToShow: ((scroller externalize: selectedMorph morphPosition) extent: selectedMorph morphExtent) ]! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:39' prior: 50350726!
                 computeSlider

	| delta |
	delta _ self buttonExtent + (self freeSliderRoom * value) asInteger.
	self isHorizontal
		ifTrue: [
			slider morphPosition: borderWidth +  delta @ borderWidth ]
		ifFalse: [
			slider morphPosition: borderWidth @ (borderWidth + delta) ] ! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 9/22/2012 15:39' prior: 50381705!
 initializeDownButton
	"initialize the receiver's downButton"

	| e |
	e _ self buttonExtent.
	downButton _ self buttonClass new.
	downButton model: self.
	self addMorph: downButton.
	downButton
		morphPosition: extent - borderWidth - e;
		morphExtent: e@e.
	self isHorizontal
		ifTrue: [ downButton updateRightButtonImage ]
		ifFalse: [ downButton updateDownButtonImage ]! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 9/22/2012 15:39' prior: 50351550!
                       initializeUpButton
	"initialize the receiver's upButton"

	| e |
	e _ self buttonExtent.
	upButton _ self buttonClass new.
	upButton model: self.
	self addMorph: upButton.
	upButton
		morphPosition: borderWidth@borderWidth;
		morphExtent: e@e.
	self isHorizontal
		ifTrue: [ upButton updateLeftButtonImage ]
		ifFalse: [ upButton updateUpButtonImage ].! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 9/22/2012 15:37' prior: 50388733!
           sliderGrabbedAt: handPositionRelativeToSlider

	grabPosition _ handPositionRelativeToSlider.
	sliderShadow
		morphPosition: slider morphPosition;
		morphExtent: slider morphExtent;
		show! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 9/22/2012 15:37' prior: 50374335!
               makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 9/22/2012 15:37' prior: 50350418!
                    justDroppedInto: aMorph event: anEvent
	isCollapsed
		ifTrue: [
			self morphPosition: (self morphPosition max: 0@0) ]
		ifFalse: [
			TopWindow ~~ self ifTrue: [self activate]].
	^super justDroppedInto: aMorph event: anEvent! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 9/22/2012 15:39' prior: 50348147!
  initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing box |
	spacing _ self boxExtent x + 2.

	box _ self createCloseBox.
	self addMorph: box.
	box morphPosition: 2@2.
	box morphExtent: self boxExtent.

	box _ self createCollapseBox.
	self addMorph: box.
	box morphPosition: spacing+2@2.
	box morphExtent: self boxExtent.

	box _ self createExpandBox.
	self addMorph: box.
	box morphPosition: spacing*2+2@2.
	box morphExtent: self boxExtent.

	box _ self createMenuBox.
	self addMorph: box.
	box morphPosition: spacing*3+2@2.
	box morphExtent: self boxExtent.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 9/22/2012 15:40' prior: 50348169!
                      openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; morphExtent: extent.
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !
!SystemWindow methodsFor: 'top window' stamp: 'jmv 9/22/2012 15:37' prior: 50380699!
     activateAndForceLabelToShow
	self activate.
	self morphPosition y < 0 ifTrue: [
		self morphPosition: (self morphPosition x @ 0)]! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 9/22/2012 15:40' prior: 50388595!
          layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww b |
	thickness _ 4.
	cornerExtent _ 20.
	ww _ extent x.
	wh _ extent y.
	w _ ww - cornerExtent - cornerExtent.
	h _ wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster)
		morphPosition: cornerExtent@0;
		morphExtent: w@thickness.
	(adjusters at: #bottomAdjuster)
		morphPosition: cornerExtent@(wh-thickness);
		morphExtent: w@thickness.
	(adjusters at: #leftAdjuster)
		morphPosition: 0@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #rightAdjuster)
		morphPosition: ww-thickness@cornerExtent;
		morphExtent: thickness@h.
	(adjusters at: #topLeftAdjuster)
		morphPosition: 0@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster)
		morphPosition: 0@(wh-cornerExtent);
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster)
		morphPosition: ww-cornerExtent@0;
		morphExtent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster)
		morphPosition: ww@wh-cornerExtent;
		morphExtent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		b _ self layoutBounds.
		layoutMorph
			morphPosition: b origin;
			morphExtent: b extent ].
	
	layoutNeeded _ false! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 9/22/2012 15:37' prior: 50369731!
                         scrollSelectionIntoView
	"Scroll my text into view if necessary and return true, else return false"

	self scrollToShow: (self editor pointBlock translatedBy: self textMorph morphPosition)! !

Morph removeSelector: #morphPositionInOwner!

Morph removeSelector: #morphPositionInOwner!

Morph removeSelector: #morphPositionInOwner:!

Morph removeSelector: #morphPositionInOwner:!

Morph removeSelector: #validateOwnerNotNil!

Morph removeSelector: #validateOwnerNotNil!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1455-CuisCore-JuanVuletich-2012Sep22-14h54m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1455] on 22 September 2012 at 11:13:48 pm'!

PNGReadWriter class removeSelector: #createAFormFrom:!

PNGReadWriter class removeSelector: #createAFormFrom:!

ImageMorph class removeSelector: #fromString:!

ImageMorph class removeSelector: #fromString:!

ImageMorph class removeSelector: #fromString:font:!

ImageMorph class removeSelector: #fromString:font:!

Morph removeSelector: #imageForm!

Morph removeSelector: #imageForm!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1456-CuisCore-JuanVuletich-2012Sep22-23h05m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1456] on 23 September 2012 at 9:59:07 pm'!
!RectangleLikeMorph commentStamp: '<historical>' prior: 50370087!
                     Hierarchy for morphs that are rectangle like. Including rectangles with rounded corners and such. The idea is that the 'extent' ivar is all that's needed to establish our dimensions and shape. Subclasses can add things like 'roundedCornerRadious' or such.!
!DisplayObject methodsFor: 'displaying-Display' stamp: 'jmv 9/23/2012 21:38' prior: 16840181!
 follow: locationBlock while: durationBlock bitsBehind: initialBitsBehind startingLoc: loc
   "Move an image around on the Display. Restore the background continuously without causing flashing. The argument, locationBlock, supplies each new location, and the argument, durationBlock, supplies true to continue or false to stop. This variant takes the bitsBehind as an input argument, and returns the final saved saved bits as method value."

   | location rect1 save1 save1Blt buffer bufferBlt newLoc rect2 bothRects |
   location _ loc.
   rect1 _ location extent: self extent.
   save1 _ initialBitsBehind.
   save1Blt _ BitBlt toForm: save1.
   buffer _ Form extent: self extent*2 depth: Display depth.  "Holds overlapping region"
   bufferBlt _ BitBlt toForm: buffer.
   Display deferUpdates: true.
   self displayOn: Display at: location rule: Form paint.
   Display deferUpdates: false; forceToScreen: (location extent: self extent).
   [durationBlock value] whileTrue: [
		newLoc _ locationBlock value.
		newLoc ~= location ifTrue: [
			rect2 _ newLoc extent: self extent.
			bothRects _ rect1 merge: rect2.
			(rect1 intersects: rect2)
				ifTrue: [  "when overlap, buffer background for both rectangles"
					bufferBlt copyFrom: bothRects in: Display to: 0@0.
					bufferBlt copyFrom: save1 boundingBox in: save1 to: rect1 origin - bothRects origin.
					"now buffer is clean background; get new bits for save1"
					save1Blt copy: (0@0 extent: self extent) from: rect2 origin - bothRects origin in: buffer.
					self displayOnPort: bufferBlt at: rect2 origin - bothRects origin rule: Form paint.
					Display deferUpdates: true.
					Display copy: bothRects from: 0@0 in: buffer rule: Form over.
					Display deferUpdates: false; forceToScreen: bothRects]
				ifFalse: [  "when no overlap, do the simple thing (both rects might be too big)"
					Display deferUpdates: true.
					Display copy: (location extent: save1 extent) from: 0@0 in: save1 rule: Form over.
					save1Blt copyFrom: rect2 in: Display to: 0@0.
					self displayOn: Display at: newLoc rule: Form paint.
					Display deferUpdates: false; 
						forceToScreen: (location extent: save1 extent); 
						forceToScreen: (newLoc extent: self extent)].
			location _ newLoc.
			rect1 _ rect2]].

	^ save1 displayOn: Display at: location
! !
!DisplayMedium methodsFor: 'coloring' stamp: 'jmv 9/23/2012 21:38' prior: 16839822!
      fillShape: aShapeForm fillColor: aColor at: location
	"Fill a region corresponding to 1 bits in aShapeForm with aColor"

	((BitBlt destForm: self sourceForm: aShapeForm fillColor: aColor
		combinationRule: Form paint
		destOrigin: location + aShapeForm offset sourceOrigin: 0@0
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits! !
!Form methodsFor: 'accessing' stamp: 'jmv 9/23/2012 21:30' prior: 50379065!
              getCanvas
	"Return a Canvas that can be used to draw onto the receiver"
	^FormCanvas onForm: self! !
!Form methodsFor: 'analyzing' stamp: 'jmv 9/23/2012 21:43' prior: 16856983!
               pixelCompare: aRect with: otherForm at: otherLoc
	"Compare the selected bits of this form (those within aRect) against
	those in a similar rectangle of otherFrom.  Return the sum of the
	absolute value of the differences of the color values of every pixel.
	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,
	in the case of 8-bits or less, this will return the sum of the differing
	bits of the corresponding pixel values (somewhat less useful)"
	| pixPerWord temp |
	pixPerWord _ 32//self depth.
	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:
		["If word-aligned, use on-the-fly difference"
		^ (BitBlt toForm: self) copy: aRect from: otherLoc in: otherForm
				fillColor: nil rule: 32].
	"Otherwise, combine in a word-sized form and then compute difference"
	temp _ self copy: aRect.
	temp copy: aRect from: otherLoc in: otherForm rule: 21.
	^ (BitBlt toForm: temp) copy: aRect from: otherLoc in: nil
				fillColor: (Bitmap with: 0) rule: 32
"  Dumb example prints zero only when you move over the original rectangle...
 | f diff | f _ Form fromUser.
[Sensor anyButtonPressed] whileFalse:
	[diff _ f pixelCompare: f boundingBox
		with: Display at: Sensor mousePoint.
	diff printString , '        ' displayAt: 0@0]
"! !
!Form methodsFor: 'analyzing' stamp: 'jmv 9/23/2012 21:43' prior: 16857025!
    primCountBits
	"Count the non-zero pixels of this form."
	self depth > 8 ifTrue:
		[^(self asFormOfDepth: 8) primCountBits].
	^ (BitBlt toForm: self)
		fillColor: (Bitmap with: 0);
		destRect: (0@0 extent: width@height);
		combinationRule: 32;
		copyBits! !
!Form methodsFor: 'analyzing' stamp: 'jmv 9/23/2012 21:46' prior: 16857036!
                  rectangleEnclosingPixelsNotOfColor: aColor
	"Answer the smallest rectangle enclosing all the pixels of me that are different from the given color. Useful for extracting a foreground graphic from its background."

	| cm slice copyBlt countBlt top bottom newH left right |
	"map the specified color to 1 and all others to 0"
	cm _ Bitmap new: (1 bitShift: (self depth min: 15)).
	cm primFill: 1.
	cm at: (aColor indexInMap: cm) put: 0.

	"build a 1-pixel high horizontal slice and BitBlts for counting pixels of interest"
	slice _ Form extent: width@1 depth: 1.
	copyBlt _ (BitBlt toForm: slice)
		sourceForm: self;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: 1;
		colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
		fillColor: (Bitmap with: 0);
		destRect: (0@0 extent: slice extent);
		combinationRule: 32.

	"scan in from top and bottom"
	top _ (0 to: height)
		detect: [:y |
			copyBlt sourceOrigin: 0@y; copyBits.
			countBlt copyBits > 0]
		ifNone: [^ 0@0 extent: 0@0].
	bottom _ (height - 1 to: top by: -1)
		detect: [:y |
			copyBlt sourceOrigin: 0@y; copyBits.
			countBlt copyBits > 0].

	"build a 1-pixel wide vertical slice and BitBlts for counting pixels of interest"
	newH _ bottom - top + 1.
	slice _ Form extent: 1@newH depth: 1.
	copyBlt _ (BitBlt toForm: slice)
		sourceForm: self;
		combinationRule: Form over;
		destX: 0 destY: 0 width: 1 height: newH;
		colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
		fillColor: (Bitmap with: 0);
		destRect: (0@0 extent: slice extent);
		combinationRule: 32.

	"scan in from left and right"
	left _ (0 to: width)
		detect: [:x |
			copyBlt sourceOrigin: x@top; copyBits.
			countBlt copyBits > 0].
	right _ (width - 1 to: left by: -1)
		detect: [:x |
			copyBlt sourceOrigin: x@top; copyBits.
			countBlt copyBits > 0].

	^ left@top corner: (right + 1)@(bottom + 1)
! !
!Form methodsFor: 'analyzing' stamp: 'jmv 9/23/2012 21:43' prior: 16857097!
                       tallyPixelValuesInRect: destRect into: valueTable
	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."

	(BitBlt toForm: self)
		sourceForm: self;  "src must be given for color map ops"
		sourceOrigin: 0@0;
		tallyMap: valueTable;
		combinationRule: 33;
		destRect: destRect;
		copyBits.
	^ valueTable

"
Move a little rectangle around the screen and print its tallies...
 | r tallies nonZero |
Cursor blank showWhile: [
[Sensor anyButtonPressed] whileFalse:
	[r _ Sensor mousePoint extent: 10@10.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.
	tallies _ (Display copy: r) tallyPixelValues.
	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]
			thenCollect: [:i | (tallies at: i) -> (i-1)].
	nonZero printString , '          ' displayAt: 0@0.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]
"! !
!Form methodsFor: 'analyzing' stamp: 'jmv 9/23/2012 21:43' prior: 16857129!
xTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by x-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice countBlt copyBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: 1@height.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				halftoneForm: nil combinationRule: Form over
				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height
				clipRect: slice boundingBox) colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (0@0 extent: slice extent);
				combinationRule: 32.
	^ (0 to: width-1) collect:
		[:x |
		copyBlt sourceOrigin: x@0; copyBits.
		countBlt copyBits]! !
!Form methodsFor: 'analyzing' stamp: 'jmv 9/23/2012 21:44' prior: 16857158!
                 yTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by y-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice copyBlt countBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: width@1.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				halftoneForm: nil combinationRule: Form over
				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1
				clipRect: slice boundingBox) colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (0@0 extent: slice extent);
				combinationRule: 32.
	^ (0 to: height-1) collect:
		[:y |
		copyBlt sourceOrigin: 0@y; copyBits.
		countBlt copyBits]! !
!Form methodsFor: 'bordering' stamp: 'jmv 9/23/2012 21:39' prior: 16857187!
                  border: rect width: borderWidth rule: rule fillColor: fillColor
        "Paint a border whose rectangular area is defined by rect. The
width of the border of each side is borderWidth. Uses fillColor for drawing
the border."
        | blt |
        blt _ (BitBlt toForm: self) combinationRule: rule; fillColor: fillColor.
        blt sourceOrigin: 0@0.
        blt destOrigin: rect origin.
        blt width: rect width; height: borderWidth; copyBits.
        blt destY: rect corner y - borderWidth; copyBits.
        blt destY: rect origin y + borderWidth.
        blt height: rect height - borderWidth - borderWidth; width:
borderWidth; copyBits.
        blt destX: rect corner x - borderWidth; copyBits! !
!Form methodsFor: 'bordering' stamp: 'jmv 9/23/2012 21:39' prior: 16857212!
                borderFormOfWidth: borderWidth sharpCorners: sharpen
	"Smear this form around and then subtract the original to produce
	an outline.  If sharpen is true, then cause right angles to be outlined
	by right angles (takes an additional diagonal smears ANDed with both
	horizontal and vertical smears)."
	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |
	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."
	bigForm _ self copy.
	all _ bigForm boundingBox.
	smearForm _ Form extent: self extent.
	smearPort _ BitBlt toForm: smearForm.
	sharpen ifTrue:
		[cornerForm _ Form extent: self extent.
		cornerPort _ BitBlt toForm: cornerForm].
	nbrs _ (0@0) fourNeighbors.
	1 to: borderWidth do:
		[:i |  "Iterate to get several layers of 'skin'"
		nbrs do:
			[:d |  "Smear the self in 4 directions to grow each layer of skin"
			smearPort copyForm: bigForm to: d rule: Form under].
		sharpen ifTrue:
			["Special treatment to smear sharp corners"
			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:
				[:d1 :d2 |
				"Copy corner points diagonally"
				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.
				"But only preserve if there were dots on either side"
				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.
				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.
				smearPort copyForm: cornerForm to: 0@0 rule: Form under].
			].
		bigForm copy: all from: 0@0 in: smearForm rule: Form over.
		].
	"Now erase the original shape to obtain the outline"
	bigForm copy: all from: 0@0 in: self rule: Form erase.
	^ bigForm! !
!Form methodsFor: 'color mapping' stamp: 'jmv 9/23/2012 21:42' prior: 16857462!
   mapColor: oldColor to: newColor
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."

	| map |
	map _ (Color cachedColormapFrom: self depth to: self depth) copy.
	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).
	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: 0@0;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits.
! !
!Form methodsFor: 'color mapping' stamp: 'jmv 9/23/2012 21:42' prior: 16857484!
             mapColors: oldColorBitsCollection to: newColorBits
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map |
	self depth < 16
		ifTrue: [map _ (Color cachedColormapFrom: self depth to: self depth) copy]
		ifFalse: [
			"use maximum resolution color map"
			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"
			map _ Color computeRGBColormapFor: self depth bitsPerColor: 5].
	oldColorBitsCollection do:[ :oldColor | map at: oldColor put: newColorBits].

	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: 0@0;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits.
! !
!Form methodsFor: 'converting' stamp: 'jmv 9/23/2012 21:38' prior: 16857653!
 asFormOfDepth: d
	| newForm |
	d = self depth ifTrue: [ ^self ].
	newForm _ Form extent: self extent depth: d.
	(BitBlt toForm: newForm)
		colorMap: (self colormapIfNeededFor: newForm);
		copy: (self boundingBox)
		from: 0@0 in: self
		fillColor: nil rule: Form over.
	"If we build a 32bpp from one of smaller depth,
	it will have zero in the alpha channel (until BitBlt is fixed!!)"
	d = 32 ifTrue: [
		newForm fixAlpha ].
	^newForm! !
!Form methodsFor: 'converting' stamp: 'jmv 9/23/2012 21:38' prior: 16857669!
                              asFormOfNativeDepth: d
	| newForm |
	d = self nativeDepth ifTrue:[^self].
	newForm _ Form extent: self extent depth: d.
	(BitBlt toForm: newForm)
		colorMap: (self colormapIfNeededFor: newForm);
		copy: (self boundingBox)
		from: 0@0 in: self
		fillColor: nil rule: Form over.
	^newForm! !
!Form methodsFor: 'converting' stamp: 'jmv 9/23/2012 21:39' prior: 16857681!
                 asGrayScale
	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"
	| f32 srcForm result map bb grays |
	self depth = 32 ifFalse: [
		f32 _ Form extent: width@height depth: 32.
		self displayOn: f32.
		^ f32 asGrayScale].
	self unhibernate.
	srcForm _ Form extent: (width * 4)@height depth: 8.
	srcForm bits: bits.
	result _ ColorForm extent: width@height depth: 8.
	map _ Bitmap new: 256.
	2 to: 256 do: [:i | map at: i put: i - 1].
	map at: 1 put: 1.  "map zero pixel values to near-black"
	bb _ (BitBlt toForm: result)
		sourceForm: srcForm;
		combinationRule: Form over;
		colorMap: map.
	0 to: width - 1 do: [:dstX |
		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);
			destOrigin: dstX@0;
			copyBits].

	"final BitBlt to zero-out pixels that were truely transparent in the original"
	map _ Bitmap new: 512.
	map at: 1 put: 16rFF.
	(BitBlt toForm: result)
		sourceForm: self;
		sourceRect: self boundingBox;
		destOrigin: 0@0;
		combinationRule: Form erase;
		colorMap: map;
		copyBits.
	
	grays _ (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].
	grays at: 1 put: Color transparent.
	result colors: grays.
	^ result
! !
!Form methodsFor: 'copying' stamp: 'jmv 9/23/2012 21:39' prior: 16857881!
                   copy: destRectangle from: sourcePt in: sourceForm rule: rule 
	"Make up a BitBlt table and copy the bits."
	(BitBlt toForm: self)
		copy: destRectangle
		from: sourcePt in: sourceForm
		fillColor: nil rule: rule! !
!Form methodsFor: 'copying' stamp: 'jmv 9/23/2012 21:39' prior: 16857897!
                               copyBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt 
		destForm: self
		sourceForm: sourceForm
		halftoneForm: nil
		combinationRule: 30
		destOrigin: destOrigin
		sourceOrigin: 0@0
		extent: sourceForm extent
		clipRect: self boundingBox)
		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 copyBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !
!Form methodsFor: 'copying' stamp: 'jmv 9/23/2012 21:39' prior: 16857919!
                             copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm 
	"Make up a BitBlt table and copy the bits."

	(BitBlt 
		destForm: self
		sourceForm: sourceForm
		fillColor: aForm
		combinationRule: rule
		destOrigin: destOrigin
		sourceOrigin: sourceRect origin
		extent: sourceRect extent
		clipRect: clipRect) copyBits! !
!Form methodsFor: 'copying' stamp: 'jmv 9/23/2012 21:39' prior: 16857933!
        copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm map: map
	"Make up a BitBlt table and copy the bits.  Use a colorMap."

	((BitBlt 
		destForm: self
		sourceForm: sourceForm
		fillColor: aForm
		combinationRule: rule
		destOrigin: destOrigin
		sourceOrigin: sourceRect origin
		extent: sourceRect extent
		clipRect: clipRect) colorMap: map) copyBits! !
!Form methodsFor: 'copying' stamp: 'jmv 9/23/2012 21:39' prior: 16857948!
                               copyBits: sourceRect from: sourceForm at: destOrigin colorMap: map 
	"Make up a BitBlt table and copy the bits with the given colorMap."
	((BitBlt 
		destForm: self
		sourceForm: sourceForm
		halftoneForm: nil
		combinationRule: Form over
		destOrigin: destOrigin
		sourceOrigin: sourceRect origin
		extent: sourceRect extent
		clipRect: self boundingBox) colorMap: map) copyBits! !
!Form methodsFor: 'displaying' stamp: 'jmv 9/23/2012 21:42' prior: 16857992!
                    displayResourceFormOn: aForm
	"a special display method for blowing up resource thumbnails"
	self extent = aForm extent ifTrue:[^self displayOn: aForm].

	"We've got no bilinear interpolation. Use WarpBlt instead"
	(WarpBlt toForm: aForm)
		sourceForm: self destRect: aForm boundingBox;
		combinationRule: 3;
		cellSize: 2;
		warpBits! !
!Form methodsFor: 'displaying' stamp: 'jmv 9/23/2012 21:39' prior: 16858005!
 drawLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger fillColor: aForm 
	"Refer to the comment in 
	DisplayMedium|drawLine:from:to:clippingBox:rule:mask:." 
	
	| dotSetter |
	"set up an instance of BitBlt for display"
	dotSetter _ BitBlt
		destForm: self
		sourceForm: sourceForm
		fillColor: aForm
		combinationRule: anInteger
		destOrigin: beginPoint
		sourceOrigin: 0 @ 0
		extent: sourceForm extent
		clipRect: clipRect.
	dotSetter drawFrom: beginPoint to: endPoint! !
!Form methodsFor: 'displaying' stamp: 'jmv 9/23/2012 21:42' prior: 16858024!
                       paintBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt destForm: self
		sourceForm: sourceForm
		halftoneForm: nil
		combinationRule: 31
		destOrigin: destOrigin
		sourceOrigin: 0@0
		extent: sourceForm extent
		clipRect: self boundingBox)
		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f replaceColor: f dominantColor withColor: Color transparent.
f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 paintBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !
!Form methodsFor: 'filling' stamp: 'jmv 9/23/2012 21:39' prior: 16858448!
eraseShape: bwForm
	"use bwForm as a mask to clear all pixels where bwForm has 1's"
	((BitBlt destForm: self sourceForm: bwForm 
		fillColor: nil
		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"
		destOrigin: bwForm offset 
		sourceOrigin: 0@0
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits.
! !
!Form methodsFor: 'filling' stamp: 'jmv 9/23/2012 21:39' prior: 16858463!
                 fill: aRectangle rule: anInteger fillColor: aForm 
	"Replace a rectangular area of the receiver with the pattern described by aForm 
	according to the rule anInteger."
	(BitBlt toForm: self)
		copy: aRectangle
		from: 0@0 in: nil
		fillColor: aForm rule: anInteger! !
!Form methodsFor: 'filling' stamp: 'jmv 9/23/2012 21:39' prior: 16858489!
          fillFromXYColorBlock: colorBlock
	"General Gradient Fill.
	Supply relative x and y in [0.0 ... 1.0] to colorBlock,
	and paint each pixel with the color that comes back"
	| poker yRel xRel |
	poker _ BitBlt bitPokerToForm: self.
	0 to: height-1 do:
		[:y | yRel _ y asFloat / (height-1) asFloat.
		0 to: width-1 do:
			[:x |  xRel _ x asFloat / (width-1) asFloat.
			poker pixelAt: x@y
				put: ((colorBlock value: xRel value: yRel) pixelWordForDepth: self depth)]]
"
 | d |
((Form extent: 100@20 depth: Display depth)
	fillFromXYColorBlock:
	[:x :y | d _ 1.0 - (x - 0.5) abs - (y - 0.5) abs.
	Color r: d g: 0 b: 1.0-d]) display
"! !
!Form methodsFor: 'filling' stamp: 'jmv 9/23/2012 21:39' prior: 16858526!
                             findShapeAroundSeedBlock: seedBlock
	"Build a shape that is black in any region marked by seedBlock. 
	SeedBlock will be supplied a form, in which to blacken various
	pixels as 'seeds'.  Then the seeds are smeared until 
	there is no change in the smear when it fills the region, ie,
	when smearing hits a black border and thus goes no further."
	| smearForm previousSmear all count smearPort |
	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."
	all _ self boundingBox.
	smearForm _ Form extent: self extent.
	smearPort _ BitBlt toForm: smearForm.
	seedBlock value: smearForm.		"Blacken seeds to be smeared"
	smearPort copyForm: self to: 0@0 rule: Form erase.  "Clear any in black"
	previousSmear _ smearForm copy.
	count _ 1.
	[count = 10 and:   "check for no change every 10 smears"
		[count _ 1.
		previousSmear copy: all from: 0@0 in: smearForm rule: Form reverse.
		previousSmear isAllWhite]]
		whileFalse: 
			[smearPort copyForm: smearForm to: 1@0 rule: Form under.
			smearPort copyForm: smearForm to: -1@0 rule: Form under.
			"After horiz smear, trim around the region border"
			smearPort copyForm: self to: 0@0 rule: Form erase.
			smearPort copyForm: smearForm to: 0@1 rule: Form under.
			smearPort copyForm: smearForm to: 0@-1 rule: Form under.
			"After vert smear, trim around the region border"
			smearPort copyForm: self to: 0@0 rule: Form erase.
			count _ count+1.
			count = 9 ifTrue: "Save penultimate smear for comparison"
				[previousSmear copy: all from: 0@0 in: smearForm rule: Form over]].
	"Now paint the filled region in me with aHalftone"
	^ smearForm! !
!Form methodsFor: 'filling' stamp: 'jmv 9/23/2012 21:42' prior: 16858579!
              floodFill2: aColor at: interiorPoint
	"Fill the shape (4-connected) at interiorPoint.  The algorithm is based on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic Press, 1990.
	NOTE: This is a less optimized variant for flood filling which is precisely along the lines of Heckbert's algorithm. For almost all cases #floodFill:at: will be faster (see the comment there) but this method is left in both as reference and as a fallback if such a strange case is encountered in reality."
	| peeker poker stack old new x y top x1 x2 dy left goRight |
	peeker _ BitBlt bitPeekerFromForm: self.
	poker _ BitBlt bitPokerToForm: self.
	stack _ OrderedCollection new: 50.
	"read old pixel value"
	old _ peeker pixelAt: interiorPoint.
	"compute new value"
	new _ self pixelValueFor: aColor.
	old = new ifTrue:[^self]. "no point, is there?!!"

	x _ interiorPoint x.
	y _ interiorPoint y.
	(y >= 0 and:[y < height]) ifTrue:[
		stack addLast: {y. x. x. 1}. "y, left, right, dy"
		stack addLast: {y+1. x. x. -1}].
	[stack isEmpty] whileFalse:[
		top _ stack removeLast.
		y _ top at: 1. x1 _ top at: 2. x2 _ top at: 3. dy _ top at: 4.
		y _ y + dy.
		"Segment of scanline (y-dy) for x1 <= x <= x2 was previously filled.
		Now explore adjacent pixels in scanline y."
		x _ x1.
		[x >= 0 and:[(peeker pixelAt: x@y) = old]] whileTrue:[
			poker pixelAt: x@y put: new.
			x _ x - 1].
		goRight _ x < x1.
		left _ x+1.
		(left < x1 and:[y-dy >= 0 and:[y-dy < height]]) 
			ifTrue:[stack addLast: {y. left. x1-1. 0-dy}].
		goRight ifTrue:[x _ x1 + 1].
		[
			goRight ifTrue:[
				[x < width and:[(peeker pixelAt: x@y) = old]] whileTrue:[
					poker pixelAt: x@y put: new.
					x _ x + 1].
				(y+dy >= 0 and:[y+dy < height]) 
					ifTrue:[stack addLast: {y. left. x-1. dy}].
				(x > (x2+1) and:[y-dy >= 0 and:[y-dy >= 0]]) 
					ifTrue:[stack addLast: {y. x2+1. x-1. 0-dy}]].
			[(x _ x + 1) <= x2 and:[(peeker pixelAt: x@y) ~= old]] whileTrue.
			left _ x.
			goRight _ true.
		x <= x2] whileTrue.
	].
! !
!Form methodsFor: 'image manipulation' stamp: 'jmv 9/23/2012 21:43' prior: 16858745!
                         replaceColor: oldColor withColor: newColor
	"Replace one color with another everywhere is this form"

	| cm newInd target ff |
	self depth = 32
		ifTrue: [cm _ (Color  cachedColormapFrom: 16 to: 32) copy]
		ifFalse: [cm _ Bitmap new: (1 bitShift: (self depth min: 15)).
				1 to: cm size do: [:i | cm at: i put: i - 1]].
	newInd _ newColor pixelValueForDepth: self depth.
	cm at: (oldColor pixelValueForDepth: (self depth min: 16))+1 put: newInd.
	target _ newColor isTransparent 
		ifTrue: [ff _ Form extent: self extent depth: depth.
			ff fillWithColor: newColor.  ff]
		ifFalse: [self].
	(BitBlt toForm: target)
		sourceForm: self;
		sourceOrigin: 0@0;
		combinationRule: Form paint;
		destX: 0 destY: 0 width: width height: height;
		colorMap: cm;
		copyBits.
	newColor = Color transparent 
		ifTrue: [target displayOn: self].! !
!Form methodsFor: 'image manipulation' stamp: 'jmv 9/23/2012 21:43' prior: 16858774!
        smear: dir distance: dist
	"Smear any black pixels in this form in the direction dir in Log N steps"
	| skew bb |
	bb _ BitBlt destForm: self sourceForm: self fillColor: nil
		combinationRule: Form under destOrigin: 0@0 sourceOrigin: 0@0
		extent: self extent clipRect: self boundingBox.
	skew _ 1.
	[skew < dist] whileTrue:
		[bb destOrigin: dir*skew; copyBits.
		skew _ skew+skew]! !
!Form methodsFor: 'pixel access' stamp: 'jmv 9/23/2012 21:43' prior: 16858963!
               pixelValueAt: aPoint 
	"Return the raw pixel value at the given point. This pixel value depends on the receiver's depth. Typical clients use colorAt: to get a Color.  "

	^ (BitBlt bitPeekerFromForm: self) pixelAt: aPoint
! !
!Form methodsFor: 'pixel access' stamp: 'jmv 9/23/2012 21:43' prior: 16858973!
               pixelValueAt: aPoint put: pixelValue
	"Store the given raw pixel value at the given point. Typical clients use colorAt:put: to store a color. "

	(BitBlt bitPokerToForm: self) pixelAt: aPoint put: pixelValue.
! !
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 9/23/2012 21:42' prior: 50360077!
                       flippedBy: direction centerAt: aPoint
	"Return a copy of the receiver flipped either #vertical or #horizontal."
	| newForm quad |
	newForm _ self class extent: self extent depth: depth.
	quad _ self boundingBox innerCorners.
	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])
		collect: [:i | quad at: i].
	(WarpBlt toForm: newForm)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: newForm);
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
	newForm offset: (self offset flippedBy: direction centerAt: aPoint).
	^ newForm
"
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
			flippedBy: #vertical centerAt: 0@0) display]
"
"Consistency test...
 | f f2 p | [Sensor anyButtonPressed] whileFalse:
	[f _ Form fromDisplay: ((p _ Sensor mousePoint) extent: 31@41).
	Display fillBlack: (p extent: 31@41).
	f2 _ f flippedBy: #vertical centerAt: 0@0.
	(f2 flippedBy: #vertical centerAt: 0@0) displayAt: p]
"
! !
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 9/23/2012 21:42' prior: 16859158!
 magnify: aRectangle by: scale smoothing: cellSize
        "Answer a Form created as a scaling of the receiver.
        Scale may be a Float, and may be greater or less than 1.0."
        | newForm |
        newForm _ self blankCopyOf: aRectangle scaledBy: scale.
        (WarpBlt toForm: newForm)
                sourceForm: self;
                colorMap: (self colormapIfNeededFor: newForm);
                cellSize: cellSize;  "installs a new colormap if cellSize > 1"
                combinationRule: 3;
                copyQuad: aRectangle innerCorners toRect: newForm boundingBox.
        ^ newForm

"Dynamic test...
[Sensor anyButtonPressed] whileFalse:
        [(Display magnify: (Sensor mousePoint extent: 131@81) by: 0.5 smoothing: 2) display]
"
"Scaling test...
| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).
Display restoreAfter: [Sensor waitNoButton.
[Sensor anyButtonPressed] whileFalse:
        [cp _ Sensor mousePoint.
        (f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]
"! !
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 9/23/2012 21:42' prior: 16859194!
       magnify: aRectangle to: extent smoothing: cellSize
        "Answer a Form created as a scaling of the receiver.
        Scale may be a Float, and may be greater or less than 1.0."
        | newForm |
        newForm _ Form extent: extent depth: depth.
        (WarpBlt toForm: newForm)
                sourceForm: self;
                colorMap: (self colormapIfNeededFor: newForm);
                cellSize: cellSize;  "installs a new colormap if cellSize > 1"
                combinationRule: 3;
                copyQuad: aRectangle innerCorners toRect: newForm boundingBox.
        ^ newForm

"Dynamic test...
[Sensor anyButtonPressed] whileFalse:
        [(Display magnify: (Sensor mousePoint extent: 131@81) to: 300@200 smoothing: 2) display]
"! !
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 9/23/2012 21:43' prior: 50360603!
                           rotateBy: deg smoothing: cellSize
	"Rotate the receiver by the indicated number of degrees."
	"rot is the destination form, bit enough for any angle."
	| side rot warp r1 pts p center |
	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.
	rot _ Form extent: side@side depth: self depth.
	center _ rot extent // 2.

	"Now compute the sin and cos constants for the rotation angle." 
	warp _ (WarpBlt toForm: rot)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: rot);
		cellSize: cellSize;  "installs a new colormap if cellSize > 1"
		combinationRule: Form over.
	r1 _ rot boundingBox aligned: center with: self boundingBox center.

	pts _ r1 innerCorners collect: [ :pt |
		p _ pt - r1 center.
		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @
		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].
	warp copyQuad: pts toRect: rot boundingBox.
	^ rot
"
 | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
		rotateBy: (a _ a+5) smoothing: 2) display].
f display
"! !
!Form methodsFor: 'transitions' stamp: 'jmv 9/23/2012 21:42' prior: 50360643!
   pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Color black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceDisplayUpdate].

	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceDisplayUpdate.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !
!ColorForm methodsFor: 'pixel accessing' stamp: 'jmv 9/23/2012 21:38' prior: 16820245!
           pixelValueAt: aPoint 
	"Return the raw pixel value at the given point. Typical clients use colorAt: to get a Color."
	"Details: To get the raw pixel value, be sure the peeker's colorMap is nil."

	^ (BitBlt bitPeekerFromForm: self) colorMap: nil; pixelAt: aPoint
! !
!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 9/23/2012 21:38' prior: 16820397!
                           twoToneFromDisplay: aRectangle backgroundColor: bgColor
	"Copy one-bit deep ColorForm from the Display using a color map that maps all colors except the background color to black. Used for caching the contents of inactive MVC windows."

	| map |
	(width = aRectangle width and: [height = aRectangle height])
		ifFalse: [self setExtent: aRectangle extent depth: depth].

	"make a color map mapping the background color
	 to zero and all other colors to one"
	map _ Bitmap new: (1 bitShift: (Display depth min: 9)).
	1 to: map size do: [:i | map at: i put: 16rFFFFFFFF].
	map at: (bgColor indexInMap: map) put: 0.

	(BitBlt toForm: self)
		destOrigin: 0@0;
		sourceForm: Display;
		sourceRect: aRectangle;
		combinationRule: Form over;
		colorMap: map;
		copyBits.
! !
!ColorForm methodsFor: 'copying' stamp: 'jmv 9/23/2012 21:38' prior: 16820438!
                  copy: aRect
 	"Return a new ColorForm containing the portion of the receiver delineated by aRect."

	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	((BitBlt
		destForm: newForm
		sourceForm: self
		fillColor: nil
		combinationRule: Form over
		destOrigin: 0@0
		sourceOrigin: aRect origin
		extent: aRect extent
		clipRect: newForm boundingBox)
		colorMap: nil) copyBits.
	colors ifNotNil: [newForm colors: colors copy].
	^ newForm
! !
!DisplayScreen methodsFor: 'displaying' stamp: 'jmv 9/23/2012 21:38' prior: 16840445!
                               copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf 
	(BitBlt
		destForm: self
		sourceForm: sf
		fillColor: hf
		combinationRule: cr
		destOrigin: destOrigin
		sourceOrigin: rect origin
		extent: rect extent
		clipRect: (clipRect intersect: clippingBox)) copyBits! !
!DisplayScreen methodsFor: 'displaying' stamp: 'jmv 9/23/2012 21:38' prior: 16840457!
                              copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf map: map
	((BitBlt
		destForm: self
		sourceForm: sf
		fillColor: hf
		combinationRule: cr
		destOrigin: destOrigin
		sourceOrigin: rect origin
		extent: rect extent
		clipRect: (clipRect intersect: clippingBox)) colorMap: map) copyBits! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 9/23/2012 21:44' prior: 16859783!
  dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: (0@0) - (radius@radius).	
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: Color black.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do:
		[:dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !
!Form class methodsFor: 'examples' stamp: 'jmv 9/23/2012 21:44' prior: 16860140!
                               toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"
	"Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| facade ball filter point queue port color q colors colr colr2 |
	colors _ Display depth = 1
		ifTrue: [Array with: Color black]
		ifFalse: [Color red wheel: 12].
	facade _ Form extent: diam@diam offset: (diam//-2) asPoint.
	(Form dotOfSize: diam) displayOn: facade
			at: (diam//2) asPoint clippingBox: facade boundingBox
			rule: Form under fillColor: Color white.
	#(1 2 3) do:
		[:x |  "simulate facade by circles of gray"
		(Form dotOfSize: x*diam//5) displayOn: facade
			at: (diam*2//5) asPoint clippingBox: facade boundingBox
			rule: Form under
			fillColor: (Color perform: 
					(#(black gray lightGray) at: x)).
		"facade displayAt: 50*x@50"].
	ball _ Form dotOfSize: diam.
	color _ 8.
	[ true ] whileTrue:
		[port _ BitBlt toForm: Display.
		"Expand 1-bit forms to any pixel depth"
		port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: -20@-20].
		Sensor waitButton.
		Sensor mouseButton2Pressed ifTrue: [^ self].
		filter _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alphaMixed: 0.3 with: Color white.
		[Sensor mouseButton1Pressed or: [queue size > 0]] whileTrue:
			[filter _ filter * 4 + Sensor mousePoint // 5.
			point _ Sensor mouseButton1Pressed
				ifTrue: [filter] ifFalse: [-20@-20].
			port copyForm: ball to: point rule: Form paint fillColor: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Display depth = 1
				ifTrue: [port copyForm: facade to: q rule: Form erase]
				ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].
			Sensor mouseButton1Pressed ifTrue: [queue addLast: point]]].
! !
!FormCanvas methodsFor: 'other' stamp: 'jmv 9/23/2012 21:44' prior: 16861156!
                     showAt: pt invalidRects: updateRects
	| blt |
	blt _ (BitBlt toForm: Display)
		sourceForm: form;
		combinationRule: Form over.
	updateRects do:
		[:rect |
		blt sourceRect: rect;
			destOrigin: rect topLeft + pt;
			copyBits]! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 9/23/2012 21:48' prior: 16861308!
          resetGrafPort
	"Private!! Create a new grafPort for a new copy."

	port _ GrafPort toForm: form.
	port clipRect: clipRect.
! !
!FormCanvas methodsFor: 'private' stamp: 'jmv 9/23/2012 21:48' prior: 50387592!
                 setForm: aForm

	form _ aForm.
	port _ GrafPort toForm: form.

	"this was the contents of the #reset method"

	"origin of the top-left corner of this cavas"
	transformations first setTranslation: 0@0.
	clipRect _ (0@0 corner: form extent).	"default clipping rectangle"
	shadowColor _ nil! !
!InfiniteForm methodsFor: 'displaying' stamp: 'jmv 9/23/2012 21:45' prior: 16868487!
        displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm
	"This is the real display message, but it doesn't get used until the new
	display protocol is installed."
	| targetBox patternBox bb |
	(patternForm is: #Form) ifFalse: [
		^ aDisplayMedium fill: clipRectangle rule: ruleInteger fillColor: patternForm].

	"Do it iteratively"
	targetBox _ aDisplayMedium boundingBox intersect: clipRectangle.
	patternBox _ patternForm boundingBox.
	bb _ BitBlt destForm: aDisplayMedium sourceForm: patternForm fillColor: aForm
		combinationRule: ruleInteger destOrigin: 0@0 sourceOrigin: 0@0
		extent: patternBox extent clipRect: clipRectangle.
	bb colorMap:
		(patternForm colormapIfNeededFor: aDisplayMedium).
	(targetBox left truncateTo: patternBox width)
		to: targetBox right - 1 by: patternBox width do:
		[:x |
		(targetBox top truncateTo: patternBox height)
			to: targetBox bottom - 1 by: patternBox height do:
			[:y |
			bb destOrigin: x@y; copyBits]]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/23/2012 21:30' prior: 50382968!
        imageForm: depth forRectangle: rect
	| canvas |
	canvas _ FormCanvas depth: depth over: rect.
	canvas fullDraw: self.
	^ canvas formWithOffset! !
!Morph methodsFor: 'drawing' stamp: 'jmv 9/23/2012 21:30' prior: 50389898!
   ownShadowForm
	"Return a form representing the 'shadow' of the receiver, without including submorphs 
	regardless of clipping"
	| canvas |
	canvas _ FormCanvas forShadowOver: self morphBoundsInWorld.
	canvas into: self.
	canvas clipBy: self morphBoundsInWorld during: [ :c | self drawOn: c ].
	^ canvas form! !
!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jmv 9/23/2012 21:45' prior: 16907974!
                 copyPixelsGray: y
	"Handle non-interlaced grayscale color mode (colorType = 0)"

	bitsPerChannel = 16 ifTrue: [
		"Warning: This is extremely slow. Besides we are downsampling to 8 bits!!"
		| blitter |
		blitter := BitBlt bitPokerToForm: form.
		0 to: width - 1 do: [ :x |
			blitter pixelAt: x @ y put: 255 - (thisScanline at: x * 2 + 1) ].
			^self ].

	"Just copy the bits"

	"This interesting technique (By Andreas Raab) is a bit obscure, but it is so fast that we leave it active"
	^self copyPixelsGrayWeirdBitBltHack: y.

	"This interesting technique  (By Yoshiki Ohshima) is also instructive"
	"true ifTrue: [ ^form bits copyFromByteArray2: thisScanline to: y * (form width* bitsPerChannel // 32) ]."

	"This Smalltalk version might be easier to understand and is quite fast too."
	"This somewhat weird mixture of (#* and #+) with (#bitShift: and #bitOr:) 
	is to make use of faster arithmetic bytecodes, but not of slow largeintegers."
	"
	base _ y * (form width * bitsPerChannel + 31 // 32) + 1.
	bits _ form bits.
	0 to: thisScanline size // 4 - 1 do: [ :i |
		| ii |
		ii _ i * 4.
		word _
	           ((thisScanline at: ii+1) *256 + 
	           (thisScanline at: ii+2) *256 + 
	           ((thisScanline at: ii+3)) bitShift: 8) bitOr: 
	           (thisScanline at: ii+4).
		bits at: base + i put: word.].
	(bytesLeft := thisScanline size bitAnd: 3) = 0 ifFalse: [
		word := 0.
		thisScanline size - bytesLeft + 1 to: thisScanline size do: [ :ii |
			word := word * 256 + (thisScanline at: ii) ].
		word := word bitShift: 8 * (4 - bytesLeft).
		bits at: base + (thisScanline size // 4) put: word ].
	"! !
!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jmv 9/23/2012 21:46' prior: 16908028!
                     copyPixelsGray: y at: startX by: incX
	"Handle interlaced grayscale color mode (colorType = 0)"

	| offset bits blitter pixPerByte shifts b pixel mask pixelNumber |
	bitsPerChannel = 16
		ifTrue: [
			b := BitBlt bitPokerToForm: form.
			startX to: width-1 by: incX do: [ :x |
				b pixelAt: x@y put: 255 - (thisScanline at: (x//incX<<1)+1).
				].
			^ self
			].
	offset := y*rowSize+1.
	bits := form bits.
	bitsPerChannel = 8 ifTrue: [
		startX to: width-1 by: incX do: [ :x | | w |
			w := offset + (x>>2).
			b := 3- (x \\ 4) * 8.
			pixel := (thisScanline at: x // incX + 1)<<b.
			mask := (255<<b) bitInvert32.
			bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)
		].
		^ self
	].
	bitsPerChannel = 1 ifTrue: [
		pixPerByte := 8.
		mask := 1.
		shifts := #(7 6 5 4 3 2 1 0).
	].
	bitsPerChannel = 2 ifTrue: [
		pixPerByte := 4.
		mask := 3.
		shifts := #(6 4 2 0).
	].
	bitsPerChannel = 4 ifTrue: [
		pixPerByte := 2.
		mask := 15.
		shifts := #(4 0).
	].

	blitter := BitBlt bitPokerToForm: form.
	pixelNumber := 0.
	startX to: width-1 by: incX do: [ :x | | rawByte |
		rawByte := thisScanline at: (pixelNumber // pixPerByte) + 1.
		pixel := (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.
		blitter pixelAt: (x@y) put: pixel.
		pixelNumber := pixelNumber + 1.
	].
! !
!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jmv 9/23/2012 21:45' prior: 16908072!
         copyPixelsGrayAlpha: y
	"Handle non-interlaced grayscale with alpha color mode (colorType = 4)"

	| i pixel gray b |
	b _ BitBlt bitPokerToForm: form.
	bitsPerChannel = 8
		ifTrue: [
			0 to: width-1 do: [ :x |
				i _ (x << 1) + 1.
				gray _ thisScanline at: i.
				pixel _ ((thisScanline at: i+1)<<24) + (gray<<16) + (gray<<8) + gray.
				b pixelAt: x@y put: pixel.
				]
			]
		ifFalse: [
			0 to: width-1 do: [ :x |
				i _ (x << 2) + 1.
				gray _ thisScanline at: i.
				pixel _ ((thisScanline at: i+2)<<24) + (gray<<16) + (gray<<8) + gray.
				b pixelAt: x@y put: pixel.
				]
			]
! !
!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jmv 9/23/2012 21:45' prior: 16908094!
                      copyPixelsGrayAlpha: y at: startX by: incX
	"Handle interlaced grayscale with alpha color mode (colorType = 4)"

	| i pixel gray b |
	b _ BitBlt bitPokerToForm: form.
	bitsPerChannel = 8
		ifTrue: [
			startX to: width-1 by: incX do: [ :x |
				i _ (x // incX << 1) + 1.
				gray _ thisScanline at: i.
				pixel _ ((thisScanline at: i+1)<<24) + (gray<<16) + (gray<<8) + gray.
				b pixelAt: x@y put: pixel.
				]
			]
		ifFalse: [
			startX to: width-1 by: incX do: [ :x |
				i _ (x // incX << 2) + 1.
				gray _ thisScanline at: i.
				pixel _ ((thisScanline at: i+2)<<24) + (gray<<16) + (gray<<8) + gray.
				b pixelAt: x@y put: pixel.
				]
			]
! !
!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jmv 9/23/2012 21:45' prior: 16908159!
                          copyPixelsIndexed: y at: startX by: incX
	"Handle interlaced indexed color mode (colorType = 3)"

	| offset bits pixPerByte shifts blitter pixel mask pixelNumber |
	offset := y*rowSize+1.
	bits := form bits.
	bitsPerChannel = 8
		ifTrue: [
			startX to: width-1 by: incX do: [ :x | | b w |
				w := offset + (x>>2).
				b := 3 - (x \\ 4) * 8.
				pixel := (thisScanline at: x // incX + 1)<<b.
				mask := (255<<b) bitInvert32.
				bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)].
			^ self ].
	bitsPerChannel = 1 ifTrue: [
		pixPerByte := 8.
		mask := 1.
		shifts := #(7 6 5 4 3 2 1 0).
	].
	bitsPerChannel = 2 ifTrue: [
		pixPerByte := 4.
		mask := 3.
		shifts := #(6 4 2 0).
	].
	bitsPerChannel = 4 ifTrue: [
		pixPerByte := 2.
		mask := 15.
		shifts := #(4 0).
	].

	blitter := BitBlt bitPokerToForm: form.
	pixelNumber := 0.
	startX to: width-1 by: incX do: [ :x | | rawByte |
		rawByte := thisScanline at: (pixelNumber // pixPerByte) + 1.
		pixel := (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.
		blitter pixelAt: (x@y) put: pixel.
		pixelNumber := pixelNumber + 1.
	].
! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 9/23/2012 21:46' prior: 16918011!
        nextWordsInto: aBitmap 
	"Fill the word based buffer from my collection. 
	Stored on stream as Big Endian. Optimized for speed. 
	Read in BigEndian, then restoreEndianness."
	| blt pos source byteSize |
	collection class isBytes
		ifFalse: [^ self next: aBitmap size into: aBitmap startingAt: 1].

	byteSize := aBitmap byteSize.
	"is the test on collection basicSize \\ 4 necessary?"
	((self position bitAnd: 3) = 0 and: [ (collection basicSize bitAnd: 3) = 0])
		ifTrue: [source := collection.
			pos := self position.
			self skip: byteSize]
		ifFalse: ["forced to copy it into a buffer"
			source := self next: byteSize.
			pos := 0].

	"Now use BitBlt to copy the bytes to the bitmap."
	blt := (BitBlt
				toForm: (Form new hackBits: aBitmap))
				sourceForm: (Form new hackBits: source).
	blt combinationRule: Form over. "store"
	blt sourceX: 0;
		 sourceY: pos // 4;
		 height: byteSize // 4;
		 width: 4.
	blt destX: 0;
		 destY: 0.
	blt copyBits.

	"And do whatever the bitmap needs to do to convert from big-endian order."
	aBitmap restoreEndianness.

	^ aBitmap 	"May be WordArray, ColorArray, etc"
! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/23/2012 21:30' prior: 50389829!
                        submorphsShadowForm
	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"
	| bnds canvas |
	bnds _ Rectangle merging: (submorphs collect: [:m | m morphFullBoundsInWorld]).
	canvas _ FormCanvas forShadowOver: bnds.
	canvas into: self.
	self drawSubmorphsOn: canvas.
	^ canvas form offset: bnds topLeft - self morphPositionInWorld! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 9/23/2012 21:45' prior: 50353654!
         magnifiedForm
	| srcRect form neededExtent |
	lastPos _ self sourcePoint.
	srcRect _ self sourceRectFrom: lastPos.
	((srcRect intersects: self morphBoundsInWorld) and: [ RecursionLock == nil ])
		ifTrue: [
			RecursionLock _ self.
			"try to reuse form if appropriate"
			auxCanvas _ (auxCanvas notNil and: [ auxCanvas extent = srcExtent ])
				ifTrue: [
					"Just in case we go out of the Display"
					srcRect origin > (0@0) ifFalse: [
						auxCanvas form fillBlack ].
					FormCanvas on: auxCanvas form over: srcRect ]
				ifFalse: [ FormCanvas depth: 32 over: srcRect ].
			World drawOn: auxCanvas.
			World drawSubmorphsOn: auxCanvas.
			form _ auxCanvas form.
			RecursionLock _ nil]
		ifFalse: [
			"cheaper method if the source is not occluded"
			form _ Display copy: srcRect].
	"smooth if non-integer scale"
	neededExtent _ (srcExtent * magnification ) truncated.
	(magnifiedForm isNil or: [ magnifiedForm extent ~=  neededExtent ])
		ifTrue: [ magnifiedForm _ Form extent: neededExtent depth: 32 ].
	(WarpBlt toForm: magnifiedForm)
		sourceForm: form;
		colorMap: (form colormapIfNeededFor: magnifiedForm);
		cellSize: (magnification isInteger ifTrue: [1] ifFalse: [2]);  "installs a new colormap if cellSize > 1"
		combinationRule: 3;
		copyQuad: form boundingBox innerCorners toRect: magnifiedForm boundingBox.
	^magnifiedForm.! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 9/23/2012 21:45' prior: 50388557!
            drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			"self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBounds
					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]
				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"
			self clipsSubmorphs ifTrue: [
				aCanvas clipBy: self clippingBoundsInWorld
					during: [ :canvas | canvas image: backgroundImage at: 0@0 ]]
				ifFalse: [ aCanvas image: backgroundImage at: 0@0 ]]

		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [color class == TranslucentColor])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: 0@0 in: nil
						fillColor: color rule: Form over]
				ifFalse: [ super drawOn: aCanvas ]]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 9/23/2012 21:45' prior: 50361114!
    flashRects: rectangleList
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."
	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."

	| blt screenRect |
	blt _ (BitBlt toForm: Display)
		sourceForm: nil;
		sourceOrigin: 0@0;
		clipRect: self viewBox;
		combinationRule: Form reverse.
	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect; forceDisplayUpdate.
		(Delay forMilliseconds: 250) wait.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect; forceDisplayUpdate].
! !
!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 9/23/2012 21:46' prior: 16953517!
               bonk: glyphForm with: bonkForm
	"Bonking means to run through the glyphs clearing out black pixels
	between characters to prevent them from straying into an adjacent
	character as a result of, eg, bolding or italicizing"
	"Uses the bonkForm to erase at every character boundary in glyphs."
	| bb offset |
	offset _ bonkForm offset x.
	bb _ BitBlt toForm: glyphForm.
	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;
		combinationRule: Form erase; destY: 0.
	1 to: xTable size-1 do: [:i | bb destX: (xTable at: i) + offset; copyBits].
! !
!WarpBlt methodsFor: 'primitives' stamp: 'jmv 9/23/2012 21:46' prior: 16983981!
            warpBitsSmoothing: n sourceMap: sourceMap
	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |
	<primitive: 'primitiveWarpBits' module: 'BitBltPlugin'>

	"Check for compressed source, destination or halftone forms"
	((sourceForm is: #Form) and: [sourceForm unhibernate])
		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].
	((destForm is: #Form) and: [destForm unhibernate])
		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].
	((halftoneForm is: #Form) and: [halftoneForm unhibernate])
		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].

	(width < 1) | (height < 1) ifTrue: [^ self].
	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"
	n > 1 ifTrue:
		[(destForm depth < 16 and: [colorMap == nil])
			ifTrue: ["color map is required to smooth non-RGB dest"
					^ self primitiveFail].
		pix _ Array new: n*n].

	nSteps _ height-1 max: 1.
	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: nSteps)
			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).
	pA _ (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)
		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).
	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: nSteps)
			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).
	pB _ (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)
		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).

	picker _ BitBlt bitPeekerFromForm: sourceForm.
	poker _ BitBlt bitPokerToForm: destForm.
	poker clipRect: self clipRect.
	nSteps _ width-1 max: 1.
	destY to: destY+height-1 do:
		[:y |
		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: nSteps)
				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).
		sp _ (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)
			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).
		destX to: destX+width-1 do:
			[:x | 
			n = 1
			ifTrue:
				[poker pixelAt: x@y
						put: (picker pixelAt: sp // fixedPtOne asPoint)]
			ifFalse:
				[0 to: n-1 do:
					[:dx | 0 to: n-1 do:
						[:dy |
						pix at: dx*n+dy+1 put:
								(picker pixelAt: sp
									+ (deltaPAB*dx//n)
									+ (deltaP12*dy//n)
										// fixedPtOne asPoint)]].
				poker pixelAt: x@y put: (self mixPix: pix
										sourceMap: sourceMap
										destMap: colorMap)].
			sp _ sp + deltaPAB].
		pA _ pA + deltaP12.
		pB _ pB + deltaP43]! !
!WorldState methodsFor: 'canvas' stamp: 'jmv 9/23/2012 21:31' prior: 50379308!
                           assuredNonDisplayCanvas
	(canvas isNil or: [
		canvas drawsOnDisplay or: [
		(canvas extent ~= viewBox extent) or: [
		canvas form depth ~= Display depth]]])
			ifTrue: [
				"allocate a new offscreen canvas the size of the window"
				self canvas: (FormCanvas withExtent: viewBox extent depth: Display depth)].
	^ self canvas! !

WarpBlt class removeSelector: #current!

WarpBlt class removeSelector: #current!

ProcessorScheduler class removeSelector: #sweepHandIdleProcess!

ProcessorScheduler class removeSelector: #sweepHandIdleProcess!

FormCanvas removeSelector: #portClass!

FormCanvas removeSelector: #portClass!

DisplayScreen removeSelector: #defaultBitBltClass!

DisplayScreen removeSelector: #defaultBitBltClass!

DisplayScreen removeSelector: #defaultCanvasClass!

DisplayScreen removeSelector: #defaultCanvasClass!

DisplayScreen removeSelector: #defaultWarpBltClass!

DisplayScreen removeSelector: #defaultWarpBltClass!

Form removeSelector: #bytesPerRow!

Form removeSelector: #bytesPerRow!

Form removeSelector: #defaultCanvasClass!

Form removeSelector: #defaultCanvasClass!

BitBlt class removeSelector: #asGrafPort!

BitBlt class removeSelector: #asGrafPort!

BitBlt class removeSelector: #current!

BitBlt class removeSelector: #current!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Smalltalk removeKey: #ActiveEvent!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1457-CuisCore-JuanVuletich-2012Sep23-21h22m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1457] on 24 September 2012 at 7:22:55 pm'!

!classDefinition: #Utilities category: #'System-Support'!
Object subclass: #Utilities
	instanceVariableNames: ''
	classVariableNames: 'AuthorInitials AuthorName CommonRequestStrings LastStats RecentSubmissions'
	poolDictionaries: ''
	category: 'System-Support'!

Object subclass: #Utilities
	instanceVariableNames: ''
	classVariableNames: 'AuthorInitials AuthorName CommonRequestStrings LastStats RecentSubmissions '
	poolDictionaries: ''
	category: 'System-Support'!
!PluggableListMorph methodsFor: 'menus' stamp: 'jmv 9/24/2012 18:58' prior: 16914213!
     addCustomMenuItems:  aMenu hand: aHandMorph
	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."

	super addCustomMenuItems: aMenu hand: aHandMorph.
	aMenu addLine.
	aMenu add: 'copy list to clipboard' target: self action: #copyListToClipboard.
	aMenu add: 'copy selection to clipboard' target: self action: #copySelectionToClipboard! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 9/24/2012 18:43' prior: 16926379!
                  maximumUsableArea

	| allowedArea |
	allowedArea _ Display boundingBox.
	^allowedArea
! !
!MessageSetWindow methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 18:50' prior: 16891360!
          filterMessageList
	"Allow the user to refine the list of messages."

	| aMenu |
	model messageList size <= 1 
		ifTrue: [^self inform: 'this is not a propitious filtering situation'].

	aMenu := MenuMorph new defaultTarget: model.
	aMenu addTitle: 'Filter by only showing...'.
	aMenu addStayUpIcons.
	aMenu 
		addList: #(
			#('unsent messages' #filterToUnsentMessages 'filter to show only messages that have no senders')
			#-
			#('messages that send...' #filterToSendersOf 'filter to show only messages that send a selector I specify')
			#('messages that do not send...' #filterToNotSendersOf 'filter to show only messages that do not send a selector I specify')
			#-
			#('messages whose selector is...' #filterToImplementorsOf 'filter to show only messages with a given selector I specify')
			#('messages whose selector is NOT...' #filterToNotImplementorsOf 'filter to show only messages whose selector is NOT a seletor I specify')
			#-
			#('messages in any change set' #filterToAnyChangeSet 'filter to show only messages that occur in at least one change set')
			#('messages not in any change set' #filterToNotAnyChangeSet 'filter to show only messages that do not occur in any change set in the system')
			#-
			#('messages authored by me' #filterToCurrentAuthor 'filter to show only messages whose authoring stamp has my initials')
			#('messages not authored by me' #filterToNotCurrentAuthor 'filter to show only messages whose authoring stamp does not have my initials')
			#-
			#('messages logged in .changes file' #filterToMessagesInChangesFile 'filter to show only messages whose latest source code is logged in the .changes file')
			#('messages only in .sources file' #filterToMessagesInSourcesFile 'filter to show only messages whose latest source code is logged in the .sources file')
			#-
			#('messages with prior versions' #filterToMessagesWithPriorVersions 'filter to show only messages that have at least one prior version')
			#('messages without prior versions' #filterToMessagesWithoutPriorVersions 'filter to show only messages that have no prior versions')
			#-
			#('uncommented messages' #filterToUncommentedMethods 'filter to show only messages that do not have comments at the beginning')
			#('commented messages' #filterToCommentedMethods 'fileter to show only messages that have comments at the beginning')
			#-
			#('messages that...'
			#filterToMessagesThat 'let me type in a block taking a class and a selector, which will specify yea or nay concerning which elements should remain in the list')
		).
	aMenu popUpInWorld: self world! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 9/24/2012 18:56' prior: 50377019!
                buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Preferences...'. { self. #preferencesDo}.
					'put up a menu offering many controls over appearance and system preferences.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 9/24/2012 18:59' prior: 50377419!
                            preferencesMenu
	"Build the preferences menu for the world."

	^self fillIn: (self menu: 'Preferences...') from: {
		{'Themes...' . {Theme . #changeTheme} . 'switch to another theme.'}.
		{'Icons...' . {Theme . #changeIcons} . 'show more or less icons.'}.
		nil.
		{'Show taskbar' . {Taskbar . #show} . 'show the taskbar'}.
		{'Hide taskbar' . {Taskbar . #hide} . 'hide the taskbar'}.
		nil.
		{'Full screen on' . { self . #fullScreenOn} . 'puts you in full-screen mode, if not already there.'}.
		{'Full screen off' . { self . #fullScreenOff} . 'if in full-screen mode, takes you out of it.'}.
		nil.
		{'Set display depth...' . {self. #setDisplayDepth} . 'choose how many bits per pixel.'}.
		{'Set desktop color...' . {self. #changeBackgroundColor} . 'choose a uniform color to use as desktop background.'}.
		nil.
		{'Set Code Author...'. {Utilities. #setAuthor}. 'supply initials to be used to identify the author of code and other content.'}.
		{'All preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.
	}! !
!Utilities class methodsFor: 'common requests' stamp: 'jmv 9/24/2012 18:56' prior: 16980889!
initialize
	"Initialize the class variables.  5/16/96 sw"
	RecentSubmissions _ OrderedCollection new! !

WorldState removeSelector: #listOfSteppingMorphs!

WorldState removeSelector: #listOfSteppingMorphs!

WorldState removeSelector: #stepListSize!

WorldState removeSelector: #stepListSize!

Utilities class removeSelector: #appendToCommonRequests:!

Utilities class removeSelector: #appendToCommonRequests:!

Utilities class removeSelector: #cleanseOtherworldlySteppers!

Utilities class removeSelector: #cleanseOtherworldlySteppers!

Utilities class removeSelector: #commonRequestStrings:!

Utilities class removeSelector: #commonRequestStrings:!

Utilities class removeSelector: #editCommonRequestStrings!

Utilities class removeSelector: #editCommonRequestStrings!

Utilities class removeSelector: #initializeCommonRequestStrings!

Utilities class removeSelector: #initializeCommonRequestStrings!

Utilities class removeSelector: #offerCommonRequestsInMorphic!

Utilities class removeSelector: #offerCommonRequestsInMorphic!

Utilities initialize!

!classDefinition: #Utilities category: #'System-Support'!
Object subclass: #Utilities
	instanceVariableNames: ''
	classVariableNames: 'AuthorInitials AuthorName LastStats RecentSubmissions'
	poolDictionaries: ''
	category: 'System-Support'!

Object subclass: #Utilities
	instanceVariableNames: ''
	classVariableNames: 'AuthorInitials AuthorName LastStats RecentSubmissions'
	poolDictionaries: ''
	category: 'System-Support'!

TheWorldMenu removeSelector: #standardFontDo!

TheWorldMenu removeSelector: #standardFontDo!

SystemWindow removeSelector: #amendSteppingStatus!

SystemWindow removeSelector: #amendSteppingStatus!

Preferences class removeSelector: #chooseCodeFont!

Preferences class removeSelector: #chooseCodeFont!

Preferences class removeSelector: #chooseFontWithPrompt:andSendTo:withSelector:highlight:!

Preferences class removeSelector: #chooseFontWithPrompt:andSendTo:withSelector:highlight:!

Preferences class removeSelector: #chooseInitialSettings!

Preferences class removeSelector: #chooseInitialSettings!

Preferences class removeSelector: #chooseListFont!

Preferences class removeSelector: #chooseListFont!

Preferences class removeSelector: #chooseMenuFont!

Preferences class removeSelector: #chooseMenuFont!

Preferences class removeSelector: #chooseSystemFont!

Preferences class removeSelector: #chooseSystemFont!

Preferences class removeSelector: #chooseWindowTitleFont!

Preferences class removeSelector: #chooseWindowTitleFont!

Preferences class removeSelector: #fontConfigurationMenu!

Preferences class removeSelector: #fontConfigurationMenu!

Preferences class removeSelector: #modalColorPickers!

Preferences class removeSelector: #modalColorPickers!

Preferences class removeSelector: #printStandardSystemFonts!

Preferences class removeSelector: #printStandardSystemFonts!

Preferences class removeSelector: #setFlag:toValue:during:!

Preferences class removeSelector: #setFlag:toValue:during:!

Preferences class removeSelector: #setNotificationParametersForStandardPreferences!

Preferences class removeSelector: #setNotificationParametersForStandardPreferences!

Preferences class removeSelector: #smartUpdatingChanged!

Preferences class removeSelector: #smartUpdatingChanged!

Preference removeSelector: #categoryList!

Preference removeSelector: #categoryList!

Preference removeSelector: #categoryList:!

Preference removeSelector: #categoryList:!

Preference removeSelector: #defaultValue:!

Preference removeSelector: #defaultValue:!

Preference removeSelector: #helpString!

Preference removeSelector: #helpString!

Preference removeSelector: #name:defaultValue:helpString:lcategoryList:changeInformee:changeSelector:!

Preference removeSelector: #name:defaultValue:helpString:lcategoryList:changeInformee:changeSelector:!

Preference removeSelector: #rawValue:!

Preference removeSelector: #rawValue:!

PluggableListMorph removeSelector: #setListFont!

PluggableListMorph removeSelector: #setListFont!

PasteUpMorph removeSelector: #listOfSteppingMorphs!

PasteUpMorph removeSelector: #listOfSteppingMorphs!

PasteUpMorph removeSelector: #stepListSize!

PasteUpMorph removeSelector: #stepListSize!

PasteUpMorph removeSelector: #steppingMorphsNotInWorld!

PasteUpMorph removeSelector: #steppingMorphsNotInWorld!

AbstractFont class removeSelector: #promptForFont:andSendTo:withSelector:highlight:!

AbstractFont class removeSelector: #promptForFont:andSendTo:withSelector:highlight:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1458-CuisCore-JuanVuletich-2012Sep24-19h20m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1457] on 24 September 2012 at 8:20:30 pm'!
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 9/24/2012 19:32'!
                  request: queryString initialAnswer: defaultAnswer centerAt: aPoint onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean answerExtent: answerExtent
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."
	"
	FillInTheBlankMorph
		request: 'Type something, then type [Return].'
		initialAnswer: 'yo ho ho!!'
		centerAt: Display center
	"

	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		setQuery: queryString
		initialAnswer: defaultAnswer
		answerExtent: answerExtent
		acceptOnCR: acceptBoolean.
	aFillInTheBlankMorph responseUponCancel: returnOnCancel.
	self currentWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.
	^ aFillInTheBlankMorph getUserResponse
! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/24/2012 20:06'!
                    popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [:m | m isKindOf: UpdatingMenuItemMorph]) 
		do: [:m | m updateContents].
	self currentWorld addMorphFront: self.
	self 
		positionAt: aPoint
		relativeTo: (selectedItem ifNil: [self items first]).
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [hand newKeyboardFocus: self].
	evt := hand lastEvent.
	(evt isKeyboard or: [evt isMouse and: [evt anyButtonPressed not]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt]! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 9/24/2012 20:09'!
                    invokeModalAt: aPoint allowKeyboard: aBoolean
	"Invoke this menu and don't return until the user has chosen a value.
	See senders of this method for finding out how to use modal menu morphs."
	| w oldFocus actHand |
	w _ self currentWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneSubCycle.
	self	
		popUpAt: aPoint
		forHand: actHand 
		allowKeyboard: aBoolean.
	self isModalInvokationDone: false.
	[self isInWorld & self isModalInvokationDone not] whileTrue: [w doOneSubCycle].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 9/24/2012 20:08'!
                              invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	|actHand w oldFocus |
	self flag: #bob.		"is <aPoint> global or local?"
	self flag: #arNote.	"<aPoint> is local to aWorld"
	w _ self currentWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneSubCycle.
	self
		popUpAt: aPoint
		forHand: actHand
		allowKeyboard: aBoolean.
	done _ false.
	[self isInWorld & done not] whileTrue: [w doOneSubCycle].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ mvcSelection ! !
!Object methodsFor: 'macpal' stamp: 'jmv 9/24/2012 20:04' prior: 16904569!
                      currentWorld
	"Answer a morphic world that is the current UI focus."

	"Should query all instances of world, looking for the one animated by the currently running process!! (and answer nil if this is not a Morphic process!!)"
	self flag: #jmvVer2.

	ActiveWorld ifNotNil:[^ActiveWorld].
	^World! !
!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jmv 9/24/2012 19:42' prior: 16780509!
           fileInSoundLibrary
	"Prompt the user for a file name and the file in the sound library with that name."
	"AbstractSound fileInSoundLibrary"

	| fileName |
	fileName _ FillInTheBlankMorph request: 'Sound library file name?'.
	fileName isEmptyOrNil ifTrue: [^ self].
	(fileName endsWith: '.sounds') ifFalse: [fileName _ fileName, '.sounds'].
	self fileInSoundLibraryNamed: fileName.
! !
!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jmv 9/24/2012 19:42' prior: 16780550!
                    fileOutSoundLibrary: aDictionary
	"File out the given dictionary, which is assumed to contain sound and instrument objects keyed by their names."
	"Note: This method is separated out so that one can file out edited sound libraries, as well as the system sound library. To make such a collection, you can inspect AbstractSound sounds and remove the items you don't want. Then do: 'AbstractSound fileOutSoundLibrary: self' from the Dictionary inspector."

	| fileName refStream |
	(aDictionary isKindOf: Dictionary)
		ifFalse: [self error: 'arg should be a dictionary of sounds'].
	fileName _ FillInTheBlankMorph request: 'Sound library file name?'.
	fileName isEmptyOrNil ifTrue: [^ self].
	refStream _ SmartRefStream fileNamed: fileName, '.sounds'.
	[ refStream nextPut: aDictionary ]
		ensure: [ refStream close ]! !
!CodeFile methodsFor: 'fileIn/fileOut' stamp: 'jmv 9/24/2012 19:45' prior: 16811161!
                         fileOut
	| fileName stream |
	fileName := FillInTheBlankMorph request: 'Enter the file name' initialAnswer:''.
	stream := FileStream newFileNamed: fileName.
	sourceSystem isEmpty ifFalse:[
		stream nextChunkPut: sourceSystem printString; newLine ].
	self fileOutOn: stream.
	stream newLine; newLine.
	self classes do: [ :cls |
		cls needsInitialize ifTrue: [
			stream newLine; nextChunkPut: cls name,' initialize']].
	stream newLine.
	stream close! !
!CodeProvider methodsFor: 'categories' stamp: 'jmv 9/24/2012 19:45' prior: 16813774!
       categoryFromUserWithPrompt: aPrompt for: aClass
	"self new categoryFromUserWithPrompt: 'testing' for: SystemDictionary"

	|  labels myCategories reject lines newName menuIndex |
	labels _ OrderedCollection with: 'new...'.
	labels addAll: (myCategories _ aClass organization categories asArray copy sort:
		[ :a :b | a asLowercase < b asLowercase ]).
	reject _ myCategories asSet.
	reject
		add: ClassOrganizer nullCategory;
		add: ClassOrganizer default.
	lines _ OrderedCollection with: 1 with: (myCategories size + 1).

	aClass allSuperclasses do: [ :cls | | cats |
			cats _ cls organization categories reject: [ :cat | reject includes: cat].
			cats isEmpty ifFalse: [
				lines add: labels size.
				labels addAll: (cats asArray sort: [ :a :b | a asLowercase < b asLowercase]).
				reject addAll: cats]].

	(labels size = 1 or: [
		menuIndex _ (PopUpMenu labelArray: labels lines: lines)
		startUpWithCaption: aPrompt.
		menuIndex = 0 ifTrue: [^ nil].
		menuIndex = 1])
			ifTrue:[
				newName _ FillInTheBlankMorph request: 'Please type new category name' initialAnswer: 'category name'.
				newName isEmpty ifTrue: [ ^nil ]]
			ifFalse: [ newName _ labels at: menuIndex ].
	^ newName ifNotNil: [ newName asSymbol ]! !
!Browser methodsFor: 'accessing' stamp: 'jmv 9/24/2012 19:45' prior: 16793828!
        request: prompt initialAnswer: initialAnswer

	^ FillInTheBlankMorph
		request: prompt
		initialAnswer: initialAnswer
! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 9/24/2012 19:45' prior: 16798450!
                 fileOutSelections 
	| f |
	f _ FileStream newFileNamed: (FillInTheBlankMorph request: 'Enter file name' initialAnswer: 'Filename.st').
	f ifNil: [^ self].
	f timeStamp.
	listSelections with: changeList do: 
		[:selected :item | selected ifTrue: [item fileOutOn: f]].
	f close! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 9/24/2012 19:45' prior: 16801749!
                rename
	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"

	| newName |
	newName _ FillInTheBlankMorph request: 'New name for this change set'
						initialAnswer: myChangeSet name.
	(newName = myChangeSet name or: [newName size = 0]) ifTrue:
			[^ Beeper beep].

	(self class changeSetNamed: newName) ifNotNil:
			[^ Utilities inform: 'Sorry that name is already used'].

	myChangeSet name: newName.
	self update.
	self changed: #mainButtonName.
	self changed: #relabel.! !
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 9/24/2012 19:43' prior: 16833549!
                        askForCategoryIn: aClass default: aString
	| categories index category |
	categories := OrderedCollection with: 'new ...'. 
	categories addAll: (aClass allMethodCategoriesIntegratedThrough: Object).	
	index := PopUpMenu withCaption: 'Please provide a good category for the new method!!'
						chooseFrom: categories.
	index = 0 ifTrue: [^ aString].
	category := index = 1 ifTrue: [FillInTheBlankMorph request: 'Enter category name:']
						ifFalse: [categories at: index].
	^ category isEmpty ifTrue: [^ aString] ifFalse: [category]! !
!FileList methodsFor: 'file menu action' stamp: 'jmv 9/24/2012 19:45' prior: 16851060!
                 addNew: aString byEvaluating: aBlock
	"A parameterization of earlier versions of #addNewDirectory and
	#addNewFile.  Fixes the bug in each that pushing the cancel button
	in the FillInTheBlank dialog gave a walkback."

	| response newName index ending |
	(response := FillInTheBlankMorph
						request: ('New {1} Name?' format: {aString})
						initialAnswer: ('{1}Name' format: {aString}))
		isEmpty ifTrue: [^ self].
	newName := response asFileName.
	Cursor wait showWhile: [
		aBlock value: newName].
	self updateFileList.
	index := list indexOf: newName.
	index = 0 ifTrue: [ending := ') ',newName.
		index := list findFirst: [:line | line endsWith: ending]].
	self fileListIndex: index.
! !
!FileList methodsFor: 'file menu action' stamp: 'jmv 9/24/2012 19:46' prior: 16851130!
                 renameFile
	"Rename the currently selected file"
	| newName response |
	listIndex = 0 ifTrue: [^ self].
	(response _ FillInTheBlankMorph request: 'NewFileName?'
 					initialAnswer: fileName)
		isEmpty ifTrue: [^ self].
	newName _ response asFileName.
	newName = fileName ifTrue: [^ self].
	directory rename: fileName toBe: newName.
	self updateFileList.
	listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = newName].
	listIndex > 0 ifTrue: [fileName _ newName].
	self changed: #fileListIndex.
! !
!MessageSet methodsFor: 'filtering' stamp: 'jmv 9/24/2012 19:46' prior: 16891034!
  filterToImplementorsOf
	"Filter the receiver's list down to only those items with a given selector"

	| aFragment inputWithBlanksTrimmed |

	aFragment _ FillInTheBlankMorph request: 'type selector:' initialAnswer: ''.
	aFragment  isEmptyOrNil ifTrue: [^ self].
	inputWithBlanksTrimmed _ aFragment withBlanksTrimmed.
	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:
		[:aSymbol | 
			self filterFrom:
				[:aClass :aSelector |
					aSelector == aSymbol]]! !
!MessageSet methodsFor: 'filtering' stamp: 'jmv 9/24/2012 19:46' prior: 16891150!
  filterToNotImplementorsOf
	"Filter the receiver's list down to only those items whose selector is NOT one solicited from the user."

	| aFragment inputWithBlanksTrimmed |

	aFragment _ FillInTheBlankMorph request: 'type selector: ' initialAnswer: ''.
	aFragment  isEmptyOrNil ifTrue: [^ self].
	inputWithBlanksTrimmed _ aFragment withBlanksTrimmed.
	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:
		[:aSymbol | 
			self filterFrom:
				[:aClass :aSelector |
					aSelector ~~ aSymbol]]! !
!MessageSet methodsFor: 'filtering' stamp: 'jmv 9/24/2012 19:46' prior: 16891168!
 filterToNotSendersOf
	"Filter the receiver's list down to only those items which do not send a given selector"

	| aFragment inputWithBlanksTrimmed aMethod |

	aFragment _ FillInTheBlankMorph request: 'type selector:' initialAnswer: ''.
	aFragment  isEmptyOrNil ifTrue: [^ self].
	inputWithBlanksTrimmed _ aFragment withBlanksTrimmed.
	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:
		[:aSymbol | 
			self filterFrom:
				[:aClass :aSelector |
					(aMethod _ aClass compiledMethodAt: aSelector) isNil or:
						[(aMethod hasLiteralThorough: aSymbol) not]]]! !
!MessageSet methodsFor: 'filtering' stamp: 'jmv 9/24/2012 19:46' prior: 16891188!
                         filterToSendersOf
	"Filter the receiver's list down to only those items which send a given selector"

	| aFragment inputWithBlanksTrimmed aMethod |

	aFragment _ FillInTheBlankMorph request: 'type selector:' initialAnswer: ''.
	aFragment  isEmptyOrNil ifTrue: [^ self].
	inputWithBlanksTrimmed _ aFragment withBlanksTrimmed.
	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:
		[:aSymbol | 
			self filterFrom:
				[:aClass :aSelector |
					(aMethod _ aClass compiledMethodAt: aSelector) notNil and:
						[aMethod hasLiteralThorough: aSymbol]]]

! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 9/24/2012 19:53' prior: 50391609!
                             editBalloonHelpContent: aString
	| reply |
	reply _ FillInTheBlankMorph
		request: 'Edit the balloon help text for ' , (self printStringLimitedTo: 40)
		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString]).
	reply ifNil: [^ self].  "User cancelled out of the dialog"
	(reply isEmpty or: [reply asString = self noHelpString])
		ifTrue: [self setBalloonText: nil]
		ifFalse: [self setBalloonText: reply]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 9/24/2012 20:12' prior: 16898117!
                              halo

	self world ifNotNil: [ :w |
		w haloMorphs do: [ :h |
			h target == self ifTrue: [^ h]]].
	^ nil! !
!Morph methodsFor: 'menus' stamp: 'jmv 9/24/2012 19:46' prior: 16898721!
           exportAsBMP
	| fName |
	fName _ FillInTheBlankMorph request:'Please enter the name' initialAnswer: (self printStringLimitedTo: 20),'.bmp'.
	fName isEmpty ifTrue:[^self].
	(self imageForm: 32) writeBMPfileNamed: fName.! !
!Morph methodsFor: 'menus' stamp: 'jmv 9/24/2012 19:46' prior: 16898730!
                          exportAsJPEG
	"Export the receiver's image as a JPEG"

	| fName |
	fName _ FillInTheBlankMorph request: 'Please enter the name' initialAnswer: (self printStringLimitedTo: 20),'.jpeg'.
	fName isEmpty ifTrue: [^ self].
	(self imageForm: 32) writeJPEGfileNamed: fName! !
!Morph methodsFor: 'menus' stamp: 'jmv 9/24/2012 19:47' prior: 16898740!
           exportAsPNG
	| fName |
	fName _ FillInTheBlankMorph request:'Please enter the name' initialAnswer: (self printStringLimitedTo: 20),'.png'.
	fName isEmpty ifTrue:[^self].
	PNGReadWriter putForm: (self imageForm: 32) onFileNamed: fName.! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 9/24/2012 19:52' prior: 50391794!
         request: queryString
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph request: 'What is your favorite color?'"

	^ self
		request: queryString
		initialAnswer: ''
		centerAt: World activeHand morphPosition
		onCancelReturn: ''
		acceptOnCR: true
		answerExtent: self defaultAnswerExtent! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 9/24/2012 19:52' prior: 50391809!
                              request: queryString initialAnswer: defaultAnswer 
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'"

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: World activeHand morphPosition
		onCancelReturn: ''
		acceptOnCR: true
		answerExtent: self defaultAnswerExtent! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/24/2012 20:08' prior: 50381491!
  basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self handleSize.
	anExtent _ ((extent x + self handleSize + 8) max: minSide) @
				((extent y + self handleSize + 8) max: minSide).
	aBox _ Rectangle center: self morphBoundsInWorld center extent: anExtent.
	w _ self world ifNil: [ target world ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: 8@8) ]! !
!ImageMorph methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 19:46' prior: 16867782!
    readFromFile
	| fileName |
	fileName _ FillInTheBlankMorph
		request: 'Please enter the image file name'
		initialAnswer: 'fileName'.
	fileName isEmpty ifTrue: [^ self].
	self image: (Form fromFileNamed: fileName).
! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 9/24/2012 19:43' prior: 16888010!
                         addItem

	| string sel |
	string _ FillInTheBlankMorph request: 'Label for new item?'.
	string isEmpty ifTrue: [^ self].
	sel _ FillInTheBlankMorph request: 'Selector?'.
	sel isEmpty ifFalse: [sel _ sel asSymbol].
	self add: string action: sel.
! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 9/24/2012 19:43' prior: 16888020!
                           addTitle

	| string |
	string _ FillInTheBlankMorph request: 'Title for this menu?'.
	string isEmpty ifTrue: [^ self].
	self addTitle: string.
! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 9/24/2012 20:10' prior: 50392667!
                        invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu"

	^ self invokeModalAt: ActiveHand morphPosition allowKeyboard: allowKeyboardControl! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 9/24/2012 20:14' prior: 16884736!
                          displayAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	self currentWorld addMorph: self centeredNear: aPoint.
	self world displayWorld.  "show myself"
	aBlock value.
	self delete! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 9/24/2012 20:14' prior: 50392738!
                            informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ self currentWorld.
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph morphWidth: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'jmv 9/24/2012 19:47' prior: 16901913!
                 promptUserForHostAddressDefault: defaultName
	"Ask the user for a host name and return its address. If the default name is the empty string, use the last host name as the default."
	"NetNameResolver promptUserForHostAddressDefault: ''"

	| default hostName serverAddr |
	defaultName isEmpty
		ifTrue: [default _ DefaultHostName]
		ifFalse: [default _ defaultName].
	hostName _ FillInTheBlankMorph
		request: 'Host name or address?'
		initialAnswer: default.
	hostName isEmpty ifTrue: [^ 0].
	serverAddr _ NetNameResolver addressForName: hostName timeout: 15.
	hostName size > 0 ifTrue: [DefaultHostName _ hostName].
	^ serverAddr! !
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 9/24/2012 20:04' prior: 16905866!
                monitor: anObjectExplorerWrapper
	"Start stepping and watching the given wrapper for changes."
	anObjectExplorerWrapper ifNil: [ ^self ].
	self currentWorld ifNotNil: [ :w |
		self monitorList at: anObjectExplorerWrapper put: anObjectExplorerWrapper asString.
		w startStepping: self at: Time millisecondClockValue selector: #step arguments: #() stepTime: 200 ]! !
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 9/24/2012 20:05' prior: 16905890!
                            step
	"If there's anything in my monitor list, see if the strings have changed."
	| string changes |
	changes _ false.
	self monitorList keysAndValuesDo: [ :k :v |
		k ifNotNil: [
			k refresh.
			(string _ k asString) ~= v ifTrue: [ self monitorList at: k put: string. changes _ true ].
		]
	].
	changes ifTrue: [ | sel |
		sel _ currentSelection.
		self changed: #getList.
		self noteNewSelection: sel.
	].
	
	self monitorList isEmpty ifTrue: [
		self currentWorld ifNotNil: [ :w | w stopStepping: self selector: #step ]]! !
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 9/24/2012 20:05' prior: 16905908!
                          stopMonitoring
	monitorList _ nil.
	self currentWorld ifNotNil: [ :w |
		w stopStepping: self selector: #step ]! !
!Parser methodsFor: 'error correction' stamp: 'jmv 9/24/2012 19:47' prior: 16911147!
                        defineClass: className
	"prompts the user to define a new class,  
	asks for it's category, and lets the users edit further  
	the definition"
	| sym cat def d2 |
	sym := className asSymbol.
	cat := FillInTheBlankMorph request: 'Enter class category : ' initialAnswer: self encoder classEncoding theNonMetaClass category.
	cat
		ifEmpty: [cat := 'Unknown'].
	def := 'Object subclass: #' , sym , '
		instanceVariableNames: '''' 
		classVariableNames: ''''
		poolDictionaries: ''''
		category: ''' , cat , ''''.
	d2 := FillInTheBlankMorph request: 'Edit class definition : ' initialAnswer: def.
	d2
		ifEmpty: [d2 := def].
	Compiler evaluate: d2.
	^ encoder
		global: (Smalltalk associationAt: sym)
		name: sym! !
!PasteUpMorph methodsFor: 'WiW support' stamp: 'jmv 9/24/2012 20:13' prior: 16911524!
  shouldGetStepsFrom: aWorld

	(self isWorldMorph and: [owner notNil]) ifTrue: [
		^self world == aWorld
	].
	^super shouldGetStepsFrom: aWorld! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 9/24/2012 20:13' prior: 50387821!
                    invalidateRect: damageRect
        "Clip damage reports to my bounds, since drawing is clipped to my bounds."

        self == self world 
                ifTrue: [ worldState recordDamagedRect: (damageRect intersect: (0@0 extent: self morphExtent) ) ]
                ifFalse: [ super invalidateRect: damageRect ]
! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 9/24/2012 20:13' prior: 16911570!
      redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

        self == self world 
                ifTrue: [worldState doFullRepaint]
                ifFalse: [super redrawNeeded]
! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 9/24/2012 20:12' prior: 16912405!
                         displayWorld

	self world privateOuterDisplayWorld
! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 9/24/2012 20:08' prior: 16917659!
           startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean 
	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,
	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."

	| maxHeight |
	maxHeight := Display height * 3 // 4.
	self frameHeight > maxHeight 
		ifTrue: 
			[^self 
				startUpSegmented: maxHeight
				withCaption: captionOrNil
				at: location
				allowKeyboard: aBoolean].
	^Cursor normal showWhile: 
							[(MVCMenuMorph from: self title: captionOrNil) 
								invokeAt: location
								allowKeyboard: aBoolean]! !
!ProgressBarMorph methodsFor: 'menu' stamp: 'jmv 9/24/2012 19:47' prior: 16923307!
                           changeProgressValue: evt
	| answer |
	answer _ FillInTheBlankMorph
		request: 'Enter new value (0 - 1.0)'
		initialAnswer: self value contents asString.
	answer isEmptyOrNil ifTrue: [^ self].
	self value: answer asNumber! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 9/24/2012 19:43' prior: 16943402!
writeClassRenameMethod: sel was: oldName fromInstVars: oldList 
	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "

	| tell choice newName answ code oldVer newList newVer instSel |
	self flag: #bobconv.
	tell := 'Reading an instance of ' , oldName 
				, '.
Which modern class should it translate to?'.
	answ := (PopUpMenu 
				labels: 'Let me type the name now
Let me think about it
Let me find a conversion file on the disk') 
					startUpWithCaption: tell.
	answ = 1 
		ifTrue: [
			tell := 'Name of the modern class {1} should translate to:' format: {oldName}.
			choice := FillInTheBlankMorph request: tell.	"class name"
			choice size = 0 
				ifTrue: [answ := 'conversion method needed']
				ifFalse: 
					[newName := choice.
					answ := Smalltalk at: newName asSymbol
								ifAbsent: ['conversion method needed'].
					answ class == String 
						ifFalse: [renamed at: oldName asSymbol put: answ name]]].
	answ = 3 | (answ = 0) 
		ifTrue: [
			self close.
			^'conversion method needed'].
	answ = 2 ifTrue: [answ := 'conversion method needed'].
	answ = 'conversion method needed' 
		ifTrue: [
			self close.
			newName := 'PutNewClassHere'].
	answ class == String 
		ifFalse: 
			[oldVer := self versionSymbol: (structures at: oldName).
			newList := (Array with: answ classVersion) , answ allInstVarNames.
			newVer := self versionSymbol: newList.
			instSel := 'convert' , oldVer , ':' , newVer , ':'].
	code := WriteStream on: (String new: 500).
	code
		nextPutAll: sel;
		newLine.
	answ class == String 
		ifFalse: [
			code
				newLine;
				tab;
				nextPutAll: 'reshaped at: #' , oldName , ' put: #' , instSel , '.'.
			code
				newLine;
				tab;
				tab;
				nextPutAll: '"Be sure to define that conversion method in class ' 
							, answ name , '"'].
	code
		newLine;
		tab;
		nextPutAll: '^ ' , newName.	"Return new class"
	self class compile: code contents classified: 'conversion'.
	newName = 'PutNewClassHere' 
		ifTrue: [
			self 
				inform: 'Please complete the following method and 
then read-in the object file again.'.
			Smalltalk browseAllImplementorsOf: sel asSymbol].
	self flag: #violateBasicLayerPrinciples.
	"SmartRefStream should not refer to UI!!!!!!!!!! (sd)"

	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  
	If this is true for class Foo, define classVersion in Foo class.  
	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."
	^answ! !
!Socket class methodsFor: 'tests' stamp: 'jmv 9/24/2012 19:47' prior: 16946100!
                             sendTest
	"Send data to the 'discard' socket of the given host.
	Tests the speed of one-way data transfers across the
	network to the given host. Note that most hosts
	do not run a discard server."

	"Socket sendTest"

	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |
	Transcript newLine; show: 'starting send test'; newLine.
	self initializeNetwork.
	serverName := FillInTheBlankMorph request: 'What is the destination server?' initialAnswer: 'create.ucsb.edu'.
	serverAddr := NetNameResolver addressForName: serverName timeout: 10.
	serverAddr ifNil: [
		^self inform: 'Could not find an address for ' , serverName].
	sock := self new.
	Transcript show: '---------- Connecting ----------';newLine.
	sock connectTo: serverAddr port: 9.
	sock isConnected ifFalse: [
		sock destroy.
		^self inform: 'could not connect'].
	Transcript show: 'connection established; sending data'; newLine.
	bytesToSend := 1000000.
	sendBuf := String new: 64 * 1024 withAll: $x.
	bytesSent := 0.
	t := Time millisecondsToRun: 
					[[bytesSent < bytesToSend] whileTrue: 
							[sock sendDone 
								ifTrue: [bytesSent := bytesSent + (sock sendSomeData: sendBuf)]]].
	sock waitForSendDoneFor: self standardTimeout.
	sock destroy.
	Transcript show: '---------- Connection Closed ----------'; newLine;
		show: 'send test done; time = ' , t printString; newLine;
		show: (bytesToSend asFloat / t roundTo: 0.01) printString, ' * 1000 bytes/sec'; newLine; endEntry! !
!StandardFileStream class methodsFor: 'error handling' stamp: 'jmv 9/24/2012 19:47' prior: 16951724!
       fileDoesNotExistUserHandling: fullFileName

	| selection newName |
	selection _ (PopUpMenu labels:
'create a new file
choose another name
cancel')
			startUpWithCaption: (FileDirectory localNameFor: fullFileName) , '
does not exist.'.
	selection = 1 ifTrue:
		[^ self new open: fullFileName forWrite: true].
	selection = 2 ifTrue:
		[ newName _ FillInTheBlankMorph request: 'Enter a new file name'
						initialAnswer:  fullFileName.
		^ self oldFileNamed:
			(self fullName: newName)].
	self halt! !
!StandardFileStream class methodsFor: 'error handling' stamp: 'jmv 9/24/2012 19:48' prior: 16951743!
      fileExistsUserHandling: fullFileName
	| dir localName choice newName newFullFileName |
	dir _ FileDirectory forFileName: fullFileName.
	localName _ FileDirectory localNameFor: fullFileName.
	choice _ (PopUpMenu
		labels:
'overwrite that file\choose another name\cancel' withNewLines)
		startUpWithCaption: localName, '
already exists.'.

	choice = 1 ifTrue: [
		dir deleteFileNamed: localName
			ifAbsent: [self error: 'Could not delete the old version of that file'].
		^ self new open: fullFileName forWrite: true].

	choice = 2 ifTrue: [
		newName _ FillInTheBlankMorph request: 'Enter a new file name' initialAnswer: fullFileName.
		newFullFileName _ self fullName: newName.
		^ self newFileNamed: newFullFileName].

	self error: 'Please close this to abort file opening'! !
!StandardFileStream class methodsFor: 'error handling' stamp: 'jmv 9/24/2012 19:48' prior: 16951770!
                readOnlyFileDoesNotExistUserHandling: fullFileName

	| dir files choices selection newName fileName |
	dir _ FileDirectory forFileName: fullFileName.
	files _ dir fileNames.
	fileName _ FileDirectory localNameFor: fullFileName.
	choices _ fileName correctAgainst: files.
	choices add: 'Choose another name'.
	choices add: 'Cancel'.
	selection _ (PopUpMenu labelArray: choices lines: (Array with: 5) )
		startUpWithCaption: (FileDirectory localNameFor: fullFileName), '
does not exist.'.
	selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].
	selection < (choices size - 1) ifTrue: [
		newName _ (dir pathName , FileDirectory slash , (choices at: selection))].
	selection = (choices size - 1) ifTrue: [
		newName _ FillInTheBlankMorph 
							request: 'Enter a new file name' 
							initialAnswer: fileName].
	newName = '' ifFalse: [^ self readOnlyFileNamed: (self fullName: newName)].
	^ self error: 'Could not open a file'! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 9/24/2012 19:48' prior: 16959157!
                              condenseSources	
	"Move all the changes onto a compacted sources file."
	"Smalltalk condenseSources"

	| f classCount dir newVersionString newSourcesName |
	dir _ FileDirectory default.
	newVersionString _ FillInTheBlankMorph request: 'Please designate the version
for the new source code file...' initialAnswer: SourceFileVersionString.
	newVersionString ifNil: [^ self].
	newVersionString = SourceFileVersionString ifTrue:
		[^ self error: 'The new source file must not be the same as the old.'].
	SourceFileVersionString _ newVersionString.

	"Write all sources with fileIndex 1"
	newSourcesName _ self newSourcesName.
	f _ FileStream newFileNamed: newSourcesName.
	f timeStamp.
'Condensing Sources File...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: Smalltalk classNames size
	during:
		[:bar | classCount _ 0.
		Smalltalk allClassesDo:
			[:class | bar value: (classCount _ classCount + 1).
			class fileOutOn: f moveSource: true toFile: 1]].
	f close.

	CompiledMethod allInstancesDo:
		[ : e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	"Make a new empty changes file"
	self closeSourceFiles.
	dir rename: self localChangesName
		toBe: self localChangesName , '.old'.
	(FileStream newFileNamed: self localChangesName)
		timeStamp; close.
	LastQuitLogPosition _ 0.

	self setMacFileInfoOn: self localChangesName.
	self setMacFileInfoOn: newSourcesName.
	self openSourceFiles.
	self inform: 'Source files have been rewritten!!
 
Check that all is well, and then save/quit.
 
Otherwise, remove new sources/changes,
replace them with the former ones, and
exit without saving the image.
 '! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 9/24/2012 19:48' prior: 16962109!
              saveAsEmbeddedImage
	"Save the current state of the system as an embedded image"

	| dir newName newImageName |
	dir _ FileDirectory default.
	newName _ FillInTheBlankMorph
		request: 'Select existing VM file'
		initialAnswer: (FileDirectory localNameFor: '').
	newName = '' ifTrue: [^ self].
	newName _ FileDirectory baseNameFor: newName asFileName.

	newImageName _ newName.
	(dir includesKey: newImageName) ifFalse:
		[^ self inform: 'Unable to find name ', newName, ' Please choose another name.'].

	self logChange: '----SAVEAS (EMBEDDED) ', newName, '----', Date dateAndTimeNow printString.
	self imageName: (dir fullNameFor: newImageName).
	LastImageName _ self imageName.
	self closeSourceFiles.
	self snapshot: true andQuit: true embedded: true
! !
!SystemDictionary methodsFor: 'toDeprecate' stamp: 'jmv 9/24/2012 19:48' prior: 16962907!
                getFileNameFromUser

	| newName |
	newName _ FillInTheBlankMorph
		request: 'New File Name?'
		initialAnswer: (FileDirectory localNameFor: self imageName).
	newName isEmpty ifTrue: [^nil].
	((FileDirectory default fileOrDirectoryExists: (self fullNameForImageNamed: newName)) or:
	 [FileDirectory default fileOrDirectoryExists: (self fullNameForChangesNamed: newName)]) ifTrue: [
		(self confirm: ('{1} already exists. Overwrite?' format: {newName})) ifFalse: [^nil]].
	^newName
! !
!SystemWindow methodsFor: 'label' stamp: 'jmv 9/24/2012 19:48' prior: 16965283!
             relabel
	| newLabel |
	newLabel _ FillInTheBlankMorph 
		request: 'New title for this window'
		initialAnswer: labelString.
	newLabel isEmpty ifTrue: [^self].
	self setLabel: newLabel! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 9/24/2012 19:43' prior: 50371558!
         createPackage

	| pkName |
	pkName _ FillInTheBlankMorph request: 'Name for new package?'.
	CodePackage
		named: pkName
		createIfAbsent: true
		registerIfNew: true! !
!CodeWindow methodsFor: 'misc' stamp: 'jmv 9/24/2012 19:45' prior: 16815525!
           getSelectorAndSendQuery: querySelector to: queryPerformer with: queryArgs
	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained and queryArgs as its arguments.  If no message is currently selected, then obtain a method name from a user type-in"

	| strm array |
	strm _ WriteStream on: (array _ Array new: queryArgs size + 1).
	strm nextPut: nil.
	strm nextPutAll: queryArgs.

	model selectedMessageName ifNil: [ | selector |
		selector _ FillInTheBlankMorph request: 'Type selector:' initialAnswer: 'flag:'.
		^ selector isEmptyOrNil ifFalse: [
			(Symbol hasInterned: selector
				ifTrue: [ :aSymbol |
					array at: 1 put: aSymbol.
					queryPerformer perform: querySelector withArguments: array])
				ifFalse: [ self inform: 'no such selector']
		]
	].

	self selectMessageAndEvaluate: [:selector |
		array at: 1 put: selector.
		queryPerformer perform: querySelector withArguments: array
	]! !
!BrowserWindow methodsFor: 'commands' stamp: 'jmv 9/24/2012 19:42' prior: 16795887!
                         findClass
	"Search for a class by name."
	| pattern foundClass classNames index toMatch exactMatch potentialClassNames |

	self okToChange ifFalse: [ ^self flash ].
	pattern _ FillInTheBlankMorph request: 'Class name or fragment?'.
	pattern isEmpty ifTrue: [^ self flash].
	toMatch _ (pattern copyWithout: $.) asLowercase withBlanksTrimmed.
	potentialClassNames _ model potentialClassNames asOrderedCollection.
	classNames _ (pattern last = $. or: [pattern last = $ ])
		ifTrue: [potentialClassNames select:
					[:nm |  nm asLowercase = toMatch]]
		ifFalse: [potentialClassNames select: 
					[:n | n includesSubstring: toMatch caseSensitive: false]].
	classNames isEmpty ifTrue: [^ self flash].
	exactMatch _ classNames detect: [ :each | each asLowercase = toMatch] ifNone: nil.

	index _ classNames size = 1
		ifTrue:	[1]
		ifFalse:	[exactMatch
			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUp]
			ifNotNil: [classNames addFirst: exactMatch.
				(PopUpMenu labelArray: classNames lines: #(1)) startUp]].
	index = 0 ifTrue: [^ self flash].
	foundClass _ Smalltalk at: (classNames at: index) asSymbol.
 	model selectCategoryForClass: foundClass.
	model selectClass: foundClass
! !
!CodeFileBrowserWindow methodsFor: 'commands' stamp: 'jmv 9/24/2012 19:43' prior: 16812040!
                      findClass
	| pattern foundClass classNames index foundCodeFile |
	self okToChange ifFalse: [^ self flash].
	pattern _ (FillInTheBlankMorph request: 'Class Name?') asLowercase.
	pattern isEmpty ifTrue: [^ self].
	classNames := Set new.
	classNames addAll: model selectedCodeFile classes keys.
	classNames := classNames asArray select: 
		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].
	classNames isEmpty ifTrue: [^ self].
	index _ classNames size = 1
				ifTrue:	[1]
				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].
	index = 0 ifTrue: [^ self].
	foundCodeFile := nil.
	foundClass := nil.
		(model selectedCodeFile classes includesKey: (classNames at: index)) ifTrue:[
			foundClass := model selectedCodeFile classes at: (classNames at: index).
			foundCodeFile := model selectedCodeFile ].
	foundClass ifNotNil: [
	 	model systemCategoryListIndex: (model systemCategoryList indexOf: foundCodeFile name asSymbol).
		model classListIndex: (model classList indexOf: foundClass name) ]! !
!DebuggerWindow methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 19:43' prior: 16835025!
                               returnValue
	| expression |
	expression _ FillInTheBlankMorph request: 'Enter expression for return value:'.
	model returnValue: expression! !
!InspectorWindow methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 19:43' prior: 16871675!
                      addEntry

	| newKey string |
	string _ FillInTheBlankMorph request:
'Enter new key, then type RETURN.
(Expression will be evaluated for value.)
Examples:  #Fred    ''a string''   3+4'.
	newKey _ Smalltalk actualCompilerClass evaluate: string.
	model addEntry: newKey! !
!InspectorWindow methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 19:46' prior: 16871748!
                       renameEntry
	| string newKey |

	string _ FillInTheBlankMorph request: 
'Enter new key, then type RETURN.
(Expression will be evaluated for value.)
Examples:  #Fred    ''a string''   3+4'
		 initialAnswer: model selectedKey printString.

	string = '' ifTrue: [
		^self ].

	newKey _ Compiler evaluate: string.

	model renameEntryTo: newKey! !
!MessageSetWindow methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 19:40' prior: 50394973!
             filterMessageList
	"Allow the user to refine the list of messages."

	| aMenu |
	model messageList size <= 1 
		ifTrue: [^self inform: 'this is not a propitious filtering situation'].

	aMenu := MenuMorph new defaultTarget: model.
	aMenu addTitle: 'Filter by only showing...'.
	aMenu addStayUpIcons.
	aMenu 
		addList: #(
			#('unsent messages' #filterToUnsentMessages 'filter to show only messages that have no senders')
			#-
			#('messages that send...' #filterToSendersOf 'filter to show only messages that send a selector I specify')
			#('messages that do not send...' #filterToNotSendersOf 'filter to show only messages that do not send a selector I specify')
			#-
			#('messages whose selector is...' #filterToImplementorsOf 'filter to show only messages with a given selector I specify')
			#('messages whose selector is NOT...' #filterToNotImplementorsOf 'filter to show only messages whose selector is NOT a seletor I specify')
			#-
			#('messages in any change set' #filterToAnyChangeSet 'filter to show only messages that occur in at least one change set')
			#('messages not in any change set' #filterToNotAnyChangeSet 'filter to show only messages that do not occur in any change set in the system')
			#-
			#('messages authored by me' #filterToCurrentAuthor 'filter to show only messages whose authoring stamp has my initials')
			#('messages not authored by me' #filterToNotCurrentAuthor 'filter to show only messages whose authoring stamp does not have my initials')
			#-
			#('messages logged in .changes file' #filterToMessagesInChangesFile 'filter to show only messages whose latest source code is logged in the .changes file')
			#('messages only in .sources file' #filterToMessagesInSourcesFile 'filter to show only messages whose latest source code is logged in the .sources file')
			#-
			#('messages with prior versions' #filterToMessagesWithPriorVersions 'filter to show only messages that have at least one prior version')
			#('messages without prior versions' #filterToMessagesWithoutPriorVersions 'filter to show only messages that have no prior versions')
			#-
			#('uncommented messages' #filterToUncommentedMethods 'filter to show only messages that do not have comments at the beginning')
			#('commented messages' #filterToCommentedMethods 'fileter to show only messages that have comments at the beginning')
		).
	aMenu popUpInWorld: self world! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 19:47' prior: 16922338!
         changePriority
	| str newPriority nameAndRules |
	nameAndRules _ model nameAndRulesForSelectedProcess.
	nameAndRules third
		ifFalse: [PopUpMenu inform: 'Nope, won''t change priority of ' , nameAndRules first.
			^ self].
	str _ FillInTheBlankMorph request: 'New priority' initialAnswer: model selectedProcess priority asString.
	newPriority _ str asNumber asInteger.
	newPriority
		ifNil: [^ self].
	(newPriority < 1
			or: [newPriority > Processor highestPriority])
		ifTrue: [PopUpMenu inform: 'Bad priority'.
			^ self].
	model class setProcess: model selectedProcess toPriority: newPriority.
	model updateProcessList! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 19:47' prior: 16922389!
               findContext
	| searchString |
	searchString _ FillInTheBlankMorph request: 'Enter a string to search for in the process stack lists' initialAnswer: model searchString.
	model findContext: searchString! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 19:47' prior: 16922423!
                    messageTally
	| secString secs |
	secString _ FillInTheBlankMorph request: 'Profile for how many seconds?' initialAnswer: '4'.
	secs _ secString asNumber asInteger.
	(secs isNil
			or: [secs isZero])
		ifTrue: [^ self].
	[ TimeProfileBrowser spyOnProcess: model selectedProcess forMilliseconds: secs * 1000 ] forkAt: model selectedProcess priority + 1.! !
!RecentMessageSetWindow methodsFor: 'menu commands' stamp: 'jmv 9/24/2012 19:47' prior: 16926709!
                          setRecentHistorySize
	"Let the user specify the recent history size"

	| aReply aNumber |
	aReply _ FillInTheBlankMorph request: 'How many recent methods
should be maintained?' initialAnswer: Utilities numberOfRecentSubmissionsToStore asString.
	aReply isEmptyOrNil ifFalse:
		[aNumber _ aReply asNumber rounded.
		(aNumber > 1 and: [aNumber <= 1000])
			ifTrue:
				[Utilities numberOfRecentSubmissionsToStore: aNumber.
				self inform: 'Okay, ', aNumber asString, ' is the new size of the recent method history']
			ifFalse:
				[self inform: 'Sorry, must be a number between 2 & 1000']]! !
!TestRunner methodsFor: 'menus' stamp: 'jmv 9/24/2012 19:48' prior: 16968703!
 setFilter
	filter _ FillInTheBlankMorph request: 'Pattern for added test cases (#* OK)' initialAnswer: '*'.
	(filter endsWith: '*') ifFalse: [ filter _ filter, '*' ].
	selectedSuites _ (tests asOrderedCollection with: selectedSuites collect: [ :ea :sel |
		sel or: [ filter match: ea asString ]
	]).
	selectedSuite _ selectedSuites indexOf: true ifAbsent: [0].
	self changed: #allSelections.
! !
!Text class methodsFor: 'instance creation' stamp: 'jmv 9/24/2012 19:44' prior: 16970177!
                          fromUser
	"Answer an instance of me obtained by requesting the user to type a string."
	"Text fromUser"

	^ self fromString:
		(FillInTheBlankMorph request: 'Enter text followed by [Return]')
! !
!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/24/2012 19:48' prior: 16971962!
      find
	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"

	| reply |
	reply _ FillInTheBlankMorph request: 'Find what? ' initialAnswer: FindText.
	"Set focus on our text morph, so that cmd-g does the search again"
	morph world activeHand newKeyboardFocus: morph.
	reply size = 0 ifTrue: [
		^ self].
	self setSearch: reply.
	ChangeText _ FindText.  "Implies no replacement to againOnce: method"
	(self findAndReplaceMany: false)
		ifFalse: [ self flash ].

"	morph installEditorToReplace: self"! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 9/24/2012 19:44' prior: 16974446!
                  saveWorldInFile
	"Save the world's submorphs, model, and stepList in a file.  "

	| fileName fileStream aClass |
	fileName _ FillInTheBlankMorph request: 'File name for this morph?'.
	fileName isEmpty ifTrue: [^ self].  "abort"

	"Save only model, stepList, submorphs in this world"
	myWorld submorphsDo: [:m |
		m allMorphsDo: [:subM | subM prepareToBeSaved]].	"Amen"

	fileStream _ FileStream newFileNamed: fileName, '.morph'.
	aClass _ myWorld model ifNil: [nil] ifNotNil: [myWorld model class].
	fileStream fileOutClass: aClass andObject: myWorld.
! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 9/24/2012 19:48' prior: 50336398!
                        setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlankMorph
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk knownInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlankMorph
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !

PasteUpMorph removeSelector: #dispatchEvent:localPosition:!

PasteUpMorph removeSelector: #dispatchEvent:localPosition:!

PasteUpMorph removeSelector: #runLocalStepMethods!

PasteUpMorph removeSelector: #runLocalStepMethods!

PasteUpMorph removeSelector: #step!

PasteUpMorph removeSelector: #step!

MVCMenuMorph removeSelector: #invokeAt:in:allowKeyboard:!

MVCMenuMorph removeSelector: #invokeAt:in:allowKeyboard:!

MenuMorph removeSelector: #invokeModalAt:in:allowKeyboard:!

MenuMorph removeSelector: #invokeModalAt:in:allowKeyboard:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:onCancelReturn:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:onCancelReturn:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:answerExtent:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:answerExtent:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:answerHeight:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:answerHeight:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:onCancelReturn:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:onCancelReturn:acceptOnCR:!

FillInTheBlankMorph class removeSelector: #request:initialAnswer:centerAt:onCancelReturn:acceptOnCR:answerHeight:!

FillInTheBlankMorph removeSelector: #setQuery:initialAnswer:answerHeight:acceptOnCR:!

FillInTheBlankMorph removeSelector: #setQuery:initialAnswer:answerHeight:acceptOnCR:!

Morph removeSelector: #outermostWorldMorph!

Morph removeSelector: #outermostWorldMorph!

MessageSet removeSelector: #filterToMessagesThat!

MessageSet removeSelector: #filterToMessagesThat!

Smalltalk removeClassNamed: #FillInTheBlank!

Smalltalk removeClassNamed: #FillInTheBlank!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1459-CuisCore-JuanVuletich-2012Sep24-19h22m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1459] on 24 September 2012 at 9:52:33 pm'!
!Object methodsFor: 'morphic' stamp: 'jmv 9/24/2012 21:43' prior: 50395406!
                currentWorld
	"Answer a morphic world that is the current UI focus."

	"Should query all instances of world, looking for the one animated by the currently running process!! (and answer nil if this is not a Morphic process!!)"
	self flag: #jmvVer2.

	^World! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 9/24/2012 21:43' prior: 50351076!
      install
	owner := nil.	"since we may have been inside another world previously"
	ActiveHand := self hands first.	"default"
	submorphs do: [:ss | ss owner ifNil: [ss privateOwner: self]].
	"Transcript that was in outPointers and then got deleted."
	self viewBox: Display boundingBox.
	Sensor flushAllButDandDEvents.
	worldState handsDo: [:h | h initForEvents].
	self borderWidth: 0.	"default"
	SystemWindow noteTopWindowIn: self.
	self displayWorldSafely! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 9/24/2012 21:43' prior: 50351094!
                       interruptNameX: labelString
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess projectProcess |
	
	ActiveHand ifNotNil:[ActiveHand interrupted].
	ActiveHand _ World activeHand.
	ActiveHand interrupted. "make sure this one's interrupted too"

	projectProcess _ ProjectX uiProcessX.	"we still need the accessor for a while"
	preemptedProcess _ Processor preemptedProcess.
	"Only debug preempted process if its priority is >= projectProcess' priority"
	preemptedProcess priority < projectProcess priority ifTrue:[
		projectProcess suspend.
		preemptedProcess _ projectProcess.
	] ifFalse:[
		preemptedProcess suspend.
	].
	Debugger openInterrupt: labelString onProcess: preemptedProcess
! !
!TheWorldMenu methodsFor: 'action' stamp: 'jmv 9/24/2012 21:47' prior: 16974322!
                  doMenuItem: aCollection with: event
	| realTarget selector nArgs |
	selector _ aCollection second.
	nArgs _ selector numArgs.
	realTarget _ aCollection first.
	realTarget == #myWorld ifTrue: [realTarget _ myWorld].
	^nArgs = 0 
		ifTrue:[realTarget perform: selector]
		ifFalse:[realTarget perform: selector with: event].
! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 9/24/2012 21:43' prior: 16986603!
         runLocalStepMethodsIn: aWorld 
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| now morphToStep stepTime |
	now _ Time millisecondClockValue.
	self triggerAlarmsBefore: now.
	stepList isEmpty 
		ifTrue: [
			^self].
	"jmv: I say it is only needed on clock rollover. See commented code below."
	"(now < lastStepTime or: [now - lastStepTime > 5000]) "
	now < lastStepTime		"clock slipped"
		ifTrue: [ self adjustWakeupTimes: now ].
	[ stepList isEmpty not and: [ stepList first scheduledTime < now ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: aWorld) 
				ifTrue: [
					lastStepMessage value: now.
					lastStepMessage ifNotNil: [
							stepTime _ lastStepMessage stepTime ifNil: [ morphToStep stepTime ].
							lastStepMessage scheduledTime: now + (stepTime max: 1).
							stepList add: lastStepMessage]].
			lastStepMessage _ nil].
	lastStepTime _ now.! !

PasteUpMorph removeSelector: #shouldGetStepsFrom:!

PasteUpMorph removeSelector: #shouldGetStepsFrom:!

ObjectExplorer removeSelector: #shouldGetStepsFrom:!

ObjectExplorer removeSelector: #shouldGetStepsFrom:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Smalltalk removeKey: #ActiveWorld!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1460-CuisCore-JuanVuletich-2012Sep24-21h40m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1460] on 25 September 2012 at 10:57:40 pm'!

!classDefinition: #WorldState category: #'Morphic-Worlds'!
Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent activeHand'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent activeHand '
	classVariableNames: 'DeferredUIMessages MaxCycleLapse '
	poolDictionaries: ''
	category: 'Morphic-Worlds'!
!MenuMorph methodsFor: 'private' stamp: 'jmv 9/25/2012 22:30'!
                              positionAt: aPoint forHand: hand relativeTo: aMenuItem
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	self morphBoundsInWorld right > owner world morphBoundsInWorld right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ self morphBoundsInWorld amountToTranslateWithin:
		(owner world morphBoundsInWorld withHeight: ((owner world morphExtentInWorld y - 18) max: (hand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!PasteUpMorph methodsFor: 'accessing' stamp: 'jmv 9/25/2012 22:40'!
                           activeHand
	"Answer the currently active hand, if any..."
	^worldState activeHand! !
!WorldState methodsFor: 'hands' stamp: 'jmv 9/25/2012 22:39'!
             activeHand
	^activeHand! !
!WorldState methodsFor: 'initialization' stamp: 'jmv 9/25/2012 22:38'!
                              setDefaultActiveHand
	activeHand _ hands first! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 9/25/2012 22:21' prior: 50391413!
                          storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."

	| bufSize stereoBuffer reverseBytes  |
	self reset.
	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"
	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.
	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.

	'Storing audio...' displayProgressAt: self currentWorld activeHand morphPosition
		from: 0 to: samplesToStore during: [:bar | | remaining out |
			remaining _ samplesToStore.
			[remaining > 0] whileTrue: [
				bar value: samplesToStore - remaining.
				stereoBuffer primFill: 0.  "clear the buffer"
				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.
				self isStereo
					ifTrue: [out _ stereoBuffer]
					ifFalse: [out _ stereoBuffer extractLeftChannel].
				reverseBytes ifTrue: [out reverseEndianness].
				(aBinaryStream isKindOf: StandardFileStream)
					ifTrue: [  "optimization for files: write sound buffer directly to file"
						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"
					ifFalse: [  "for non-file streams:"
						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].
				remaining _ remaining - bufSize]].
! !
!Debugger methodsFor: 'private' stamp: 'jmv 9/25/2012 22:45' prior: 16833945!
                resumeProcess
	savedCursor
		ifNotNil: [Sensor currentCursor: savedCursor].
	interruptedProcess isTerminated ifFalse: [
		errorWasInUIProcess
					ifTrue: [ProjectX resumeProcessX: interruptedProcess]
					ifFalse: [interruptedProcess resume]].
	"if old process was terminated, just terminate current one"
	interruptedProcess _ nil.
	contextStackIndex _ 0.
	contextStack _ nil.
	contextStackTop _ nil.
	receiverInspector _ nil.
	contextVariablesInspector _ nil.
	self currentWorld ifNotNil: [ :w | w displayWorld ].
	Smalltalk installLowSpaceWatcher.
	"restart low space handler"
	errorWasInUIProcess == false
		ifFalse: [Processor terminateActive]! !
!DisplayScreen methodsFor: 'other' stamp: 'jmv 9/25/2012 22:46' prior: 16840617!
   newDepth: pixelSize
"
	Display newDepth: 8.
	Display newDepth: 1.
"
	(self supportsDisplayDepth: pixelSize)
		ifFalse:[^self inform:'Display depth ', pixelSize printString, ' is not supported on this system'].
	self newDepthNoRestore: pixelSize.
	self currentWorld ifNotNil: [ :w | w  buildMagnifiedBackgroundImage ].
	self restore.! !
!DisplayScreen methodsFor: 'other' stamp: 'jmv 9/25/2012 22:46' prior: 16840651!
                               restore
	self currentWorld ifNotNil: [ :w | w fullRepaintNeeded ]! !
!DisplayScreen methodsFor: 'other' stamp: 'jmv 9/25/2012 22:46' prior: 16840655!
          restoreAfter: aBlock
	"Evaluate the block, wait for a mouse click, and then restore the screen."

	aBlock value.
	Sensor waitButton.
	self currentWorld ifNotNil: [ :w | w fullRepaintNeeded ]! !
!DisplayScreen class methodsFor: 'display box access' stamp: 'jmv 9/25/2012 22:46' prior: 16840856!
                          checkForNewScreenSize
	"Check whether the screen size has changed and if so take appropriate actions"

	Display extent = DisplayScreen actualScreenSize ifTrue: [^ self].
	DisplayScreen startUp.
	self currentWorld ifNotNil: [ :w | w restoreMorphicDisplay ]! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 9/25/2012 22:47' prior: 50370583!
          testLayout1
	"
	self new testLayout1
	"
	| pane row1 row2 row3 r1c1 r1c2 r1c3 r1c4 r1c5 r2c1 r2c2 r2c3 r3c1 r3c2 r3c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row1 _ LayoutMorph newRow separation: 5.
	row1 color: Color red;
		addMorph: (r1c1 _ BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 10);
		addMorph: (r1c2 _ BorderedRectMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r1c3 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r1c4 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.15);
		addMorph: (r1c5 _ BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
	pane addMorph: row1 layoutSpec: LayoutSpec useAll.
	row2 _ LayoutMorph newRow separation: 5.
	row2 color: Color red;
		addMorph: (r2c1 _ BorderedRectMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r2c2 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r2c3 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.2).
	pane addMorph: row2 layoutSpec: LayoutSpec useAll.
	row3 _ LayoutMorph newRow separation: 5.
	row3 color: Color red;
		addMorph: (r3c1 _ BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
		addMorph: (r3c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40);
		addMorph: (r3c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row3 layoutSpec: (LayoutSpec fixedHeight: 60).
	pane openInWorld; morphExtent: 408@300.
	self currentWorld doOneCycleNow.

	self assert: row1 morphWidth = (pane morphWidth - 10).
	self assert: r1c1 morphWidth class == SmallInteger.
	self assert: r1c1 morphHeight class == SmallInteger.
	self assert: r1c1 morphWidth = 10.
	self assert: r1c1 morphHeight = (row1 morphHeight - 10).
	self assert: r1c2 morphWidth = 200.
	self assert: r1c2 morphHeight = (row1 morphHeight - 10).
	self assert: r1c3 morphWidth = (r1c2 morphWidth / 0.8 * 0.4) rounded.
	self assert: r1c3 morphHeight = (row1 morphHeight - 10).
	self assert: r1c4 morphWidth = (r1c2 morphWidth / 0.8 * 0.15) rounded.
	self assert: r1c4 morphHeight = (row1 morphHeight - 10).
	self assert: r1c5 morphWidth = 20.
	self assert: r1c5 morphHeight = 20.

	self assert: row2 morphWidth = (pane morphWidth - 10).
	self assert: r2c1 morphWidth = 216.
	self assert: r2c1 morphHeight = (row2 morphHeight - 10).
	self assert: r2c2 morphWidth = (r2c1 morphWidth / 0.8 * 0.4) rounded.
	self assert: r2c2 morphHeight = (row2 morphHeight - 10).
	self assert: r2c3 morphWidth = (r2c1 morphWidth / 0.8 * 0.2) rounded.
	self assert: r2c3 morphHeight = (row2 morphHeight - 10).

	self assert: row3 morphWidth = (pane morphWidth - 10).
	self assert: row3 morphHeight = 60.
	self assert: r3c1 morphWidth = 20.
	self assert: r3c1 morphHeight = (row3 morphHeight - 10 * 0.8) rounded.
	self assert: r3c2 morphWidth = (row3 morphWidth - 10 - 20 - 10 - 30 * 0.5) rounded.
	self assert: r3c2 morphHeight = 40.
	self assert: r3c3 morphWidth = 30.
	self assert: r3c3 morphHeight = (row3 morphHeight - 10).

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 9/25/2012 22:47' prior: 50370698!
                       testLayout2
	"
	self new testLayout2
	"
	| pane row c1 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (c1 _ BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane openInWorld; morphExtent: 400@300.
	self currentWorld doOneCycleNow.

	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = (pane morphHeight - 10 * 0.9) rounded.
	self assert: c1 morphBoundsInWorld bottom = (row morphBoundsInWorld bottom - 5) description: 'Should be at bottom'.
	self assert: c1 morphWidth = 20.
	self assert: c1 morphHeight = (row morphHeight - 10 * 0.8) rounded.
	self assert: c2 morphBoundsInWorld top = (row morphBoundsInWorld top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = 256.
	self assert: c2 morphHeight = 40.
	self assert: ((c3 morphBoundsInWorld top - row morphBoundsInWorld top) - (row morphBoundsInWorld bottom - c3 morphBoundsInWorld bottom)) abs < 2 description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (c1 morphHeight / 0.8 * 0.7) rounded.

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 9/25/2012 22:47' prior: 50374635!
                             testLayout3
	"
	self new testLayout3
	"
	| pane row innerRow i1 i2 i3 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	innerRow _ LayoutMorph newRow color: Color red;  separation: 5.
	innerRow
		addMorph: (i1 _ RectangleLikeMorph new)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i2 _ RectangleLikeMorph new)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i3 _ RectangleLikeMorph new)
			layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 minorDirectionPadding: #center);
		addMorph: (c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 200).
	pane openInWorld; morphExtent: 400@300.
	self currentWorld doOneCycleNow.

	self assert: row morphBoundsInWorld left = (pane morphBoundsInWorld left + 5).
	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = 200.
	self assert: innerRow morphBoundsInWorld left = (row morphBoundsInWorld left + 5).
	self assert: (innerRow morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - innerRow morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: innerRow morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: innerRow morphHeight = 30.

	self assert: i1 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 5).
	self assert: (i1 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i1 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i1 morphWidth = 10.
	self assert: i1 morphHeight = 10.
	self assert: i2 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 20).
	self assert: (i2 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i2 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i2 morphWidth = 10.
	self assert: i2 morphHeight = 10.
	self assert: i3 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 35).
	self assert: (i3 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i3 morphWidth = (innerRow morphWidth - 40).
	self assert: i3 morphHeight = 10.

	self assert: c2 morphBoundsInWorld top = (row morphBoundsInWorld top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: c2 morphHeight = 40.
	self assert: (c3 morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - c3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (row morphHeight - 10).

	pane delete! !
!Morph methodsFor: 'focus handling' stamp: 'jmv 9/25/2012 22:31' prior: 16897781!
              hasKeyboardFocus

	self world ifNotNil: [ :w |
		w activeHand ifNotNil: [ :h |
			^ h keyboardFocus == self ]].
	^ false! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 9/25/2012 22:26' prior: 16898209!
          showBalloon: msgString
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."
	| w |
	self showBalloon: msgString hand: ((w _ self world) ifNotNil: [ w activeHand ])! !
!Morph methodsFor: 'initialization' stamp: 'jmv 9/25/2012 22:25' prior: 16898342!
                  openInHand
	"Attach the receiver to the current hand in the current morphic world"

	self currentWorld activeHand attachMorph: self! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 9/25/2012 22:25' prior: 50356482!
         resizeMorph
	| handle |
	handle := HandleMorph new 
				forEachPointDo: [:newPoint | self morphExtent: newPoint - self morphPositionInWorld].
	self currentWorld activeHand attachMorph: handle.
	handle startStepping! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 9/25/2012 22:25' prior: 16899475!
              delete
	"Remove the receiver as a submorph of its owner and make its 
	new owner be nil."

	| aWorld |
	aWorld := self world ifNil: [ self currentWorld ].
	"Terminate genie recognition focus"
	"I encountered a case where the hand was nil, so I put in a little 
	protection - raa "
	" This happens when we are in an MVC project and open
	  a morphic window. - BG "
	aWorld ifNotNil: [
		aWorld activeHand
			releaseKeyboardFocus: self;
			releaseMouseFocus: self].
	owner ifNotNil:[ self privateDelete].! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 9/25/2012 22:21' prior: 50395757!
                             request: queryString
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph request: 'What is your favorite color?'"

	^ self
		request: queryString
		initialAnswer: ''
		centerAt: self currentWorld activeHand morphPosition
		onCancelReturn: ''
		acceptOnCR: true
		answerExtent: self defaultAnswerExtent! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 9/25/2012 22:21' prior: 50395775!
                  request: queryString initialAnswer: defaultAnswer 
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'"

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: self currentWorld activeHand morphPosition
		onCancelReturn: ''
		acceptOnCR: true
		answerExtent: self defaultAnswerExtent! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/25/2012 22:46' prior: 16865127!
               nextFocusMorph

	^(keyboardFocus ifNil: [ self world ])
		previousMorphThat: [ :m |
			m handlesKeyboard and: [ m isReallyVisible ]]! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/25/2012 22:46' prior: 16865134!
  nextFocusWindow

	^(SystemWindow topWindow ifNil: [ self world ])
		nextMorphThat: [ :m | 
			(m is: #SystemWindow) and: [ m isReallyVisible ]]! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/25/2012 22:46' prior: 16865141!
                       previousFocusMorph
	^ (keyboardFocus ifNil: [ self world ])
		nextMorphThat: [ :m | 
			m handlesKeyboard and: [ m isReallyVisible ]]! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/25/2012 22:46' prior: 16865148!
 previousFocusWindow

	^ (SystemWindow topWindow ifNil: [ self world ])
		previousMorphThat: [ :m |
			(m is: #SystemWindow) and: [ m isReallyVisible ]]! !
!HandMorph methodsFor: 'objects from disk' stamp: 'jmv 9/25/2012 22:22' prior: 16865464!
            objectForDataStream: refStrm
	| dp |
	"I am about to be written on an object file.  Write a path to me in the other system instead."

	"owned by the project"
"	(refStrm project world hands includes: self) ifTrue: [
		^ self].	"

	self flag: #jmvVer2.

	dp _ DiskProxy global: #World selector: #activeHand args: #().
	refStrm replace: self with: dp.
	^ dp
	"Note, when this file is loaded in an MVC project, this will return nil.  The MenuItemMorph that has this in a field will have that item not work.  Maybe warn the user at load time?"! !
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 9/25/2012 22:23' prior: 16869962!
              acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| ok prevSelection prevScrollValue |
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar value.
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 
		ifTrue: [^self flash].
	self hasEditingConflicts 
		ifTrue: [
			(self confirm: 
'Caution!! Contents were saved
elsewhere since you started
editing them here.  Accept anyway?' ) 
					ifFalse: [^self flash]].
	ok _ model acceptContentsFrom: owner.
	ok == true
		ifTrue: [ model refetch ].

	"sps 8/13/2001 22:41: restore selection and scroll info"
	
	["During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the codeholding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
		ok
			ifTrue: [
				self editor selectFrom: prevSelection first to: prevSelection last.
				WorldState addDeferredUIMessage: [
						self currentWorld activeHand newKeyboardFocus: self.
						owner setScrollDeltas.
						owner verticalScrollBar setValue: prevScrollValue ]]
	] on: Error do: nil! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 9/25/2012 22:55' prior: 50394671!
    magnifiedForm
	| srcRect form neededExtent |
	lastPos _ self sourcePoint.
	srcRect _ self sourceRectFrom: lastPos.
	((srcRect intersects: self morphBoundsInWorld) and: [ RecursionLock == nil ])
		ifTrue: [
			RecursionLock _ self.
			"try to reuse form if appropriate"
			auxCanvas _ (auxCanvas notNil and: [ auxCanvas extent = srcExtent ])
				ifTrue: [
					"Just in case we go out of the Display"
					srcRect origin > (0@0) ifFalse: [
						auxCanvas form fillBlack ].
					FormCanvas on: auxCanvas form over: srcRect ]
				ifFalse: [ FormCanvas depth: 32 over: srcRect ].
			self world drawOn: auxCanvas.
			self world drawSubmorphsOn: auxCanvas.
			form _ auxCanvas form.
			RecursionLock _ nil]
		ifFalse: [
			"cheaper method if the source is not occluded"
			form _ Display copy: srcRect].
	"smooth if non-integer scale"
	neededExtent _ (srcExtent * magnification ) truncated.
	(magnifiedForm isNil or: [ magnifiedForm extent ~=  neededExtent ])
		ifTrue: [ magnifiedForm _ Form extent: neededExtent depth: 32 ].
	(WarpBlt toForm: magnifiedForm)
		sourceForm: form;
		colorMap: (form colormapIfNeededFor: magnifiedForm);
		cellSize: (magnification isInteger ifTrue: [1] ifFalse: [2]);  "installs a new colormap if cellSize > 1"
		combinationRule: 3;
		copyQuad: form boundingBox innerCorners toRect: magnifiedForm boundingBox.
	^magnifiedForm.! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 9/25/2012 22:24' prior: 50392495!
                             sourcePoint
	"If we are being dragged use our center, otherwise use pointer position"
	^ (trackPointer not or: [owner notNil and: [owner is: #HandMorph]])
		ifTrue: [ self morphBoundsInWorld center ]
		ifFalse: [ self world activeHand morphPosition ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/25/2012 22:30' prior: 50395325!
                   popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [:m | m isKindOf: UpdatingMenuItemMorph]) 
		do: [:m | m updateContents].
	self currentWorld addMorphFront: self.
	self 
		positionAt: aPoint
		forHand: hand
		relativeTo: (selectedItem ifNil: [self items first]).
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [hand newKeyboardFocus: self].
	evt := hand lastEvent.
	(evt isKeyboard or: [evt isMouse and: [evt anyButtonPressed not]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/25/2012 22:30' prior: 50346991!
                          popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [:m | m isKindOf: UpdatingMenuItemMorph]) 
		do: [:m | m updateContents].
	aWorld addMorphFront: self.
	self 
		positionAt: aPoint
		forHand: hand
		relativeTo: (selectedItem ifNil: [self items first]).
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [hand newKeyboardFocus: self].
	evt := hand lastEvent.
	(evt isKeyboard or: [evt isMouse and: [evt anyButtonPressed not]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt]! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 9/25/2012 22:24' prior: 50366368!
                           keyStroke: aKeyboardEvent 
	| matchString char asc selectable help |
	help _ HoverHelpMorph contents: 'Enter text to\narrow selection down\to matching items ' withNewLines.
	help popUpForHand: self activeHand.
	char := aKeyboardEvent keyCharacter.
	asc := char asciiValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: 
					[selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: 
							["self delete."

							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: 
			["escape key"

			self valueOfProperty: #matchString
				ifPresentDo: 
					[:str | 
					str isEmpty 
						ifFalse: 
							["If filtered, first ESC removes filter"

							self setProperty: #matchString toValue: String new.
							self selectItem: nil event: aKeyboardEvent.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			popUpOwner ifNil: [^self delete].
			"If a sub-menu, then deselect, and return focus to outer menu"
			self selectItem: nil event: aKeyboardEvent.
			aKeyboardEvent hand newMouseFocus: popUpOwner owner.
			^aKeyboardEvent hand newKeyboardFocus: popUpOwner owner].
	(asc = 28 or: [asc = 29]) 
		ifTrue: 
			["left or right arrow key"

			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: 
					[aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].
	matchString := char = Character backspace 
				ifTrue: 
					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent.
	help _ HoverHelpMorph contents: 'Enter text to\narrow selection down\to matching items ' withNewLines.
	help popUpForHand: self world activeHand.
! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 9/25/2012 22:30' prior: 50392651!
       sightTarget: event 
	| bullseye menu newTarget |
	owner
		ifNil: [^ self ].
	bullseye _ Point fromUserWithCursor: Cursor target.
	self world activeHand morphPosition: bullseye.
	menu _ CustomMenu new.
	(owner morphsAt: bullseye) do: [ :m |
		menu add: m printString action: m ].
	menu title: self printString, ' targets... '.
	newTarget _ menu startUp.
	newTarget
		ifNil: [^ self].
	self target: newTarget! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 9/25/2012 22:29' prior: 50395839!
                 invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w oldFocus actHand |
	w _ self currentWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneSubCycle.
	self	
		popUpAt: actHand morphPosition
		forHand: actHand 
		allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	[self isInWorld & self isModalInvokationDone not] whileTrue: [w doOneSubCycle].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ self modalSelection! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 9/25/2012 22:32' prior: 16912347!
            invokeWorldMenu
	"Put up the world menu, triggered by the passed-in event.
	Perhaps a good place to disable it if needed"

	| menu |
	menu _ (TheWorldMenu new 
		world: self
		hand: self activeHand) buildWorldMenu.
	menu addTitle: Preferences desktopMenuTitle.
	menu popUpInWorld: self! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 9/25/2012 22:40' prior: 50396877!
         install
	owner := nil.	"since we may have been inside another world previously"
	worldState setDefaultActiveHand.
	submorphs do: [:ss | ss owner ifNil: [ss privateOwner: self]].
	"Transcript that was in outPointers and then got deleted."
	self viewBox: Display boundingBox.
	Sensor flushAllButDandDEvents.
	worldState handsDo: [:h | h initForEvents].
	self borderWidth: 0.	"default"
	SystemWindow noteTopWindowIn: self.
	self displayWorldSafely! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 9/25/2012 22:32' prior: 50391665!
  startUpWithoutKeyboard
	"Display and make a selection from the receiver as long as the button  is pressed. Answer the current selection.  Do not allow keyboard input into the menu"
	
	^ self startUpWithCaption: nil at: self currentWorld activeHand morphPosition allowKeyboard: false! !
!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2012 22:49' prior: 50361141!
                     defaultAction

	| delta textFrame barFrame outerFrame result range width w1 f h textWidth textForm innerBarFrame |
	f _ StrikeFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.
	
	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
			
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ 0@0 extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + (0@2).
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal 
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [		
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		w1 _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		textForm displayAt: textFrame topLeft.
		Display fillBlack: barFrame.
		Display fillWhite: innerBarFrame.
		Display fillGray: (barFrame topLeft + (2@2) extent: w1@17) ].
	self currentWorld ifNotNil: [ :w | w fullRepaintNeeded ].
	self resume: result! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2012 22:49' prior: 50396895!
     interruptNameX: labelString
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess projectProcess |
	
	self currentWorld activeHand interrupted.
	projectProcess _ ProjectX uiProcessX.	"we still need the accessor for a while"
	preemptedProcess _ Processor preemptedProcess.
	"Only debug preempted process if its priority is >= projectProcess' priority"
	preemptedProcess priority < projectProcess priority ifTrue:[
		projectProcess suspend.
		preemptedProcess _ projectProcess.
	] ifFalse:[
		preemptedProcess suspend.
	].
	Debugger openInterrupt: labelString onProcess: preemptedProcess
! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 9/25/2012 22:26' prior: 50361287!
                    newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor anyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor anyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ self currentWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent.
	^ rect! !
!ReferenceStreamTest methodsFor: 'testing' stamp: 'jmv 9/25/2012 22:42' prior: 16928213!
                    testDiskProxy
	"
	ReferenceStreamTest new testDiskProxy
	"
	| newInstance oldInstance |
	self flag: #jmvVer2.
	oldInstance _ { Smalltalk . Display . Morph}.
	newInstance _ ReferenceStream unStream: (ReferenceStream streamedRepresentationOf: oldInstance).
	1 to: oldInstance size do: [ :i |
		self assert: (newInstance at: i) == (oldInstance at: i) ]! !
!SmartRefStreamTest methodsFor: 'testing' stamp: 'jmv 9/25/2012 22:42' prior: 16944021!
       testDiskProxy
	"
	SmartRefStreamTest new testDiskProxy
	"
	| newInstance oldInstance |
	self flag: #jmvVer2.
	oldInstance _ { Smalltalk . Display . Morph}.
	newInstance _ SmartRefStream unStream: (SmartRefStream streamedRepresentationOf: oldInstance).
	1 to: oldInstance size do: [ :i |
		self assert: (newInstance at: i) == (oldInstance at: i) ]! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 9/25/2012 22:51' prior: 50357609!
          reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	ClassicTheme beCurrent.
	self currentWorld ifNotNil: [ :w | w backgroundImageData: nil ].
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	FormCanvas clearFormsCache.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	CursorWithAlpha class removeSelector: #buildBiggerNormal.
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	self currentWorld ifNotNil: [ :w | w  submorphsDo: [ :a | a delete ]].
	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	"????
	Smalltalk organization removeCategoriesMatching: 'Signal Processing*'.
	SystemOrganization removeSystemCategory: 'LinearAlgebra'.
	Smalltalk organization removeCategoriesMatching: 'Sound-*'
	"

	Beeper setDefault: nil.
	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(ZipConstants GZipConstants ZipFileConstants ChronologyConstants SpaceTally).
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSorter zapAllChangeSets.
	Smalltalk garbageCollect.


	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionaryTest methodsFor: 'testing' stamp: 'jmv 9/25/2012 22:51' prior: 50380110!
               testPointersToEachIn
	"
	SystemDictionaryTest new testPointersToEachIn
	"
	| p1 p2 |
	p1 _ (Smalltalk pointersTo: self currentWorld).
	p2 _ (Smalltalk pointersToEachIn: {self currentWorld}) first.
	self assert: p1 = p2! !
!SystemWindow methodsFor: 'top window' stamp: 'jmv 9/25/2012 22:33' prior: 16965729!
             passivate
	"Make me unable to respond to mouse and keyboard"

	| focus h |
	h _ self world activeHand.
	focus _ h keyboardFocus.
	focus ifNotNil: [
		(focus ownerThatIsA: SystemWindow) == self
			ifTrue: [ h releaseKeyboardFocus ]].

	self redrawNeeded! !
!Taskbar methodsFor: 'stepping' stamp: 'jmv 9/25/2012 22:51' prior: 50358018!
                  step

	"My dimensions are constrained live."
	| r |
	r _ self world morphBoundsInWorld.
	r _ r left @ (r bottom -18) extent: r width@18.
	self morphBoundsInWorld = r ifFalse: [
		self morphBoundsInWorld: r]! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 9/25/2012 22:51' prior: 16967412!
                          testClassShow
	taskbar class show.
	self should: [ taskbar isInWorld ].
	self currentWorld removeMorph: taskbar! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 9/25/2012 22:51' prior: 50354444!
                         testVerticalAlignment
	
	self should: [ taskbar morphBoundsInWorld bottom = self currentWorld morphBoundsInWorld bottom ]! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 9/25/2012 22:52' prior: 50351569!
               testWidth
	
	self should: [ taskbar morphWidth = self currentWorld morphWidth ]! !
!TextEditorTest methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2012 22:33' prior: 16972977!
             testSimpleEditor
	"
	TextEditorTest new testSimpleEditor
	"
	| m |
	self shouldnt: [
		m _ OneLineEditorMorph new.
		m editor offerMenuFromEsc:
			(KeyboardEvent new
				setType: #keystroke
				buttons: 0
				position: 0@0
				keyValue: 65
				hand: self currentWorld activeHand
				stamp: 0)
	] raise: Exception! !
!TextModelMorph methodsFor: 'focus handling' stamp: 'jmv 9/25/2012 22:27' prior: 16974011!
         focusText

	self world activeHand newKeyboardFocus: self textMorph! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 9/25/2012 22:52' prior: 16974378!
       fullScreenOff

	Display fullScreenMode: false.
	DisplayScreen checkForNewScreenSize.
	myWorld restoreMorphicDisplay! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 9/25/2012 22:52' prior: 16974384!
                      fullScreenOn

	Display fullScreenMode: true.
	DisplayScreen checkForNewScreenSize.
	myWorld restoreMorphicDisplay! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 9/25/2012 22:52' prior: 16974527!
                        startMessageTally
	"Tally on all the processes in the system, and not only the UI"
	
	(self confirm: 'MessageTally all the processes in
the system, until the mouse pointer
goes to the top of the screen') ifTrue: [
		MessageTally spyAllOn: [
			[Sensor peekMousePt y > 0] whileTrue: [myWorld doOneCycle]]]! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 9/25/2012 22:52' prior: 16974539!
                         startThenBrowseMessageTally
	"Tally only the UI process"
	
	(self confirm: 'MessageTally the UI process until the
mouse pointer goes to the top of the screen')
		ifTrue: [TimeProfileBrowser
				onBlock: [[Sensor peekMousePt y > 10]
						whileTrue: [myWorld doOneCycle]]]! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 9/25/2012 22:52' prior: 50395057!
                      buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Preferences...'. { self. #preferencesDo}.
					'put up a menu offering many controls over appearance and system preferences.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Restore Display (r)'. { myWorld. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!Theme class methodsFor: 'class initialization' stamp: 'jmv 9/25/2012 22:52' prior: 16976559!
                   currentTheme: aTheme

	CurrentTheme := aTheme new.
	SHTextStylerST80 initialize.
	self currentWorld backgroundImage ifNil: [ self currentWorld color: CurrentTheme background ].
	SystemWindow initialize.
	FormCanvas clearFormsCache.
	Taskbar reset; initialize.
	self currentWorld restoreMorphicDisplay.
	
	^ CurrentTheme! !
!Utilities class methodsFor: 'common requests' stamp: 'jmv 9/25/2012 22:53' prior: 16980955!
saveScreenshot
	"Make a screenshot of the world and save it to a file"

	"SampledSound playSoundNamed: 'camera'."
	PNGReadWriter
		putForm: (self currentWorld imageForm: 32)
		onFileNamed:
			(FileDirectory default
				nextNameFor: 'CuisScreen'
				extension: 'png')! !
!Utilities class methodsFor: 'closure support' stamp: 'jmv 9/25/2012 22:52' prior: 16982530!
                     postRecompileCleanup	"Utilities postRecompileCleanup"
	"Cleanup after loading closure bootstrap"
	"Before doing this, please start a new UI process (for example, by hitting alt-period and closing the debugger)."
	| unboundMethods contexts |
	self currentWorld removeAllKnownFailing.
	ProcessorScheduler startUp.
	WeakArray restartFinalizationProcess.
	MethodChangeRecord allInstancesDo:[:x| x noteNewMethod: nil].
	Smalltalk cleanOutUndeclared.
	Delay startTimerEventLoop.
	EventSensor install.
	WorldState allInstancesDo:[:ws| ws convertAlarms; convertStepList].
	Workspace allInstancesDo:[:ws| ws initializeBindings].
	Smalltalk garbageCollect.
	Smalltalk
		at: #DebuggerMethodMap
		ifPresent: [ :dmm | dmm voidMapCache ].
	Smalltalk garbageCollect.
	unboundMethods _ CompiledMethod unboundMethods.
	unboundMethods notEmpty ifTrue: [
		unboundMethods inspectWithLabel: 'Unbound Methods'].
	Smalltalk at: #BlockContext ifPresent: [ :bc |
		contexts _ bc allInstances.
		contexts ifNotEmpty: [
			contexts inspect. 
			self inform: 'There are left-over BlockContexts'.
			^self ]].
	unboundMethods isEmpty ifTrue:[
		self inform:'Congratulations - The bootstrap is now complete.'.
	]! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 9/25/2012 22:40' prior: 50363923!
        doOneCycleNowFor: aWorld
	"Immediately do one cycle of the interaction loop.
	This should not be called directly, but only via doOneCycleFor:"

	| hadAnyEvent |
	DisplayScreen checkForNewScreenSize.

	"process user input events"
	self handsDo: [ :h |
		activeHand _ h.
		hadAnyEvent _ h processEventQueue.
		activeHand _ nil.
	].

	"the default is the primary hand"
	activeHand _ self hands first.

	aWorld runStepMethods.		"there are currently some variations here"
	self displayWorldSafely: aWorld.

	^hadAnyEvent! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 9/25/2012 22:41' prior: 16986813!
    doOneSubCycleFor: aWorld
	"Like doOneCycle, but preserves activeHand."

	| currentHand |
	currentHand _ activeHand.
	self doOneCycleFor: aWorld.
	activeHand _ currentHand! !
!WorldState class methodsFor: 'class initialization' stamp: 'jmv 9/25/2012 22:57' prior: 16987057!
               addDeferredUIMessage: valuableObject

	self deferredUIMessages nextPut: valuableObject! !
!WorldState class methodsFor: 'class initialization' stamp: 'jmv 9/25/2012 22:57' prior: 16987063!
   deferredUIMessages

	self flag: #jmvVer2.	"make this an inst variable of the world..."
	^DeferredUIMessages ifNil: [DeferredUIMessages _ SharedQueue new].
! !
!WorldTest methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2012 22:54' prior: 16987089!
      testDoOneCycleWorksWithDeferredQueue
        "Ensure that nested doOneCycles don't break deferred UI messages"
        | finished |
        [
                WorldState addDeferredUIMessage: [ self currentWorld doOneCycleNow ].
                WorldState addDeferredUIMessage: nil "whatever".
                self currentWorld doOneCycleNow.
                finished _ true.
        ] valueWithin: 1 seconds onTimeout: [finished _ false ].
        self assert: finished! !

!classDefinition: #WorldState category: #'Morphic-Worlds'!
Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent activeHand'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent activeHand'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

MenuMorph removeSelector: #invokeModalAt:allowKeyboard:!

MenuMorph removeSelector: #invokeModalAt:allowKeyboard:!

MenuMorph removeSelector: #positionAt:relativeTo:!

MenuMorph removeSelector: #positionAt:relativeTo:!

Morph removeSelector: #activeHand!

Morph removeSelector: #activeHand!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	Smalltalk removeKey: #ActiveHand!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1461-CuisCore-JuanVuletich-2012Sep25-22h21m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1461] on 26 September 2012 at 5:59:58 pm'!
!Morph methodsFor: 'change reporting' stamp: 'jmv 9/26/2012 17:59' prior: 50387792!
            invalidateRect: aRectangle

	| rectInOwner rectInOwns |

	"warning. Senders are using global coordinates. Redesign!!"
	"local now!!!!!!!!!!"
	self flag: #jmvVer2.	"ok?"
	
 	rectInOwns _ self clipsSubmorphs
		ifTrue: [ aRectangle intersect: (0@0 extent: self morphExtent) ]
		ifFalse: [ aRectangle ].
	owner ifNotNil: [
		rectInOwner _ location displayBoundsOfTransformOf: rectInOwns.
		owner invalidateRect: rectInOwner ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1462-CuisCore-JuanVuletich-2012Sep26-17h46m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1462] on 27 September 2012 at 8:27:56 pm'!
!Morph methodsFor: 'menus' stamp: 'jmv 9/27/2012 20:25' prior: 50356444!
    changeColor
	"Change the color of the receiver -- triggered, e.g. from a menu"

	"ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: self world activeHand;
		target: self;
		selector: #color:;
		originalColor: self color;
		putUpFor: self near: self morphFullBoundsInWorld"! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 9/27/2012 20:25' prior: 50397759!
              keyStroke: aKeyboardEvent 
	| matchString char asc selectable help |
	help _ HoverHelpMorph contents: 'Enter text to\narrow selection down\to matching items ' withNewLines.
	help popUpForHand: self world activeHand.
	char := aKeyboardEvent keyCharacter.
	asc := char asciiValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: 
					[selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: 
							["self delete."

							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: 
			["escape key"

			self valueOfProperty: #matchString
				ifPresentDo: 
					[:str | 
					str isEmpty 
						ifFalse: 
							["If filtered, first ESC removes filter"

							self setProperty: #matchString toValue: String new.
							self selectItem: nil event: aKeyboardEvent.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			popUpOwner ifNil: [^self delete].
			"If a sub-menu, then deselect, and return focus to outer menu"
			self selectItem: nil event: aKeyboardEvent.
			aKeyboardEvent hand newMouseFocus: popUpOwner owner.
			^aKeyboardEvent hand newKeyboardFocus: popUpOwner owner].
	(asc = 28 or: [asc = 29]) 
		ifTrue: 
			["left or right arrow key"

			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: 
					[aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].
	matchString := char = Character backspace 
				ifTrue: 
					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent.
	help _ HoverHelpMorph contents: 'Enter text to\narrow selection down\to matching items ' withNewLines.
	help popUpForHand: self world activeHand.
! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 9/27/2012 20:25' prior: 50357818!
                              changeColor
	"Change the color of the receiver -- triggered, e.g. from a menu.  This variant allows the recolor triggered from the window's halo recolor handle to have the same result as choosing change-window-color from the window-title menu"

	"ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: self world activeHand;
		target: self;
		selector: #setWindowColor:;
		originalColor: self color;
		putUpFor: self near: self morphFullBoundsInWorld"! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 9/27/2012 20:26' prior: 50357851!
                               setWindowColor
	"Allow the user to select a new basic color for the window"

	"ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: self world activeHand;
		target: self;
		selector: #setWindowColor:;
		originalColor: self widgetsColor;
		putUpFor: self near: self morphFullBoundsInWorld"! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1463-CuisCore-JuanVuletich-2012Sep27-20h25m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1463] on 3 October 2012 at 2:51:23 pm'!
!CPUWatcher methodsFor: 'startup-shutdown' stamp: 'jmv 10/3/2012 11:21'!
                               monitorProcessPeriod: secs sampleRate: msecs suspendPorcine: aBoolean
	self stopMonitoring.

	watcher _ [ [ | promise |
		promise _ Processor tallyCPUUsageFor: secs every: msecs.
		tally _ promise value.
		promise _ nil.
		aBoolean ifTrue: [ self findThePig ].
	] repeat ] newProcess.
	watcher priority: Processor highestPriority.
	watcher resume.
	Processor yield ! !
!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'jmv 10/3/2012 11:21'!
                             startMonitoringPeriod: pd rate: rt threshold: th suspendPorcine: aBoolean
	"CPUWatcher startMonitoring"

	CurrentCPUWatcher ifNotNil: [ ^CurrentCPUWatcher startMonitoring. ].
	CurrentCPUWatcher _ (self new)
		monitorProcessPeriod: pd sampleRate: rt suspendPorcine: aBoolean;
		threshold: th;
		yourself.
	^CurrentCPUWatcher
! !
!ProcessBrowserWindow methodsFor: 'open/close' stamp: 'jmv 10/3/2012 11:24'!
           openInWorld
	
	super openInWorld.
	self startAutoUpdate.
	self startCPUWatcher! !
!CPUWatcher methodsFor: 'startup-shutdown' stamp: 'jmv 10/3/2012 11:21' prior: 16797208!
                     startMonitoring
	self
		monitorProcessPeriod: 20 sampleRate: 100 suspendPorcine: true! !
!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'jmv 10/3/2012 11:22' prior: 16797281!
     startMonitoring
	"CPUWatcher startMonitoring"

	^self startMonitoringPeriod: 20 rate: 100 threshold: 0.8 suspendPorcine: true! !
!ProcessBrowser methodsFor: 'initialize-release' stamp: 'jmv 10/3/2012 11:22' prior: 16921707!
startCPUWatcher
	"Answers whether I started the CPUWatcher"

	CPUWatcher isMonitoring ifFalse: [
		CPUWatcher startMonitoringPeriod: 2 rate: 100 threshold: 0.85 suspendPorcine: false.
		^true
	].
	^false
! !
!ProcessBrowser methodsFor: 'initialize-release' stamp: 'jmv 10/3/2012 11:12' prior: 16921718!
                 stopCPUWatcher

	CPUWatcher stopMonitoring.
	self updateProcessList! !
!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 10/3/2012 11:10' prior: 16921854!
processNameList
	"since processList is a WeakArray, we have to strengthen the result"
	| tally |
	tally _ CPUWatcher current ifNotNil: [ :pw | pw tally ].
	^ (processList asOrderedCollection
		copyWithout: nil)
		collect: [:each | | percent |
			percent _ tally
				ifNotNil: [ ((((tally occurrencesOf: each) * 100.0 / tally size) roundTo: 1)
						asString padded: #left to: 2 with: $ ), '% '  ]
				ifNil: [ '' ].
			percent, (self prettyNameForProcess: each)
		] ! !
!ProcessBrowser class methodsFor: 'process control' stamp: 'jmv 10/3/2012 11:12' prior: 16921977!
        nameAndRulesFor: aProcess 
	"Answer a nickname and two flags: allow-stop, and allow-debug"
	^ [aProcess caseOf: {
		[] -> [{'no process'. false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{'the low space watcher'. false. false}].
		[WeakArray runningFinalizationProcess] -> [{'the WeakArray finalization process'. false. false}].
		[Processor activeProcess] -> [{'the UI process'. false. true}].
		[Processor backgroundProcess] -> [{'the idle process'. false. false}].
		[Sensor interruptWatcherProcess] -> [{'the user interrupt watcher'. false. false}].
		[Sensor eventTicklerProcess] -> [{'the event tickler'. false. false}].
		[ProjectX uiProcessX] -> [{'the inactive Morphic UI process'. false. false}].
		[Smalltalk
			at: #SoundPlayer
			ifPresent: [:sp | sp playerProcess]] -> [{'the Sound Player'. false. false}].
		[CPUWatcher currentWatcherProcess] -> [{'the CPUWatcher'. false. false}]}
		 otherwise: 
			[(aProcess priority = Processor timingPriority
					and: [aProcess suspendedContext receiver == Delay])
				ifTrue: [{'the timer interrupt watcher'. false. false}]
				ifFalse: [{aProcess suspendedContext asString. true. true}]]]
		ifError: [:err :rcvr | {aProcess suspendedContext asString. true. true}]! !
!ProcessBrowserWindow methodsFor: 'menu building' stamp: 'jmv 10/3/2012 11:13' prior: 16922256!
                 processListMenu
	| menu |
	menu _ MenuMorph new defaultTarget: self.

	model selectedProcess
		ifNotNil: [ :selectedProcess |
			| nameAndRules | 
			nameAndRules _ model nameAndRulesForSelectedProcess.
			menu addList: #(
				('inspect (i)'					#inspectProcess)
				('explore (I)'				#exploreProcess)
				('inspect Pointers (P)'		#inspectPointers)).
			nameAndRules second
				ifTrue: [
					menu add: 'terminate (t)' target: model action: #terminateProcess.
					selectedProcess isSuspended
						ifTrue: [menu add: 'resume (r)' target: model action: #resumeProcess]
						ifFalse: [menu add: 'suspend (s)' target: model action: #suspendProcess]].
			nameAndRules third
				ifTrue: [
					menu addList: #(
						('change priority (p)'		 	#changePriority)
						('debug (d)'						#debugProcess))].
			menu addList: #(('profile messages (m)'	#messageTally)).
			(selectedProcess suspendingList isKindOf: Semaphore)
				ifTrue: [menu add: 'signal Semaphore (S)' target: model action: #signalSemaphore].
			menu add: 'full stack (k)' target: model action: #moreStack.
			menu addLine].

	menu addList: #(
		('find context... (f)'		#findContext)
		('find again (g)'			#nextContext		''		model)).
	menu addLine.

	menu
		add: (isStepping
				ifTrue: ['turn off auto-update (a)']
				ifFalse: ['turn on auto-update (a)'])
		action: #toggleAutoUpdate.
	menu add: 'update list (u)' target: model action: #updateProcessList.

	menu addLine.
	CPUWatcher isMonitoring
			ifTrue: [ menu add: 'stop CPUWatcher' action: #stopCPUWatcher ]
			ifFalse: [ menu add: 'start CPUWatcher' action: #startCPUWatcher  ].

	^ menu! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 10/3/2012 11:17' prior: 16922442!
                        startCPUWatcher
	model startCPUWatcher ifTrue: [
		self setUpdateCallbackAfter: 3 ]! !

CPUWatcher class removeSelector: #startMonitoringPeriod:rate:threshold:!

CPUWatcher class removeSelector: #startMonitoringPeriod:rate:threshold:!

CPUWatcher removeSelector: #monitorProcessPeriod:sampleRate:!

CPUWatcher removeSelector: #monitorProcessPeriod:sampleRate:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1464-CuisCore-JuanVuletich-2012Oct03-14h47m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1464] on 7 October 2012 at 1:29:29 pm'!
!ProcessBrowser class methodsFor: 'process control' stamp: 'jmv 10/6/2012 17:04' prior: 50398715!
              nameAndRulesFor: aProcess 
	"Answer a nickname and two flags: allow-stop, and allow-debug"
	^ [aProcess caseOf: {
		[] -> [{'no process'. false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{'the low space watcher'. false. false}].
		[WeakArray runningFinalizationProcess] -> [{'the WeakArray finalization process'. false. false}].
		[Processor activeProcess] -> [{'the UI process'. false. true}].
		[Processor backgroundProcess] -> [{'the idle process'. false. false}].
		[Sensor interruptWatcherProcess] -> [{'the user interrupt watcher'. false. false}].
		[Sensor eventTicklerProcess] -> [{'the event tickler'. false. false}].
		[ProjectX uiProcessX] -> [{'the inactive Morphic UI process'. false. false}].
		[SoundPlayer playerProcess] -> [{'the Sound Player'. false. false}].
		[CPUWatcher currentWatcherProcess] -> [{'the CPUWatcher'. false. false}]}
		otherwise: [
			(aProcess priority = Processor timingPriority
					and: [aProcess suspendedContext receiver == Delay])
				ifTrue: [{'the timer interrupt watcher'. false. false}]
				ifFalse: [{aProcess suspendedContext asString. true. true}]]]
		ifError: [ :err :rcvr | {aProcess suspendedContext asString. true. true}]! !

ProcessorScheduler removeSelector: #tallyCPUUsageFor:!

ProcessorScheduler removeSelector: #tallyCPUUsageFor:!

ProcessBrowser class removeSelector: #tallyCPUUsageFor:!

ProcessBrowser class removeSelector: #tallyCPUUsageFor:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1465-CuisCore-JuanVuletich-2012Oct07-13h02m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1465] on 8 October 2012 at 10:49:41 pm'!
!Delay class methodsFor: 'timer process' stamp: 'jmv 10/8/2012 22:41'!
         timerProcess
	^TimerEventLoop! !
!ProcessBrowser class methodsFor: 'process control' stamp: 'jmv 10/8/2012 22:44'!
             rulesFor: aProcess
	"Answer two flags: allow-stop, and allow-debug"
	^ [aProcess caseOf: {
		[] -> [{false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{false. false}].
		[WeakArray runningFinalizationProcess] -> [{false. false}].
		[Processor activeProcess] -> [{false. true}].
		[Processor backgroundProcess] -> [{false. false}].
		[Sensor interruptWatcherProcess] -> [{false. false}].
		[Sensor eventTicklerProcess] -> [{false. false}].
		[ProjectX uiProcessX] -> [{false. false}].
		[SoundPlayer playerProcess] -> [{false. false}].
		[CPUWatcher currentWatcherProcess] -> [{false. false}].
		[Delay timerProcess] -> [{false. false}]}
		otherwise: [ {true. true}]]
		ifError: [ :err :rcvr | {true. true}]! !
!BlockClosure methodsFor: 'evaluating' stamp: 'jmv 10/8/2012 22:20' prior: 16789941!
                              valueWithin: aDuration onTimeout: timeoutBlock
	"Evaluate the receiver.
	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"

	| theProcess delay watchdog |

	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].

	"the block will be executed in the current process"
	theProcess := Processor activeProcess.
	delay := aDuration asDelay.

	"make a watchdog process"
	watchdog := [
		delay wait. 	"wait for timeout or completion"
		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 
	] newProcess.

	"Watchdog needs to run at high priority to do its job (but not at timing priority)"
	watchdog priority: Processor timingPriority-1.
	watchdog name: 'BlockClosure Watchdog'.

	"catch the timeout signal"
	^ [	watchdog resume.				"start up the watchdog"
		self ensure:[						"evaluate the receiver"
			theProcess := nil.				"it has completed, so ..."
			delay delaySemaphore signal.	"arrange for the watchdog to exit"
		]] on: TimedOut do: [ :e | timeoutBlock value ].
! !
!BlockClosure methodsFor: 'private' stamp: 'jmv 10/8/2012 22:20' prior: 16790233!
            grabProcessorFor: milliseconds onTimeout: timeoutBlock
	"Evaluate the receiver (block), without the possibility of preemption by regular priority processes.
	If not finished after milliseconds, restore original priority and evaluate timeoutBlock.
	Use with care!!"
	"Based on #valueUnpreemptively"
	
	| activeProcess oldPriority result done |
	activeProcess _ Processor activeProcess.
	oldPriority _ activeProcess priority.
	done _ false.
	
	activeProcess priority: Processor highIOPriority + Processor lowIOPriority // 2.
	milliseconds ifNotNil: [
		[
			(Delay forMilliseconds: milliseconds) wait.
			done ifFalse: [
				activeProcess
					suspend;
					priority: oldPriority;
					resume.
				timeoutBlock value ]
		] forkAt: Processor highIOPriority named: '#grabProcessorFor:onTimeout:' ].

	result _ self ensure: [
		done _ true.
		activeProcess priority: oldPriority].
	
	"Yield after restoring priority to give the preempted processes a chance to run"
	Processor yield.
	^result! !
!BlockContext methodsFor: 'evaluating' stamp: 'jmv 10/8/2012 22:19' prior: 16790971!
             valueWithin: aDuration onTimeout: timeoutBlock
	"Evaluate the receiver.
	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"

	| theProcess delay watchdog |

	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].

	"the block will be executed in the current process"
	theProcess := Processor activeProcess.
	delay := aDuration asDelay.

	"make a watchdog process"
	watchdog := [
		delay wait. 	"wait for timeout or completion"
		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 
	] newProcess.

	"Watchdog needs to run at high priority to do its job (but not at timing priority)"
	watchdog priority: Processor timingPriority-1.
	watchdog name: 'BlockContext Watchdog'.

	"catch the timeout signal"
	^ [	watchdog resume.				"start up the watchdog"
		self ensure:[						"evaluate the receiver"
			theProcess := nil.				"it has completed, so ..."
			delay delaySemaphore signal.	"arrange for the watchdog to exit"
		]] on: TimedOut do: [ :e | timeoutBlock value ].
! !
!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 10/8/2012 22:45' prior: 16797126!
      catchThePig: aProcess
	| rule |
	"nickname, allow-stop, allow-debug"
	rule _ (ProcessBrowser rulesFor: aProcess) first.

	(ProcessBrowser isUIProcess: aProcess)
		ifTrue: [ "aProcess debugWithTitle: 'Interrupted from the CPUWatcher'." ]
		ifFalse: [
			rule ifFalse: [ ^self ].
			ProcessBrowser suspendProcess: aProcess.
			self openWindowForSuspendedProcess: aProcess ]! !
!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 10/8/2012 22:45' prior: 16797157!
                 openMorphicWindowForSuspendedProcess: aProcess
	| menu rule |
	menu _ MenuMorph new.
	"nickname  allow-stop  allow-debug"
	rule _ (ProcessBrowser rulesFor: aProcess) second.
	menu add: 'Dismiss this menu' target: menu selector: #delete; addLine.
	menu add: 'Open Process Browser' target: ProcessBrowserWindow selector: #openProcessBrowser.
	menu add: 'Resume'
		target: self
		selector: #resumeProcess:fromMenu:
		argumentList: { aProcess . menu }.
	menu add: 'Terminate'
		target: self
		selector: #terminateProcess:fromMenu:
		argumentList: { aProcess . menu }.
	rule ifTrue: [
		menu add: 'Debug at a lower priority'
			target: self
			selector: #debugProcess:fromMenu:
			argumentList: { aProcess . menu }.
	].
	menu addTitle: aProcess identityHash asString,
		' ', aProcess name,
		' is taking too much time and has been suspended.
What do you want to do with it?'.
	menu stayUp.
	menu popUpInWorld
! !
!CPUWatcher methodsFor: 'startup-shutdown' stamp: 'jmv 10/8/2012 21:54' prior: 50398635!
                           monitorProcessPeriod: secs sampleRate: msecs suspendPorcine: aBoolean
	self stopMonitoring.

	watcher _ [ [ | promise |
		promise _ Processor tallyCPUUsageFor: secs every: msecs.
		tally _ promise value.
		promise _ nil.
		aBoolean ifTrue: [ self findThePig ].
	] repeat ] newProcess.
	watcher priority: Processor highestPriority.
	watcher name: 'CPUWatcher monitor'.
	watcher resume.
	Processor yield ! !
!ConnectionQueue methodsFor: 'private' stamp: 'jmv 10/8/2012 22:17' prior: 16826126!
                     initPortNumber: anInteger queueLength: queueLength
	"Private!! Initialize the receiver to listen on the given port number. Up to queueLength connections will be queued."

	portNumber _ anInteger.
	maxQueueLength _ queueLength.
	connections _ OrderedCollection new.
	accessSema _ Semaphore forMutualExclusion.
	socket _ nil.
	process _ [self listenLoop] newProcess.
	process priority: Processor highIOPriority.
	process name: 'ConnectionQueue'.
	process resume! !
!Delay class methodsFor: 'timer process' stamp: 'jmv 10/8/2012 22:10' prior: 16838038!
                          startTimerEventLoop
	"Start the timer event loop"
	"Delay startTimerEventLoop"
	self stopTimerEventLoop.
	AccessProtect := Semaphore forMutualExclusion.
	ActiveDelayStartTime := Time millisecondClockValue.
	SuspendedDelays := 
		Heap withAll: (SuspendedDelays ifNil:[#()])
			sortBlock: [:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].
	TimingSemaphore := Semaphore new.
	RunTimerEventLoop := true.
	TimerEventLoop := [self runTimerEventLoop] newProcess.
	TimerEventLoop
		priority: Processor timingPriority;
		name: 'Delay Scheduling';
		resume.
	TimingSemaphore signal. "get going"
! !
!DelayTest methodsFor: 'testing-limits' stamp: 'jmv 10/8/2012 22:17' prior: 16838143!
                           testMultiProcessWaitOnSameDelay
	"Ensure that waiting on the same delay from multiple processes raises an error"
	"
	self new testMultiProcessWaitOnSameDelay
	"
	| delay p1 p2 wasRun |
	delay := Delay forSeconds: 1.
	wasRun := false.
	p1 := [delay wait] newProcess.
	p1 priority: Processor activePriority+1.
	p1 name: 'testMultiProcessWaitOnSameDelay-1'.
	p1 resume.
	p2 := [
		self should:[delay wait] raise: Error.
		wasRun := true.
	] newProcess.
	p2 priority:  Processor activePriority+1.
	p2 name: 'testMultiProcessWaitOnSameDelay-2'.
	p2 resume.
	p1 terminate.
	p2 terminate.
	self assert: wasRun.

! !
!InputSensor methodsFor: 'user interrupts' stamp: 'jmv 10/8/2012 21:59' prior: 16870945!
      installInterruptWatcher
	"Initialize the interrupt watcher process. Terminate the old process if any."
	"Sensor installInterruptWatcher"

	InterruptWatcherProcess ifNotNil: [InterruptWatcherProcess terminate].
	InterruptSemaphore _ Semaphore new.
	InterruptWatcherProcess _ [self userInterruptWatcher] newProcess.
	InterruptWatcherProcess priority: Processor lowIOPriority.
	InterruptWatcherProcess name: 'User interrupt watcher'.
	InterruptWatcherProcess resume.
	self primInterruptSemaphore: InterruptSemaphore! !
!EventSensor methodsFor: 'private' stamp: 'jmv 10/8/2012 21:58' prior: 16845644!
           installEventTickler
	"Initialize the interrupt watcher process. Terminate the old process if any."
	"Sensor installEventTickler"

	EventTicklerProcess ifNotNil: [ EventTicklerProcess terminate ].
	EventTicklerProcess _ [ self eventTickler ] newProcess.
	EventTicklerProcess priority: Processor lowIOPriority.
	EventTicklerProcess name: 'Event Tickler'.
	EventTicklerProcess resume! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jmv 10/8/2012 22:16' prior: 16884470!
     startMIDITracking

	midiParser ifNil: [^ self].
	midiParser midiPort ifNil: [^ self].
	midiParser midiPort ensureOpen.
	self stopMIDITracking.
	SoundPlayer useShortBuffer.
	process _ [self midiTrackingLoop] newProcess.
	process priority: Processor userInterruptPriority.
	process name: 'MIDISynth'.
	process resume! !
!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 10/8/2012 22:16' prior: 16891685!
     spyAllEvery: millisecs on: aBlock
	"Create a spy and spy on the given block at the specified rate."
	"Spy all the system processes"

	| myDelay time0 |
	aBlock isBlock
		ifFalse: [ self error: 'spy needs a block here' ].
	self class: aBlock receiver class method: aBlock method.
		"set up the probe"
	myDelay := Delay forMilliseconds: millisecs.
	time0 := Time millisecondClockValue.
	gcStats _ Smalltalk getVMParameters.
	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].
	Timer _ [
		[true] whileTrue: [
			| startTime observedProcess |
			startTime := Time millisecondClockValue.
			myDelay wait.
			observedProcess := Processor preemptedProcess.
			self
				tally: observedProcess suspendedContext
				in: observedProcess
				"tally can be > 1 if ran a long primitive"
				by: (Time millisecondClockValue - startTime) // millisecs].
		nil] newProcess.
	Timer priority: Processor timingPriority-1.
	Timer name: 'MessageTally'.
		"activate the probe and evaluate the block"
	Timer resume.
	^ aBlock ensure: [
		"cancel the probe and return the value"
		"Could have already been terminated. See #terminateTimerProcess"
		Timer ifNotNil: [
			Timer terminate.
			Timer _ nil ].
		"Collect gc statistics"
		Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal |
			gcVal ifNotNil: [
				gcStats at: idx put: (gcVal - (gcStats at: idx))]].
		time := Time millisecondClockValue - time0]! !
!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 10/8/2012 22:16' prior: 16891731!
                               spyEvery: millisecs on: aBlock
	"Create a spy and spy on the given block at the specified rate."
	"Spy only on the active process (in which aBlock is run)"

	| myDelay time0 observedProcess |
	aBlock isBlock
		ifFalse: [ self error: 'spy needs a block here' ].
	self class: aBlock receiver class method: aBlock method.
		"set up the probe"
	observedProcess _ Processor activeProcess.
	myDelay := Delay forMilliseconds: millisecs.
	time0 := Time millisecondClockValue.
	gcStats _ Smalltalk getVMParameters.
	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].
	Timer _ [
		[ true ] whileTrue: [
			| startTime |
			startTime := Time millisecondClockValue.
			myDelay wait.
			self
				tally: Processor preemptedProcess suspendedContext
				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])
				"tally can be > 1 if ran a long primitive"
				by: (Time millisecondClockValue - startTime) // millisecs].
		nil] newProcess.
	Timer priority: Processor timingPriority-1.
	Timer name: 'MessageTally'.
		"activate the probe and evaluate the block"
	Timer resume.
	^ aBlock ensure: [
		"cancel the probe and return the value"
		"Could have already been terminated. See #terminateTimerProcess"
		Timer ifNotNil: [
			Timer terminate.
			Timer _ nil ].
		"Collect gc statistics"
		Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal |
			gcVal ifNotNil: [
				gcStats at: idx put: (gcVal - (gcStats at: idx))]].
		time := Time millisecondClockValue - time0]! !
!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 10/8/2012 22:15' prior: 16891780!
                       spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration
	"Create a spy and spy on the given process at the specified rate."
	| myDelay time0 endTime observedProcess sem |
	(aProcess isKindOf: Process)
		ifFalse: [self error: 'spy needs a Process here'].
	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.
	"set up the probe"
	observedProcess _ aProcess.
	myDelay _ Delay forMilliseconds: millisecs.
	time0 _ Time millisecondClockValue.
	endTime _ time0 + msecDuration.
	sem _ Semaphore new.
	gcStats _ Smalltalk getVMParameters.
	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].
	Timer _ [
			[
				| startTime |
				startTime _ Time millisecondClockValue.
				myDelay wait.
				self
					tally: Processor preemptedProcess suspendedContext
					in: (observedProcess == Processor preemptedProcess ifTrue: [ observedProcess ] ifFalse: [nil])
					"tally can be > 1 if ran a long primitive"
					by: (Time millisecondClockValue - startTime) // millisecs.
				startTime < endTime
			] whileTrue.
			sem signal.
		] newProcess.
	Timer priority: Processor timingPriority-1.
	Timer name: 'MessageTally'.
		"activate the probe and evaluate the block"
	Timer resume.
	"activate the probe and wait for it to finish"
	sem wait.
	"Collect gc statistics"
	Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal |
		gcVal ifNotNil: [
			gcStats at: idx put: (gcVal - (gcStats at: idx))]].
	time _ Time millisecondClockValue - time0! !
!Process methodsFor: 'accessing' stamp: 'jmv 10/8/2012 21:52' prior: 16921345!
                 name

	^name ifNil: [ 'unnamed' ]! !
!Process methodsFor: 'printing' stamp: 'jmv 10/8/2012 22:30' prior: 16921381!
             browserPrintStringWith: anObject

	^String streamContents: [ :stream |
		stream nextPut: $(.
		priority printOn: stream.
		self isSuspended
			ifTrue: [ stream nextPut: $s ].
		stream nextPutAll: ') '.
		self hash printOn: stream.
		stream space.
		stream nextPutAll: self name.
		anObject ifNotNil: [
			stream
				nextPutAll: ': ';
				nextPutAll: anObject asString ]]! !
!ProcessBrowser methodsFor: 'process actions' stamp: 'jmv 10/8/2012 22:45' prior: 16921770!
              suspendProcess
	| rule |
	selectedProcess isSuspended
		ifTrue: [^ self].
	rule _ (self class rulesFor: selectedProcess) first.
	rule
		ifFalse: [
			PopUpMenu inform: 'Nope, won''t suspend ' , selectedProcess name.
			^ self].
	self class suspendProcess: selectedProcess.
	self updateProcessList! !
!ProcessBrowser methodsFor: 'process actions' stamp: 'jmv 10/8/2012 22:45' prior: 16921783!
                        terminateProcess
	| rule |
	rule _ (self class rulesFor: selectedProcess) first.
	rule
		ifFalse: [PopUpMenu inform: 'Nope, won''t kill ' , selectedProcess name.
			^ self].
	self class terminateProcess: selectedProcess.	
	self updateProcessList! !
!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 10/8/2012 22:32' prior: 50398697!
              processNameList
	"since processList is a WeakArray, we have to strengthen the result"
	| tally |
	tally _ CPUWatcher current ifNotNil: [ :pw | pw tally ].
	^ (processList asOrderedCollection
		copyWithout: nil)
		collect: [:each | | percent |
			percent _ tally
				ifNotNil: [ ((((tally occurrencesOf: each) * 100.0 / tally size) roundTo: 1)
						asString padded: #left to: 2 with: $ ), '% '  ]
				ifNil: [ '' ].
			percent, (each browserPrintStringWith: nil)
		] ! !
!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'jmv 10/8/2012 22:46' prior: 16922083!
       dumpPigStackOn: aStream andClose: aBoolean
	"Must run forked on its own process, so the monitored behavior is not affected too much"

	| promise tally process depth stack suspendedContext |
	promise := Processor tallyCPUUsageFor: 1 every: 10.
	tally := promise value.
	"WorldState addDeferredUIMessage: [self dumpTallyOnTranscript: tally]."
	aStream nextPutAll: '====Al processes===='; newLine.
	self dumpTally: tally on: aStream.
	aStream newLine; nextPutAll: '====Process using most CPU===='; newLine.
	process _ tally sortedCounts first value.
	(100.0 * (tally occurrencesOf: process) / tally size) rounded printOn: aStream.
	aStream
		nextPutAll: ' % ';
		nextPutAll: (process browserPrintStringWith: nil);
		newLine.
	depth _ 20.
	stack _ process == Processor activeProcess
		ifTrue: [thisContext stackOfSize: depth]
		ifFalse: [suspendedContext _ process suspendedContext.
			suspendedContext
				ifNotNil: [suspendedContext stackOfSize: depth]].
	stack 
		ifNil: [ aStream nextPutAll: 'No context'; newLine]
		ifNotNil: [
			stack do: [ :c | 
				c printOn: aStream.
				aStream newLine]].
	aBoolean ifTrue: [aStream close]! !
!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'jmv 10/8/2012 22:47' prior: 16922123!
                dumpTally: tally on: aStream
	"tally is from ProcessorScheduler>>tallyCPUUsageFor:
	Dumps lines with percentage of time, hash of process, and a friendly name"

	tally sortedCounts do: [ :assoc |
		(((assoc key / tally size) * 100.0) roundTo: 1) printOn: aStream.
		aStream
			nextPutAll: '%   ';
			print: assoc value identityHash; space;
			nextPutAll: assoc value name;
			newLine.
	]! !
!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'jmv 10/8/2012 22:22' prior: 16922161!
                        tallyCPUUsageFor: seconds every: msec 
	"Compute CPU usage using a msec millisecond sample for the given number of seconds,
	then dump the usage statistics on the Transcript. The UI is free to continue, meanwhile.
	This method has no senders, but is a useful utility"

	"ProcessBrowser tallyCPUUsageFor: 10 every: 100"

	| promise |
	promise := Processor tallyCPUUsageFor: seconds every: msec.
	
	[| tally |
	tally := promise value.
	WorldState addDeferredUIMessage: [self dumpTallyOnTranscript: tally]] 
			fork! !
!ProcessBrowserWindow methodsFor: 'menu building' stamp: 'jmv 10/8/2012 22:47' prior: 50398757!
                            processListMenu
	| menu |
	menu _ MenuMorph new defaultTarget: self.

	model selectedProcess
		ifNotNil: [ :selectedProcess |
			| rules | 
			rules _ model class rulesFor: model selectedProcess.
			menu addList: #(
				('inspect (i)'					#inspectProcess)
				('explore (I)'				#exploreProcess)
				('inspect Pointers (P)'		#inspectPointers)).
			rules first
				ifTrue: [
					menu add: 'terminate (t)' target: model action: #terminateProcess.
					selectedProcess isSuspended
						ifTrue: [menu add: 'resume (r)' target: model action: #resumeProcess]
						ifFalse: [menu add: 'suspend (s)' target: model action: #suspendProcess]].
			rules second
				ifTrue: [
					menu addList: #(
						('change priority (p)'		 	#changePriority)
						('debug (d)'						#debugProcess))].
			menu addList: #(('profile messages (m)'	#messageTally)).
			(selectedProcess suspendingList isKindOf: Semaphore)
				ifTrue: [menu add: 'signal Semaphore (S)' target: model action: #signalSemaphore].
			menu add: 'full stack (k)' target: model action: #moreStack.
			menu addLine].

	menu addList: #(
		('find context... (f)'		#findContext)
		('find again (g)'			#nextContext		''		model)).
	menu addLine.

	menu
		add: (isStepping
				ifTrue: ['turn off auto-update (a)']
				ifFalse: ['turn on auto-update (a)'])
		action: #toggleAutoUpdate.
	menu add: 'update list (u)' target: model action: #updateProcessList.

	menu addLine.
	CPUWatcher isMonitoring
			ifTrue: [ menu add: 'stop CPUWatcher' action: #stopCPUWatcher ]
			ifFalse: [ menu add: 'start CPUWatcher' action: #startCPUWatcher  ].

	^ menu! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 10/8/2012 22:47' prior: 50396618!
             changePriority
	| str newPriority rule |
	rule _ (model class rulesFor: model selectedProcess) second.
	rule
		ifFalse: [PopUpMenu inform: 'Nope, won''t change priority of ' , model selectedProcess name.
			^ self].
	str _ FillInTheBlankMorph request: 'New priority' initialAnswer: model selectedProcess priority asString.
	newPriority _ str asNumber asInteger.
	newPriority
		ifNil: [^ self].
	(newPriority < 1
			or: [newPriority > Processor highestPriority])
		ifTrue: [PopUpMenu inform: 'Bad priority'.
			^ self].
	model class setProcess: model selectedProcess toPriority: newPriority.
	model updateProcessList! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 10/8/2012 22:47' prior: 16922360!
                     debugProcess
	| rule |
	rule _ (model class rulesFor: model selectedProcess) second.
	rule third
		ifFalse: [PopUpMenu inform: 'Nope, won''t debug ' , model selectedProcess name.
			^ self].
	model class debugProcess: model selectedProcess.! !
!ProcessTerminateBug methodsFor: 'tests' stamp: 'jmv 10/8/2012 22:15' prior: 16922519!
                     testSchedulerTermination
	| process sema gotHere sema2 |
	gotHere _ false.
	sema _ Semaphore new.
	sema2 _ Semaphore new.
	process _ [
		sema signal.
		sema2 wait.
		"will be suspended here"
		gotHere _ true ] newProcess.
	process priority: Processor activeProcess priority.
	process name: 'testSchedulerTermination'.
	process resume.
	sema wait.
	"until process gets scheduled"
	process terminate.
	sema2 signal.
	Processor yield.
	"will give process a chance to continue and horribly screw up"
	self assert: gotHere not.! !
!ProcessTerminateBug methodsFor: 'tests' stamp: 'jmv 10/8/2012 22:15' prior: 16922558!
                           testUnwindFromActiveProcess
	| sema process |
	sema := Semaphore forMutualExclusion.
	self assert:(sema isSignaled).
	process := [
		sema critical:[
			self deny: sema isSignaled.
			Processor activeProcess terminate.
		]
	] newProcess.
	process priority: Processor userInterruptPriority.
	process name: 'testUnwindFromActiveProcess'.
	process resume.
	self assert: sema isSignaled! !
!ProcessTerminateBug methodsFor: 'tests' stamp: 'jmv 10/8/2012 22:14' prior: 16922571!
        testUnwindFromForeignProcess
	| sema process |
	sema := Semaphore forMutualExclusion.
	self assert: sema isSignaled.
	process := [
		sema critical:[
			self deny: sema isSignaled.
			sema wait. "deadlock"
		]
	] newProcess.
	process priority: Processor userInterruptPriority.
	process name: 'testUnwindFromForeignProcess'.
	process resume.
	self deny: sema isSignaled.
	"This is for illustration only - the BlockCannotReturn cannot 
	be handled here (it's truncated already)"
	self shouldnt: [process terminate] raise: BlockCannotReturn.
	self assert: sema isSignaled! !
!ProcessorScheduler methodsFor: 'CPU usage tally' stamp: 'jmv 10/8/2012 22:23' prior: 16922841!
     tallyCPUUsageFor: seconds every: msec
	"Start a high-priority process that will tally the next ready process for the given
	number of seconds. Answer a Block that will return the tally (a Bag) after the task
	is complete" 
	| tally sem delay endDelay |
	tally _ IdentityBag new: 200.
	delay _ Delay forMilliseconds: msec truncated.
	endDelay _ Delay forSeconds: seconds.
	endDelay schedule.
	sem _ Semaphore new.
	[
		[ endDelay isExpired ] whileFalse: [
			delay wait.
			tally add: Processor nextReadyProcess
		].
		sem signal.
	] forkAt: self highestPriority named: 'Processor CPU Usage Tallier'.

	^[ sem wait. tally ]! !
!ProcessorScheduler class methodsFor: 'background process' stamp: 'jmv 10/8/2012 22:00' prior: 16922925!
     startUp
	"Install a background process of the lowest possible priority that is always runnable."
	"Details: The virtual machine requires that there is aways some runnable process that can be scheduled; this background process ensures that this is the case."

	Smalltalk installLowSpaceWatcher.
	BackgroundProcess ifNotNil: [BackgroundProcess terminate].
	BackgroundProcess _ [self idleProcess] newProcess.
	BackgroundProcess priority: SystemRockBottomPriority.
	BackgroundProcess name: 'Idle Process'.
	BackgroundProcess resume.
! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 10/8/2012 21:57' prior: 16923716!
           spawnNewProcessX

	UIProcess _ [
		World clearWaitDelay.
		[World doOneCycle.  Processor yield.  false] whileFalse: [].
	] newProcess priority: Processor userSchedulingPriority.
	UIProcess name: 'Morphic UI'.
	UIProcess resume! !
!SHTextStyler methodsFor: 'styling' stamp: 'jmv 10/8/2012 22:06' prior: 50333603!
        styleInBackgroundProcess
	"Do the styling on a copy of the provided text (and in a separate process).
	After finishing, send it to the model, via #stylerStyled:checkForChanges:
	The the model should grab the TextAttributes we added to the copy, as appropriate."
	| afterFormatProcess |
	self terminateBackgroundStylingProcess.

	formattedText _ textModel actualContents copy.
	self mutex critical: [
		
		"This part, running at current priority, and fired by sem, is for events to be triggered at current priority"
		sem _ Semaphore new. 
		afterFormatProcess _ [
			sem ifNotNil: [
				sem wait.
				textModel stylerStyled: formattedText checkForChanges: true ]
		] newProcess.
		afterFormatProcess
			priority: Processor activePriority;
			name: 'Shout after style update';
			resume.

		"This part runs at low priority, and signals sem when finished"
		backgroundProcess _  [
			textModel privateStyleWith: self.
			sem signal] newProcess.
		backgroundProcess
			priority: Processor userBackgroundPriority;
			name: 'Shout format';
			resume
	]! !
!ScorePlayer methodsFor: 'midi output' stamp: 'jmv 10/8/2012 22:14' prior: 16934449!
                startMIDIPlaying
	"Start up a process to play this score via MIDI."

	midiPort ensureOpen.
	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].
	midiPlayerProcess _ [self midiPlayLoop] newProcess.
	midiPlayerProcess
		priority: Processor userInterruptPriority;
		name: 'ScorePlayer';
		resume.
! !
!SoundPlayer class methodsFor: 'player process' stamp: 'jmv 10/8/2012 22:14' prior: 16948784!
                 startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag sound: aSound
	"Start the sound player process. Terminate the old process, if any."
	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"

	self stopPlayerProcess.
	aSound
		ifNil:[ActiveSounds _ OrderedCollection new]
		ifNotNil:[ActiveSounds _ OrderedCollection with: aSound].
	Buffer _ SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.
	LastBuffer ifNotNil:[LastBuffer _ SoundBuffer basicNew: Buffer basicSize].
	PlayerSemaphore _ Semaphore forMutualExclusion.
	SamplingRate _ samplesPerSecond.
	Stereo _ stereoFlag.
	ReadyForBuffer _ Semaphore new.
	SoundSupported _ true. "Assume so"
	UseReadySemaphore _ true.  "set to false if ready semaphore not supported by VM"
	self primSoundStartBufferSize: Buffer stereoSampleCount
		rate: samplesPerSecond
		stereo: Stereo
		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).
	"Check if sound start prim was successful"
	SoundSupported ifFalse:[^self].
	UseReadySemaphore
		ifTrue: [PlayerProcess _ [SoundPlayer playLoop] newProcess]
		ifFalse: [PlayerProcess _ [SoundPlayer oldStylePlayLoop] newProcess].
	UseReverb ifTrue: [self startReverb].

	PlayerProcess
		priority: Processor userInterruptPriority;
		name: 'Sound Player';
		resume! !
!SoundRecorder methodsFor: 'recording controls' stamp: 'jmv 10/8/2012 22:13' prior: 16949290!
 startRecording
	"Turn of the sound input driver and start the recording process. Initially, recording is paused."

	| semaIndex |
	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"
	Preferences canRecordWhilePlaying ifFalse: [SoundPlayer shutDown].
	recordProcess ifNotNil: [self stopRecording].
	paused _ true.
	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.
	meterLevel _ 0.
	self allocateBuffer.
	bufferAvailableSema _ Semaphore new.
	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.
	self primStartRecordingDesiredSampleRate: samplingRate asInteger
		stereo: stereo
		semaIndex: semaIndex.
	RecorderActive _ true.
	samplingRate _ self primGetActualRecordingSampleRate.
	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.
	recordProcess _ [self recordLoop] newProcess.
	recordProcess
		priority: Processor userInterruptPriority;
		name: 'Sound Recorder';
		resume.
! !
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 10/8/2012 22:03' prior: 16959792!
              installLowSpaceWatcher
	"Start a process to watch for low-space conditions."
	"Smalltalk installLowSpaceWatcher"

	self primSignalAtBytesLeft: 0.  "disable low-space interrupts"
	LowSpaceProcess ifNotNil: [LowSpaceProcess terminate].
	LowSpaceProcess _ [self lowSpaceWatcher] newProcess.
	LowSpaceProcess priority: Processor lowIOPriority.
	LowSpaceProcess name: 'Low Space Watcher'.
	LowSpaceProcess resume.

! !
!Transcripter class methodsFor: 'instance creation' stamp: 'jmv 10/8/2012 22:12' prior: 16978670!
startTranscriptProcess   "Transcripter startTranscriptProcess"
	| activeProcess |
	Transcript _ self newInFrame: Display boundingBox.
	activeProcess _ [Transcript readEvalPrint.
					Smalltalk processShutDownList: true; quitPrimitive]
						newProcess.
	activeProcess
		priority: Processor userSchedulingPriority;
		name: 'Transcripter';
		resume.
	Processor terminateActive
! !
!WeakArray class methodsFor: 'private' stamp: 'jmv 10/8/2012 22:02' prior: 16984821!
                restartFinalizationProcess
	"kill any old process, just in case"
	FinalizationProcess
		ifNotNil: [ 
			FinalizationProcess terminate.
			FinalizationProcess := nil ].

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.
	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.
	FinalizationProcess := [ self finalizationProcess ] newProcess.
	FinalizationProcess priority: Processor userInterruptPriority.
	FinalizationProcess name: 'WeakArray finalization'.
	FinalizationProcess resume! !

ProcessBrowser class removeSelector: #nameAndRulesFor:!

ProcessBrowser class removeSelector: #nameAndRulesFor:!

ProcessBrowser removeSelector: #nameAndRulesFor:!

ProcessBrowser removeSelector: #nameAndRulesFor:!

ProcessBrowser removeSelector: #nameAndRulesForSelectedProcess!

ProcessBrowser removeSelector: #nameAndRulesForSelectedProcess!

ProcessBrowser removeSelector: #prettyNameForProcess:!

ProcessBrowser removeSelector: #prettyNameForProcess:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Sensor installEventTickler.
Sensor installInterruptWatcher.
Delay startTimerEventLoop!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1466-CuisCore-JuanVuletich-2012Oct08-21h45m-jmv.4.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1465] on 8 October 2012 at 11:30:05 pm'!
!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 10/8/2012 23:24' prior: 16797141!
         findThePig
	"tally has been updated. Look at it to see if there is a bad process.
	This runs at a very high priority, so make it fast"
	| countAndProcess | 
	countAndProcess _ tally sortedCounts first.
	(countAndProcess key / tally size > threshold) ifTrue: [ | proc |
		proc _ countAndProcess value.
		proc == Processor backgroundProcess ifTrue: [ ^self ].	"idle process? OK"
		self catchThePig: proc
	].
! !
!CPUWatcher methodsFor: 'startup-shutdown' stamp: 'jmv 10/8/2012 23:19' prior: 50399068!
             monitorProcessPeriod: secs sampleRate: msecs suspendPorcine: aBoolean
	| thisTally delay |
	self stopMonitoring.
	watcher _ [
		thisTally _ IdentityBag new: 200.
		delay _ Delay forMilliseconds: msecs truncated.
		[
			secs * 1000 // msecs timesRepeat: [
				delay wait.
				thisTally add: Processor nextReadyProcess
			].
			tally _ thisTally copy.
			aBoolean ifTrue: [ self findThePig ].
		] repeat
	] newProcess.
	watcher priority: Processor highestPriority.
	watcher name: 'CPUWatcher monitor'.
	watcher resume.
	Processor yield! !
!CPUWatcher methodsFor: 'accessing' stamp: 'jmv 10/8/2012 23:02' prior: 16797223!
                     tally
	^tally! !
!CPUWatcher class methodsFor: 'as yet unclassified' stamp: 'jmv 10/8/2012 23:27' prior: 50398650!
             startMonitoringPeriod: pd rate: rt threshold: th suspendPorcine: aBoolean
	"CPUWatcher startMonitoring"

	CurrentCPUWatcher ifNil: [
		CurrentCPUWatcher _ self new.
		CurrentCPUWatcher
			threshold: th;
			monitorProcessPeriod: pd sampleRate: rt suspendPorcine: aBoolean ]! !
!ProcessBrowser methodsFor: 'initialize-release' stamp: 'jmv 10/8/2012 23:28' prior: 50398682!
             startCPUWatcher
	"Answers whether I started the CPUWatcher"

	CPUWatcher isMonitoring ifFalse: [
		CPUWatcher startMonitoringPeriod: 1 rate: 100 threshold: 0.85 suspendPorcine: false.
		^true
	].
	^false
! !

ProcessBrowser class removeSelector: #tallyCPUUsageFor:every:!

ProcessBrowser class removeSelector: #tallyCPUUsageFor:every:!

CPUWatcher class removeSelector: #startMonitoring!

CPUWatcher class removeSelector: #startMonitoring!

CPUWatcher removeSelector: #startMonitoring!

CPUWatcher removeSelector: #startMonitoring!

CPUWatcher removeSelector: #threshold!

CPUWatcher removeSelector: #threshold!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1467-CuisCore-JuanVuletich-2012Oct08-22h49m-jmv.6.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1467] on 10 October 2012 at 10:42:03 am'!
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 10/10/2012 10:41' prior: 50396387!
                      createPackage

	| pkName |
	pkName _ FillInTheBlankMorph request: 'Name for new package?'.
	pkName ifNotEmpty: [
		CodePackage
			named: pkName
			createIfAbsent: true
			registerIfNew: true ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1468-CuisCore-JuanVuletich-2012Oct10-10h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1468] on 10 October 2012 at 4:25:25 pm'!
!CodeFile methodsFor: 'initialize' stamp: 'jmv 10/10/2012 13:56' prior: 16810978!
  fromFileNamed: aName
	| stream |
	fullName _ aName.
	stream _ FileStream readOnlyFileNamed: aName.
	[ self buildFrom: stream ] ensure: [ stream close ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1469-CuisCore-JuanVuletich-2012Oct10-13h56m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1469] on 15 October 2012 at 12:19 pm'!
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 10/14/2012 22:11' prior: 50388972!
       mouseUp: aMouseButtonEvent localPosition: localEventPosition
	"The mouse came up within the list; take appropriate action"

	| row |
	row _ self rowAtLocation: localEventPosition.
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	(autoDeselect == false and: [row = 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"
	"No change if model is locked"
	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])
		ifTrue: [
			aMouseButtonEvent mouseButton1Changed ifTrue: [
				self changeModelSelection: 0]]
		ifFalse: [self changeModelSelection: row].
	Cursor normal show.
! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 10/15/2012 11:17' prior: 50389040!
   mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (localEventPosition y < 0 and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: 0@0) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [ self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1470-RightClickFixes-JuanVuletich-2012Oct15-12h18m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1469] on 15 October 2012 at 12:20:37 pm'!
!StringTest methodsFor: 'testing' stamp: 'jmv 10/14/2012 21:34'!
                    testLineSeparators
	"
	Test that #newLineCharacter is considered a line separator and not a line terminator.
	This means that the last line never ends with a #newLineCharacter (although it might be empty!!)
	StringTest new testLineSeparators
	"
	'
' lineIndicesDo: [ :start :endWithoutDelimiters :end |
		{ start . endWithoutDelimiters. end } print
		].! !
!String methodsFor: 'accessing' stamp: 'jmv 10/15/2012 11:23' prior: 16954983!
            lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"
	
	| start end endWithoutDelimiters |
	start _ 1.
	[
		end _ self indexOfAnyOf: CSLineEnders startingAt: start ifAbsent: [ 0 ].
		end = 0
			ifTrue: [
				"Last line was found. Evaluate and exit.
				Note. If last char in receiver is a line separator, there's an extra empty line"
				endWithoutDelimiters _ end _ self size.
				aBlock value: start value: endWithoutDelimiters value: end.
				^self ].

		"Account for CrLf sequence"
		endWithoutDelimiters _ end - 1.
		(end < self size
			and: [(self at: end + 1) = Character lfCharacter
			and: [(self at: end) = Character crCharacter ]])
				ifTrue: [ end _ end + 1].

		aBlock value: start value: endWithoutDelimiters value: end.
		start _ end + 1 ] repeat! !

Editor removeSelector: #lines!

Editor removeSelector: #lines!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1471-CuisCore-JuanVuletich-2012Oct15-12h19m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1471] on 17 October 2012 at 11:00:08 am'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 10/17/2012 10:30' prior: 16874797!
                  tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results"
	"0 tinyBenchmarks"
	"On a 292 MHz G3 Mac: 22,727,272 bytecodes/sec; 984,169 sends/sec"
	"On a 400 MHz PII/Win98:  18,028,169 bytecodes/sec; 1,081,272 sends/sec"
	"On a 1.6GHz Atom/Win7 with Cog:  201,099,764 bytecodes/sec; 28,197,075 sends/sec"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue:[n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^ ((n1 * 500000 * 1000) // t1) asStringWithCommas, ' bytecodes/sec; ',
	  ((r * 1000) // t2) asStringWithCommas, ' sends/sec'! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1472-CuisCore-JuanVuletich-2012Oct17-10h26m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1472] on 21 October 2012 at 8:00:39 pm'!

!classDefinition: #WorldState category: #'Morphic-Worlds'!
Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent activeHand world'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent activeHand world '
	classVariableNames: 'DeferredUIMessages MaxCycleLapse '
	poolDictionaries: ''
	category: 'Morphic-Worlds'!
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 10/21/2012 19:58'!
                        worldState: aWorldState
	"
	World worldState: (World instVarNamed: 'worldState')
	"
	worldState _ aWorldState.
	worldState world: self! !
!Process methodsFor: 'UI support' stamp: 'jmv 10/21/2012 19:41'!
                     animatedUI
	"If we are an UI process, answer the root object of that UI.
	For a Morphic process, it is the Morphic World.
	Answer nil if not an UI process."

	^self triggerEvent: #animatedUI! !
!Process methodsFor: 'UI support' stamp: 'jmv 10/21/2012 19:37'!
                             animatedUI: anUIRoot
	"Let us know that we are running a certain UI.
	In Morphic, anUIRoot should be the World being run.
	We use the event system to avoid the need to add an ivar to us."

	self when: #animatedUI send: #yourself to: anUIRoot! !
!WorldState methodsFor: 'initialization' stamp: 'jmv 10/21/2012 19:55'!
   world: aPasteUpMorph

	world _ aPasteUpMorph! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 10/21/2012 19:46' prior: 50399664!
               spawnNewProcessX

	UIProcess _ [
		World clearWaitDelay.
		[ World doOneCycle. Processor yield. true] whileTrue: [].
	] newProcess priority: Processor userSchedulingPriority.
	UIProcess
		name: 'Morphic UI';
		animatedUI: World;
		resume! !

!classDefinition: #WorldState category: #'Morphic-Worlds'!
Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent activeHand world'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent activeHand world'
	classVariableNames: 'DeferredUIMessages MaxCycleLapse'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1473-CuisCore-JuanVuletich-2012Oct21-19h04m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1473] on 23 October 2012 at 11:08:06 pm'!
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 10/23/2012 23:02'!
          spawnNewMorphicProcessFor: aWorld

	UIProcess ifNotNil: [ UIProcess animatedUI: nil ].
	UIProcess _ [
		aWorld clearWaitDelay.
		[ aWorld doOneCycle. Processor yield. true] whileTrue: [].
	] newProcess priority: Processor userSchedulingPriority.
	UIProcess
		name: 'Morphic UI';
		animatedUI: aWorld;
		resume! !
!Debugger methodsFor: 'private' stamp: 'jmv 10/21/2012 21:04' prior: 50397117!
                        resumeProcess
	savedCursor
		ifNotNil: [Sensor currentCursor: savedCursor].
	interruptedProcess isTerminated ifFalse: [
		interruptedProcess resume ].
	"if old process was terminated, just terminate current one"
	interruptedProcess _ nil.
	contextStackIndex _ 0.
	contextStack _ nil.
	contextStackTop _ nil.
	receiverInspector _ nil.
	contextVariablesInspector _ nil.
	self currentWorld ifNotNil: [ :w | w displayWorld ].
	Smalltalk installLowSpaceWatcher.
	"restart low space handler"
	errorWasInUIProcess == false
		ifFalse: [ Processor terminateActive ]! !
!Process methodsFor: 'UI support' stamp: 'jmv 10/23/2012 23:01' prior: 50400220!
                               animatedUI: anUIRoot
	"Let us know that we are running a certain UI.
	In Morphic, anUIRoot should be the World being run.
	We use the event system to avoid the need to add an ivar to us."

	self removeActionsForEvent: #animatedUI.
	anUIRoot ifNotNil: [
		self when: #animatedUI send: #yourself to: anUIRoot ]! !
!ProcessBrowser class methodsFor: 'process control' stamp: 'jmv 10/21/2012 20:10' prior: 16921972!
     isUIProcess: aProcess
	^aProcess animatedUI notNil! !
!ProcessBrowser class methodsFor: 'process control' stamp: 'jmv 10/23/2012 17:21' prior: 50398891!
       rulesFor: aProcess
	"Answer two flags: allow-stop, and allow-debug"

	"Don't mess with the process running the ProcessBrowser.
	If we support several active UIs, we'd detect the UI process running us"
	self flag: #jmvVer2.
	aProcess == Processor activeProcess
		ifTrue: [^{false. false}].

	^ [aProcess caseOf: {
		[] -> [{false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{false. false}].
		[WeakArray runningFinalizationProcess] -> [{false. false}].
		[Processor activeProcess] -> [{false. true}].
		[Processor backgroundProcess] -> [{false. false}].
		[Sensor interruptWatcherProcess] -> [{false. false}].
		[Sensor eventTicklerProcess] -> [{false. false}].
		[SoundPlayer playerProcess] -> [{false. false}].
		[CPUWatcher currentWatcherProcess] -> [{false. false}].
		[Delay timerProcess] -> [{false. false}]}
		otherwise: [ {true. true}]]
		ifError: [ :err :rcvr | {true. true}]! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 10/21/2012 20:59' prior: 50397979!
 interruptNameX: labelString
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess  |
	preemptedProcess _ Processor preemptedProcess.
	"Don't stop the background process. This crashes the VM!!"
	preemptedProcess == Processor backgroundProcess
		ifTrue: [ ^self ].
	preemptedProcess suspend.
	Debugger
		openInterrupt: labelString, 
			' - Process: ', preemptedProcess name, 
			' - Priority: ', preemptedProcess priority printString 
		onProcess: preemptedProcess! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 10/21/2012 20:21' prior: 16923708!
   spawnNewProcessIfThisIsUIX: suspendedProcess

	suspendedProcess animatedUI ifNotNil: [ :aWorld |
		self spawnNewMorphicProcessFor: aWorld.
		^true
	].
	^false		"no new process was created"! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 10/21/2012 20:28' prior: 16982201!
    reportCPUandRAM
	"Write several text files with useful analysis for profiling purposes.
	Overwrites any existing report.
	Utilities reportCPUandRAM
	"	

	| stream tally |
	
	"VM statistics (Memory use and GC, mainly)"
	stream _ FileStream forceNewFileNamed: 'MemoryStats.txt'.
	[ stream nextPutAll: Utilities vmStatisticsReportString ] 
		ensure: [ stream close ].
	
	"Process list"
	stream _ FileStream forceNewFileNamed: 'ProcessList.txt'.
	[
		ProcessBrowser new processNameList 
			do: [ :each | 
				stream nextPutAll: each; newLine ]
	] ensure: [ stream close ].

"Fork all these, so they run in sequence, as the system is back running"
[
	
	"Process taking most CPU"
	stream _ FileStream forceNewFileNamed: 'ThePig.txt'.
	ProcessBrowser dumpPigStackOn: stream andClose: true.
	
	"Tally of all processes"
	stream _ FileStream forceNewFileNamed: 'FullTally.txt'.
	[
		tally _ MessageTally new.
		tally reportOtherProcesses: true.	"actually irrelevant"
		tally spyAllEvery: 1 on: [ (Delay forMilliseconds: 1000) wait ].
		tally report: stream ] ensure: [ stream close ].

	"Memory Analysis"
	stream _ FileStream forceNewFileNamed: 'MemoryAnalysis.txt'.
	[ SpaceTally new printSpaceAnalysis: 1 on: stream ]
		ensure: [ stream close ]

] forkNamed: 'CPU usage analysis'! !
!WorldState methodsFor: 'canvas' stamp: 'jmv 10/21/2012 20:01' prior: 50383040!
                     canvas: aFormCanvas
	canvas _ aFormCanvas.
	aFormCanvas ifNotNil: [
		aFormCanvas into: world ].
	damageRecorder
		ifNil: [ damageRecorder _ DamageRecorder new]
		ifNotNil: [ damageRecorder doFullRepaint]! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 10/21/2012 20:03' prior: 16986734!
                          doDeferredUpdatingFor: aWorld
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."
	| properDisplay |
	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].
	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	self flag: #jmvVer.
	true "aWorld == World" ifTrue: [  "this world fills the entire Display"
		properDisplay ifFalse: [
			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"
			self canvas: (Display getCanvas copyClipRect: Display boundingBox).
		]
	] ifFalse: [  "this world is inside an MVC window"
		self revisar.
		self halt.
	].
	^ true! !

ProjectX class removeSelector: #resumeProcessX:!

ProjectX class removeSelector: #resumeProcessX:!

ProjectX class removeSelector: #spawnNewProcessFor:!

ProjectX class removeSelector: #spawnNewProcessX!

ProjectX class removeSelector: #spawnNewProcessX!

ProjectX class removeSelector: #uiProcessX!

ProjectX class removeSelector: #uiProcessX!

HandMorph removeSelector: #interrupted!

HandMorph removeSelector: #interrupted!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1474-CuisCore-JuanVuletich-2012Oct23-22h48m-jmv.5.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1473] on 23 October 2012 at 11:08:52 pm'!
!Object methodsFor: 'morphic' stamp: 'jmv 10/23/2012 17:41'!
                  runningWorld
	"Answer a morphic world that is the current UI focus.
	This is the UI root animated by the active Process.
	This method could answer nil, if not in an UI process!!"

	^Processor activeProcess animatedUI! !
!Object methodsFor: 'private' stamp: 'jmv 10/23/2012 17:33' prior: 16905404!
                       primitiveError: aString 
	"This method is called when the error handling results in a recursion in 
	calling on error: or halt or halt:."

	| context emergencyEvaluator lines r |
	r _ 10@10 extent: (Display extent -20 min: 700@1000).
	lines _ r height // StrikeFont default height.
	emergencyEvaluator _ Transcripter newInFrame: r.
	emergencyEvaluator
		nextPutAll: '***System error handling failed***'; newLine;
		nextPutAll: aString; newLine;
		nextPutAll: '-------------------------------'; newLine.
	context _ thisContext sender sender.
	(30 min: lines - 10) timesRepeat: [context ifNotNil: [emergencyEvaluator print: (context _ context sender); newLine]].
	emergencyEvaluator
		nextPutAll: '-------------------------------'; newLine;
		nextPutAll: 'Type ''revert'' to revert your last method change.'; newLine;
		nextPutAll: 'Type ''exit'' to exit the emergency evaluator.'; newLine.
	emergencyEvaluator readEvalPrint! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 10/23/2012 17:43' prior: 50397063!
             storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."

	| bufSize stereoBuffer reverseBytes  |
	self reset.
	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"
	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.
	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.

	'Storing audio...' displayProgressAt: Sensor mousePoint
		from: 0 to: samplesToStore during: [:bar | | remaining out |
			remaining _ samplesToStore.
			[remaining > 0] whileTrue: [
				bar value: samplesToStore - remaining.
				stereoBuffer primFill: 0.  "clear the buffer"
				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.
				self isStereo
					ifTrue: [out _ stereoBuffer]
					ifFalse: [out _ stereoBuffer extractLeftChannel].
				reverseBytes ifTrue: [out reverseEndianness].
				(aBinaryStream isKindOf: StandardFileStream)
					ifTrue: [  "optimization for files: write sound buffer directly to file"
						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"
					ifFalse: [  "for non-file streams:"
						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].
				remaining _ remaining - bufSize]].
! !
!Debugger methodsFor: 'initialize' stamp: 'jmv 10/23/2012 18:09' prior: 16833277!
     openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Sensor currentCursor.
	Sensor currentCursor: Cursor normal.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self lowSpaceChoices, (msgString ifNil: ['']) ]
		ifFalse: [ msgString ].

	errorWasInUIProcess _ ProjectX newProcessIfUIX: interruptedProcess.
	WorldState addDeferredUIMessage: [
		PreDebugWindow open: self label: label message: msg ].
	^self! !
!Debugger methodsFor: 'private' stamp: 'jmv 10/23/2012 17:45' prior: 50400290!
         resumeProcess
	savedCursor
		ifNotNil: [Sensor currentCursor: savedCursor].
	interruptedProcess isTerminated ifFalse: [
		interruptedProcess resume ].
	"if old process was terminated, just terminate current one"
	interruptedProcess _ nil.
	contextStackIndex _ 0.
	contextStack _ nil.
	contextStackTop _ nil.
	receiverInspector _ nil.
	contextVariablesInspector _ nil.
	self runningWorld ifNotNil: [ :w | w displayWorld ].
	Smalltalk installLowSpaceWatcher.
	"restart low space handler"
	errorWasInUIProcess == false
		ifFalse: [ Processor terminateActive ]! !
!DisplayScreen methodsFor: 'other' stamp: 'jmv 10/23/2012 17:45' prior: 50397140!
                              newDepth: pixelSize
"
	Display newDepth: 8.
	Display newDepth: 1.
"
	(self supportsDisplayDepth: pixelSize)
		ifFalse:[^self inform:'Display depth ', pixelSize printString, ' is not supported on this system'].
	self newDepthNoRestore: pixelSize.
	self runningWorld ifNotNil: [ :w | w  buildMagnifiedBackgroundImage ].
	self restore.! !
!DisplayScreen methodsFor: 'other' stamp: 'jmv 10/23/2012 17:45' prior: 50397154!
                              restore
	self runningWorld ifNotNil: [ :w | w fullRepaintNeeded ]! !
!DisplayScreen methodsFor: 'other' stamp: 'jmv 10/23/2012 17:45' prior: 50397159!
         restoreAfter: aBlock
	"Evaluate the block, wait for a mouse click, and then restore the screen."

	aBlock value.
	Sensor waitButton.
	self runningWorld ifNotNil: [ :w | w fullRepaintNeeded ]! !
!DisplayScreen class methodsFor: 'display box access' stamp: 'jmv 10/23/2012 17:45' prior: 50397169!
                         checkForNewScreenSize
	"Check whether the screen size has changed and if so take appropriate actions"

	Display extent = DisplayScreen actualScreenSize ifTrue: [^ self].
	DisplayScreen startUp.
	self runningWorld ifNotNil: [ :w | w restoreMorphicDisplay ]! !
!Morph methodsFor: 'initialization' stamp: 'jmv 10/23/2012 17:49' prior: 50397476!
          openInHand
	"Attach the receiver to the current hand in the current morphic world"

	self runningWorld activeHand attachMorph: self! !
!Morph methodsFor: 'initialization' stamp: 'jmv 10/23/2012 17:48' prior: 16898348!
      openInWorld

	self runningWorld ifNotNil: [ :w | self openInWorld: w ]! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 10/23/2012 17:51' prior: 50397483!
     resizeMorph
	| handle |
	handle _ HandleMorph new 
				forEachPointDo: [ :newPoint | self morphExtent: newPoint - self morphPositionInWorld].
	self runningWorld activeHand attachMorph: handle.
	handle startStepping! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 10/23/2012 17:51' prior: 50397493!
             delete
	"Remove the receiver as a submorph of its owner and make its 
	new owner be nil."

	| aWorld |
	aWorld _ self world ifNil: [ self runningWorld ].
	"Terminate genie recognition focus"
	"I encountered a case where the hand was nil, so I put in a little 
	protection - raa "
	" This happens when we are in an MVC project and open
	  a morphic window. - BG "
	aWorld ifNotNil: [
		aWorld activeHand
			releaseKeyboardFocus: self;
			releaseMouseFocus: self].
	owner ifNotNil:[ self privateDelete].! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 10/23/2012 17:44' prior: 50397513!
                             request: queryString
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph request: 'What is your favorite color?'"

	^ self
		request: queryString
		initialAnswer: ''
		centerAt: self runningWorld activeHand morphPosition
		onCancelReturn: ''
		acceptOnCR: true
		answerExtent: self defaultAnswerExtent! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 10/23/2012 17:44' prior: 50397531!
                 request: queryString initialAnswer: defaultAnswer 
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'"

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: self runningWorld activeHand morphPosition
		onCancelReturn: ''
		acceptOnCR: true
		answerExtent: self defaultAnswerExtent! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 10/23/2012 17:45' prior: 50395296!
                           request: queryString initialAnswer: defaultAnswer centerAt: aPoint onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean answerExtent: answerExtent
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."
	"
	FillInTheBlankMorph
		request: 'Type something, then type [Return].'
		initialAnswer: 'yo ho ho!!'
		centerAt: Display center
	"

	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		setQuery: queryString
		initialAnswer: defaultAnswer
		answerExtent: answerExtent
		acceptOnCR: acceptBoolean.
	aFillInTheBlankMorph responseUponCancel: returnOnCancel.
	self runningWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.
	^ aFillInTheBlankMorph getUserResponse
! !
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 10/23/2012 17:47' prior: 50397602!
                              acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| ok prevSelection prevScrollValue |
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar value.
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 
		ifTrue: [^self flash].
	self hasEditingConflicts 
		ifTrue: [
			(self confirm: 
'Caution!! Contents were saved
elsewhere since you started
editing them here.  Accept anyway?' ) 
					ifFalse: [^self flash]].
	ok _ model acceptContentsFrom: owner.
	ok == true
		ifTrue: [ model refetch ].

	"sps 8/13/2001 22:41: restore selection and scroll info"
	self flag: #jmvVer2.	"Check this. Do we need the error handler? Consider explicitly the case where no world?"
	["During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the codeholding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
		ok
			ifTrue: [
				self editor selectFrom: prevSelection first to: prevSelection last.
				WorldState addDeferredUIMessage: [
					self world activeHand newKeyboardFocus: self.
					owner setScrollDeltas.
					owner verticalScrollBar setValue: prevScrollValue ]]
	] on: Error do: nil! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 10/23/2012 17:58' prior: 50397705!
        popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [:m | m isKindOf: UpdatingMenuItemMorph]) 
		do: [:m | m updateContents].
	self runningWorld addMorphFront: self.
	self 
		positionAt: aPoint
		forHand: hand
		relativeTo: (selectedItem ifNil: [self items first]).
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [hand newKeyboardFocus: self].
	evt := hand lastEvent.
	(evt isKeyboard or: [evt isMouse and: [evt anyButtonPressed not]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 10/23/2012 17:58' prior: 16887706!
                         popUpInWorld
	"Present this menu in the current World"

	^ self popUpInWorld: self runningWorld! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 10/23/2012 17:58' prior: 50397859!
       invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w oldFocus actHand |
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneSubCycle.
	self	
		popUpAt: actHand morphPosition
		forHand: actHand 
		allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	[self isInWorld & self isModalInvokationDone not] whileTrue: [w doOneSubCycle].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 10/23/2012 17:53' prior: 50395851!
             displayAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	self runningWorld ifNotNil: [ :w |
		w addMorph: self centeredNear: aPoint.
		self world displayWorld.  "show myself"
		].
	aBlock value.
	self delete! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 10/23/2012 17:56' prior: 50395862!
informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ self world ifNil: [ self runningWorld ].
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph morphWidth: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 10/23/2012 17:57' prior: 50395373!
  invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	|actHand w oldFocus |
	self flag: #bob.		"is <aPoint> global or local?"
	self flag: #arNote.	"<aPoint> is local to aWorld"
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneSubCycle.
	self
		popUpAt: aPoint
		forHand: actHand
		allowKeyboard: aBoolean.
	done _ false.
	[self isInWorld & done not] whileTrue: [w doOneSubCycle].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ mvcSelection ! !
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 10/23/2012 17:51' prior: 50395907!
         monitor: anObjectExplorerWrapper
	"Start stepping and watching the given wrapper for changes."
	anObjectExplorerWrapper ifNil: [ ^self ].
	self monitorList at: anObjectExplorerWrapper put: anObjectExplorerWrapper asString.
	self runningWorld startStepping: self at: Time millisecondClockValue selector: #step arguments: #() stepTime: 200! !
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 10/23/2012 17:51' prior: 50395922!
                   step
	"If there's anything in my monitor list, see if the strings have changed."
	| string changes |
	changes _ false.
	self monitorList keysAndValuesDo: [ :k :v |
		k ifNotNil: [
			k refresh.
			(string _ k asString) ~= v ifTrue: [ self monitorList at: k put: string. changes _ true ].
		]
	].
	changes ifTrue: [ | sel |
		sel _ currentSelection.
		self changed: #getList.
		self noteNewSelection: sel.
	].
	
	self monitorList isEmpty ifTrue: [
		self runningWorld stopStepping: self selector: #step ]! !
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 10/23/2012 17:51' prior: 50395942!
             stopMonitoring
	monitorList _ nil.
	self runningWorld stopStepping: self selector: #step! !
!PasteUpMorph methodsFor: 'caching' stamp: 'jmv 10/23/2012 17:26' prior: 16911549!
                 releaseCachedState
	super releaseCachedState.
	backgroundImage _ nil.
	self isWorldMorph ifTrue: [
		self cleanseStepList.
		worldState canvas: nil ]! !
!PasteUpMorph class methodsFor: 'system startup' stamp: 'jmv 10/23/2012 17:28' prior: 16912581!
       shutDown

	"Should use some other way to find relevant instances"
	self flag: #jmvVer2.
	self allInstancesDo: [ :each |
		each releaseCachedState ]! !
!PasteUpMorph class methodsFor: 'system startup' stamp: 'jmv 10/23/2012 17:30' prior: 16912587!
         startUp

	"Should use some other way to find relevant instances"
	self flag: #jmvVer2.
	self allInstancesDo: [ :each |
		each buildMagnifiedBackgroundImage.
		each isWorldMorph ifTrue: [
			each restoreMorphicDisplay.

			"5.8 series of Mac VM seem to ignore the first call to primitive 127.
			This is a workaround for that."
			"Display forceToScreen: (0@0 extent: 1@1)."
			"Now it seems that VM will not be widely used... If Display artifacts appear with newer Cog Mac VMs,
			reitroduce it, maybe checking VM version"
		]
	]! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 10/23/2012 17:43' prior: 50397913!
            startUpWithoutKeyboard
	"Display and make a selection from the receiver as long as the button  is pressed. Answer the current selection.  Do not allow keyboard input into the menu"
	
	^ self startUpWithCaption: nil at: self runningWorld activeHand morphPosition allowKeyboard: false! !
!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 10/23/2012 18:04' prior: 50397926!
                    defaultAction

	| delta textFrame barFrame outerFrame result range width w1 f h textWidth textForm innerBarFrame |
	f _ StrikeFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.
	
	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
			
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ 0@0 extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + (0@2).
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal 
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [		
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		w1 _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		textForm displayAt: textFrame topLeft.
		Display fillBlack: barFrame.
		Display fillWhite: innerBarFrame.
		Display fillGray: (barFrame topLeft + (2@2) extent: w1@17) ].
	"Not pretty at all!!"
	self runningWorld ifNotNil: [ :w | w fullRepaintNeeded ].
	self resume: result! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 10/23/2012 17:58' prior: 50398002!
                         newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor anyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor anyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent.
	^ rect! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 10/23/2012 17:59' prior: 50398065!
                    reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	ClassicTheme beCurrent.
	PasteUpMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	FormCanvas clearFormsCache.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	CursorWithAlpha class removeSelector: #buildBiggerNormal.
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	"????
	Smalltalk organization removeCategoriesMatching: 'Signal Processing*'.
	SystemOrganization removeSystemCategory: 'LinearAlgebra'.
	Smalltalk organization removeCategoriesMatching: 'Sound-*'
	"

	Beeper setDefault: nil.
	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(ZipConstants GZipConstants ZipFileConstants ChronologyConstants SpaceTally).
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSorter zapAllChangeSets.
	Smalltalk garbageCollect.


	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'jmv 10/23/2012 18:10' prior: 16919317!
     open: model label: aString message: messageString
	|  window extentToUse |
	window _ self new.
	window
		model: model;
		buildMorphicWindowMessage: messageString.
	aString ifNotNil: [ window setLabel: aString ].
	extentToUse _ 560 @ 300.
	"nice and wide to show plenty of the error msg"
	 window openInWorld: self runningWorld extent: extentToUse! !
!Theme class methodsFor: 'class initialization' stamp: 'jmv 10/23/2012 18:03' prior: 50398302!
   currentTheme: aTheme

	CurrentTheme := aTheme new.
	SHTextStylerST80 initialize.
	self runningWorld backgroundImage ifNil: [ self runningWorld color: CurrentTheme background ].
	SystemWindow initialize.
	FormCanvas clearFormsCache.
	Taskbar reset; initialize.
	self runningWorld restoreMorphicDisplay.
	
	^ CurrentTheme! !
!Utilities class methodsFor: 'common requests' stamp: 'jmv 10/23/2012 18:04' prior: 50398315!
                               saveScreenshot
	"Make a screenshot of the world and save it to a file"

	"SampledSound playSoundNamed: 'camera'."
	PNGReadWriter
		putForm: (self runningWorld imageForm: 32)
		onFileNamed:
			(FileDirectory default
				nextNameFor: 'CuisScreen'
				extension: 'png')! !
!Utilities class methodsFor: 'closure support' stamp: 'jmv 10/23/2012 18:03' prior: 50398327!
                    postRecompileCleanup	"Utilities postRecompileCleanup"
	"Cleanup after loading closure bootstrap"
	"Before doing this, please start a new UI process (for example, by hitting alt-period and closing the debugger)."
	| unboundMethods contexts |
	self runningWorld ifNotNil: [ :w | w removeAllKnownFailing ].
	ProcessorScheduler startUp.
	WeakArray restartFinalizationProcess.
	MethodChangeRecord allInstancesDo:[:x| x noteNewMethod: nil].
	Smalltalk cleanOutUndeclared.
	Delay startTimerEventLoop.
	EventSensor install.
	WorldState allInstancesDo:[:ws| ws convertAlarms; convertStepList].
	Workspace allInstancesDo:[:ws| ws initializeBindings].
	Smalltalk garbageCollect.
	Smalltalk
		at: #DebuggerMethodMap
		ifPresent: [ :dmm | dmm voidMapCache ].
	Smalltalk garbageCollect.
	unboundMethods _ CompiledMethod unboundMethods.
	unboundMethods notEmpty ifTrue: [
		unboundMethods inspectWithLabel: 'Unbound Methods'].
	Smalltalk at: #BlockContext ifPresent: [ :bc |
		contexts _ bc allInstances.
		contexts ifNotEmpty: [
			contexts inspect. 
			self inform: 'There are left-over BlockContexts'.
			^self ]].
	unboundMethods isEmpty ifTrue:[
		self inform:'Congratulations - The bootstrap is now complete.'.
	]! !

SystemWindow removeSelector: #openInWorldExtent:!

SystemWindow removeSelector: #openInWorldExtent:!

PasteUpMorph removeSelector: #install!

PasteUpMorph removeSelector: #install!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1475-CuisCore-JuanVuletich-2012Oct23-23h08m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1475] on 23 October 2012 at 11:26:36 pm'!

!classDefinition: #TaskbarTest category: #'Taskbar-Tests'!
TestCase subclass: #TaskbarTest
	instanceVariableNames: 'taskbar needsDelete'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Taskbar-Tests'!

TestCase subclass: #TaskbarTest
	instanceVariableNames: 'taskbar needsDelete '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Taskbar-Tests'!
!ProjectX class methodsFor: 'nil' stamp: 'jmv 10/23/2012 23:18'!
                          ui
	^UIProcess animatedUI! !
!TaskbarTest methodsFor: 'Running' stamp: 'jmv 10/23/2012 23:12'!
 tearDown

	needsDelete ifTrue: [
		taskbar delete ]! !
!ScannerTest methodsFor: 'testing' stamp: 'jmv 10/23/2012 23:20' prior: 16934052!
                       testLiteralSymbols

	self assert: ('*+-/\~=<>&@%,|' allSatisfy: [:char | Scanner isLiteralSymbol: (String with: char) asSymbol])
		description: 'single letter binary symbols can be printed without string quotes'.
		
	self assert: (#('x' 'x:' 'x:y:' 'from:to:by:' 'yourself') allSatisfy: [:str | Scanner isLiteralSymbol: str asSymbol])
		description: 'valid ascii selector symbols can be printed without string quotes'.
		
	((32 to: 94), (96 to: 126) collect: [:ascii | Character value: ascii]) ,
	#(':x:yourself' '::' 'x:yourself' '123' 'x0:x1:x2:' 'x.y.z' '1abc' 'a1b0c2' ' x' 'x ' '+x-y' '||' '-' '++' '+' '+/-' '-/+' '<|>' '#x' '()' '[]' '{}' '')
		do: [:str |
			self assert: (Compiler evaluate: str asSymbol printString) = str asSymbol
				description: 'in all case, a Symbol must be printed in an interpretable fashion']! !
!SystemDictionaryTest methodsFor: 'testing' stamp: 'jmv 10/23/2012 23:25' prior: 50398142!
       testPointersToEachIn
	"
	SystemDictionaryTest new testPointersToEachIn
	"
	| p1 p2 |
	p1 _ (Smalltalk pointersTo: Smalltalk).
	p2 _ (Smalltalk pointersToEachIn: {Smalltalk}) first.
	self assert: p1 = p2! !
!TaskbarTest methodsFor: 'Running' stamp: 'jmv 10/23/2012 23:18' prior: 16967466!
setUp

	Taskbar reset.	
	taskbar _ Taskbar singleton.
	needsDelete _ taskbar owner isNil.
	needsDelete ifTrue: [ taskbar openInWorld: ProjectX ui ].
	taskbar visible: false.
	taskbar step! !

!classDefinition: #TaskbarTest category: #'Taskbar-Tests'!
TestCase subclass: #TaskbarTest
	instanceVariableNames: 'taskbar needsDelete'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Taskbar-Tests'!

TestCase subclass: #TaskbarTest
	instanceVariableNames: 'taskbar needsDelete'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Taskbar-Tests'!

Taskbar removeSelector: #initialize!

Taskbar removeSelector: #initialize!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1476-CuisCore-JuanVuletich-2012Oct23-23h23m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1475] on 23 October 2012 at 11:30:38 pm'!
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 10/23/2012 23:28' prior: 50397180!
           testLayout1
	"
	self new testLayout1
	"
	| pane row1 row2 row3 r1c1 r1c2 r1c3 r1c4 r1c5 r2c1 r2c2 r2c3 r3c1 r3c2 r3c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row1 _ LayoutMorph newRow separation: 5.
	row1 color: Color red;
		addMorph: (r1c1 _ BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 10);
		addMorph: (r1c2 _ BorderedRectMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r1c3 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r1c4 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.15);
		addMorph: (r1c5 _ BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
	pane addMorph: row1 layoutSpec: LayoutSpec useAll.
	row2 _ LayoutMorph newRow separation: 5.
	row2 color: Color red;
		addMorph: (r2c1 _ BorderedRectMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r2c2 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r2c3 _ BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.2).
	pane addMorph: row2 layoutSpec: LayoutSpec useAll.
	row3 _ LayoutMorph newRow separation: 5.
	row3 color: Color red;
		addMorph: (r3c1 _ BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
		addMorph: (r3c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40);
		addMorph: (r3c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row3 layoutSpec: (LayoutSpec fixedHeight: 60).
	pane openInWorld; morphExtent: 408@300.
	ProjectX ui doOneCycleNow.

	self assert: row1 morphWidth = (pane morphWidth - 10).
	self assert: r1c1 morphWidth class == SmallInteger.
	self assert: r1c1 morphHeight class == SmallInteger.
	self assert: r1c1 morphWidth = 10.
	self assert: r1c1 morphHeight = (row1 morphHeight - 10).
	self assert: r1c2 morphWidth = 200.
	self assert: r1c2 morphHeight = (row1 morphHeight - 10).
	self assert: r1c3 morphWidth = (r1c2 morphWidth / 0.8 * 0.4) rounded.
	self assert: r1c3 morphHeight = (row1 morphHeight - 10).
	self assert: r1c4 morphWidth = (r1c2 morphWidth / 0.8 * 0.15) rounded.
	self assert: r1c4 morphHeight = (row1 morphHeight - 10).
	self assert: r1c5 morphWidth = 20.
	self assert: r1c5 morphHeight = 20.

	self assert: row2 morphWidth = (pane morphWidth - 10).
	self assert: r2c1 morphWidth = 216.
	self assert: r2c1 morphHeight = (row2 morphHeight - 10).
	self assert: r2c2 morphWidth = (r2c1 morphWidth / 0.8 * 0.4) rounded.
	self assert: r2c2 morphHeight = (row2 morphHeight - 10).
	self assert: r2c3 morphWidth = (r2c1 morphWidth / 0.8 * 0.2) rounded.
	self assert: r2c3 morphHeight = (row2 morphHeight - 10).

	self assert: row3 morphWidth = (pane morphWidth - 10).
	self assert: row3 morphHeight = 60.
	self assert: r3c1 morphWidth = 20.
	self assert: r3c1 morphHeight = (row3 morphHeight - 10 * 0.8) rounded.
	self assert: r3c2 morphWidth = (row3 morphWidth - 10 - 20 - 10 - 30 * 0.5) rounded.
	self assert: r3c2 morphHeight = 40.
	self assert: r3c3 morphWidth = 30.
	self assert: r3c3 morphHeight = (row3 morphHeight - 10).

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 10/23/2012 23:28' prior: 50397296!
                            testLayout2
	"
	self new testLayout2
	"
	| pane row c1 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (c1 _ BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane openInWorld; morphExtent: 400@300.
	ProjectX ui doOneCycleNow.

	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = (pane morphHeight - 10 * 0.9) rounded.
	self assert: c1 morphBoundsInWorld bottom = (row morphBoundsInWorld bottom - 5) description: 'Should be at bottom'.
	self assert: c1 morphWidth = 20.
	self assert: c1 morphHeight = (row morphHeight - 10 * 0.8) rounded.
	self assert: c2 morphBoundsInWorld top = (row morphBoundsInWorld top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = 256.
	self assert: c2 morphHeight = 40.
	self assert: ((c3 morphBoundsInWorld top - row morphBoundsInWorld top) - (row morphBoundsInWorld bottom - c3 morphBoundsInWorld bottom)) abs < 2 description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (c1 morphHeight / 0.8 * 0.7) rounded.

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 10/23/2012 23:28' prior: 50397353!
  testLayout3
	"
	self new testLayout3
	"
	| pane row innerRow i1 i2 i3 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	innerRow _ LayoutMorph newRow color: Color red;  separation: 5.
	innerRow
		addMorph: (i1 _ RectangleLikeMorph new)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i2 _ RectangleLikeMorph new)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i3 _ RectangleLikeMorph new)
			layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 minorDirectionPadding: #center);
		addMorph: (c2 _ BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 200).
	pane openInWorld; morphExtent: 400@300.
	ProjectX ui doOneCycleNow.

	self assert: row morphBoundsInWorld left = (pane morphBoundsInWorld left + 5).
	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = 200.
	self assert: innerRow morphBoundsInWorld left = (row morphBoundsInWorld left + 5).
	self assert: (innerRow morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - innerRow morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: innerRow morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: innerRow morphHeight = 30.

	self assert: i1 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 5).
	self assert: (i1 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i1 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i1 morphWidth = 10.
	self assert: i1 morphHeight = 10.
	self assert: i2 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 20).
	self assert: (i2 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i2 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i2 morphWidth = 10.
	self assert: i2 morphHeight = 10.
	self assert: i3 morphBoundsInWorld left = (innerRow morphBoundsInWorld left + 35).
	self assert: (i3 morphBoundsInWorld top - innerRow morphBoundsInWorld top) = (innerRow morphBoundsInWorld bottom - i3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: i3 morphWidth = (innerRow morphWidth - 40).
	self assert: i3 morphHeight = 10.

	self assert: c2 morphBoundsInWorld top = (row morphBoundsInWorld top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: c2 morphHeight = 40.
	self assert: (c3 morphBoundsInWorld top - row morphBoundsInWorld top) = (row morphBoundsInWorld bottom - c3 morphBoundsInWorld bottom) description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (row morphHeight - 10).

	pane delete! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 10/23/2012 23:28' prior: 50398173!
                 testClassShow
	taskbar class show.
	self should: [ taskbar isInWorld ].
	ProjectX ui removeMorph: taskbar! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 10/23/2012 23:28' prior: 50398180!
                              testVerticalAlignment
	
	self should: [ taskbar morphBoundsInWorld bottom = ProjectX ui morphBoundsInWorld bottom ]! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 10/23/2012 23:28' prior: 50398187!
                    testWidth
	
	self should: [ taskbar morphWidth = ProjectX ui morphWidth ]! !
!TextEditorTest methodsFor: 'as yet unclassified' stamp: 'jmv 10/23/2012 23:29' prior: 50398193!
                  testSimpleEditor
	"
	TextEditorTest new testSimpleEditor
	"
	| m |
	self shouldnt: [
		m _ OneLineEditorMorph new.
		m editor offerMenuFromEsc:
			(KeyboardEvent new
				setType: #keystroke
				buttons: 0
				position: 0@0
				keyValue: 65
				hand: ProjectX ui activeHand
				stamp: 0)
	] raise: Exception! !
!WorldTest methodsFor: 'as yet unclassified' stamp: 'jmv 10/23/2012 23:30' prior: 50398409!
              testDoOneCycleWorksWithDeferredQueue
        "Ensure that nested doOneCycles don't break deferred UI messages"
        | finished |
        [
                WorldState addDeferredUIMessage: [ ProjectX ui doOneCycleNow ].
                WorldState addDeferredUIMessage: nil "whatever".
                ProjectX ui doOneCycleNow.
                finished _ true.
        ] valueWithin: 1 seconds onTimeout: [finished _ false ].
        self assert: finished! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1477-CuisCore-JuanVuletich-2012Oct23-23h26m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1474] on 23 October 2012 at 8:41:08 pm'!

Object removeSelector: #currentWorld!

Object removeSelector: #currentWorld!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Smalltalk removeKey: #World!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1478-CuisCore-JuanVuletich-2012Oct23-20h38m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1478] on 25 October 2012 at 5:54:57 pm'!
!DropEvent methodsFor: 'accessing' stamp: 'jmv 10/25/2012 17:54' prior: 16841171!
               wasHandled: aBool

	"This is ugly, and means that events are copied in many places..."
	self flag: #jmvVer.

	wasHandled _ aBool! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 10/25/2012 17:42' prior: 50348212!
      justDroppedInto: newOwnerMorph event: anEvent 
	"This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"

	newOwnerMorph activateWindow.
	self isInWorld  ifTrue: [
		self world startSteppingSubmorphsOf: self ].
	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 10/25/2012 17:43' prior: 50356434!
addHalo: evt
	| halo |
	halo _ HaloMorph new.
	halo popUpFor: self event: evt.
	halo morphBoundsInWorld: self worldBoundsForHalo.
	^halo! !
!MenuMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 10/25/2012 17:42' prior: 16887741!
                          justDroppedInto: newOwnerMorph event: evt
	| halo |
	super justDroppedInto: newOwnerMorph event: evt.
	halo _ evt hand halo.
	(halo notNil and:[halo target hasOwner: self]) ifTrue: [
		"Grabbed single menu item"
		self addHalo: evt ].
	stayUp ifFalse: [ evt hand newMouseFocus: self ]! !
!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 10/25/2012 17:44' prior: 50392760!
   acceptDroppingMorph: dropped event: evt 
	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"

	| aMorph |
	aMorph _ self morphToDropFrom: dropped.
	self isWorldMorph 
		ifTrue: [	
			"Add the given morph to this world and start stepping it if it wants to be."
			self addMorphFront: aMorph.
			(aMorph morphFullBoundsInWorld intersects: self viewBox) 
				ifFalse: [
					Beeper beep.
					aMorph morphPosition: extent // 2]]
		ifFalse: [super acceptDroppingMorph: aMorph event: evt].
	aMorph submorphsDo: [ :m | (m is: #HaloMorph) ifTrue: [ m delete ]].
	self world startSteppingSubmorphsOf: aMorph! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 10/25/2012 17:42' prior: 50392926!
        justDroppedInto: newOwnerMorph event: anEvent
	isCollapsed
		ifTrue: [
			self morphPosition: (self morphPosition max: 0@0) ]
		ifFalse: [
			TopWindow ~~ self ifTrue: [ self activate ]].
	^super justDroppedInto: newOwnerMorph event: anEvent! !
!UserInputEvent methodsFor: 'accessing' stamp: 'jmv 10/25/2012 17:54' prior: 16980688!
                    wasHandled: aBool

	"This is ugly, and means that events are copied in many places..."
	self flag: #jmvVer.

	wasHandled _ aBool! !

Morph removeSelector: #haloClass!

Morph removeSelector: #haloClass!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1479-CuisCore-JuanVuletich-2012Oct25-17h40m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1479] on 25 October 2012 at 11:29:43 pm'!
!HaloMorph methodsFor: 'private' stamp: 'jmv 10/25/2012 23:09'!
             addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition nameBackground |
	nameBackground _ RectangleLikeMorph new
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ (self morphWidth - nameMorph morphWidth // 2) @ (self morphHeight + (self handleSize * 2)).
	nameMorph morphPosition: namePosition.
	nameBackground morphPosition: nameMorph morphPosition - 2.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 10/25/2012 23:09' prior: 50391036!
addHandles
	| box |
	self removeAllMorphs.  "remove old handles, if any"
	self morphBoundsInWorld: target worldBoundsForHalo.  "update my size"
	box _ self basicBox.

	target addHandlesTo: self box: box.

	self addNameString: (target printStringLimitedTo: 40).
	growingOrRotating _ false.
	self redrawNeeded! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 10/25/2012 23:20' prior: 50392080!
               attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m morphExtent // 2.
	m morphPosition: delta negated! !

HaloMorph removeSelector: #addNameBeneath:string:!

HaloMorph removeSelector: #addNameBeneath:string:!

HaloMorph removeSelector: #mouseMove:localPosition:!

HaloMorph removeSelector: #mouseMove:localPosition:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1480-CuisCore-JuanVuletich-2012Oct25-23h27m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1480] on 28 October 2012 at 11:49:58 pm'!
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 10/28/2012 23:48'!
           externalizeDelta: aPoint
	"Externalize a distance vector. A distance is not a position. It is a magnitude with a direction.
	It is usually used as a delta to be added to a position to obtain some other position."

	| x y |
	x _ (aPoint x * self a11) + (aPoint y * self a12).
	y _ (aPoint x * self a21) + (aPoint y * self a22).
	^x @ y! !
!MatrixTransform2x3 methodsFor: 'converting coordinates' stamp: 'jmv 10/28/2012 23:49'!
                      internalizeDelta: aPoint
	"Internalize a distance vector. A distance is not a position. It is a magnitude with a direction.
	It is usually used as a delta to be added to a position to obtain some other position."

	| x y det a11 a12 a21 a22 detX detY |
	x _ aPoint x asFloat.
	y _ aPoint y asFloat.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^0@0 ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !
!Morph methodsFor: 'geometry' stamp: 'jmv 10/28/2012 23:49'!
                              externalizeDistance: aPoint
	"aPoint is in own coordinates. Answer is in owner's coordinates."
	^ location externalizeDelta: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 10/28/2012 23:49'!
                            internalizeDistance: aPoint
	"aPoint is in owner's coordinates. Answer is in own coordinates."
	^ location internalizeDelta: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 10/28/2012 23:37' prior: 50352986!
            externalizeDistanceToWorld: aPoint
	"aPoint is a distance in own coordinates. Answer is in world coordinates.
	BUT there is no well defined World!!"
	"Add scale factor!!"
	self flag: #jmvVer2.
	^aPoint! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 10/28/2012 23:27' prior: 50375617!
                        openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self morphExtent: w@h.
	self morphPosition: aWorld morphExtent - extent // 2.
	labelMorph fitContents.
	subLabelMorph fitContents.
	layoutNeeded _ true.
	aWorld startSteppingSubmorphsOf: self.! !
!Taskbar methodsFor: 'stepping' stamp: 'jmv 10/28/2012 23:49' prior: 50398163!
                  step

	"My dimensions are constrained live."
	self morphExtent: (self internalize: self world morphExtent) x @ 18.
	self morphPosition: 0@ (self world morphExtent y - (self externalizeDistance: extent ) y)! !

Morph removeSelector: #externalizeDist:!

Morph removeSelector: #internalizeDist:!

MatrixTransform2x3 removeSelector: #externalizeDistance:!

MatrixTransform2x3 removeSelector: #externalizeDistance:!

MatrixTransform2x3 removeSelector: #internalizeDistance:!

MatrixTransform2x3 removeSelector: #internalizeDistance:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1481-CuisCore-JuanVuletich-2012Oct28-23h19m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1481] on 9 November 2012 at 6:02:13 pm'!
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 11/9/2012 17:45'!
  drawString: aString from: firstIndex to: lastIndex in: aRectangle font: fontOrNil color: c kern: kernOrNil
	| font portRect bounds kern |
	bounds _ currentTransformation displayBoundsOfTransformOf: aRectangle.
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left
		y1: bounds top
		x2: bounds right
		y2: bounds bottom.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [port clipRect: portRect. ^self].
	port clipWidth = 0 ifTrue: [port clipRect: portRect. ^self].
	font _ fontOrNil ifNil: [ StrikeFont default ].
	kern _ kernOrNil ifNil: [ font baseKern negated ].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: bounds topLeft
		strikeFont: font
		kern: kern.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 11/9/2012 17:44' prior: 50385497!
drawString: s at: pt font: aFont color: aColor

	^ self drawString: s from: 1 to: s size at: pt font: aFont color: aColor kern: nil! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 11/9/2012 17:43' prior: 50387363!
    drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c kern: kernOrNil

	| p1 font kern |
	p1 _ currentTransformation transform: aPoint.
	port colorMap: nil.
	font _ fontOrNil ifNil: [ StrikeFont default ].
	kern _ kernOrNil ifNil: [ font baseKern negated ].
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: p1
		strikeFont: font
		kern: kern! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 11/9/2012 17:46' prior: 50385571!
                 drawString: s in: boundsRect font: fontOrNil color: c
	^self drawString: s from: 1 to: s size in: boundsRect font: fontOrNil color: c kern: nil! !

FormCanvas removeSelector: #drawString:from:to:at:font:color:!

FormCanvas removeSelector: #drawString:from:to:at:font:color:!

FormCanvas removeSelector: #drawString:from:to:in:font:color:!

FormCanvas removeSelector: #drawString:from:to:in:font:color:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1482-CuisCore-JuanVuletich-2012Nov09-17h17m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1482] on 14 November 2012 at 11:32:57 am'!
!MessageTally commentStamp: '<historical>' prior: 16891526!
       My instances observe and report the amount of time spent in methods.

NOTE: a higher-level user interface (combining the MessageTally result tree with a method browser) is available from TimeProfileBrowser.

MessageTally provides two different strategies available for profiling:

* spyOn: and friends use a high-priority Process to interrupt the block or process being spied on at periodic intervals. The interrupted call stack is then examined for caller information.

* tallySends: and friends use the interpreter simulator to run the block, recording every method call.

The two give you different results:

* spyOn: gives you a view of where the time is being spent in your program, at least on a rough statistical level (assuming you've run the block for long enough and have a high enough poll rate). If you're trying to optimize your code, start here and optimize the methods where most of the time is being spent first.

* tallySends: gives you accurate counts of how many times methods get called, and by exactly which route. If you're debugging, or trying to figure out if a given method is getting called too many times, this is your tool.

You can change the printing format (that is, the whitespace and string compression) by using these instance methods: 
	maxClassNameSize:
	maxClassPlusSelectorSize:
	maxTabs:

You can change the default polling period (initially set to 1) by calling
	MessageTally defaultPollPeriod: numberOfMilliseconds

Q: How do you interpret MessageTally>>tallySends:
A: The methods #tallySends: and #spyOn: measure two very different quantities, but broken down in the same who-called-who format.  #spyOn: is approximate, but more indicative of real time spent, whereas #tallySends: is exact and a precise record of how many times each method got executed.!
!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 11/12/2012 12:01' prior: 50399241!
                            spyEvery: millisecs on: aBlock
	"Create a spy and spy on the given block at the specified rate."
	"Spy only on the active process (in which aBlock is run)"

	| myDelay time0 observedProcess |
	aBlock isBlock
		ifFalse: [ self error: 'spy needs a block here' ].
	self class: aBlock receiver class method: aBlock method.
		"set up the probe"
	observedProcess _ Processor activeProcess.
	myDelay := Delay forMilliseconds: millisecs.
	time0 := Time millisecondClockValue.
	gcStats _ Smalltalk getVMParameters.
	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].
	Timer _ [
		[ true ] whileTrue: [
			| startTime |
			startTime := Time millisecondClockValue.
			myDelay wait.

			self
				tally: Processor preemptedProcess suspendedContext
				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess])
				"tally can be > 1 if ran a long primitive"
				by: (Time millisecondClockValue - startTime) // millisecs].
		nil] newProcess.
	Timer priority: Processor timingPriority-1.
	Timer name: 'MessageTally'.
		"activate the probe and evaluate the block"
	Timer resume.
	^ aBlock ensure: [
		"cancel the probe and return the value"
		"Could have already been terminated. See #terminateTimerProcess"
		Timer ifNotNil: [
			Timer terminate.
			Timer _ nil ].
		"Collect gc statistics"
		Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal |
			gcVal ifNotNil: [
				gcStats at: idx put: (gcVal - (gcStats at: idx))]].
		time := Time millisecondClockValue - time0]! !
!MessageTally methodsFor: 'printing' stamp: 'jmv 11/11/2012 22:38' prior: 16891894!
              printOn: aStream total: total totalTime: totalTime tallyExact: isExact 

	isExact 
		ifTrue: [
			| myTally |
			myTally := tally.
			receivers
				ifNotNil: [receivers do: [:r | myTally := myTally - r tally]].
			aStream
				print: myTally;
				space]
		ifFalse: [
			| percentage |
			percentage := tally asFloat / total * 100.0.
			aStream
				nextPutAll: (percentage printShowingDecimalPlaces: 1);
				nextPutAll: '% (';
				nextPutAll: (percentage * totalTime / 100) rounded asStringWithCommas;
				nextPutAll: 'ms) '].
	receivers
		ifNil: [
			aStream
				nextPutAll: 'primitives';
				newLine]
		ifNotNil: [
			| className aSelector aClass |
			aSelector := class selectorAtMethod: method setClass: [ :c | aClass := c].
			className := aClass name contractTo: self maxClassNameSize.
			aStream
				nextPutAll: class name;
				nextPutAll: (aClass = class 
							ifTrue: ['>>']
							ifFalse: ['(' , aClass name , ')>>']);
				nextPutAll: (aSelector 
							contractTo: self maxClassPlusSelectorSize - className size);
				newLine]! !
!MessageTally methodsFor: 'printing' stamp: 'jmv 11/12/2012 12:47' prior: 16891946!
                          rootPrintOn: aStream total: total totalTime: totalTime threshold: threshold

	| groups |
	groups _ (self sonsOver: threshold) groupBy: [ :aTally | aTally process] having: [ :g | true ].
	groups do: [ :g |
		| sons p |
		sons _ g asArray sort.
		p _ g anyOne process.
		(reportOtherProcesses or: [ p notNil ]) ifTrue: [
			aStream nextPutAll: '--------------------------------'; newLine.
			aStream nextPutAll: 'Process: ',  (p ifNil: [ 'other processes'] ifNotNil: [ p browserPrintString]); newLine.
			aStream nextPutAll: '--------------------------------'; newLine.
			sons do: [ :son |
				son
					treePrintOn: aStream
					tabs: OrderedCollection new
					thisTab: ''
					total: total
					totalTime: totalTime
					tallyExact: false
					orThreshold: threshold].
			aStream newLine].
	]! !
!MessageTally methodsFor: 'tallying' stamp: 'jmv 11/12/2012 13:43' prior: 16892146!
               tally: context in: aProcess by: count
	"Explicitly tally the specified context and its stack."
	| sender |

	"Add to this node if appropriate"
	context method == method ifTrue: [^self bumpBy: count].
	
	"No sender? Add new branch to the tree."
	sender _ context home sender.
	sender ifNil: [
		^ (self bumpBy: count) tallyPath: context in: aProcess by: count].
	
	"Find the node for the sending context (or add it if necessary)"
	^ (self tally: sender in: aProcess by: count) tallyPath: context in: aProcess by: count! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/12/2012 15:20' prior: 50333248!
                               spyAllOn: aBlock
	"Spy on all the processes in the system
	
	[1000 timesRepeat: [3.14159 printString. Processor yield]] forkNamed: 'p1'.
	[1000 timesRepeat: [30 factorial. Processor yield]] forkNamed: 'p2'.
	[1000 timesRepeat: [30 factorial. Processor yield]] forkNamed: 'p3'.
	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]
	
	"
	| node result |
	node _ self new.
	node reportOtherProcesses: true.	"Irrelevant in this case. All processes will be reported on their own."
	result _ node spyAllEvery: self defaultPollPeriod on: aBlock.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false.
	^ result! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/12/2012 11:23' prior: 16892261!
                   spyOn: aBlock
	"
	Spy on aBlock, in the current process. Do not include statistics on other processes in the report.
	[1000 timesRepeat: [
		100 timesRepeat: [120 factorial].
		(Delay forMilliseconds: 10) wait
		]] forkAt: 45 named: '45'.
	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]]
	"
	^self spyOn: aBlock reportOtherProcesses: false! !
!Process methodsFor: 'printing' stamp: 'jmv 11/12/2012 12:40' prior: 50399346!
              browserPrintStringWith: anObject

	^String streamContents: [ :stream |
		stream nextPut: $(.
		priority printOn: stream.
		self isSuspended
			ifTrue: [ stream nextPut: $s ].
		stream nextPutAll: ') '.
		self hash printOn: stream.
		stream space.
		stream nextPut: $'.
		stream nextPutAll: self name.
		stream nextPut: $'.
		anObject ifNotNil: [
			stream
				nextPutAll: ': ';
				nextPutAll: anObject asString ]]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1483-CuisCore-JuanVuletich-2012Nov14-11h32m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1483] on 14 November 2012 at 11:18:44 pm'!
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 11/14/2012 23:17' prior: 50391480!
                  buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	 (self buildArrowOfDirection: #up size: 120) display
	"

	| resizeFactor resizedForm f e c bottomMargin topMargin |
	resizeFactor _ 4.
	e _ finalSizeInteger@finalSizeInteger*resizeFactor.
	f _ Form extent: e depth: 32.
	c _ Color gray: 0.5.
	topMargin _ finalSizeInteger * 3//4.
	bottomMargin _ finalSizeInteger * 4//4.
	0 to: e y-1-bottomMargin do: [ :y |
		0 to: e x -1 do: [ :x |
			(e x / 2 - 1 - x) abs * 2 + topMargin < y ifTrue: [
				f colorAt: x@y put: c
			]
		]
	].
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !

FormCanvas class removeSelector: #buildArrowIn:!

FormCanvas class removeSelector: #buildArrowIn:!

FormCanvas class removeSelector: #verticesForSimpleArrow:!

FormCanvas class removeSelector: #verticesForSimpleArrow:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1484-CuisCore-JuanVuletich-2012Nov14-19h48m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1484] on 14 November 2012 at 11:50:38 pm'!

!classDefinition: #DarkGrayTheme category: #'Theme-Themes'!
Theme subclass: #DarkGrayTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Theme-Themes'!

Theme subclass: #DarkGrayTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Theme-Themes'!
!DarkGrayTheme commentStamp: 'cbr 10/15/2012 18:19' prior: 0!
       A low contrast, darker gray theme with square corners and some alpha. The Shout configuration should be a good starting place for doing darker, lower contrast themes.!
!Theme methodsFor: 'colors' stamp: 'cbr 10/10/2012 20:15'!
                             missingCommentTextColor

	^ TextColor red! !
!Theme methodsFor: 'widget colors' stamp: 'cbr 10/10/2012 23:36'!
                 textPane
	^Color white! !
!DarkGrayTheme methodsFor: 'colors' stamp: 'cbr 10/10/2012 20:32'!
   background
	^Color black! !
!DarkGrayTheme methodsFor: 'colors' stamp: 'cbr 10/10/2012 20:18'!
 missingCommentTextColor

	^ TextColor cyan! !
!DarkGrayTheme methodsFor: 'colors' stamp: 'cbr 10/15/2012 18:10'!
               paneBackgroundFrom: aColor
	^ (aColor alphaMixed: 0.3 with: Color black) alpha: 0.9! !
!DarkGrayTheme methodsFor: 'colors' stamp: 'jmv 11/14/2012 23:32'!
      shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #white.
		#undefined 				-> #cyan.
		#methodTags 			-> #magenta.
		#pseudoVariables 		-> #(cyan darker).
		#messages 				-> #(yellow darker).
		#arguments 				-> #(cyan muchDarker).
		#instVar 					-> #green.
		#incompleteMessages -> #(gray muchLighter).
		#blockLevelFour 		-> #magenta.
		#blockLevelFive 		-> #(blue darker).
		#blockLevelSix 			-> #green.
		#blockLevelSeven 		-> #yellow.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchLighter).
	}! !
!DarkGrayTheme methodsFor: 'colors' stamp: 'cbr 10/10/2012 22:09'!
      text
	^ Color white! !
!DarkGrayTheme methodsFor: 'colors' stamp: 'cbr 10/15/2012 18:10'!
      textPane
	^ Color gray! !
!DarkGrayTheme methodsFor: 'colors' stamp: 'cbr 10/10/2012 19:08'!
   windowLabel
	^ Color black! !
!DarkGrayTheme methodsFor: 'other options' stamp: 'cbr 10/10/2012 19:04'!
                        embossedTitles
	^false! !
!DarkGrayTheme methodsFor: 'other options' stamp: 'cbr 10/15/2012 18:14'!
                            roundButtons
	^true! !
!DarkGrayTheme methodsFor: 'as yet unclassified' stamp: 'cbr 10/10/2012 18:35'!
                         roundWindowCorners
	^false! !
!DarkGrayTheme methodsFor: 'as yet unclassified' stamp: 'cbr 10/10/2012 18:32'!
                  useUniformColors
	^ true! !
!Browser methodsFor: 'class functions' stamp: 'cbr 10/10/2012 20:17' prior: 16793893!
              classCommentText
	"return the text to display for the comment of the currently selected class"
	| theClass |
	theClass _ self selectedClassOrMetaClass.
	theClass ifNil: [ ^Text 
				initialFont: Preferences standardCodeFont 
				stringOrText: ''].

	^ theClass hasComment
		ifTrue: [ 
			Text 
				initialFont: Preferences standardCodeFont 
				stringOrText: theClass comment ]
		ifFalse: [
			Text 
				initialFont: Preferences standardCodeFont
				string: 'THIS CLASS HAS NO COMMENT!!' 
				attribute: Theme current missingCommentTextColor ]! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2012 23:47' prior: 50391774!
                            createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"

	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval
				allowStyler: true.
	result morphExtent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result morphPosition: 14@25.
	result morphExtent: extent-(28@62).
	^ result! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2012 23:47' prior: 50386152!
               drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				roundRect: (0@0 extent: extent)
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		fillRectangle: (14@25 extent: extent-(28@62))
		color: (Theme current paneBackgroundFrom: Theme current textPane)! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 11/14/2012 23:30' prior: 16931396!
     privateStyle
	| ranges |
	ranges _ self rangesIn: formattedText setWorkspace: true.
	ranges ifNotNil: [ self setAttributesIn: formattedText fromRanges: ranges in: nil ]! !
!TextModelMorph methodsFor: 'drawing' stamp: 'cbr 10/10/2012 23:04' prior: 50386911!
                               drawOn: aCanvas 
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"


	| bw bc |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"


	super drawOn: aCanvas.
	bw _ Preferences focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan]
			ifFalse: [
				self textMorph hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ] 
					ifFalse: [
						self textMorph hasUnacceptedEdits
							ifTrue: [
								bc _ Color red]]]].

	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [
		bc ifNil: [
			bc _ Theme current focusIndicator ]]
	ifFalse: [
		bc ifNotNil: [
			bc _ bc alphaMixed: 0.4 with: Color white ]].
	bc ifNotNil: [
		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1485-CuisCore-CaseyRansberger-2012Nov14-23h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1485] on 16 November 2012 at 4:08:21 pm'!
!Matrix methodsFor: 'accessing' stamp: 'jmv 11/16/2012 15:30'!
               x: x y: y
	"Answer element at column x, row y"
	^ self i: y j: x! !
!Matrix methodsFor: 'accessing' stamp: 'jmv 11/16/2012 15:31'!
                             x: x y: y put: aNumber
	"Answer element at column x, row y"
	^ self i: y j: x put: aNumber! !
!FFT2D methodsFor: 'computing' stamp: 'jmv 11/16/2012 15:33' prior: 16847711!
                    transformColumns: forward
	| transform height realColumn imagColumn |
	height _ realMatrix height.
	transform _ FFT new: height.
	realColumn _ FloatArray new: height.
	imagColumn _ FloatArray new: height.
	1 to: realMatrix width do: [ :x |
		1 to: height do: [ :y |
			realColumn at: y put: (realMatrix x: x y: y)].
		imagMatrix ifNotNil: [
			1 to: height do: [ :y |
				imagColumn at: y put: (imagMatrix x: x y: y)]].
		transform realData: realColumn imagData: imagColumn.
		transform transformForward: forward.
		1 to: height do: [ :y |
			realMatrix x: x y: y put: (realColumn at: y)].
		imagMatrix ifNotNil: [
			1 to: height do: [ :y |
				imagMatrix x: x y: y put: (imagColumn at: y)]]]! !
!FFT2D methodsFor: 'computing' stamp: 'jmv 11/16/2012 15:35' prior: 16847740!
                         transformRows: forward
	| transform width realRow imagRow |
	width _ realMatrix width.
	transform _ FFT new: width.
	realRow _ FloatArray new: width.
	imagRow _ FloatArray new: width.
	1 to: realMatrix height do: [ :y |
		1 to: width do: [ :x |
			realRow at: x put: (realMatrix x: x y: y)].
		imagMatrix ifNotNil: [
			1 to: width do: [ :x |
				imagRow at: x put: (imagMatrix x: x y: y)]].
		transform realData: realRow imagData: imagRow.
		transform transformForward: forward.
		1 to: width do: [ :x |
			realMatrix x: x y: y put: (realRow at: x)].
		imagMatrix ifNotNil: [
			1 to: width do: [ :x |
				imagMatrix x: x y: y put: (imagRow at: x)]]]! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 11/16/2012 12:14' prior: 50341448!
 * aMatrixOrNumber
	"Standard matrix multiplication"
	| result |
	(aMatrixOrNumber is: #Matrix) ifTrue: [
		width = aMatrixOrNumber height ifFalse: [ ^self error: 'Matrix sizes do not match' ].
		result _ self appropriateResultClass newHeight: height width: aMatrixOrNumber width.
		result fillWith: self multipliedBy: aMatrixOrNumber ]
	ifFalse: [
		result _ self copy.
		result replaceValues: [ :i :j :value | value * aMatrixOrNumber ] ].
	^result
	! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 11/16/2012 12:14' prior: 50341465!
          + aMatrixOrNumber
	"Add element by element"
	| result |
	(aMatrixOrNumber is: #Matrix) ifTrue: [
		(width = aMatrixOrNumber width) & (height = aMatrixOrNumber height)
			ifFalse: [ ^self error: 'Matrix sizes do not match' ].
		result _ self appropriateResultClass newHeight: height width: width.
		result fillWith: self plus: aMatrixOrNumber ]
	ifFalse: [
		result _ self copy.
		result replaceValues: [ :i :j :value | value + aMatrixOrNumber ] ].
	^result
	! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 11/16/2012 12:15' prior: 50341482!
  - aMatrixOrNumber
	"Substract element by element"
	| result |
	(aMatrixOrNumber is: #Matrix) ifTrue: [
		(width = aMatrixOrNumber width) & (height = aMatrixOrNumber height)
			ifFalse: [ ^self error: 'Matrix sizes do not match' ].
		result _ self appropriateResultClass newHeight: height width: width.
		result fillWith: self minus: aMatrixOrNumber ]
	ifFalse: [
		result _ self copy.
		result replaceValues: [ :i :j :value | value - aMatrixOrNumber ] ].
	^result
	! !
!Matrix methodsFor: 'aritmethic' stamp: 'jmv 11/16/2012 12:15' prior: 50341499!
                           / aNumber
	"Divide by a scalar"
	| reciprocal result |
	reciprocal _ 1 / aNumber.
	result _ self copy.
	result replaceValues: [ :i :j :value | value * reciprocal ].
	^result
	! !
!Matrix methodsFor: 'misc' stamp: 'jmv 11/16/2012 12:14' prior: 16886285!
   replaceValues: aBlock
	"Replace each value with the result of evaluating aBlock, with i, j and the previous value as the arguments"

	1 to: height do: [ :i |
		1 to: width do: [ :j |
			self i: i j: j put:
				(aBlock value: i value: j value: (self i: i j: j)) ] ]! !
!FloatMatrix methodsFor: 'misc' stamp: 'jmv 11/16/2012 12:14' prior: 16855877!
     addNormalNoise: standardDeviation seed: randomSeed
	| random |
	random _ NormalRandom new seed: randomSeed.
	self replaceValues: [ :i :j :v | random next * standardDeviation + v ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1486-CuisCore-JuanVuletich-2012Nov16-16h07m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1486] on 24 November 2012 at 10:17:14 am'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts'!
RectangleLikeMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction separation padding'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

RectangleLikeMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction separation padding '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LayoutMorph removeSelector: #defaultBorderWidth!

LayoutMorph removeSelector: #defaultBorderWidth!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts'!
RectangleLikeMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction separation padding'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

RectangleLikeMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction separation padding'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1487-CuisCore-JuanVuletich-2012Nov24-10h16m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1486] on 24 November 2012 at 10:19 am'!
!SmalltalkEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/24/2012 10:18' prior: 16942486!
                               selection
	"Answer the text that is currently selected.
	Redefined for Smalltalk code: if there's no regular selection, and all the selectionBlocks contain the same string,
	answer that string."
	| t regularSelection allPartsEqual samePart |
	t _ model actualContents.
	regularSelection _ ( t copyFrom: self startIndex to: self stopIndex - 1 ).
	allPartsEqual _ true.
	samePart _ nil.
	^Text streamContents: [ :strm |
		"Multiple selection"
		selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock | | toAppend |
			toAppend _ t copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1.
			toAppend size > 0 ifTrue: [
				samePart
					ifNil: [ samePart _ toAppend ]
					ifNotNil: [
						allPartsEqual _ allPartsEqual and: [ samePart = toAppend ]].
				strm nextPutAll: toAppend.
				strm withAttributes: (toAppend attributesAt: toAppend size) do: [ strm newLine ]].
			].
		(allPartsEqual and: [ regularSelection isEmpty ]) ifTrue: [
			^samePart ifNil: [ '' asText ]].
		"Regular selection"
		strm nextPutAll: regularSelection ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1488-CuisCore-JuanVuletich-2012Nov24-10h17m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1486] on 25 November 2012 at 12:09:06 am'!
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 11/25/2012 00:08' prior: 50390620!
                    dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| globalPt aMorphHandlesIt handledByInner lastHandler answer eventPositionInChild |

	"Only for MouseDown"
	self isMouseDown
		ifFalse: [ ^super dispatchWith: aMorph localPosition: positionInAMorph ].

	"Try to get out quickly"
	globalPt _ self eventPosition.
	(aMorph morphFullBoundsInWorld containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ eventHandler.
	aMorphHandlesIt _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isWorldMorph or: [
					self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self)
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ aMorph containsPoint: positionInAMorph event: self ])
		ifTrue:[
			"aMorph is in the top-most unlocked, visible morph in the chain."
			aMorphHandlesIt ifTrue: [ self sentTo: aMorph localPosition: positionInAMorph ].
			answer _ self ]
		ifFalse: [
			"Mouse was not on aMorph nor any of its children"
			answer _ #rejected ].

	eventHandler _ lastHandler.
	^answer! !

PasteUpMorph removeSelector: #isPlayfieldLike!

PasteUpMorph removeSelector: #isPlayfieldLike!

Morph removeSelector: #isPlayfieldLike!

Morph removeSelector: #isPlayfieldLike!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1489-CuisCore-JuanVuletich-2012Nov24-10h19m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1494] on 27 November 2012 at 11:17:23 pm'!
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 11/27/2012 23:16' prior: 50400360!
                          interruptNameX: labelString
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess  |
	preemptedProcess _ Processor preemptedProcess.

	"Only debug preempted process if its priority is >= UIProcess' priority"
	preemptedProcess priority < UIProcess priority ifTrue: [
		preemptedProcess _ UIProcess ].

	preemptedProcess suspend.
	Debugger
		openInterrupt: labelString, 
			' - Process: ', preemptedProcess name, 
			' - Priority: ', preemptedProcess priority printString 
		onProcess: preemptedProcess! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1490-CuisCore-JuanVuletich-2012Nov27-23h15m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1490] on 30 November 2012 at 9:02:14 pm'!
!MenuMorph methodsFor: 'private' stamp: 'jmv 11/30/2012 20:45'!
                     positionAt: aPoint forHand: hand
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| delta |
	self adjustSubmorphsLayout.
	self morphPosition: aPoint - (2 @ 8).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	self morphBoundsInWorld right > owner world morphBoundsInWorld right
		ifTrue: [
			self moveRight: aPoint x + 1 ].

	"Make sure that the menu fits in the world."
	delta _ self morphBoundsInWorld amountToTranslateWithin:
		(owner world morphBoundsInWorld withHeight:
			((owner world morphExtentInWorld y - 18) max: (hand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 11/30/2012 20:13' prior: 16887622!
deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."

	stayUp ifFalse: [ self delete ].
	popUpOwner ifNotNil: [
		popUpOwner isSelected: false.
		popUpOwner deleteIfPopUp: evt ].
	evt ifNotNil: [ evt hand releaseMouseFocus: self ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 11/30/2012 20:57' prior: 50392570!
                            popUpAdjacentTo: rightOrLeftPointInWorld forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 11/30/2012 20:57' prior: 50400841!
                 popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m isKindOf: UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self.
	self positionAt: aPoint forHand: hand.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 11/30/2012 20:57' prior: 50397732!
             popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m isKindOf: UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self.
	self positionAt: aPoint forHand: hand.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 11/30/2012 20:56' prior: 50392679!
                     adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each morphWidth])].

	w _ w + 1.
	p _ 5 @ 5.
	submorphs do: [ :m |
		m morphWidth: w.
		m morphPosition: p.
		p _ p + (0@(m morphHeight + 1)) ].

	self morphExtent: w+4 @ p y + 5! !

MenuMorph removeSelector: #positionAt:forHand:relativeTo:!

MenuMorph removeSelector: #positionAt:forHand:relativeTo:!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1491-CuisCore-JuanVuletich-2012Nov30-21h00m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1491] on 3 December 2012 at 12:34:31 am'!
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/3/2012 00:33' prior: 50400702!
    delete
	"Remove the receiver as a submorph of its owner and make its 
	new owner be nil."

	| aWorld |
	aWorld _ self world ifNil: [ self runningWorld ].
	"Terminate genie recognition focus"
	"I encountered a case where the hand was nil, so I put in a little 
	protection - raa "
	" This happens when we are in an MVC project and open
	  a morphic window. - BG "
	aWorld ifNotNil: [
		aWorld activeHand ifNotNil: [ :h | h
			releaseKeyboardFocus: self;
			releaseMouseFocus: self ]].
	owner ifNotNil:[ self privateDelete].! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 12/3/2012 00:32' prior: 50368521!
                     processMouseUp: aMouseButtonEvent localPosition: localEventPosition
	"The handling of control between menu item requires them to act on mouse up even if not the current focus. This is different from the default behavior which really only wants to handle mouse ups when they got mouse downs before"

	aMouseButtonEvent wasHandled ifTrue:[^self]. "not interested"
	aMouseButtonEvent hand ifNotNil: [ :h | h releaseMouseFocus: self ].
	aMouseButtonEvent wasHandled: true.
	aMouseButtonEvent mouseButton3Changed
		ifTrue: [ self mouseButton3Up: aMouseButtonEvent localPosition: localEventPosition ]
		ifFalse: [ self mouseUp: aMouseButtonEvent localPosition: localEventPosition ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/3/2012 00:32' prior: 50402977!
          deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."

	stayUp ifFalse: [ self delete ].
	popUpOwner ifNotNil: [
		popUpOwner isSelected: false.
		popUpOwner deleteIfPopUp: evt ].
	evt ifNotNil: [ evt hand ifNotNil: [ :h | h releaseMouseFocus: self ]]! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 12/3/2012 00:31' prior: 50390452!
          mouseUp: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event.
	Note: This might be sent from a modal shell."
	(self fullContainsPoint: localEventPosition) ifFalse:[
		"Mouse up outside. Release eventual focus and delete if pop up."
		aMouseButtonEvent hand ifNotNil: [ :h | h releaseMouseFocus: self ].
		^ self deleteIfPopUp: aMouseButtonEvent ].
	stayUp ifFalse: [
		"Still in pop-up transition; keep focus"
		aMouseButtonEvent hand newMouseFocus: self ]! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 12/3/2012 00:29' prior: 50400899!
       displayAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	self runningWorld ifNotNil: [ :w |
		w addMorph: self centeredNear: aPoint.
		self world ifNotNil: [ w displayWorld ].  "show myself"
		].
	aBlock value.
	self delete! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 12/3/2012 00:30' prior: 50400910!
                 informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ self world ifNil: [ self runningWorld ].
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph morphWidth: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w ifNotNil: [
			w displayWorld	].	 "show myself"
	]. 
	self delete.
	w ifNotNil: [
		w displayWorld ]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1492-CuisCore-JuanVuletich-2012Dec03-00h51m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1492] on 3 December 2012 at 12:54:37 am'!
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 12/3/2012 00:54' prior: 50332845!
       arrowOfDirection: aSymbol size: finalSizeInteger
	^CachedForms
		at: { aSymbol . finalSizeInteger }
		ifAbsentPut: [
			self buildArrowOfDirection: aSymbol size: finalSizeInteger ]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
FormCanvas clearFormsCache!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1493-CuisCore-JuanVuletich-2012Dec03-00h51m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1493] on 4 December 2012 at 10:39:44 am'!
!Object methodsFor: 'tracing' stamp: 'jmv 12/4/2012 10:39' prior: 50380127!
inboundPointersExcluding: objectsToExclude
"Answer a list of all objects in the system that point to me, excluding those in the collection of objectsToExclude. I do my best to avoid creating any temporary objects that point to myself, especially method and block contexts. Adapted from PointerFinder class >> #pointersTo:except:"

	| object lastObject pointers objectsToAlwaysExclude |
	Smalltalk garbageCollect.
	"Do this to get rid or just created MethodContext instance."
	Smalltalk primitiveGarbageCollect.
	lastObject _ Object new.
	"big collection shouldn't grow, so it's contents array is always the same"
	pointers := OrderedCollection new: 1000.
	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious
	 method and block contexts out of the results"
	object := self someObject.
	[lastObject == object] whileFalse: [
		object isInMemory
			ifTrue: [((object statePointsTo: self)
				or: [object class == self])
					ifTrue: [pointers add: object]].
		object := object nextObject].

	objectsToAlwaysExclude := {
		pointers collector.
		thisContext.
		thisContext sender.
		thisContext sender sender.
		objectsToExclude.
	}.

	^ pointers removeAllSuchThat: [ :ea |
		(objectsToAlwaysExclude identityIncludes: ea)
			or: [ objectsToExclude identityIncludes: ea ]]! !
!ClosureTests methodsFor: 'testing' stamp: 'jmv 12/4/2012 10:33' prior: 16810765!
         testIsClean
	"
	ClosureTests new testIsClean
	"
	| tempVar |
	tempVar _ 1.
	self assert: [ 3 + 4 ] isClean.
	self assert: [ :a | a * 2 ] isClean.
	self assert: [ Smalltalk size ] isClean.
	self assert: [ :blockArg | blockArg printString ] isClean.
	self assert: [ | blockTemp | blockTemp printString ] isClean.
	self assert: [ | blockTemp | blockTemp _7 ] isClean.
	self deny: [ | outerBlockTemp | [ outerBlockTemp printString ] isClean ] value.
	self deny: [ | outerBlockTemp | [ outerBlockTemp _7 ] isClean ] value.
	self deny: [ tempVar + 1 ] isClean.
	self deny: [ tempVar _ 1 ] isClean.
	self deny: [ ivar + 1 ] isClean.
	self deny: [ ivar _ 1 ] isClean.
	self deny: [ ^ true ] isClean.
	self deny: [ self printString ] isClean.
	self deny: [ ^ self ] isClean.
	self deny: [ ClassVar + 1 ] isClean.
	self deny: [ ClassVar _ 1 ] isClean! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/4/2012 10:14' prior: 50400204!
                              worldState: aWorldState
	"
	| w |
	w _ self runningWorld.
	w worldState: (w instVarNamed: 'worldState')
	"
	worldState _ aWorldState.
	worldState world: self! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 12/4/2012 10:39' prior: 50380071!
      pointersToEachIn: anArray
	"Find all occurrences in the system of pointers to elements of the argument
	anObject.
	| p1 p2 |
	p1 _ (Smalltalk pointersTo: World).
	p2 _ (Smalltalk pointersToEachIn: {World}) first.
	p1 = p2.
	
	Maybe write a few tests...
	"
	| object lastObject pointers subject |
	Smalltalk garbageCollect.
	"Do this to get rid or just created MethodContext instance."
	Smalltalk primitiveGarbageCollect.
	lastObject _ Object new.
	"big collection shouldn't grow, so it's contents array is always the same"
	pointers _ anArray collect: [ :each | OrderedCollection new: 1000 ].
	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious
	 method and block contexts out of the results"
	object _ self someObject.
	[ lastObject == object ] whileFalse: [
		object isInMemory ifTrue: [
			1 to: anArray size do: [ :i |
				subject _ anArray at: i.
				((object statePointsTo: subject)
					or: [ object class == subject ])
						ifTrue: [ (pointers at: i) add: object ]]].
		object _ object nextObject].

	pointers do: [ :oc |
		oc
			remove: anArray;
			remove: thisContext ifAbsent: nil;
			remove: thisContext sender ifAbsent: nil;
			remove: thisContext sender sender ifAbsent: nil;
			remove: oc collector ifAbsent: nil ].
	^pointers! !
!SystemDictionaryTest methodsFor: 'testing' stamp: 'jmv 12/4/2012 10:39' prior: 50401360!
                       testPointersToEachIn
	"
	SystemDictionaryTest new testPointersToEachIn
	"
	| p1 p2 |
	p1 _ (Smalltalk pointersTo: Smalltalk).
	p2 _ (Smalltalk pointersToEachIn: {Smalltalk}) first.
	self assert: p1 = p2! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

	PasteUpMorph allInstancesDo: [ :w |
		(w instVarNamed: 'worldState') ifNotNil: [ :ws |
			w worldState: ws ]].
	
	SmalltalkCompleter initialize!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1494-CuisCore-JuanVuletich-2012Dec04-10h14m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1494] on 4 December 2012 at 10:06:51 pm'!

!classDefinition: #TestValueWithinFix category: #'Tests-Bugs'!
TestCase subclass: #TestValueWithinFix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tests-Bugs'!

TestCase subclass: #TestValueWithinFix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tests-Bugs'!
!TestValueWithinFix methodsFor: 'tests' stamp: 'nice 12/27/2009 03:11'!
    testValueWithinNonLocalReturnFixReal
	"self run: #testValueWithinNonLocalReturnFixReal"
	"The real test for the fix is just as obscure as the original problem"
	| startTime |
	self valueWithinNonLocalReturn.
	startTime := Time millisecondClockValue.
	[[] repeat] valueWithin: 100 milliSeconds onTimeout:[ | deltaTime |
		"This *should* timeout after 100 msecs but the pending process from
		the previous invokation will signal timeout after 20 msecs already
		which will in turn cut this invokation short."
		deltaTime := Time millisecondClockValue - startTime.
		self deny: deltaTime < 90.
	].
! !
!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:38'!
    testValueWithinNonLocalReturnFixSimply
	"self run: #testValueWithinNonLocalReturnFixSimply"
	"The simple version to test the fix"
	self valueWithinNonLocalReturn.
	self shouldnt:[(Delay forMilliseconds: 50) wait] raise: TimedOut.! !
!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 12/4/2012 20:35'!
                  testValueWithinTimingBasic
	"Test timing of valueWithin:onTimeout:"
	| time |
	time := [
		[1000 milliSeconds asDelay wait]
			valueWithin: 100 milliSeconds onTimeout: []
	] durationToRun.
	self assert: time < 150 milliSeconds.! !
!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 12/4/2012 20:35'!
                    testValueWithinTimingNestedInner
	"Test nested timing of valueWithin:onTimeout:"
	| time |
	time := [
		[
			[5 seconds asDelay wait]
				valueWithin: 100 milliSeconds onTimeout: []
		] valueWithin: 500 milliSeconds onTimeout: []
	] durationToRun.
	self assert: time < 150 milliSeconds.
! !
!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 12/4/2012 20:35'!
                        testValueWithinTimingNestedOuter
	"Test nested timing of valueWithin:onTimeout:"
	| time |
	time := [
		[
			3 timesRepeat: [
				[5 seconds asDelay wait]
					valueWithin: 100 milliSeconds onTimeout: []]
		] valueWithin: 150 milliSeconds onTimeout: []
	] durationToRun.
	self assert: time > 100 milliSeconds.
	self assert: time < 200 milliSeconds.
	! !
!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 12/4/2012 20:35'!
                         testValueWithinTimingRepeat
	"Test timing of valueWithin:onTimeout:"
	| time |
	time := [
		3 timesRepeat: [
			[500 milliSeconds asDelay wait]
				valueWithin: 100 milliSeconds onTimeout: []]
	] durationToRun.
	self assert: time < 350 milliSeconds.
! !
!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:37'!
                             valueWithinNonLocalReturn
	"Do a non-local return from a valueWithin: block"
	[^self] valueWithin: 20 milliSeconds onTimeout:[].
! !
!BlockClosure methodsFor: 'evaluating' stamp: 'ar 12/4/2012 20:36' prior: 50398917!
       valueWithin: aDuration onTimeout: timeoutBlock
	"Evaluate the receiver.
	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"

	| theProcess delay watchdog tag |

	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].

	"the block will be executed in the current process"
	theProcess := Processor activeProcess.
	delay := aDuration asDelay.
	tag := self.

	"make a watchdog process"
	watchdog := [
		delay wait. 	"wait for timeout or completion"
		theProcess ifNotNil:[ theProcess signalException: (TimedOut new tag: tag)] 
	] newProcess.

	"Watchdog needs to run at high priority to do its job (but not at timing priority)"
	watchdog priority: Processor timingPriority-1.

	"catch the timeout signal"
	^ [	watchdog resume.				"start up the watchdog"
		self ensure:[						"evaluate the receiver"
			theProcess := nil.				"it has completed, so ..."
			delay delaySemaphore signal.	"arrange for the watchdog to exit"
		]] on: TimedOut do: [ :e | 
			e tag == tag 
				ifTrue:[ timeoutBlock value ]
				ifFalse:[ e pass]].! !
!BlockContext methodsFor: 'evaluating' stamp: 'ar 12/4/2012 20:37' prior: 50398986!
                              valueWithin: aDuration onTimeout: timeoutBlock
	"Evaluate the receiver.
	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"

	| theProcess delay watchdog tag |

	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].

	"the block will be executed in the current process"
	theProcess := Processor activeProcess.
	delay := aDuration asDelay.
	tag := self.

	"make a watchdog process"
	watchdog := [
		delay wait. 	"wait for timeout or completion"
		theProcess ifNotNil:[ theProcess signalException: (TimedOut new tag: tag)] 
	] newProcess.

	"Watchdog needs to run at high priority to do its job (but not at timing priority)"
	watchdog priority: Processor timingPriority-1.

	"catch the timeout signal"
	^ [	watchdog resume.				"start up the watchdog"
		self ensure:[						"evaluate the receiver"
			theProcess := nil.				"it has completed, so ..."
			delay delaySemaphore signal.	"arrange for the watchdog to exit"
		]] on: TimedOut do: [ :e | 
			e tag == tag 
				ifTrue:[ timeoutBlock value ]
				ifFalse:[ e pass]].! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1495-CuisCore-JuanVuletich-2012Dec04-22h03m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 10:20:41 pm'!

!classDefinition: #Base64MimeConverter category: #'Collections-Streams'!
MimeConverter subclass: #Base64MimeConverter
	instanceVariableNames: 'data multiLine'
	classVariableNames: 'FromCharTable ToCharTable'
	poolDictionaries: ''
	category: 'Collections-Streams'!

MimeConverter subclass: #Base64MimeConverter
	instanceVariableNames: 'data multiLine '
	classVariableNames: 'FromCharTable ToCharTable '
	poolDictionaries: ''
	category: 'Collections-Streams'!
!Base64MimeConverter methodsFor: 'accessing' stamp: 'ar 4/15/2008 17:58'!
                    multiLine
	"Determines whether we allow multi-line encodings (the default) or force everything into a single line (for use with URLs etc. where the continuation marker and the line break cause problems)"
	^multiLine! !
!Base64MimeConverter methodsFor: 'accessing' stamp: 'ar 4/15/2008 17:58'!
                           multiLine: aBool
	"Determines whether we allow multi-line encodings (the default) or force everything into a single line (for use with URLs etc. where the continuation marker and the line break cause problems)"
	multiLine := aBool! !
!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:17'!
                             mimeEncode: aStream multiLine: aBool
	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."

	^self mimeEncode: aStream multiLine: aBool atStart: true! !
!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:16'!
                         mimeEncode: aStream multiLine: aBool atStart: resetInput
	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."

	| me |
	resetInput ifTrue:[aStream position: 0].
	me := self new dataStream: aStream.
	me multiLine: aBool.
	me mimeStream: (ReadWriteStream on: (String new: aStream size + 20 * 4 // 3)).
	me mimeEncode.
	me mimeStream position: 0.
	^ me mimeStream! !
!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:17'!
     mimeEncodeContinue: aStream
	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."
	^self mimeEncode: aStream multiLine: true atStart: false! !
!StringTest methodsFor: 'tests - converting' stamp: 'ul 10/30/2012 02:14'!
                 testBase64

	self 
		assert: 'SGVsbG8gV29ybGQ=' base64Decoded = 'Hello World';
		assert: 'Hello World' base64Encoded = 'SGVsbG8gV29ybGQ=';
		assert: (String new: 100 withAll: $x) base64Encoded  = 'eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eA=='! !
!Base64MimeConverter methodsFor: 'conversion' stamp: 'jmv 12/4/2012 22:15' prior: 16784416!
                  mimeEncode
	"Convert from data to 6 bit characters."

	| phase1 phase2 raw nib lineLength |
	phase1 := phase2 := false.
	lineLength := 0.
	[dataStream atEnd] whileFalse: [
		(multiLine and:[lineLength >= 70]) ifTrue: [ mimeStream newLine.  lineLength := 0. ].
		data := raw := dataStream next asInteger.
		nib := (data bitAnd: 16rFC) bitShift: -2.
		mimeStream nextPut: (ToCharTable at: nib+1).
		(raw := dataStream next) ifNil: [raw := 0. phase1 := true].
		data := ((data bitAnd: 3) bitShift: 8) + raw asInteger.
		nib := (data bitAnd: 16r3F0) bitShift: -4.
		mimeStream nextPut: (ToCharTable at: nib+1).
		(raw := dataStream next) ifNil: [raw := 0. phase2 := true].
		data := ((data bitAnd: 16rF) bitShift: 8) + (raw asInteger).
		nib := (data bitAnd: 16rFC0) bitShift: -6.
		mimeStream nextPut: (ToCharTable at: nib+1).
		nib := (data bitAnd: 16r3F).
		mimeStream nextPut: (ToCharTable at: nib+1).

		lineLength := lineLength + 4.].
	phase1 ifTrue: [mimeStream skip: -2; nextPut: $=; nextPut: $=.
			^ mimeStream].
	phase2 ifTrue: [mimeStream skip: -1; nextPut: $=.
			^ mimeStream].

! !
!Base64MimeConverter methodsFor: 'conversion' stamp: 'ul 6/17/2011 12:36' prior: 16784452!
nextValue
	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"
	| raw num |
	[raw := mimeStream next.
	raw ifNil: [^ nil].	"end of stream"
	raw == $= ifTrue: [^ nil].
	num := FromCharTable at: raw asciiValue + 1.
	num ifNotNil: [^ num].
	"else ignore space, return, tab, ..."
	] repeat! !
!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:17' prior: 16784554!
                      mimeEncode: aStream
	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."
	^self mimeEncode: aStream multiLine: true atStart: true! !
!String methodsFor: 'converting' stamp: 'ul 10/30/2012 02:09' prior: 16955784!
                      base64Encoded
	"Encode the receiver as base64"
	"'Hello World' base64Encoded"

	^(Base64MimeConverter
		mimeEncode: (ReadStream on: self)
		multiLine: false) contents! !

!classDefinition: #Base64MimeConverter category: #'Collections-Streams'!
MimeConverter subclass: #Base64MimeConverter
	instanceVariableNames: 'data multiLine'
	classVariableNames: 'FromCharTable ToCharTable'
	poolDictionaries: ''
	category: 'Collections-Streams'!

MimeConverter subclass: #Base64MimeConverter
	instanceVariableNames: 'data multiLine'
	classVariableNames: 'FromCharTable ToCharTable'
	poolDictionaries: ''
	category: 'Collections-Streams'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1496-CuisCore-JuanVuletich-2012Dec04-22h18m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 10:28:33 pm'!
!SpaceTally methodsFor: 'class analysis' stamp: 'jmv 12/4/2012 22:28' prior: 16950348!
             spaceTally: classes 
	"Answer a collection of SpaceTallyItems representing the memory space (in bytes) consumed by the code and instances of each class in the system. Note that code sizes do not currently report memory consumed by class variables. "
	"
	SpaceTally new spaceTally: (Array with: TextModelMorph with: Point)
	"
	self preAllocateResultsFor: classes.
	Smalltalk garbageCollect.
	self computeSpaceUsage.
	^ results
		 sort: [ :a :b | a spaceForInstances > b spaceForInstances ];
		 yourself! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1497-CuisCore-JuanVuletich-2012Dec04-22h20m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 10:36:58 pm'!
!Parser methodsFor: 'pragmas' stamp: 'jmv 12/4/2012 22:34' prior: 16910129!
                  pragmaLiteral: selectorSoFar
	"Read a pragma literal.  As a nicety we allow a variable name (rather
	 than a literal string) as the second argument to primitive:error:"

	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])
		ifTrue: [ ^ self advance ].
	(here == $# and: [ tokenType == #word ])
		ifTrue: [ ^ self advance ].
	(here == #- and: [ tokenType == #number ])
		ifTrue: [ ^ (self advance; advance) negated ].
	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])
		ifTrue: [ ^ (Scanner new scanTokens: self advance) first ].
	"This nicety allows one to supply a primitive error
	 temp as a variable name, rather than a string."
	((selectorSoFar beginsWith: 'primitive:')
	 and: [(selectorSoFar endsWith: 'error:')
	 and: [hereType == #word]]) ifTrue:
		[^self advance].
	^self expected: 'Literal constant'! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1498-CuisCore-JuanVuletich-2012Dec04-22h28m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 10:42:08 pm'!
!Decompiler methodsFor: 'private' stamp: 'eem 11/9/2012 14:17' prior: 16835845!
                   convertToDoLoop
	"If statements contains the pattern
		var := startExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	then replace this by
		startExpr to: limit by: incConst do: [:var | ...statements...]"
	| initStmt toDoStmt limitStmt |
	(stack notEmpty
	 and: [stack last isAssignmentNode])
		ifTrue:
			[initStmt := stack last.
			 (toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			 stack removeLast; addLast: toDoStmt.
			 statements removeLast]
		ifFalse:
			[statements size < 2 ifTrue:
				[^self].
			initStmt := statements at: statements size-1.
			(toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			statements removeLast; removeLast; addLast: toDoStmt].
	initStmt variable scope: -1.  "Flag arg as block temp"

	"Attempt further conversion of the pattern
		limitVar := limitExpr.
		startExpr to: limitVar by: incConst do: [:var | ...statements...]
	to
		startExpr to: limitExpr by: incConst do: [:var | ...statements...].
	The complication here is that limitVar := limitExpr's value may be used, in which case it'll
	be statements last, or may not be used, in which case it'll be statements nextToLast."
	statements size < 2 ifTrue: [^ self].
	limitStmt := statements last.
	((limitStmt isMemberOf: AssignmentNode)
		and: [limitStmt variable isTemp
		and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
			[limitStmt := statements at: statements size-1.
			((limitStmt isMemberOf: AssignmentNode)
				and: [limitStmt variable isTemp
				and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
					[^self]].

	(self blockScopeRefersOnlyOnceToTemp: limitStmt variable fieldOffset) ifFalse:
		[^self].
	toDoStmt arguments at: 1 put: limitStmt value.
	limitStmt variable scope: -2.  "Flag limit var so it won't print"
	statements last == limitStmt
		ifTrue: [statements removeLast]
		ifFalse: [statements removeLast; removeLast; addLast: toDoStmt]! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1499-CuisCore-JuanVuletich-2012Dec04-22h36m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 10:46:12 pm'!
!SystemDictionary methodsFor: 'image format' stamp: 'jmv 12/4/2012 22:45' prior: 16964421!
      imageFormatVersion
	"Answer an integer identifying the type of image in memory. The image version number may
	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements
	of the image (e.g. block closure support required). This invokes an optional primitive
	that may not be available on all virtual machines."

	"
	Smalltalk imageFormatVersion
	"

	<primitive: 'primitiveImageFormatVersion'>

	"Cog provides a VM parameter"
	^[Smalltalk vm vmParameterAt: 41]
		on: Error
		do: [self notify: 'This virtual machine does not support the optional ',
				'primitive #primitiveImageFormatVersion'.
			nil]
! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1500-CuisCore-JuanVuletich-2012Dec04-22h43m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 10:49:52 pm'!
!MessageNode methodsFor: 'printing' stamp: 'eem 11/5/2012 15:01' prior: 16889116!
            printWhileOn: aStream indent: level
	self printReceiver: receiver on: aStream indent: level.
	self
		printKeywords: originalSelector
		arguments: originalArguments
		on: aStream indent: level! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1501-CuisCore-JuanVuletich-2012Dec04-22h46m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 10:52:08 pm'!
!CompiledMethod methodsFor: 'literals' stamp: 'eem 11/5/2012 09:42' prior: 16822661!
                               sendsSelector: aSelector 
	| scanner |
	scanner := InstructionStream on: self.
	scanner scanFor: 
		[:x | 
		 scanner selectorToSendOrSelf == aSelector ifTrue:
			[^true].
		 false	"keep scanning"].
	^false! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1502-CuisCore-JuanVuletich-2012Dec04-22h50m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 10:53:50 pm'!
!VariableNode methodsFor: 'code generation' stamp: 'eem 11/2/2012 10:15' prior: 16982754!
           sizeCodeForReturn: encoder
	encoder
		if: code
		isSpecialLiteralForReturn:
			[:specialLiteral|
			 ^encoder sizeReturnSpecialLiteral: specialLiteral].
	(self code = LdSelf or: [self code = LdSuper]) ifTrue:
		[^encoder sizeReturnReceiver].
	^super sizeCodeForReturn: encoder! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1503-CuisCore-JuanVuletich-2012Dec04-22h52m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 10:55:27 pm'!
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 12/4/2012 22:55' prior: 16960693!
   vmParameterAt: parameterIndex
	"parameterIndex is a positive integer corresponding to one of the VM's internal
	parameter/metric registers.  Answer with the current value of that register.
	Fail if parameterIndex has no corresponding register.
	VM parameters are numbered as follows:
		1	end of old-space (0-based, read-only)
		2	end of young-space (read-only)
		3	end of memory (read-only)
		4	allocationCount (read-only; nil in Cog VMs)
		5	allocations between GCs (read-write; nil in Cog VMs)
		6	survivor count tenuring threshold (read-write)
		7	full GCs since startup (read-only)
		8	total milliseconds in full GCs since startup (read-only)
		9	incremental GCs since startup (read-only)
		10	total milliseconds in incremental GCs since startup (read-only)
		11	tenures of surving objects since startup (read-only)
		12-20 specific to the translating VM
		21	root table size (read-only)
		22	root table overflows since startup (read-only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc.
		24	memory threshold above whichto shrink object memory (read-write)
		25	memory headroom when growing object memory (read-write)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)
		27	number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking
		28	number of times sweep loop iterated for current IGC/FGC (read-only)
		29	number of times make forward loop iterated for current IGC/FGC (read-only)
		30	number of times compact move loop iterated for current IGC/FGC (read-only)
		31	number of grow memory requests (read-only)
		32	number of shrink memory requests (read-only)
		33	number of root table entries used for current IGC/FGC (read-only)
		34	number of allocations done before current IGC/FGC (read-only)
		35	number of survivor objects after current IGC/FGC (read-only)
		36	millisecond clock when current IGC/FGC completed (read-only)
		37	number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)
		38	milliseconds taken by current IGC (read-only)
		39	Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)
		40	BytesPerWord for this image
		41	imageFormatVersion for the VM
		42	number of stack pages in use (Cog Stack VM only, otherwise nil)
		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)
		44	size of eden, in bytes (Cog VMs only, otherwise nil)
		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)
		46	size of machine code zone, in bytes (stored in image file header; Cog JIT VM only, otherwise nil)
		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)
		48	various properties of the Cog VM as an integer encoding an array of bit flags.
			 Bit 0: implies the image's Process class has threadId as its 3rd inst var (zero relative)
		49	the size of the external semaphore table (read-write; Cog VMs only)
		50-55 reserved for VM parameters that persist in the image (such as eden above)
		56	number of process switches since startup (read-only)
		57	number of ioProcessEvents calls since startup (read-only)
		58	number of ForceInterruptCheck (Cog VMs) or quickCheckInterruptCalls (non-Cog VMs) calls since startup (read-only)
		59	number of check event calls since startup (read-only)
		60	number of stack page overflows since startup (read-only; Cog VMs only)
		61	number of stack page divorces since startup (read-only; Cog VMs only)
		62	number of machine code zone compactions since startup (read-only; Cog VMs only)
		63	milliseconds taken by machine code zone compactions since startup (read-only; Cog VMs only)
		64	current number of machine code methods (read-only; Cog VMs only)
		65	true if the VM supports multiple bytecode sets;  (read-only; Cog VMs only; nil in older Cog VMs)
		70	the value of VM_PROXY_MAJOR (the interpreterProxy major version number)
		71	the value of VM_PROXY_MINOR (the interpreterProxy minor version number)"

	<primitive: 254>
	self primitiveFailed! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 12/4/2012 22:55' prior: 16960731!
        vmParameterAt: parameterIndex put: newValue
	"parameterIndex is a positive integer corresponding to one of the VM's internal
	parameter/metric registers.  Store newValue (a positive integer) into that
	register and answer with the previous value that was stored there.
	Fail if newValue is out of range, if parameterIndex has no corresponding
	register, or if the corresponding register is read-only.

	As of 2011-ish the parameters which can be set are
		5	allocations between GCs (read-write; nil in Cog VMs)
		6	survivor count tenuring threshold (read-write)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc.
		24	memory threshold above whichto shrink object memory (read-write)
		25	memory headroom when growing object memory (read-write)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)
		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)
		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)
		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)
		48	various properties of the Cog VM as an integer encoding an array of bit flags.
			 Bit 0: implies the image's Process class has threadId as its 3rd inst var (zero relative)
		49	the size of the external semaphore table (read-write; Cog VMs only)"

	<primitive: 254>
	self primitiveFailed! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1504-CuisCore-JuanVuletich-2012Dec04-22h53m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1504] on 4 December 2012 at 11:37:01 pm'!

!classDefinition: #ClosureExtractor category: #'Kernel-Methods'!
InstructionClient subclass: #ClosureExtractor
	instanceVariableNames: 'action scanner currentContext'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

InstructionClient subclass: #ClosureExtractor
	instanceVariableNames: 'action scanner currentContext '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!
!ClosureExtractor methodsFor: 'instruction decoding' stamp: 'eem 10/24/2012 14:08'!
 blockReturnTop
	currentContext := currentContext sender! !
!ClosureExtractor methodsFor: 'accessing' stamp: 'eem 10/24/2012 14:09' prior: 16810671!
            scanner: anInstructionStream
	scanner := anInstructionStream.
	currentContext := MethodContext
							sender: nil
							receiver: self
							method: scanner method
							arguments: (Array new: scanner method numArgs)! !
!ClosureExtractor methodsFor: 'instruction decoding' stamp: 'eem 10/24/2012 14:11' prior: 16810676!
                             pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize
	"Create a BlockClosure corresponding to the closure bytecode
	 and execute the action block with it. The created BlockClosure is only a pseudo value,
	 it is not populated with meaningful context and argument information."
	| block |
	block := BlockClosure
				outerContext: currentContext
				startpc: scanner pc
				numArgs: numArgs
				copiedValues: (Array new: numCopied)..
	currentContext := block asContextWithSender: currentContext.
	action value: block! !

!classDefinition: #ClosureExtractor category: #'Kernel-Methods'!
InstructionClient subclass: #ClosureExtractor
	instanceVariableNames: 'action scanner currentContext'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

InstructionClient subclass: #ClosureExtractor
	instanceVariableNames: 'action scanner currentContext'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1505-CuisCore-JuanVuletich-2012Dec04-23h35m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 11:05:52 pm'!
!Parser methodsFor: 'expression types' stamp: 'eem 10/8/2012 13:40' prior: 16910532!
                            braceExpression
	" { elements } => BraceNode."

	| elements locations loc more |
	elements := OrderedCollection new.
	locations := OrderedCollection new.
	self advance.
	more := hereType ~~ #rightBrace.
	[more]
		whileTrue: 
			[loc := hereMark + requestorOffset.
			self expression
				ifTrue: 
					[elements addLast: parseNode.
					locations addLast: loc]
				ifFalse:
					[^self expected: 'Variable or expression or right brace'].
			(self match: #period)
				ifTrue: [more := hereType ~~ #rightBrace]
				ifFalse: [more := false]].
	parseNode := BraceNode new elements: elements sourceLocations: locations.
	(self match: #rightBrace)
		ifFalse: [^self expected: 'Period or right brace'].
	^true! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1506-CuisCore-JuanVuletich-2012Dec04-23h02m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1495] on 4 December 2012 at 11:06:23 pm'!
!CompiledMethod methodsFor: 'scanning' stamp: 'eliot 10/8/2012 11:24' prior: 16822755!
                               scanFor: byteOrClosure
	"Answer whether the receiver contains the argument as a bytecode,
	 if it is a number, or evaluates to true if a block."
	^ (InstructionStream on: self) scanFor: (byteOrClosure isBlock
													ifTrue: [byteOrClosure]
													ifFalse: [[:instr | instr = byteOrClosure]])
"
Smalltalk browseAllSelect: [:m | m scanFor: 134]
"! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1507-CuisCore-JuanVuletich-2012Dec04-23h05m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1507] on 4 December 2012 at 11:42:47 pm'!
!AutoCompleter methodsFor: 'keyboard' stamp: 'jmv 12/4/2012 23:38' prior: 16783303!
                           handleKeystrokeBefore: kbEvent
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."
	| currentPos currentCharIsAlphaNumeric keyValue ctrl cmd tab colon alphanum backspace esc space return keyChar  |
	currentPos _ textMorph editor startIndex-1.
	currentCharIsAlphaNumeric _ currentPos > 0 and: [ model textSize >= currentPos and: [
			(model actualContents at: currentPos) isAlphaNumeric ]].
	keyValue _ kbEvent keyValue.
	keyChar _ kbEvent keyCharacter.
	ctrl _ kbEvent controlKeyPressed.
	cmd _ kbEvent commandAltKeyPressed.
	tab _ keyChar = Character tab.
	colon _ keyChar = $:.
	alphanum _ kbEvent keyCharacter isAlphaNumeric.
	backspace _ keyValue = 8.
	esc _ keyValue = 27.
	space _ #(0 32 160) includes: keyValue.
	return _ kbEvent isReturnKey.

	"Stuff to do if the menu is not open"
	menuMorph ifNil: [
		"Ctrl-Space or Tab for open"
		"Mac specific note: Using option-space (actually option+160) effectively disables the non-breaking space character 160"
		(space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [
			(self opensWithTab and: [tab]) and: [ currentCharIsAlphaNumeric ]])
				ifTrue: [ self openCompletionMenu. ^ true].
		"Auto-open - currently deactivated"
"		(ctrl not & cmd not & alphanum) 
			ifTrue: [ self openCompletionMenu ]."
		^ false].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.
	"Escape"
	esc ifTrue: [ self closeMenu. ^ true].
	"Backspace"
	backspace ifTrue: [
		currentCharIsAlphaNumeric ifFalse: [ self closeMenu ].
		^ false].
	"Home"
	keyValue = 1 ifTrue: [ menuMorph home. ^ true ].
	"End"
	keyValue = 4 ifTrue: [ menuMorph end. ^ true].
	"?"
	keyChar = $? ifTrue: [ menuMorph help. ^true].
	"Arrow up"
	keyValue = 30 ifTrue: [ menuMorph moveUp. ^ true].
	"Arrow down"
	keyValue = 31 ifTrue: [ menuMorph moveDown. ^ true].
	"Page up"
	keyValue = 11 ifTrue: [ menuMorph pageUp. ^ true].
	"Page down"
	keyValue = 12 ifTrue: [ menuMorph pageDown. ^ true].
	"Return, Tab or Ctrl-Space"
	(return or: [ space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [ tab]]) ifTrue: [
		self insertSelected
			ifTrue: [^ true]].
	"All keys but the alphanumeric chars (without command and control ) 
	and the backspace key do close the menu"
	(ctrl not & cmd not and: [ alphanum | colon])
		ifFalse: [ self closeMenu ].
	^false! !
!BitBlt class methodsFor: 'private' stamp: 'jmv 12/4/2012 23:40' prior: 16788403!
            exampleAt: originPoint rule: rule fillColor: mask 
	"This builds a source and destination form and copies the source to the
	destination using the specifed rule and mask. It is called from the method
	named exampleOne. Only works with Display depth of 1"

	| s d border aBitBlt | 
	border _ Form extent: 32@32.
	border fillBlack.
	border fill: (1@1 extent: 30@30) fillColor: Color white.
	s _ Form extent: 32@32.
	s fillWhite.
	s fillBlack: (7@7 corner: 25@25).
	d _ Form extent: 32@32.
	d fillWhite.
	d fillBlack: (0@0 corner: 32@16).

	s displayOn: Display at: originPoint.
	border displayOn: Display at: originPoint rule: Form under.
	d displayOn: Display at: originPoint + (s width @0).
	border displayOn: Display at: originPoint + (s width @0) rule: Form under.

	d displayOn: Display at: originPoint + (s extent // (2 @ 1)). 
	aBitBlt _ BitBlt
		destForm: Display
		sourceForm: s
		fillColor: mask
		combinationRule: rule
		destOrigin: originPoint + (s extent // (2 @ 1))
		sourceOrigin: 0 @ 0
		extent: s extent
		clipRect: Display computeBoundingBox.
	aBitBlt copyBits.
	border 
		displayOn: Display at: originPoint + (s extent // (2 @ 1))
		rule: Form under.

	"BitBlt exampleAt: 100@100 rule: 0 fillColor: nil"  ! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 12/4/2012 23:40' prior: 50351773!
     scanCategory
	"Scan anything that involves more than one chunk; method name is historical only"

	| itemPosition item item2 tokens firstToken secondToken stamp isComment anIndex def isMeta name record methodReference doItOnlyIfInBaseSystem |
	itemPosition _ file position.
	item _ file nextChunk.
	isComment _ (item includesSubString: 'commentStamp:').
	((isComment
	or: [item includesSubString: 'methodsFor:']
	or: [item includesSubString: 'classDefinition:']
	or: [item includesSubString: 'classRemoval:']
	or: [item includesSubString: 'methodRemoval:'])
	or: [item includesSubString: 'methodMoveToSomePackage:']
	or: [item includesSubString: 'classMoveToSomePackage:'])
		ifFalse: [
			"Maybe a preamble, but not one we recognize; bail out with the preamble trick"
			^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)
				 text: ('preamble: ' , item contractTo: 160)].

	tokens _ Smalltalk actualScannerClass new scanTokens: item.
	tokens size >= 2 ifTrue: [
		stamp _ ''.
		anIndex _ tokens indexOf: #stamp: ifAbsent: nil.
		anIndex ifNotNil: [stamp _ tokens at: (anIndex + 1)].
		firstToken _ tokens first.
		secondToken _ tokens second.

		firstToken == #classDefinition: ifTrue: [
			itemPosition _ file position.
			isMeta _ secondToken includesSubString: ' class'.
			name _ isMeta ifTrue: [secondToken substrings first] ifFalse: [secondToken].
			def _ file nextChunk.
			record _ ChangeRecord new file: file position: itemPosition type: #classDefinition
				class: name asSymbol category: tokens last meta: isMeta stamp: nil.
			self addItem: record text: 'classDefinition: ', def.
			^ self ].

		(firstToken == #classRemoval: or: [ firstToken == #classMoveToSomePackage: ]) ifTrue: [
			doItOnlyIfInBaseSystem _ firstToken == #classMoveToSomePackage:.
			itemPosition _ file position.
			item2 _ file nextChunk.
			item2 size > 0 ifTrue: [
				self 
					addItem: (ClassDeletionChangeRecord new
						clsName: secondToken;
						doItOnlyIfInBaseSystem: doItOnlyIfInBaseSystem)
					text: 
						(doItOnlyIfInBaseSystem ifTrue: ['clase move to some package: '] ifFalse: ['class removal: ']), secondToken ].
			^ self ].

		(firstToken == #methodRemoval: or: [ firstToken == #methodMoveToSomePackage: ]) ifTrue: [
			doItOnlyIfInBaseSystem _ firstToken == #methodMoveToSomePackage:.
			itemPosition _ file position.
			item2 _ file nextChunk.
			item2 size > 0 ifTrue: [
				isMeta _ tokens third == #class.
				isMeta ifTrue: [secondToken substrings first] ifFalse: [secondToken].
				methodReference _ (MethodReference new
					setClassSymbol: secondToken
					classIsMeta: isMeta
					methodSymbol: tokens last
					stringVersion: secondToken, ' ', (isMeta ifTrue: ['class '] ifFalse: ['']), tokens last).
				self
					addItem: (MethodDeletionChangeRecord new
						methodReference: methodReference;
						doItOnlyIfInBaseSystem: doItOnlyIfInBaseSystem)
					text: 
						(doItOnlyIfInBaseSystem ifTrue: ['method move to some package: '] ifFalse: ['method removal: ']), 
							methodReference asStringOrText ].
			^ self ].
		
		secondToken == #methodsFor: ifTrue: [
			^ self scanCategory: tokens third class: firstToken meta: false stamp: stamp].

		tokens third == #methodsFor: ifTrue: [
			^ self scanCategory: tokens fourth class: firstToken meta: true stamp: stamp]].

	secondToken == #commentStamp:
		ifTrue: [
			stamp _ tokens third.
			self addItem:
					(ChangeRecord new file: file position: file position type: #classComment
									class: firstToken category: nil meta: false stamp: stamp)
					text: 'class comment for ' , firstToken, 
						  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).
			file nextChunk.
			^ self]! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 12/4/2012 23:40' prior: 50334185!
                        install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage _ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/4/2012 23:39' prior: 16816059!
         collect: aBlock andFold: binaryBlock
	"Evaluate the block with the first two elements of the receiver,
	 then with the result of the first evaluation and the next element,
	 and so on.  Answer the result of the final evaluation. If the receiver
	 is empty, raise an error. If the receiver has a single element, answer
	 that element."
	"
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each ] andFold: [:a :b | a, ' ', b]
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each  size] andFold: [:a :b | a + b]
	"

	| first eachValue nextValue |
	first _ true.
	self do: [ :each |
		eachValue _  aBlock value: each.
		first
			ifTrue: [
				first _ false.
				nextValue _ eachValue ]
			ifFalse: [
				nextValue _ binaryBlock
					value: nextValue
					value: eachValue ]].
	first ifTrue: [ self errorEmptyCollection ].
	^ nextValue! !
!DisplayObject methodsFor: 'displaying-Display' stamp: 'jmv 12/4/2012 23:41' prior: 16840256!
                slideFrom: startPoint to: stopPoint nSteps: nSteps 
	"does not display at the first point, but does at the last"
	| i p delta |
	i _ 0.
	p _ startPoint.
	delta _ (stopPoint-startPoint) // nSteps.
	^ self follow: [p _ p+delta]
		while: [(i _ i+1) < nSteps]! !
!FFT methodsFor: 'initialization' stamp: 'jmv 12/4/2012 23:41' prior: 16847359!
             nu: order
	"Initialize variables and tables for transforming 2^nu points"
	|  j perms k |
	nu _ order.
	n _ 2 bitShift: nu-1.

	"Initialize permutation table (bit-reversed indices)"
	j _ 0.
	perms _ WriteStream on: (Array new: n).
	0 to: n-2 do:
		[:i |
		i < j ifTrue: [perms nextPut: i+1; nextPut: j+1].
		k _ n // 2.
		[k <= j] whileTrue: [j _ j-k.  k _ k//2].
		j _ j + k].
	permTable _ perms contents asWordArray.

	"Initialize sin table 0..pi/2 in n/4 steps."
	sinTable _ (0 to: n/4) collect: [:i | (i asFloat / (n//4) * Float pi / 2.0) sin].
	
	sinTable _ sinTable asFloatArray.
	realData _ FloatArray new: n.
	imagData _ FloatArray new: n.

	self initializeHammingWindow: 0.54.  "0.54 for Hamming, 0.5 for hanning"! !
!RunArray methodsFor: 'copying' stamp: 'jmv 12/4/2012 23:41' prior: 16929565!
                            copyFrom: start to: stop
	| newRuns run1 run2 offset1 offset2 answer | 
	stop < start ifTrue: [
		answer _ RunArray new.
		answer canJoinMessage: canJoinMessage.
		^answer ].
	self at: start setRunOffsetAndValue: [ :r :o :value1 |
		run1 _ r.
		offset1 _ o. 
		value1 ].
	self at: stop setRunOffsetAndValue: [ :r :o :value2 |
		run2 _ r.
		offset2 _ o.
		value2].
	run1 = run2
		ifTrue: [
			newRuns _ Array with: offset2 - offset1 + 1]
		ifFalse: [
			newRuns _ runs copyFrom: run1 to: run2.
			newRuns at: 1 put: (newRuns at: 1) - offset1.
			newRuns at: newRuns size put: offset2 + 1 ].
	answer _ RunArray runs: newRuns values: (values copyFrom: run1 to: run2).
	answer canJoinMessage: canJoinMessage.
	^answer! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 12/4/2012 23:42' prior: 16931404!
                             privateStyle: anInterval
	| ranges end start |
	start _ anInterval first.
	end _ anInterval last.
	ranges _ self rangesIn: (formattedText copyFrom: start to: end) setWorkspace: true.
	ranges ifNotNil: [
		self setAttributesIn: formattedText fromRanges: ranges in: anInterval ]! !
!SHTextStylerST80 class methodsFor: 'style table' stamp: 'jmv 12/4/2012 23:42' prior: 16931633!
        attributeArrayForColor: aColorOrNil emphasis: anEmphasisSymbolOrArrayorNil
	"Answer a new Array containing any non nil TextAttributes specified"
	| answer emphArray |

	answer _ #().
	aColorOrNil ifNotNil: [ answer _ answer, {TextColor color: aColorOrNil} ].
	anEmphasisSymbolOrArrayorNil ifNotNil: [
		emphArray _ anEmphasisSymbolOrArrayorNil isSymbol 
			ifTrue: [ {anEmphasisSymbolOrArrayorNil} ] 
			ifFalse: [ anEmphasisSymbolOrArrayorNil ].
		emphArray do: [ :each |
			each ~= #normal
				ifTrue: [
					answer _ answer, {TextEmphasis perform: each}]]].
	^answer! !
!SampledSound methodsFor: 'sound tracks' stamp: 'jmv 12/4/2012 23:42' prior: 16932481!
            volumeForm: height from: start to: stop nSamplesPerPixel: nPerPixel
	"Note: nPerPixel can be Integer or Float for pixel-perfect alignment."
	"In an inspector of a samplesSound...
		self currentWorld addMorph: (ImageMorph new image:
			(self volumeForm: 32 from: 1 to: samples size nSamplesPerPixel: 225))
	"
	| volPlot width sample min max vol |
	width _ stop-start//nPerPixel.
	volPlot _ Form extent: width@height.
	(start max: 1) to: (stop min: samples size)-nPerPixel by: nPerPixel do:
		[:i | min _ max _ 0.
		i asInteger to: (i+nPerPixel-1) asInteger by: 4 do:  "by: 4 makes it faster yet looks the same"
			[:j | sample _ samples at: j.
			sample < min ifTrue: [min _ sample].
			sample > max ifTrue: [max _ sample]].
		vol _ (max - min) * height // 65536.
		volPlot fillBlack: ((i-start//nPerPixel) @ (height-vol//2) extent: 1@(vol+1))].
	^ volPlot
	
! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1508-CuisCore-JuanVuletich-2012Dec04-23h37m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1508] on 6 December 2012 at 10:40:25 am'!
!FormCanvas methodsFor: 'private' stamp: 'jmv 3/18/2011 10:35' prior: 50384052!
         setPaintColor: aColor
	"Install a new color used for filling."
	| paintColor screen patternWord |
	paintColor _ shadowColor ifNil: [ aColor ].
	paintColor ifNil: [ paintColor _ Color transparent].
	(paintColor is: #Color) ifFalse:[
		(paintColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].
		^port fillPattern: paintColor; combinationRule: Form paint].
	"Okay, so paintColor really *is* a color"
	port sourceForm: nil.
	(paintColor isOpaque) ifTrue: [
		port fillPattern: paintColor.
		port combinationRule: Form paint.
		self depth = 8 ifTrue:[
			"In 8 bit depth it's usually a good idea to use a stipple pattern"
			port fillColor: (form balancedPatternFor: paintColor)].
		^self].

	self depth > 8 ifTrue:[
		"BitBlt setup for alpha mapped transfer"
		port fillPattern: paintColor.
		self depth = 16
			ifTrue:[port alphaBits: paintColor privateAlpha; combinationRule: 31]
			ifFalse:[port combinationRule: Form blend].
		^self].

	"Can't represent actual transparency -- use stipple pattern"
	screen _ Color translucentMaskFor: paintColor alpha depth: self depth.
	patternWord _ form pixelWordFor: paintColor.
	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).
	port combinationRule: Form paint! !
!TheWorldMenu methodsFor: 'action' stamp: 'jmv 11/4/2011 10:23' prior: 50396921!
    doMenuItem: aCollection with: event
	| realTarget selector nArgs |
	selector _ aCollection second.
	nArgs _ selector numArgs.
	realTarget _ aCollection first.
	realTarget == #myWorld ifTrue: [realTarget _ myWorld].
	realTarget == #myHand ifTrue: [realTarget _ myHand].
	realTarget == #theWorldMenu ifTrue: [realTarget _ self].
	^nArgs = 0 
		ifTrue:[realTarget perform: selector]
		ifFalse:[realTarget perform: selector with: event].
! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1509-CuisCore-JuanVuletich-2012Dec06-10h32m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1509] on 7 December 2012 at 6:35:28 pm'!
!Process methodsFor: 'accessing' stamp: 'jmv 12/7/2012 18:14' prior: 50334022!
                   isTerminated

	self isActiveProcess ifTrue: [^ false].
	^suspendedContext isNil | suspendedContext pc isNil
	  or: ["If the suspendedContext is the bottomContext it is the block in Process>>newProcess.
		   If so, and the pc is greater than the startpc, the bock has alrteady sent and returned
		   from value and there is nothing more to do."
		suspendedContext isBottomContext
		and: [
			suspendedContext pc > suspendedContext startpc]]! !
!ProcessBrowser class methodsFor: 'process control' stamp: 'jmv 12/7/2012 18:04' prior: 16921965!
   debugProcess: aProcess
"	self resumeProcess: aProcess."
	aProcess debugWithTitle: 'Interrupted from the Process Browser'.
! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 12/7/2012 18:00' prior: 50399554!
  debugProcess
	| rule |
	rule _ (model class rulesFor: model selectedProcess) second.
	rule
		ifFalse: [PopUpMenu inform: 'Nope, won''t debug ' , model selectedProcess name.
			^ self].
	model class debugProcess: model selectedProcess.! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1510-CuisCore-JuanVuletich-2012Dec07-18h33m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1510] on 10 December 2012 at 3:42:56 pm'!
!SequenceableCollection methodsFor: 'accessing' stamp: 'jmv 11/20/2012 16:20'!
                          indexOfMax
	"Answer the index of the maximum value in me."
	
	| answer max e |
	max _ self at: 1.
	answer _ 1.
	2 to: self size do: [ :i |
		e _ self at: i.
		e > max ifTrue: [
			max _ e.
			answer _ i ]].
	^answer! !

----End fileIn of /Users/juanvuletich/Desktop/CuisUpdate/Cuis4.0-1260/CuisUpdates/1511-CuisCore-JuanVuletich-2012Dec10-15h42m-jmv.1.cs----!

SystemVersion current!

SystemVersion current print!

Transcript clear!

SystemVersion current print!

About edit!

Smalltalk removeKey: #About!

Clipboard default: Clipboard new!

AuthorInitials!

AuthorName!


Utilities clearAuthor.
Smalltalk removeEmptyMessageCategories.
Smalltalk organization removeEmptyCategories!

   ChangeSorter zapAllChangeSets.
   Smalltalk garbageCollect.!

    MethodChangeRecord allInstances "must be empty"!


Transcript clear.
SystemVersion current print.!


Clipboard default: Clipboard new.
Smalltalk flushClassNameCache.
DebuggerMethodMap voidMapCache.
Smalltalk garbageCollect.!

Symbol rehash.!


	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome.
	].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.!

   Preferences inspectUnused.!

   Smalltalk obsoleteClasses!

   Smalltalk browseUndeclaredReferences!

   Metaclass allInstances select: [ :a | a obsoleteSubclasses notEmpty ]!

   Smalltalk obsoleteBehaviors !

   Smalltalk browseObsoleteMethodReferences!

----SNAPSHOT----#(12 December 2012 12:10:43 pm) Cuis4.1.image priorSource: 434!

----QUIT/NOSAVE----#(12 December 2012 12:10:50 pm) Cuis4.1.image priorSource: 2344444!